/*
 * Copyright (c) 2020 Raspberry Pi (Trading) Ltd.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * @file     /home/alex/tmp/rp2040/rp2040.h
 * @brief    CMSIS HeaderFile
 * @version  0.1
 * @date     29. December 2021
 * @note     Generated by SVDConv V3.3.35 on Wednesday, 29.12.2021 13:04:07
 *           from File 'rp2040.svd',
 */



/** @addtogroup Raspberry Pi
  * @{
  */


/** @addtogroup rp2040
  * @{
  */


#ifndef RP2040_H
#define RP2040_H

#ifdef __cplusplus
extern "C" {
#endif


/** @addtogroup Configuration_of_CMSIS
  * @{
  */



/* =========================================================================================================================== */
/* ================                                Interrupt Number Definition                                ================ */
/* =========================================================================================================================== */

typedef enum {
/* =======================================  ARM Cortex-M0+ Specific Interrupt Numbers  ======================================= */
  Reset_IRQn                = -15,              /*!< -15 Reset Vector, invoked on Power up and warm reset */
  NonMaskableInt_IRQn       = -14,              /*!< -14 Non maskable Interrupt, cannot be stopped or preempted */
  HardFault_IRQn            = -13,              /*!< -13 Hard Fault, all classes of Fault */
  SVCall_IRQn               =  -5,              /*!< -5 System Service Call via SVC instruction */
  PendSV_IRQn               =  -2,              /*!< -2 Pendable request for system service */
  SysTick_IRQn              =  -1,              /*!< -1 System Tick Timer */
/* ===========================================  rp2040 Specific Interrupt Numbers  =========================================== */
  TIMER_IRQ_0_IRQn          =   0,              /*!< 0 TIMER_IRQ_0 */
  TIMER_IRQ_1_IRQn          =   1,              /*!< 1 TIMER_IRQ_1 */
  TIMER_IRQ_2_IRQn          =   2,              /*!< 2 TIMER_IRQ_2 */
  TIMER_IRQ_3_IRQn          =   3,              /*!< 3 TIMER_IRQ_3 */
  PWM_IRQ_WRAP_IRQn         =   4,              /*!< 4 PWM_IRQ_WRAP */
  USBCTRL_IRQ_IRQn          =   5,              /*!< 5 USBCTRL_IRQ */
  XIP_IRQ_IRQn              =   6,              /*!< 6 XIP_IRQ */
  PIO0_IRQ_0_IRQn           =   7,              /*!< 7 PIO0_IRQ_0 */
  PIO0_IRQ_1_IRQn           =   8,              /*!< 8 PIO0_IRQ_1 */
  PIO1_IRQ_0_IRQn           =   9,              /*!< 9 PIO1_IRQ_0 */
  PIO1_IRQ_1_IRQn           =  10,              /*!< 10 PIO1_IRQ_1 */
  DMA_IRQ_0_IRQn            =  11,              /*!< 11 DMA_IRQ_0 */
  DMA_IRQ_1_IRQn            =  12,              /*!< 12 DMA_IRQ_1 */
  IO_IRQ_BANK0_IRQn         =  13,              /*!< 13 IO_IRQ_BANK0 */
  IO_IRQ_QSPI_IRQn          =  14,              /*!< 14 IO_IRQ_QSPI */
  SIO_IRQ_PROC0_IRQn        =  15,              /*!< 15 SIO_IRQ_PROC0 */
  SIO_IRQ_PROC1_IRQn        =  16,              /*!< 16 SIO_IRQ_PROC1 */
  CLOCKS_IRQ_IRQn           =  17,              /*!< 17 CLOCKS_IRQ */
  SPI0_IRQ_IRQn             =  18,              /*!< 18 SPI0_IRQ */
  SPI1_IRQ_IRQn             =  19,              /*!< 19 SPI1_IRQ */
  UART0_IRQ_IRQn            =  20,              /*!< 20 UART0_IRQ */
  UART1_IRQ_IRQn            =  21,              /*!< 21 UART1_IRQ */
  ADC_IRQ_FIFO_IRQn         =  22,              /*!< 22 ADC_IRQ_FIFO */
  I2C0_IRQ_IRQn             =  23,              /*!< 23 I2C0_IRQ */
  I2C1_IRQ_IRQn             =  24,              /*!< 24 I2C1_IRQ */
  RTC_IRQ_IRQn              =  25               /*!< 25 RTC_IRQ */
} IRQn_Type;



/* =========================================================================================================================== */
/* ================                           Processor and Core Peripheral Section                           ================ */
/* =========================================================================================================================== */

/* ==========================  Configuration of the ARM Cortex-M0+ Processor and Core Peripherals  =========================== */
#define __CM0PLUS_REV                 0x0001U   /*!< CM0PLUS Core Revision */
#define __NVIC_PRIO_BITS               2        /*!< Number of Bits used for Priority Levels */
#define __Vendor_SysTickConfig         0        /*!< Set to 1 if different SysTick Config is used */
#define __VTOR_PRESENT                 1        /*!< Set to 1 if CPU supports Vector Table Offset Register */
#define __MPU_PRESENT                  1        /*!< MPU present */
#define __FPU_PRESENT                  0        /*!< FPU present */


/** @} */ /* End of group Configuration_of_CMSIS */

#include "core_cm0plus.h"                       /*!< ARM Cortex-M0+ processor and core peripherals */
//#include "system_rp2040.h"                      /*!< rp2040 System */

#ifndef __IM                                    /*!< Fallback for older CMSIS versions */
  #define __IM   __I
#endif
#ifndef __OM                                    /*!< Fallback for older CMSIS versions */
  #define __OM   __O
#endif
#ifndef __IOM                                   /*!< Fallback for older CMSIS versions */
  #define __IOM  __IO
#endif


/* ========================================  Start of section using anonymous unions  ======================================== */
#if defined (__CC_ARM)
  #pragma push
  #pragma anon_unions
#elif defined (__ICCARM__)
  #pragma language=extended
#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wc11-extensions"
  #pragma clang diagnostic ignored "-Wreserved-id-macro"
  #pragma clang diagnostic ignored "-Wgnu-anonymous-struct"
  #pragma clang diagnostic ignored "-Wnested-anon-types"
#elif defined (__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined (__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined (__TASKING__)
  #pragma warning 586
#elif defined (__CSMC__)
  /* anonymous unions are enabled by default */
#else
  #warning Not supported compiler type
#endif


/* =========================================================================================================================== */
/* ================                            Device Specific Peripheral Section                             ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripherals
  * @{
  */



/* =========================================================================================================================== */
/* ================                                         XIP_CTRL                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief QSPI flash execute-in-place block (XIP_CTRL)
  */

typedef struct {                                /*!< (@ 0x14000000) XIP_CTRL Structure */

  union {
    __IOM uint32_t CTRL;                        /*!< (@ 0x00000000) Cache control */

    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] When 1, enable the cache. When the cache is disabled, all XIP accesses will go straight to the flash, without querying the cache. When enabled, cacheable XIP accesses will query the cache, and the flash will not be accessed if the tag matches and the valid bit is set. If the cache is enabled, cache-as-SRAM accesses have no effect on the cache data RAM, and will produce a bus error response. */
      __IOM uint32_t ERR_BADWRITE : 1;          /*!< [1..1] When 1, writes to any alias other than 0x0 (caching, allocating) will produce a bus fault. When 0, these writes are silently ignored. In either case, writes to the 0x0 alias will deallocate on tag match, as usual. */
            uint32_t            : 1;
      __IOM uint32_t POWER_DOWN : 1;            /*!< [3..3] When 1, the cache memories are powered down. They retain state, but can not be accessed. This reduces static power dissipation. Writing 1 to this bit forces CTRL_EN to 0, i.e. the cache cannot be enabled when powered down. Cache-as-SRAM accesses will produce a bus error response when the cache is powered down. */
            uint32_t            : 28;
    } CTRL_b;
  } ;

  union {
    __IOM uint32_t FLUSH;                       /*!< (@ 0x00000004) Cache Flush control */

    struct {
      __IOM uint32_t FLUSH      : 1;            /*!< [0..0] Write 1 to flush the cache. This clears the tag memory, but the data memory retains its contents. (This means cache-as-SRAM contents is not affected by flush or reset.) Reading will hold the bus (stall the processor) until the flush completes. Alternatively STAT can be polled until completion. */
            uint32_t            : 31;
    } FLUSH_b;
  } ;

  union {
    __IOM uint32_t STAT;                        /*!< (@ 0x00000008) Cache Status */

    struct {
      __IM  uint32_t FLUSH_READY : 1;           /*!< [0..0] Reads as 0 while a cache flush is in progress, and 1 otherwise. The cache is flushed whenever the XIP block is reset, and also when requested via the FLUSH register. */
      __IM  uint32_t FIFO_EMPTY : 1;            /*!< [1..1] When 1, indicates the XIP streaming FIFO is completely empty. */
      __IM  uint32_t FIFO_FULL  : 1;            /*!< [2..2] When 1, indicates the XIP streaming FIFO is completely full. The streaming FIFO is 2 entries deep, so the full and empty flag allow its level to be ascertained. */
            uint32_t            : 29;
    } STAT_b;
  } ;
  __IOM uint32_t  CTR_HIT;                      /*!< (@ 0x0000000C) Cache Hit counter A 32 bit saturating counter that increments upon each cache hit, i.e. when an XIP access is serviced directly from cached data. Write any value to clear. */
  __IOM uint32_t  CTR_ACC;                      /*!< (@ 0x00000010) Cache Access counter A 32 bit saturating counter that increments upon each XIP access, whether the cache is hit or not. This includes noncacheable accesses. Write any value to clear. */

  union {
    __IOM uint32_t STREAM_ADDR;                 /*!< (@ 0x00000014) FIFO stream address */

    struct {
            uint32_t            : 2;
      __IOM uint32_t STREAM_ADDR : 30;          /*!< [31..2] The address of the next word to be streamed from flash to the streaming FIFO. Increments automatically after each flash access. Write the initial access address here before starting a streaming read. */
    } STREAM_ADDR_b;
  } ;

  union {
    __IOM uint32_t STREAM_CTR;                  /*!< (@ 0x00000018) FIFO stream control */

    struct {
      __IOM uint32_t STREAM_CTR : 22;           /*!< [21..0] Write a nonzero value to start a streaming read. This will then progress in the background, using flash idle cycles to transfer a linear data block from flash to the streaming FIFO. Decrements automatically (1 at a time) as the stream progresses, and halts on reaching 0. Write 0 to halt an in-progress stream, and discard any in-flight read, so that a new stream can immediately be started (aft */
            uint32_t            : 10;
    } STREAM_CTR_b;
  } ;
  __IM  uint32_t  STREAM_FIFO;                  /*!< (@ 0x0000001C) FIFO stream data Streamed data is buffered here, for retrieval by the system DMA. This FIFO can also be accessed via the XIP_AUX slave, to avoid exposing the DMA to bus stalls caused by other XIP traffic. */
} XIP_CTRL_Type;                                /*!< Size = 32 (0x20) */



/* =========================================================================================================================== */
/* ================                                          XIP_SSI                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief DW_apb_ssi has the following features:\n
        * APB interface – Allows for easy integration into a DesignWare Synthesizable Components for AMBA 2 implementation.\n
        * APB3 and APB4 protocol support.\n
        * Scalable APB data bus width – Supports APB data bus widths of 8, 16, and 32 bits.\n
        * Serial-master or serial-slave operation – Enables serial communication with serial-master or serial-slave peripheral devices.\n
        * Programmable Dual/Quad/Octal SPI support in Master Mode.\n
        * Dual Data Rate (DDR) and Read Data Strobe (RDS) Support - Enables the DW_apb_ssi master to perform operations with the device in DDR and RDS modes when working in Dual/Quad/Octal mode of operation.\n
        * Data Mask Support - Enables the DW_apb_ssi to selectively update the bytes in the device. This feature is applicable only in enhanced SPI modes.\n
        * eXecute-In-Place (XIP) support - Enables the DW_apb_ssi master to behave as a memory mapped I/O and fetches the data from the device based on the APB read request. This feature is applicable only in enhanced SPI modes.\n
        * DMA Controller Interface – Enables the DW_apb_ssi to interface to a DMA controller over the bus using a handshaking interface for transfer requests.\n
        * Independent masking of interrupts – Master collision, transmit FIFO overflow, transmit FIFO empty, receive FIFO full, receive FIFO underflow, and receive FIFO overflow interrupts can all be masked independently.\n
        * Multi-master contention detection – Informs the processor of multiple serial-master accesses on the serial bus.\n
        * Bypass of meta-stability flip-flops for synchronous clocks – When the APB clock (pclk) and the DW_apb_ssi serial clock (ssi_clk) are synchronous, meta-stable flip-flops are not used when transferring control signals across these clock domains.\n
        * Programmable delay on the sample time of the received serial data bit (rxd); enables programmable control of routing delays resulting in higher serial data-bit rates.\n
        * Programmable features:\n
        - Serial interface operation – Choice of Motorola SPI, Texas Instruments Synchronous Serial Protocol or National Semiconductor Microwire.\n
        - Clock bit-rate – Dynamic control of the serial bit rate of the data transfer; used in only serial-master mode of operation.\n
        - Data Item size (4 to 32 bits) – Item size of each data transfer under the control of the programmer.\n
        * Configured features:\n
        - FIFO depth – 16 words deep. The FIFO width is fixed at 32 bits.\n
        - 1 slave select output.\n
        - Hardware slave-select – Dedicated hardware slave-select line.\n
        - Combined interrupt line - one combined interrupt line from the DW_apb_ssi to the interrupt controller.\n
        - Interrupt polarity – active high interrupt lines.\n
        - Serial clock polarity – low serial-clock polarity directly after reset.\n
        - Serial clock phase – capture on first edge of serial-clock directly after reset. (XIP_SSI)
  */

typedef struct {                                /*!< (@ 0x18000000) XIP_SSI Structure */

  union {
    __IOM uint32_t CTRLR0;                      /*!< (@ 0x00000000) Control register 0 */

    struct {
      __IOM uint32_t DFS        : 4;            /*!< [3..0] Data frame size */
      __IOM uint32_t FRF        : 2;            /*!< [5..4] Frame format */
      __IOM uint32_t SCPH       : 1;            /*!< [6..6] Serial clock phase */
      __IOM uint32_t SCPOL      : 1;            /*!< [7..7] Serial clock polarity */
      __IOM uint32_t TMOD       : 2;            /*!< [9..8] Transfer mode */
      __IOM uint32_t SLV_OE     : 1;            /*!< [10..10] Slave output enable */
      __IOM uint32_t SRL        : 1;            /*!< [11..11] Shift register loop (test mode) */
      __IOM uint32_t CFS        : 4;            /*!< [15..12] Control frame size Value of n -> n+1 clocks per frame. */
      __IOM uint32_t DFS_32     : 5;            /*!< [20..16] Data frame size in 32b transfer mode Value of n -> n+1 clocks per frame. */
      __IOM uint32_t SPI_FRF    : 2;            /*!< [22..21] SPI frame format */
            uint32_t            : 1;
      __IOM uint32_t SSTE       : 1;            /*!< [24..24] Slave select toggle enable */
            uint32_t            : 7;
    } CTRLR0_b;
  } ;

  union {
    __IOM uint32_t CTRLR1;                      /*!< (@ 0x00000004) Master Control register 1 */

    struct {
      __IOM uint32_t NDF        : 16;           /*!< [15..0] Number of data frames */
            uint32_t            : 16;
    } CTRLR1_b;
  } ;

  union {
    __IOM uint32_t SSIENR;                      /*!< (@ 0x00000008) SSI Enable */

    struct {
      __IOM uint32_t SSI_EN     : 1;            /*!< [0..0] SSI enable */
            uint32_t            : 31;
    } SSIENR_b;
  } ;

  union {
    __IOM uint32_t MWCR;                        /*!< (@ 0x0000000C) Microwire Control */

    struct {
      __IOM uint32_t MWMOD      : 1;            /*!< [0..0] Microwire transfer mode */
      __IOM uint32_t MDD        : 1;            /*!< [1..1] Microwire control */
      __IOM uint32_t MHS        : 1;            /*!< [2..2] Microwire handshaking */
            uint32_t            : 29;
    } MWCR_b;
  } ;

  union {
    __IOM uint32_t SER;                         /*!< (@ 0x00000010) Slave enable */

    struct {
      __IOM uint32_t SER        : 1;            /*!< [0..0] For each bit: 0 -> slave not selected 1 -> slave selected */
            uint32_t            : 31;
    } SER_b;
  } ;

  union {
    __IOM uint32_t BAUDR;                       /*!< (@ 0x00000014) Baud rate */

    struct {
      __IOM uint32_t SCKDV      : 16;           /*!< [15..0] SSI clock divider */
            uint32_t            : 16;
    } BAUDR_b;
  } ;

  union {
    __IOM uint32_t TXFTLR;                      /*!< (@ 0x00000018) TX FIFO threshold level */

    struct {
      __IOM uint32_t TFT        : 8;            /*!< [7..0] Transmit FIFO threshold */
            uint32_t            : 24;
    } TXFTLR_b;
  } ;

  union {
    __IOM uint32_t RXFTLR;                      /*!< (@ 0x0000001C) RX FIFO threshold level */

    struct {
      __IOM uint32_t RFT        : 8;            /*!< [7..0] Receive FIFO threshold */
            uint32_t            : 24;
    } RXFTLR_b;
  } ;

  union {
    __IOM uint32_t TXFLR;                       /*!< (@ 0x00000020) TX FIFO level */

    struct {
      __IM  uint32_t TFTFL      : 8;            /*!< [7..0] Transmit FIFO level */
            uint32_t            : 24;
    } TXFLR_b;
  } ;

  union {
    __IOM uint32_t RXFLR;                       /*!< (@ 0x00000024) RX FIFO level */

    struct {
      __IM  uint32_t RXTFL      : 8;            /*!< [7..0] Receive FIFO level */
            uint32_t            : 24;
    } RXFLR_b;
  } ;

  union {
    __IOM uint32_t SR;                          /*!< (@ 0x00000028) Status register */

    struct {
      __IM  uint32_t BUSY       : 1;            /*!< [0..0] SSI busy flag */
      __IM  uint32_t TFNF       : 1;            /*!< [1..1] Transmit FIFO not full */
      __IM  uint32_t TFE        : 1;            /*!< [2..2] Transmit FIFO empty */
      __IM  uint32_t RFNE       : 1;            /*!< [3..3] Receive FIFO not empty */
      __IM  uint32_t RFF        : 1;            /*!< [4..4] Receive FIFO full */
      __IM  uint32_t TXE        : 1;            /*!< [5..5] Transmission error */
      __IM  uint32_t DCOL       : 1;            /*!< [6..6] Data collision error */
            uint32_t            : 25;
    } SR_b;
  } ;

  union {
    __IOM uint32_t IMR;                         /*!< (@ 0x0000002C) Interrupt mask */

    struct {
      __IOM uint32_t TXEIM      : 1;            /*!< [0..0] Transmit FIFO empty interrupt mask */
      __IOM uint32_t TXOIM      : 1;            /*!< [1..1] Transmit FIFO overflow interrupt mask */
      __IOM uint32_t RXUIM      : 1;            /*!< [2..2] Receive FIFO underflow interrupt mask */
      __IOM uint32_t RXOIM      : 1;            /*!< [3..3] Receive FIFO overflow interrupt mask */
      __IOM uint32_t RXFIM      : 1;            /*!< [4..4] Receive FIFO full interrupt mask */
      __IOM uint32_t MSTIM      : 1;            /*!< [5..5] Multi-master contention interrupt mask */
            uint32_t            : 26;
    } IMR_b;
  } ;

  union {
    __IOM uint32_t ISR;                         /*!< (@ 0x00000030) Interrupt status */

    struct {
      __IM  uint32_t TXEIS      : 1;            /*!< [0..0] Transmit FIFO empty interrupt status */
      __IM  uint32_t TXOIS      : 1;            /*!< [1..1] Transmit FIFO overflow interrupt status */
      __IM  uint32_t RXUIS      : 1;            /*!< [2..2] Receive FIFO underflow interrupt status */
      __IM  uint32_t RXOIS      : 1;            /*!< [3..3] Receive FIFO overflow interrupt status */
      __IM  uint32_t RXFIS      : 1;            /*!< [4..4] Receive FIFO full interrupt status */
      __IM  uint32_t MSTIS      : 1;            /*!< [5..5] Multi-master contention interrupt status */
            uint32_t            : 26;
    } ISR_b;
  } ;

  union {
    __IOM uint32_t RISR;                        /*!< (@ 0x00000034) Raw interrupt status */

    struct {
      __IM  uint32_t TXEIR      : 1;            /*!< [0..0] Transmit FIFO empty raw interrupt status */
      __IM  uint32_t TXOIR      : 1;            /*!< [1..1] Transmit FIFO overflow raw interrupt status */
      __IM  uint32_t RXUIR      : 1;            /*!< [2..2] Receive FIFO underflow raw interrupt status */
      __IM  uint32_t RXOIR      : 1;            /*!< [3..3] Receive FIFO overflow raw interrupt status */
      __IM  uint32_t RXFIR      : 1;            /*!< [4..4] Receive FIFO full raw interrupt status */
      __IM  uint32_t MSTIR      : 1;            /*!< [5..5] Multi-master contention raw interrupt status */
            uint32_t            : 26;
    } RISR_b;
  } ;

  union {
    __IOM uint32_t TXOICR;                      /*!< (@ 0x00000038) TX FIFO overflow interrupt clear */

    struct {
      __IM  uint32_t TXOICR     : 1;            /*!< [0..0] Clear-on-read transmit FIFO overflow interrupt */
            uint32_t            : 31;
    } TXOICR_b;
  } ;

  union {
    __IOM uint32_t RXOICR;                      /*!< (@ 0x0000003C) RX FIFO overflow interrupt clear */

    struct {
      __IM  uint32_t RXOICR     : 1;            /*!< [0..0] Clear-on-read receive FIFO overflow interrupt */
            uint32_t            : 31;
    } RXOICR_b;
  } ;

  union {
    __IOM uint32_t RXUICR;                      /*!< (@ 0x00000040) RX FIFO underflow interrupt clear */

    struct {
      __IM  uint32_t RXUICR     : 1;            /*!< [0..0] Clear-on-read receive FIFO underflow interrupt */
            uint32_t            : 31;
    } RXUICR_b;
  } ;

  union {
    __IOM uint32_t MSTICR;                      /*!< (@ 0x00000044) Multi-master interrupt clear */

    struct {
      __IM  uint32_t MSTICR     : 1;            /*!< [0..0] Clear-on-read multi-master contention interrupt */
            uint32_t            : 31;
    } MSTICR_b;
  } ;

  union {
    __IOM uint32_t ICR;                         /*!< (@ 0x00000048) Interrupt clear */

    struct {
      __IM  uint32_t ICR        : 1;            /*!< [0..0] Clear-on-read all active interrupts */
            uint32_t            : 31;
    } ICR_b;
  } ;

  union {
    __IOM uint32_t DMACR;                       /*!< (@ 0x0000004C) DMA control */

    struct {
      __IOM uint32_t RDMAE      : 1;            /*!< [0..0] Receive DMA enable */
      __IOM uint32_t TDMAE      : 1;            /*!< [1..1] Transmit DMA enable */
            uint32_t            : 30;
    } DMACR_b;
  } ;

  union {
    __IOM uint32_t DMATDLR;                     /*!< (@ 0x00000050) DMA TX data level */

    struct {
      __IOM uint32_t DMATDL     : 8;            /*!< [7..0] Transmit data watermark level */
            uint32_t            : 24;
    } DMATDLR_b;
  } ;

  union {
    __IOM uint32_t DMARDLR;                     /*!< (@ 0x00000054) DMA RX data level */

    struct {
      __IOM uint32_t DMARDL     : 8;            /*!< [7..0] Receive data watermark level (DMARDLR+1) */
            uint32_t            : 24;
    } DMARDLR_b;
  } ;

  union {
    __IOM uint32_t IDR;                         /*!< (@ 0x00000058) Identification register */

    struct {
      __IM  uint32_t IDCODE     : 32;           /*!< [31..0] Peripheral dentification code */
    } IDR_b;
  } ;

  union {
    __IOM uint32_t SSI_VERSION_ID;              /*!< (@ 0x0000005C) Version ID */

    struct {
      __IM  uint32_t SSI_COMP_VERSION : 32;     /*!< [31..0] SNPS component version (format X.YY) */
    } SSI_VERSION_ID_b;
  } ;

  union {
    __IOM uint32_t DR0;                         /*!< (@ 0x00000060) Data Register 0 (of 36) */

    struct {
      __IOM uint32_t DR         : 32;           /*!< [31..0] First data register of 36 */
    } DR0_b;
  } ;
  __IM  uint32_t  RESERVED[35];

  union {
    __IOM uint32_t RX_SAMPLE_DLY;               /*!< (@ 0x000000F0) RX sample delay */

    struct {
      __IOM uint32_t RSD        : 8;            /*!< [7..0] RXD sample delay (in SCLK cycles) */
            uint32_t            : 24;
    } RX_SAMPLE_DLY_b;
  } ;

  union {
    __IOM uint32_t SPI_CTRLR0;                  /*!< (@ 0x000000F4) SPI control */

    struct {
      __IOM uint32_t TRANS_TYPE : 2;            /*!< [1..0] Address and instruction transfer format */
      __IOM uint32_t ADDR_L     : 4;            /*!< [5..2] Address length (0b-60b in 4b increments) */
            uint32_t            : 2;
      __IOM uint32_t INST_L     : 2;            /*!< [9..8] Instruction length (0/4/8/16b) */
            uint32_t            : 1;
      __IOM uint32_t WAIT_CYCLES : 5;           /*!< [15..11] Wait cycles between control frame transmit and data reception (in SCLK cycles) */
      __IOM uint32_t SPI_DDR_EN : 1;            /*!< [16..16] SPI DDR transfer enable */
      __IOM uint32_t INST_DDR_EN : 1;           /*!< [17..17] Instruction DDR transfer enable */
      __IOM uint32_t SPI_RXDS_EN : 1;           /*!< [18..18] Read data strobe enable */
            uint32_t            : 5;
      __IOM uint32_t XIP_CMD    : 8;            /*!< [31..24] SPI Command to send in XIP mode (INST_L = 8-bit) or to append to Address (INST_L = 0-bit) */
    } SPI_CTRLR0_b;
  } ;

  union {
    __IOM uint32_t TXD_DRIVE_EDGE;              /*!< (@ 0x000000F8) TX drive edge */

    struct {
      __IOM uint32_t TDE        : 8;            /*!< [7..0] TXD drive edge */
            uint32_t            : 24;
    } TXD_DRIVE_EDGE_b;
  } ;
} XIP_SSI_Type;                                 /*!< Size = 252 (0xfc) */



/* =========================================================================================================================== */
/* ================                                          SYSINFO                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief SYSINFO (SYSINFO)
  */

typedef struct {                                /*!< (@ 0x40000000) SYSINFO Structure */

  union {
    __IOM uint32_t CHIP_ID;                     /*!< (@ 0x00000000) JEDEC JEP-106 compliant chip identifier. */

    struct {
      __IM  uint32_t MANUFACTURER : 12;         /*!< [11..0] MANUFACTURER */
      __IM  uint32_t PART       : 16;           /*!< [27..12] PART */
      __IM  uint32_t REVISION   : 4;            /*!< [31..28] REVISION */
    } CHIP_ID_b;
  } ;

  union {
    __IOM uint32_t PLATFORM;                    /*!< (@ 0x00000004) Platform register. Allows software to know what environment it is running in. */

    struct {
      __IM  uint32_t FPGA       : 1;            /*!< [0..0] FPGA */
      __IM  uint32_t ASIC       : 1;            /*!< [1..1] ASIC */
            uint32_t            : 30;
    } PLATFORM_b;
  } ;
  __IM  uint32_t  RESERVED[14];
  __IM  uint32_t  GITREF_RP2040;                /*!< (@ 0x00000040) Git hash of the chip source. Used to identify chip version. */
} SYSINFO_Type;                                 /*!< Size = 68 (0x44) */



/* =========================================================================================================================== */
/* ================                                          SYSCFG                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Register block for various chip control signals (SYSCFG)
  */

typedef struct {                                /*!< (@ 0x40004000) SYSCFG Structure */
  __IOM uint32_t  PROC0_NMI_MASK;               /*!< (@ 0x00000000) Processor core 0 NMI source mask Set a bit high to enable NMI from that IRQ */
  __IOM uint32_t  PROC1_NMI_MASK;               /*!< (@ 0x00000004) Processor core 1 NMI source mask Set a bit high to enable NMI from that IRQ */

  union {
    __IOM uint32_t PROC_CONFIG;                 /*!< (@ 0x00000008) Configuration for processors */

    struct {
      __IM  uint32_t PROC0_HALTED : 1;          /*!< [0..0] Indication that proc0 has halted */
      __IM  uint32_t PROC1_HALTED : 1;          /*!< [1..1] Indication that proc1 has halted */
            uint32_t            : 22;
      __IOM uint32_t PROC0_DAP_INSTID : 4;      /*!< [27..24] Configure proc0 DAP instance ID. Recommend that this is NOT changed until you require debug access in multi-chip environment WARNING: do not set to 15 as this is reserved for RescueDP */
      __IOM uint32_t PROC1_DAP_INSTID : 4;      /*!< [31..28] Configure proc1 DAP instance ID. Recommend that this is NOT changed until you require debug access in multi-chip environment WARNING: do not set to 15 as this is reserved for RescueDP */
    } PROC_CONFIG_b;
  } ;

  union {
    __IOM uint32_t PROC_IN_SYNC_BYPASS;         /*!< (@ 0x0000000C) For each bit, if 1, bypass the input synchronizer between that GPIO and the GPIO input register in the SIO. The input synchronizers should generally be unbypassed, to avoid injecting metastabilities into processors. If you're feeling brave, you can bypass to save two cycles of input latency. This register applies to GPIO 0...29. */

    struct {
      __IOM uint32_t PROC_IN_SYNC_BYPASS : 30;  /*!< [29..0] PROC_IN_SYNC_BYPASS */
            uint32_t            : 2;
    } PROC_IN_SYNC_BYPASS_b;
  } ;

  union {
    __IOM uint32_t PROC_IN_SYNC_BYPASS_HI;      /*!< (@ 0x00000010) For each bit, if 1, bypass the input synchronizer between that GPIO and the GPIO input register in the SIO. The input synchronizers should generally be unbypassed, to avoid injecting metastabilities into processors. If you're feeling brave, you can bypass to save two cycles of input latency. This register applies to GPIO 30...35 (the QSPI IOs). */

    struct {
      __IOM uint32_t PROC_IN_SYNC_BYPASS_HI : 6;/*!< [5..0] PROC_IN_SYNC_BYPASS_HI */
            uint32_t            : 26;
    } PROC_IN_SYNC_BYPASS_HI_b;
  } ;

  union {
    __IOM uint32_t DBGFORCE;                    /*!< (@ 0x00000014) Directly control the SWD debug port of either processor */

    struct {
      __IM  uint32_t PROC0_SWDO : 1;            /*!< [0..0] Observe the value of processor 0 SWDIO output. */
      __IOM uint32_t PROC0_SWDI : 1;            /*!< [1..1] Directly drive processor 0 SWDIO input, if PROC0_ATTACH is set */
      __IOM uint32_t PROC0_SWCLK : 1;           /*!< [2..2] Directly drive processor 0 SWCLK, if PROC0_ATTACH is set */
      __IOM uint32_t PROC0_ATTACH : 1;          /*!< [3..3] Attach processor 0 debug port to syscfg controls, and disconnect it from external SWD pads. */
      __IM  uint32_t PROC1_SWDO : 1;            /*!< [4..4] Observe the value of processor 1 SWDIO output. */
      __IOM uint32_t PROC1_SWDI : 1;            /*!< [5..5] Directly drive processor 1 SWDIO input, if PROC1_ATTACH is set */
      __IOM uint32_t PROC1_SWCLK : 1;           /*!< [6..6] Directly drive processor 1 SWCLK, if PROC1_ATTACH is set */
      __IOM uint32_t PROC1_ATTACH : 1;          /*!< [7..7] Attach processor 1 debug port to syscfg controls, and disconnect it from external SWD pads. */
            uint32_t            : 24;
    } DBGFORCE_b;
  } ;

  union {
    __IOM uint32_t MEMPOWERDOWN;                /*!< (@ 0x00000018) Control power downs to memories. Set high to power down memories. Use with extreme caution */

    struct {
      __IOM uint32_t SRAM0      : 1;            /*!< [0..0] SRAM0 */
      __IOM uint32_t SRAM1      : 1;            /*!< [1..1] SRAM1 */
      __IOM uint32_t SRAM2      : 1;            /*!< [2..2] SRAM2 */
      __IOM uint32_t SRAM3      : 1;            /*!< [3..3] SRAM3 */
      __IOM uint32_t SRAM4      : 1;            /*!< [4..4] SRAM4 */
      __IOM uint32_t SRAM5      : 1;            /*!< [5..5] SRAM5 */
      __IOM uint32_t USB        : 1;            /*!< [6..6] USB */
      __IOM uint32_t ROM        : 1;            /*!< [7..7] ROM */
            uint32_t            : 24;
    } MEMPOWERDOWN_b;
  } ;
} SYSCFG_Type;                                  /*!< Size = 28 (0x1c) */



/* =========================================================================================================================== */
/* ================                                          CLOCKS                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief CLOCKS (CLOCKS)
  */

typedef struct {                                /*!< (@ 0x40008000) CLOCKS Structure */

  union {
    __IOM uint32_t CLK_GPOUT0_CTRL;             /*!< (@ 0x00000000) Clock control, can be changed on-the-fly (except for auxsrc) */

    struct {
            uint32_t            : 5;
      __IOM uint32_t AUXSRC     : 4;            /*!< [8..5] Selects the auxiliary clock source, will glitch when switching */
            uint32_t            : 1;
      __IOM uint32_t KILL       : 1;            /*!< [10..10] Asynchronously kills the clock generator */
      __IOM uint32_t ENABLE     : 1;            /*!< [11..11] Starts and stops the clock generator cleanly */
      __IOM uint32_t DC50       : 1;            /*!< [12..12] Enables duty cycle correction for odd divisors */
            uint32_t            : 3;
      __IOM uint32_t PHASE      : 2;            /*!< [17..16] This delays the enable signal by up to 3 cycles of the input clock This must be set before the clock is enabled to have any effect */
            uint32_t            : 2;
      __IOM uint32_t NUDGE      : 1;            /*!< [20..20] An edge on this signal shifts the phase of the output by 1 cycle of the input clock This can be done at any time */
            uint32_t            : 11;
    } CLK_GPOUT0_CTRL_b;
  } ;

  union {
    __IOM uint32_t CLK_GPOUT0_DIV;              /*!< (@ 0x00000004) Clock divisor, can be changed on-the-fly */

    struct {
      __IOM uint32_t FRAC       : 8;            /*!< [7..0] Fractional component of the divisor */
      __IOM uint32_t INT        : 24;           /*!< [31..8] Integer component of the divisor, 0 -> divide by 2^16 */
    } CLK_GPOUT0_DIV_b;
  } ;
  __IM  uint32_t  CLK_GPOUT0_SELECTED;          /*!< (@ 0x00000008) Indicates which SRC is currently selected by the glitchless mux (one-hot). This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1. */

  union {
    __IOM uint32_t CLK_GPOUT1_CTRL;             /*!< (@ 0x0000000C) Clock control, can be changed on-the-fly (except for auxsrc) */

    struct {
            uint32_t            : 5;
      __IOM uint32_t AUXSRC     : 4;            /*!< [8..5] Selects the auxiliary clock source, will glitch when switching */
            uint32_t            : 1;
      __IOM uint32_t KILL       : 1;            /*!< [10..10] Asynchronously kills the clock generator */
      __IOM uint32_t ENABLE     : 1;            /*!< [11..11] Starts and stops the clock generator cleanly */
      __IOM uint32_t DC50       : 1;            /*!< [12..12] Enables duty cycle correction for odd divisors */
            uint32_t            : 3;
      __IOM uint32_t PHASE      : 2;            /*!< [17..16] This delays the enable signal by up to 3 cycles of the input clock This must be set before the clock is enabled to have any effect */
            uint32_t            : 2;
      __IOM uint32_t NUDGE      : 1;            /*!< [20..20] An edge on this signal shifts the phase of the output by 1 cycle of the input clock This can be done at any time */
            uint32_t            : 11;
    } CLK_GPOUT1_CTRL_b;
  } ;

  union {
    __IOM uint32_t CLK_GPOUT1_DIV;              /*!< (@ 0x00000010) Clock divisor, can be changed on-the-fly */

    struct {
      __IOM uint32_t FRAC       : 8;            /*!< [7..0] Fractional component of the divisor */
      __IOM uint32_t INT        : 24;           /*!< [31..8] Integer component of the divisor, 0 -> divide by 2^16 */
    } CLK_GPOUT1_DIV_b;
  } ;
  __IM  uint32_t  CLK_GPOUT1_SELECTED;          /*!< (@ 0x00000014) Indicates which SRC is currently selected by the glitchless mux (one-hot). This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1. */

  union {
    __IOM uint32_t CLK_GPOUT2_CTRL;             /*!< (@ 0x00000018) Clock control, can be changed on-the-fly (except for auxsrc) */

    struct {
            uint32_t            : 5;
      __IOM uint32_t AUXSRC     : 4;            /*!< [8..5] Selects the auxiliary clock source, will glitch when switching */
            uint32_t            : 1;
      __IOM uint32_t KILL       : 1;            /*!< [10..10] Asynchronously kills the clock generator */
      __IOM uint32_t ENABLE     : 1;            /*!< [11..11] Starts and stops the clock generator cleanly */
      __IOM uint32_t DC50       : 1;            /*!< [12..12] Enables duty cycle correction for odd divisors */
            uint32_t            : 3;
      __IOM uint32_t PHASE      : 2;            /*!< [17..16] This delays the enable signal by up to 3 cycles of the input clock This must be set before the clock is enabled to have any effect */
            uint32_t            : 2;
      __IOM uint32_t NUDGE      : 1;            /*!< [20..20] An edge on this signal shifts the phase of the output by 1 cycle of the input clock This can be done at any time */
            uint32_t            : 11;
    } CLK_GPOUT2_CTRL_b;
  } ;

  union {
    __IOM uint32_t CLK_GPOUT2_DIV;              /*!< (@ 0x0000001C) Clock divisor, can be changed on-the-fly */

    struct {
      __IOM uint32_t FRAC       : 8;            /*!< [7..0] Fractional component of the divisor */
      __IOM uint32_t INT        : 24;           /*!< [31..8] Integer component of the divisor, 0 -> divide by 2^16 */
    } CLK_GPOUT2_DIV_b;
  } ;
  __IM  uint32_t  CLK_GPOUT2_SELECTED;          /*!< (@ 0x00000020) Indicates which SRC is currently selected by the glitchless mux (one-hot). This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1. */

  union {
    __IOM uint32_t CLK_GPOUT3_CTRL;             /*!< (@ 0x00000024) Clock control, can be changed on-the-fly (except for auxsrc) */

    struct {
            uint32_t            : 5;
      __IOM uint32_t AUXSRC     : 4;            /*!< [8..5] Selects the auxiliary clock source, will glitch when switching */
            uint32_t            : 1;
      __IOM uint32_t KILL       : 1;            /*!< [10..10] Asynchronously kills the clock generator */
      __IOM uint32_t ENABLE     : 1;            /*!< [11..11] Starts and stops the clock generator cleanly */
      __IOM uint32_t DC50       : 1;            /*!< [12..12] Enables duty cycle correction for odd divisors */
            uint32_t            : 3;
      __IOM uint32_t PHASE      : 2;            /*!< [17..16] This delays the enable signal by up to 3 cycles of the input clock This must be set before the clock is enabled to have any effect */
            uint32_t            : 2;
      __IOM uint32_t NUDGE      : 1;            /*!< [20..20] An edge on this signal shifts the phase of the output by 1 cycle of the input clock This can be done at any time */
            uint32_t            : 11;
    } CLK_GPOUT3_CTRL_b;
  } ;

  union {
    __IOM uint32_t CLK_GPOUT3_DIV;              /*!< (@ 0x00000028) Clock divisor, can be changed on-the-fly */

    struct {
      __IOM uint32_t FRAC       : 8;            /*!< [7..0] Fractional component of the divisor */
      __IOM uint32_t INT        : 24;           /*!< [31..8] Integer component of the divisor, 0 -> divide by 2^16 */
    } CLK_GPOUT3_DIV_b;
  } ;
  __IM  uint32_t  CLK_GPOUT3_SELECTED;          /*!< (@ 0x0000002C) Indicates which SRC is currently selected by the glitchless mux (one-hot). This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1. */

  union {
    __IOM uint32_t CLK_REF_CTRL;                /*!< (@ 0x00000030) Clock control, can be changed on-the-fly (except for auxsrc) */

    struct {
      __IOM uint32_t SRC        : 2;            /*!< [1..0] Selects the clock source glitchlessly, can be changed on-the-fly */
            uint32_t            : 3;
      __IOM uint32_t AUXSRC     : 2;            /*!< [6..5] Selects the auxiliary clock source, will glitch when switching */
            uint32_t            : 25;
    } CLK_REF_CTRL_b;
  } ;

  union {
    __IOM uint32_t CLK_REF_DIV;                 /*!< (@ 0x00000034) Clock divisor, can be changed on-the-fly */

    struct {
            uint32_t            : 8;
      __IOM uint32_t INT        : 2;            /*!< [9..8] Integer component of the divisor, 0 -> divide by 2^16 */
            uint32_t            : 22;
    } CLK_REF_DIV_b;
  } ;
  __IM  uint32_t  CLK_REF_SELECTED;             /*!< (@ 0x00000038) Indicates which SRC is currently selected by the glitchless mux (one-hot). The glitchless multiplexer does not switch instantaneously (to avoid glitches), so software should poll this register to wait for the switch to complete. This register contains one decoded bit for each of the clock sources enumerated in the CTRL SRC field. At most one of these bits will be set at any time, indicating that clock is currently present at the output of the glitchless mux. Whilst switching */

  union {
    __IOM uint32_t CLK_SYS_CTRL;                /*!< (@ 0x0000003C) Clock control, can be changed on-the-fly (except for auxsrc) */

    struct {
      __IOM uint32_t SRC        : 1;            /*!< [0..0] Selects the clock source glitchlessly, can be changed on-the-fly */
            uint32_t            : 4;
      __IOM uint32_t AUXSRC     : 3;            /*!< [7..5] Selects the auxiliary clock source, will glitch when switching */
            uint32_t            : 24;
    } CLK_SYS_CTRL_b;
  } ;

  union {
    __IOM uint32_t CLK_SYS_DIV;                 /*!< (@ 0x00000040) Clock divisor, can be changed on-the-fly */

    struct {
      __IOM uint32_t FRAC       : 8;            /*!< [7..0] Fractional component of the divisor */
      __IOM uint32_t INT        : 24;           /*!< [31..8] Integer component of the divisor, 0 -> divide by 2^16 */
    } CLK_SYS_DIV_b;
  } ;
  __IM  uint32_t  CLK_SYS_SELECTED;             /*!< (@ 0x00000044) Indicates which SRC is currently selected by the glitchless mux (one-hot). The glitchless multiplexer does not switch instantaneously (to avoid glitches), so software should poll this register to wait for the switch to complete. This register contains one decoded bit for each of the clock sources enumerated in the CTRL SRC field. At most one of these bits will be set at any time, indicating that clock is currently present at the output of the glitchless mux. Whilst switching */

  union {
    __IOM uint32_t CLK_PERI_CTRL;               /*!< (@ 0x00000048) Clock control, can be changed on-the-fly (except for auxsrc) */

    struct {
            uint32_t            : 5;
      __IOM uint32_t AUXSRC     : 3;            /*!< [7..5] Selects the auxiliary clock source, will glitch when switching */
            uint32_t            : 2;
      __IOM uint32_t KILL       : 1;            /*!< [10..10] Asynchronously kills the clock generator */
      __IOM uint32_t ENABLE     : 1;            /*!< [11..11] Starts and stops the clock generator cleanly */
            uint32_t            : 20;
    } CLK_PERI_CTRL_b;
  } ;
  __IM  uint32_t  RESERVED;
  __IM  uint32_t  CLK_PERI_SELECTED;            /*!< (@ 0x00000050) Indicates which SRC is currently selected by the glitchless mux (one-hot). This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1. */

  union {
    __IOM uint32_t CLK_USB_CTRL;                /*!< (@ 0x00000054) Clock control, can be changed on-the-fly (except for auxsrc) */

    struct {
            uint32_t            : 5;
      __IOM uint32_t AUXSRC     : 3;            /*!< [7..5] Selects the auxiliary clock source, will glitch when switching */
            uint32_t            : 2;
      __IOM uint32_t KILL       : 1;            /*!< [10..10] Asynchronously kills the clock generator */
      __IOM uint32_t ENABLE     : 1;            /*!< [11..11] Starts and stops the clock generator cleanly */
            uint32_t            : 4;
      __IOM uint32_t PHASE      : 2;            /*!< [17..16] This delays the enable signal by up to 3 cycles of the input clock This must be set before the clock is enabled to have any effect */
            uint32_t            : 2;
      __IOM uint32_t NUDGE      : 1;            /*!< [20..20] An edge on this signal shifts the phase of the output by 1 cycle of the input clock This can be done at any time */
            uint32_t            : 11;
    } CLK_USB_CTRL_b;
  } ;

  union {
    __IOM uint32_t CLK_USB_DIV;                 /*!< (@ 0x00000058) Clock divisor, can be changed on-the-fly */

    struct {
            uint32_t            : 8;
      __IOM uint32_t INT        : 2;            /*!< [9..8] Integer component of the divisor, 0 -> divide by 2^16 */
            uint32_t            : 22;
    } CLK_USB_DIV_b;
  } ;
  __IM  uint32_t  CLK_USB_SELECTED;             /*!< (@ 0x0000005C) Indicates which SRC is currently selected by the glitchless mux (one-hot). This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1. */

  union {
    __IOM uint32_t CLK_ADC_CTRL;                /*!< (@ 0x00000060) Clock control, can be changed on-the-fly (except for auxsrc) */

    struct {
            uint32_t            : 5;
      __IOM uint32_t AUXSRC     : 3;            /*!< [7..5] Selects the auxiliary clock source, will glitch when switching */
            uint32_t            : 2;
      __IOM uint32_t KILL       : 1;            /*!< [10..10] Asynchronously kills the clock generator */
      __IOM uint32_t ENABLE     : 1;            /*!< [11..11] Starts and stops the clock generator cleanly */
            uint32_t            : 4;
      __IOM uint32_t PHASE      : 2;            /*!< [17..16] This delays the enable signal by up to 3 cycles of the input clock This must be set before the clock is enabled to have any effect */
            uint32_t            : 2;
      __IOM uint32_t NUDGE      : 1;            /*!< [20..20] An edge on this signal shifts the phase of the output by 1 cycle of the input clock This can be done at any time */
            uint32_t            : 11;
    } CLK_ADC_CTRL_b;
  } ;

  union {
    __IOM uint32_t CLK_ADC_DIV;                 /*!< (@ 0x00000064) Clock divisor, can be changed on-the-fly */

    struct {
            uint32_t            : 8;
      __IOM uint32_t INT        : 2;            /*!< [9..8] Integer component of the divisor, 0 -> divide by 2^16 */
            uint32_t            : 22;
    } CLK_ADC_DIV_b;
  } ;
  __IM  uint32_t  CLK_ADC_SELECTED;             /*!< (@ 0x00000068) Indicates which SRC is currently selected by the glitchless mux (one-hot). This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1. */

  union {
    __IOM uint32_t CLK_RTC_CTRL;                /*!< (@ 0x0000006C) Clock control, can be changed on-the-fly (except for auxsrc) */

    struct {
            uint32_t            : 5;
      __IOM uint32_t AUXSRC     : 3;            /*!< [7..5] Selects the auxiliary clock source, will glitch when switching */
            uint32_t            : 2;
      __IOM uint32_t KILL       : 1;            /*!< [10..10] Asynchronously kills the clock generator */
      __IOM uint32_t ENABLE     : 1;            /*!< [11..11] Starts and stops the clock generator cleanly */
            uint32_t            : 4;
      __IOM uint32_t PHASE      : 2;            /*!< [17..16] This delays the enable signal by up to 3 cycles of the input clock This must be set before the clock is enabled to have any effect */
            uint32_t            : 2;
      __IOM uint32_t NUDGE      : 1;            /*!< [20..20] An edge on this signal shifts the phase of the output by 1 cycle of the input clock This can be done at any time */
            uint32_t            : 11;
    } CLK_RTC_CTRL_b;
  } ;

  union {
    __IOM uint32_t CLK_RTC_DIV;                 /*!< (@ 0x00000070) Clock divisor, can be changed on-the-fly */

    struct {
      __IOM uint32_t FRAC       : 8;            /*!< [7..0] Fractional component of the divisor */
      __IOM uint32_t INT        : 24;           /*!< [31..8] Integer component of the divisor, 0 -> divide by 2^16 */
    } CLK_RTC_DIV_b;
  } ;
  __IM  uint32_t  CLK_RTC_SELECTED;             /*!< (@ 0x00000074) Indicates which SRC is currently selected by the glitchless mux (one-hot). This slice does not have a glitchless mux (only the AUX_SRC field is present, not SRC) so this register is hardwired to 0x1. */

  union {
    __IOM uint32_t CLK_SYS_RESUS_CTRL;          /*!< (@ 0x00000078) CLK_SYS_RESUS_CTRL */

    struct {
      __IOM uint32_t TIMEOUT    : 8;            /*!< [7..0] This is expressed as a number of clk_ref cycles and must be >= 2x clk_ref_freq/min_clk_tst_freq */
      __IOM uint32_t ENABLE     : 1;            /*!< [8..8] Enable resus */
            uint32_t            : 3;
      __IOM uint32_t FRCE       : 1;            /*!< [12..12] Force a resus, for test purposes only */
            uint32_t            : 3;
      __IOM uint32_t CLEAR      : 1;            /*!< [16..16] For clearing the resus after the fault that triggered it has been corrected */
            uint32_t            : 15;
    } CLK_SYS_RESUS_CTRL_b;
  } ;

  union {
    __IOM uint32_t CLK_SYS_RESUS_STATUS;        /*!< (@ 0x0000007C) CLK_SYS_RESUS_STATUS */

    struct {
      __IM  uint32_t RESUSSED   : 1;            /*!< [0..0] Clock has been resuscitated, correct the error then send ctrl_clear=1 */
            uint32_t            : 31;
    } CLK_SYS_RESUS_STATUS_b;
  } ;

  union {
    __IOM uint32_t FC0_REF_KHZ;                 /*!< (@ 0x00000080) Reference clock frequency in kHz */

    struct {
      __IOM uint32_t FC0_REF_KHZ : 20;          /*!< [19..0] FC0_REF_KHZ */
            uint32_t            : 12;
    } FC0_REF_KHZ_b;
  } ;

  union {
    __IOM uint32_t FC0_MIN_KHZ;                 /*!< (@ 0x00000084) Minimum pass frequency in kHz. This is optional. Set to 0 if you are not using the pass/fail flags */

    struct {
      __IOM uint32_t FC0_MIN_KHZ : 25;          /*!< [24..0] FC0_MIN_KHZ */
            uint32_t            : 7;
    } FC0_MIN_KHZ_b;
  } ;

  union {
    __IOM uint32_t FC0_MAX_KHZ;                 /*!< (@ 0x00000088) Maximum pass frequency in kHz. This is optional. Set to 0x1ffffff if you are not using the pass/fail flags */

    struct {
      __IOM uint32_t FC0_MAX_KHZ : 25;          /*!< [24..0] FC0_MAX_KHZ */
            uint32_t            : 7;
    } FC0_MAX_KHZ_b;
  } ;

  union {
    __IOM uint32_t FC0_DELAY;                   /*!< (@ 0x0000008C) Delays the start of frequency counting to allow the mux to settle Delay is measured in multiples of the reference clock period */

    struct {
      __IOM uint32_t FC0_DELAY  : 3;            /*!< [2..0] FC0_DELAY */
            uint32_t            : 29;
    } FC0_DELAY_b;
  } ;

  union {
    __IOM uint32_t FC0_INTERVAL;                /*!< (@ 0x00000090) The test interval is 0.98us * 2**interval, but let's call it 1us * 2**interval The default gives a test interval of 250us */

    struct {
      __IOM uint32_t FC0_INTERVAL : 4;          /*!< [3..0] FC0_INTERVAL */
            uint32_t            : 28;
    } FC0_INTERVAL_b;
  } ;

  union {
    __IOM uint32_t FC0_SRC;                     /*!< (@ 0x00000094) Clock sent to frequency counter, set to 0 when not required Writing to this register initiates the frequency count */

    struct {
      __IOM uint32_t FC0_SRC    : 8;            /*!< [7..0] FC0_SRC */
            uint32_t            : 24;
    } FC0_SRC_b;
  } ;

  union {
    __IOM uint32_t FC0_STATUS;                  /*!< (@ 0x00000098) Frequency counter status */

    struct {
      __IM  uint32_t PASS       : 1;            /*!< [0..0] Test passed */
            uint32_t            : 3;
      __IM  uint32_t DONE       : 1;            /*!< [4..4] Test complete */
            uint32_t            : 3;
      __IM  uint32_t RUNNING    : 1;            /*!< [8..8] Test running */
            uint32_t            : 3;
      __IM  uint32_t WAITING    : 1;            /*!< [12..12] Waiting for test clock to start */
            uint32_t            : 3;
      __IM  uint32_t FAIL       : 1;            /*!< [16..16] Test failed */
            uint32_t            : 3;
      __IM  uint32_t SLOW       : 1;            /*!< [20..20] Test clock slower than expected, only valid when status_done=1 */
            uint32_t            : 3;
      __IM  uint32_t FAST       : 1;            /*!< [24..24] Test clock faster than expected, only valid when status_done=1 */
            uint32_t            : 3;
      __IM  uint32_t DIED       : 1;            /*!< [28..28] Test clock stopped during test */
            uint32_t            : 3;
    } FC0_STATUS_b;
  } ;

  union {
    __IOM uint32_t FC0_RESULT;                  /*!< (@ 0x0000009C) Result of frequency measurement, only valid when status_done=1 */

    struct {
      __IM  uint32_t FRAC       : 5;            /*!< [4..0] FRAC */
      __IM  uint32_t KHZ        : 25;           /*!< [29..5] KHZ */
            uint32_t            : 2;
    } FC0_RESULT_b;
  } ;

  union {
    __IOM uint32_t WAKE_EN0;                    /*!< (@ 0x000000A0) enable clock in wake mode */

    struct {
      __IOM uint32_t clk_sys_clocks : 1;        /*!< [0..0] clk_sys_clocks */
      __IOM uint32_t clk_adc_adc : 1;           /*!< [1..1] clk_adc_adc */
      __IOM uint32_t clk_sys_adc : 1;           /*!< [2..2] clk_sys_adc */
      __IOM uint32_t clk_sys_busctrl : 1;       /*!< [3..3] clk_sys_busctrl */
      __IOM uint32_t clk_sys_busfabric : 1;     /*!< [4..4] clk_sys_busfabric */
      __IOM uint32_t clk_sys_dma : 1;           /*!< [5..5] clk_sys_dma */
      __IOM uint32_t clk_sys_i2c0 : 1;          /*!< [6..6] clk_sys_i2c0 */
      __IOM uint32_t clk_sys_i2c1 : 1;          /*!< [7..7] clk_sys_i2c1 */
      __IOM uint32_t clk_sys_io : 1;            /*!< [8..8] clk_sys_io */
      __IOM uint32_t clk_sys_jtag : 1;          /*!< [9..9] clk_sys_jtag */
      __IOM uint32_t clk_sys_vreg_and_chip_reset : 1;/*!< [10..10] clk_sys_vreg_and_chip_reset */
      __IOM uint32_t clk_sys_pads : 1;          /*!< [11..11] clk_sys_pads */
      __IOM uint32_t clk_sys_pio0 : 1;          /*!< [12..12] clk_sys_pio0 */
      __IOM uint32_t clk_sys_pio1 : 1;          /*!< [13..13] clk_sys_pio1 */
      __IOM uint32_t clk_sys_pll_sys : 1;       /*!< [14..14] clk_sys_pll_sys */
      __IOM uint32_t clk_sys_pll_usb : 1;       /*!< [15..15] clk_sys_pll_usb */
      __IOM uint32_t clk_sys_psm : 1;           /*!< [16..16] clk_sys_psm */
      __IOM uint32_t clk_sys_pwm : 1;           /*!< [17..17] clk_sys_pwm */
      __IOM uint32_t clk_sys_resets : 1;        /*!< [18..18] clk_sys_resets */
      __IOM uint32_t clk_sys_rom : 1;           /*!< [19..19] clk_sys_rom */
      __IOM uint32_t clk_sys_rosc : 1;          /*!< [20..20] clk_sys_rosc */
      __IOM uint32_t clk_rtc_rtc : 1;           /*!< [21..21] clk_rtc_rtc */
      __IOM uint32_t clk_sys_rtc : 1;           /*!< [22..22] clk_sys_rtc */
      __IOM uint32_t clk_sys_sio : 1;           /*!< [23..23] clk_sys_sio */
      __IOM uint32_t clk_peri_spi0 : 1;         /*!< [24..24] clk_peri_spi0 */
      __IOM uint32_t clk_sys_spi0 : 1;          /*!< [25..25] clk_sys_spi0 */
      __IOM uint32_t clk_peri_spi1 : 1;         /*!< [26..26] clk_peri_spi1 */
      __IOM uint32_t clk_sys_spi1 : 1;          /*!< [27..27] clk_sys_spi1 */
      __IOM uint32_t clk_sys_sram0 : 1;         /*!< [28..28] clk_sys_sram0 */
      __IOM uint32_t clk_sys_sram1 : 1;         /*!< [29..29] clk_sys_sram1 */
      __IOM uint32_t clk_sys_sram2 : 1;         /*!< [30..30] clk_sys_sram2 */
      __IOM uint32_t clk_sys_sram3 : 1;         /*!< [31..31] clk_sys_sram3 */
    } WAKE_EN0_b;
  } ;

  union {
    __IOM uint32_t WAKE_EN1;                    /*!< (@ 0x000000A4) enable clock in wake mode */

    struct {
      __IOM uint32_t clk_sys_sram4 : 1;         /*!< [0..0] clk_sys_sram4 */
      __IOM uint32_t clk_sys_sram5 : 1;         /*!< [1..1] clk_sys_sram5 */
      __IOM uint32_t clk_sys_syscfg : 1;        /*!< [2..2] clk_sys_syscfg */
      __IOM uint32_t clk_sys_sysinfo : 1;       /*!< [3..3] clk_sys_sysinfo */
      __IOM uint32_t clk_sys_tbman : 1;         /*!< [4..4] clk_sys_tbman */
      __IOM uint32_t clk_sys_timer : 1;         /*!< [5..5] clk_sys_timer */
      __IOM uint32_t clk_peri_uart0 : 1;        /*!< [6..6] clk_peri_uart0 */
      __IOM uint32_t clk_sys_uart0 : 1;         /*!< [7..7] clk_sys_uart0 */
      __IOM uint32_t clk_peri_uart1 : 1;        /*!< [8..8] clk_peri_uart1 */
      __IOM uint32_t clk_sys_uart1 : 1;         /*!< [9..9] clk_sys_uart1 */
      __IOM uint32_t clk_sys_usbctrl : 1;       /*!< [10..10] clk_sys_usbctrl */
      __IOM uint32_t clk_usb_usbctrl : 1;       /*!< [11..11] clk_usb_usbctrl */
      __IOM uint32_t clk_sys_watchdog : 1;      /*!< [12..12] clk_sys_watchdog */
      __IOM uint32_t clk_sys_xip : 1;           /*!< [13..13] clk_sys_xip */
      __IOM uint32_t clk_sys_xosc : 1;          /*!< [14..14] clk_sys_xosc */
            uint32_t            : 17;
    } WAKE_EN1_b;
  } ;

  union {
    __IOM uint32_t SLEEP_EN0;                   /*!< (@ 0x000000A8) enable clock in sleep mode */

    struct {
      __IOM uint32_t clk_sys_clocks : 1;        /*!< [0..0] clk_sys_clocks */
      __IOM uint32_t clk_adc_adc : 1;           /*!< [1..1] clk_adc_adc */
      __IOM uint32_t clk_sys_adc : 1;           /*!< [2..2] clk_sys_adc */
      __IOM uint32_t clk_sys_busctrl : 1;       /*!< [3..3] clk_sys_busctrl */
      __IOM uint32_t clk_sys_busfabric : 1;     /*!< [4..4] clk_sys_busfabric */
      __IOM uint32_t clk_sys_dma : 1;           /*!< [5..5] clk_sys_dma */
      __IOM uint32_t clk_sys_i2c0 : 1;          /*!< [6..6] clk_sys_i2c0 */
      __IOM uint32_t clk_sys_i2c1 : 1;          /*!< [7..7] clk_sys_i2c1 */
      __IOM uint32_t clk_sys_io : 1;            /*!< [8..8] clk_sys_io */
      __IOM uint32_t clk_sys_jtag : 1;          /*!< [9..9] clk_sys_jtag */
      __IOM uint32_t clk_sys_vreg_and_chip_reset : 1;/*!< [10..10] clk_sys_vreg_and_chip_reset */
      __IOM uint32_t clk_sys_pads : 1;          /*!< [11..11] clk_sys_pads */
      __IOM uint32_t clk_sys_pio0 : 1;          /*!< [12..12] clk_sys_pio0 */
      __IOM uint32_t clk_sys_pio1 : 1;          /*!< [13..13] clk_sys_pio1 */
      __IOM uint32_t clk_sys_pll_sys : 1;       /*!< [14..14] clk_sys_pll_sys */
      __IOM uint32_t clk_sys_pll_usb : 1;       /*!< [15..15] clk_sys_pll_usb */
      __IOM uint32_t clk_sys_psm : 1;           /*!< [16..16] clk_sys_psm */
      __IOM uint32_t clk_sys_pwm : 1;           /*!< [17..17] clk_sys_pwm */
      __IOM uint32_t clk_sys_resets : 1;        /*!< [18..18] clk_sys_resets */
      __IOM uint32_t clk_sys_rom : 1;           /*!< [19..19] clk_sys_rom */
      __IOM uint32_t clk_sys_rosc : 1;          /*!< [20..20] clk_sys_rosc */
      __IOM uint32_t clk_rtc_rtc : 1;           /*!< [21..21] clk_rtc_rtc */
      __IOM uint32_t clk_sys_rtc : 1;           /*!< [22..22] clk_sys_rtc */
      __IOM uint32_t clk_sys_sio : 1;           /*!< [23..23] clk_sys_sio */
      __IOM uint32_t clk_peri_spi0 : 1;         /*!< [24..24] clk_peri_spi0 */
      __IOM uint32_t clk_sys_spi0 : 1;          /*!< [25..25] clk_sys_spi0 */
      __IOM uint32_t clk_peri_spi1 : 1;         /*!< [26..26] clk_peri_spi1 */
      __IOM uint32_t clk_sys_spi1 : 1;          /*!< [27..27] clk_sys_spi1 */
      __IOM uint32_t clk_sys_sram0 : 1;         /*!< [28..28] clk_sys_sram0 */
      __IOM uint32_t clk_sys_sram1 : 1;         /*!< [29..29] clk_sys_sram1 */
      __IOM uint32_t clk_sys_sram2 : 1;         /*!< [30..30] clk_sys_sram2 */
      __IOM uint32_t clk_sys_sram3 : 1;         /*!< [31..31] clk_sys_sram3 */
    } SLEEP_EN0_b;
  } ;

  union {
    __IOM uint32_t SLEEP_EN1;                   /*!< (@ 0x000000AC) enable clock in sleep mode */

    struct {
      __IOM uint32_t clk_sys_sram4 : 1;         /*!< [0..0] clk_sys_sram4 */
      __IOM uint32_t clk_sys_sram5 : 1;         /*!< [1..1] clk_sys_sram5 */
      __IOM uint32_t clk_sys_syscfg : 1;        /*!< [2..2] clk_sys_syscfg */
      __IOM uint32_t clk_sys_sysinfo : 1;       /*!< [3..3] clk_sys_sysinfo */
      __IOM uint32_t clk_sys_tbman : 1;         /*!< [4..4] clk_sys_tbman */
      __IOM uint32_t clk_sys_timer : 1;         /*!< [5..5] clk_sys_timer */
      __IOM uint32_t clk_peri_uart0 : 1;        /*!< [6..6] clk_peri_uart0 */
      __IOM uint32_t clk_sys_uart0 : 1;         /*!< [7..7] clk_sys_uart0 */
      __IOM uint32_t clk_peri_uart1 : 1;        /*!< [8..8] clk_peri_uart1 */
      __IOM uint32_t clk_sys_uart1 : 1;         /*!< [9..9] clk_sys_uart1 */
      __IOM uint32_t clk_sys_usbctrl : 1;       /*!< [10..10] clk_sys_usbctrl */
      __IOM uint32_t clk_usb_usbctrl : 1;       /*!< [11..11] clk_usb_usbctrl */
      __IOM uint32_t clk_sys_watchdog : 1;      /*!< [12..12] clk_sys_watchdog */
      __IOM uint32_t clk_sys_xip : 1;           /*!< [13..13] clk_sys_xip */
      __IOM uint32_t clk_sys_xosc : 1;          /*!< [14..14] clk_sys_xosc */
            uint32_t            : 17;
    } SLEEP_EN1_b;
  } ;

  union {
    __IOM uint32_t ENABLED0;                    /*!< (@ 0x000000B0) indicates the state of the clock enable */

    struct {
      __IM  uint32_t clk_sys_clocks : 1;        /*!< [0..0] clk_sys_clocks */
      __IM  uint32_t clk_adc_adc : 1;           /*!< [1..1] clk_adc_adc */
      __IM  uint32_t clk_sys_adc : 1;           /*!< [2..2] clk_sys_adc */
      __IM  uint32_t clk_sys_busctrl : 1;       /*!< [3..3] clk_sys_busctrl */
      __IM  uint32_t clk_sys_busfabric : 1;     /*!< [4..4] clk_sys_busfabric */
      __IM  uint32_t clk_sys_dma : 1;           /*!< [5..5] clk_sys_dma */
      __IM  uint32_t clk_sys_i2c0 : 1;          /*!< [6..6] clk_sys_i2c0 */
      __IM  uint32_t clk_sys_i2c1 : 1;          /*!< [7..7] clk_sys_i2c1 */
      __IM  uint32_t clk_sys_io : 1;            /*!< [8..8] clk_sys_io */
      __IM  uint32_t clk_sys_jtag : 1;          /*!< [9..9] clk_sys_jtag */
      __IM  uint32_t clk_sys_vreg_and_chip_reset : 1;/*!< [10..10] clk_sys_vreg_and_chip_reset */
      __IM  uint32_t clk_sys_pads : 1;          /*!< [11..11] clk_sys_pads */
      __IM  uint32_t clk_sys_pio0 : 1;          /*!< [12..12] clk_sys_pio0 */
      __IM  uint32_t clk_sys_pio1 : 1;          /*!< [13..13] clk_sys_pio1 */
      __IM  uint32_t clk_sys_pll_sys : 1;       /*!< [14..14] clk_sys_pll_sys */
      __IM  uint32_t clk_sys_pll_usb : 1;       /*!< [15..15] clk_sys_pll_usb */
      __IM  uint32_t clk_sys_psm : 1;           /*!< [16..16] clk_sys_psm */
      __IM  uint32_t clk_sys_pwm : 1;           /*!< [17..17] clk_sys_pwm */
      __IM  uint32_t clk_sys_resets : 1;        /*!< [18..18] clk_sys_resets */
      __IM  uint32_t clk_sys_rom : 1;           /*!< [19..19] clk_sys_rom */
      __IM  uint32_t clk_sys_rosc : 1;          /*!< [20..20] clk_sys_rosc */
      __IM  uint32_t clk_rtc_rtc : 1;           /*!< [21..21] clk_rtc_rtc */
      __IM  uint32_t clk_sys_rtc : 1;           /*!< [22..22] clk_sys_rtc */
      __IM  uint32_t clk_sys_sio : 1;           /*!< [23..23] clk_sys_sio */
      __IM  uint32_t clk_peri_spi0 : 1;         /*!< [24..24] clk_peri_spi0 */
      __IM  uint32_t clk_sys_spi0 : 1;          /*!< [25..25] clk_sys_spi0 */
      __IM  uint32_t clk_peri_spi1 : 1;         /*!< [26..26] clk_peri_spi1 */
      __IM  uint32_t clk_sys_spi1 : 1;          /*!< [27..27] clk_sys_spi1 */
      __IM  uint32_t clk_sys_sram0 : 1;         /*!< [28..28] clk_sys_sram0 */
      __IM  uint32_t clk_sys_sram1 : 1;         /*!< [29..29] clk_sys_sram1 */
      __IM  uint32_t clk_sys_sram2 : 1;         /*!< [30..30] clk_sys_sram2 */
      __IM  uint32_t clk_sys_sram3 : 1;         /*!< [31..31] clk_sys_sram3 */
    } ENABLED0_b;
  } ;

  union {
    __IOM uint32_t ENABLED1;                    /*!< (@ 0x000000B4) indicates the state of the clock enable */

    struct {
      __IM  uint32_t clk_sys_sram4 : 1;         /*!< [0..0] clk_sys_sram4 */
      __IM  uint32_t clk_sys_sram5 : 1;         /*!< [1..1] clk_sys_sram5 */
      __IM  uint32_t clk_sys_syscfg : 1;        /*!< [2..2] clk_sys_syscfg */
      __IM  uint32_t clk_sys_sysinfo : 1;       /*!< [3..3] clk_sys_sysinfo */
      __IM  uint32_t clk_sys_tbman : 1;         /*!< [4..4] clk_sys_tbman */
      __IM  uint32_t clk_sys_timer : 1;         /*!< [5..5] clk_sys_timer */
      __IM  uint32_t clk_peri_uart0 : 1;        /*!< [6..6] clk_peri_uart0 */
      __IM  uint32_t clk_sys_uart0 : 1;         /*!< [7..7] clk_sys_uart0 */
      __IM  uint32_t clk_peri_uart1 : 1;        /*!< [8..8] clk_peri_uart1 */
      __IM  uint32_t clk_sys_uart1 : 1;         /*!< [9..9] clk_sys_uart1 */
      __IM  uint32_t clk_sys_usbctrl : 1;       /*!< [10..10] clk_sys_usbctrl */
      __IM  uint32_t clk_usb_usbctrl : 1;       /*!< [11..11] clk_usb_usbctrl */
      __IM  uint32_t clk_sys_watchdog : 1;      /*!< [12..12] clk_sys_watchdog */
      __IM  uint32_t clk_sys_xip : 1;           /*!< [13..13] clk_sys_xip */
      __IM  uint32_t clk_sys_xosc : 1;          /*!< [14..14] clk_sys_xosc */
            uint32_t            : 17;
    } ENABLED1_b;
  } ;

  union {
    __IOM uint32_t INTR;                        /*!< (@ 0x000000B8) Raw Interrupts */

    struct {
      __IM  uint32_t CLK_SYS_RESUS : 1;         /*!< [0..0] CLK_SYS_RESUS */
            uint32_t            : 31;
    } INTR_b;
  } ;

  union {
    __IOM uint32_t INTE;                        /*!< (@ 0x000000BC) Interrupt Enable */

    struct {
      __IOM uint32_t CLK_SYS_RESUS : 1;         /*!< [0..0] CLK_SYS_RESUS */
            uint32_t            : 31;
    } INTE_b;
  } ;

  union {
    __IOM uint32_t INTF;                        /*!< (@ 0x000000C0) Interrupt Force */

    struct {
      __IOM uint32_t CLK_SYS_RESUS : 1;         /*!< [0..0] CLK_SYS_RESUS */
            uint32_t            : 31;
    } INTF_b;
  } ;

  union {
    __IOM uint32_t INTS;                        /*!< (@ 0x000000C4) Interrupt status after masking & forcing */

    struct {
      __IM  uint32_t CLK_SYS_RESUS : 1;         /*!< [0..0] CLK_SYS_RESUS */
            uint32_t            : 31;
    } INTS_b;
  } ;
} CLOCKS_Type;                                  /*!< Size = 200 (0xc8) */



/* =========================================================================================================================== */
/* ================                                          RESETS                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief RESETS (RESETS)
  */

typedef struct {                                /*!< (@ 0x4000C000) RESETS Structure */

  union {
    __IOM uint32_t RESET;                       /*!< (@ 0x00000000) Reset control. If a bit is set it means the peripheral is in reset. 0 means the peripheral's reset is deasserted. */

    struct {
      __IOM uint32_t adc        : 1;            /*!< [0..0] adc */
      __IOM uint32_t busctrl    : 1;            /*!< [1..1] busctrl */
      __IOM uint32_t dma        : 1;            /*!< [2..2] dma */
      __IOM uint32_t i2c0       : 1;            /*!< [3..3] i2c0 */
      __IOM uint32_t i2c1       : 1;            /*!< [4..4] i2c1 */
      __IOM uint32_t io_bank0   : 1;            /*!< [5..5] io_bank0 */
      __IOM uint32_t io_qspi    : 1;            /*!< [6..6] io_qspi */
      __IOM uint32_t jtag       : 1;            /*!< [7..7] jtag */
      __IOM uint32_t pads_bank0 : 1;            /*!< [8..8] pads_bank0 */
      __IOM uint32_t pads_qspi  : 1;            /*!< [9..9] pads_qspi */
      __IOM uint32_t pio0       : 1;            /*!< [10..10] pio0 */
      __IOM uint32_t pio1       : 1;            /*!< [11..11] pio1 */
      __IOM uint32_t pll_sys    : 1;            /*!< [12..12] pll_sys */
      __IOM uint32_t pll_usb    : 1;            /*!< [13..13] pll_usb */
      __IOM uint32_t pwm        : 1;            /*!< [14..14] pwm */
      __IOM uint32_t rtc        : 1;            /*!< [15..15] rtc */
      __IOM uint32_t spi0       : 1;            /*!< [16..16] spi0 */
      __IOM uint32_t spi1       : 1;            /*!< [17..17] spi1 */
      __IOM uint32_t syscfg     : 1;            /*!< [18..18] syscfg */
      __IOM uint32_t sysinfo    : 1;            /*!< [19..19] sysinfo */
      __IOM uint32_t tbman      : 1;            /*!< [20..20] tbman */
      __IOM uint32_t timer      : 1;            /*!< [21..21] timer */
      __IOM uint32_t uart0      : 1;            /*!< [22..22] uart0 */
      __IOM uint32_t uart1      : 1;            /*!< [23..23] uart1 */
      __IOM uint32_t usbctrl    : 1;            /*!< [24..24] usbctrl */
            uint32_t            : 7;
    } RESET_b;
  } ;

  union {
    __IOM uint32_t WDSEL;                       /*!< (@ 0x00000004) Watchdog select. If a bit is set then the watchdog will reset this peripheral when the watchdog fires. */

    struct {
      __IOM uint32_t adc        : 1;            /*!< [0..0] adc */
      __IOM uint32_t busctrl    : 1;            /*!< [1..1] busctrl */
      __IOM uint32_t dma        : 1;            /*!< [2..2] dma */
      __IOM uint32_t i2c0       : 1;            /*!< [3..3] i2c0 */
      __IOM uint32_t i2c1       : 1;            /*!< [4..4] i2c1 */
      __IOM uint32_t io_bank0   : 1;            /*!< [5..5] io_bank0 */
      __IOM uint32_t io_qspi    : 1;            /*!< [6..6] io_qspi */
      __IOM uint32_t jtag       : 1;            /*!< [7..7] jtag */
      __IOM uint32_t pads_bank0 : 1;            /*!< [8..8] pads_bank0 */
      __IOM uint32_t pads_qspi  : 1;            /*!< [9..9] pads_qspi */
      __IOM uint32_t pio0       : 1;            /*!< [10..10] pio0 */
      __IOM uint32_t pio1       : 1;            /*!< [11..11] pio1 */
      __IOM uint32_t pll_sys    : 1;            /*!< [12..12] pll_sys */
      __IOM uint32_t pll_usb    : 1;            /*!< [13..13] pll_usb */
      __IOM uint32_t pwm        : 1;            /*!< [14..14] pwm */
      __IOM uint32_t rtc        : 1;            /*!< [15..15] rtc */
      __IOM uint32_t spi0       : 1;            /*!< [16..16] spi0 */
      __IOM uint32_t spi1       : 1;            /*!< [17..17] spi1 */
      __IOM uint32_t syscfg     : 1;            /*!< [18..18] syscfg */
      __IOM uint32_t sysinfo    : 1;            /*!< [19..19] sysinfo */
      __IOM uint32_t tbman      : 1;            /*!< [20..20] tbman */
      __IOM uint32_t timer      : 1;            /*!< [21..21] timer */
      __IOM uint32_t uart0      : 1;            /*!< [22..22] uart0 */
      __IOM uint32_t uart1      : 1;            /*!< [23..23] uart1 */
      __IOM uint32_t usbctrl    : 1;            /*!< [24..24] usbctrl */
            uint32_t            : 7;
    } WDSEL_b;
  } ;

  union {
    __IOM uint32_t RESET_DONE;                  /*!< (@ 0x00000008) Reset done. If a bit is set then a reset done signal has been returned by the peripheral. This indicates that the peripheral's registers are ready to be accessed. */

    struct {
      __IM  uint32_t adc        : 1;            /*!< [0..0] adc */
      __IM  uint32_t busctrl    : 1;            /*!< [1..1] busctrl */
      __IM  uint32_t dma        : 1;            /*!< [2..2] dma */
      __IM  uint32_t i2c0       : 1;            /*!< [3..3] i2c0 */
      __IM  uint32_t i2c1       : 1;            /*!< [4..4] i2c1 */
      __IM  uint32_t io_bank0   : 1;            /*!< [5..5] io_bank0 */
      __IM  uint32_t io_qspi    : 1;            /*!< [6..6] io_qspi */
      __IM  uint32_t jtag       : 1;            /*!< [7..7] jtag */
      __IM  uint32_t pads_bank0 : 1;            /*!< [8..8] pads_bank0 */
      __IM  uint32_t pads_qspi  : 1;            /*!< [9..9] pads_qspi */
      __IM  uint32_t pio0       : 1;            /*!< [10..10] pio0 */
      __IM  uint32_t pio1       : 1;            /*!< [11..11] pio1 */
      __IM  uint32_t pll_sys    : 1;            /*!< [12..12] pll_sys */
      __IM  uint32_t pll_usb    : 1;            /*!< [13..13] pll_usb */
      __IM  uint32_t pwm        : 1;            /*!< [14..14] pwm */
      __IM  uint32_t rtc        : 1;            /*!< [15..15] rtc */
      __IM  uint32_t spi0       : 1;            /*!< [16..16] spi0 */
      __IM  uint32_t spi1       : 1;            /*!< [17..17] spi1 */
      __IM  uint32_t syscfg     : 1;            /*!< [18..18] syscfg */
      __IM  uint32_t sysinfo    : 1;            /*!< [19..19] sysinfo */
      __IM  uint32_t tbman      : 1;            /*!< [20..20] tbman */
      __IM  uint32_t timer      : 1;            /*!< [21..21] timer */
      __IM  uint32_t uart0      : 1;            /*!< [22..22] uart0 */
      __IM  uint32_t uart1      : 1;            /*!< [23..23] uart1 */
      __IM  uint32_t usbctrl    : 1;            /*!< [24..24] usbctrl */
            uint32_t            : 7;
    } RESET_DONE_b;
  } ;
} RESETS_Type;                                  /*!< Size = 12 (0xc) */



/* =========================================================================================================================== */
/* ================                                            PSM                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief PSM (PSM)
  */

typedef struct {                                /*!< (@ 0x40010000) PSM Structure */

  union {
    __IOM uint32_t FRCE_ON;                     /*!< (@ 0x00000000) Force block out of reset (i.e. power it on) */

    struct {
      __IOM uint32_t rosc       : 1;            /*!< [0..0] rosc */
      __IOM uint32_t xosc       : 1;            /*!< [1..1] xosc */
      __IOM uint32_t clocks     : 1;            /*!< [2..2] clocks */
      __IOM uint32_t resets     : 1;            /*!< [3..3] resets */
      __IOM uint32_t busfabric  : 1;            /*!< [4..4] busfabric */
      __IOM uint32_t rom        : 1;            /*!< [5..5] rom */
      __IOM uint32_t sram0      : 1;            /*!< [6..6] sram0 */
      __IOM uint32_t sram1      : 1;            /*!< [7..7] sram1 */
      __IOM uint32_t sram2      : 1;            /*!< [8..8] sram2 */
      __IOM uint32_t sram3      : 1;            /*!< [9..9] sram3 */
      __IOM uint32_t sram4      : 1;            /*!< [10..10] sram4 */
      __IOM uint32_t sram5      : 1;            /*!< [11..11] sram5 */
      __IOM uint32_t xip        : 1;            /*!< [12..12] xip */
      __IOM uint32_t vreg_and_chip_reset : 1;   /*!< [13..13] vreg_and_chip_reset */
      __IOM uint32_t sio        : 1;            /*!< [14..14] sio */
      __IOM uint32_t proc0      : 1;            /*!< [15..15] proc0 */
      __IOM uint32_t proc1      : 1;            /*!< [16..16] proc1 */
            uint32_t            : 15;
    } FRCE_ON_b;
  } ;

  union {
    __IOM uint32_t FRCE_OFF;                    /*!< (@ 0x00000004) Force into reset (i.e. power it off) */

    struct {
      __IOM uint32_t rosc       : 1;            /*!< [0..0] rosc */
      __IOM uint32_t xosc       : 1;            /*!< [1..1] xosc */
      __IOM uint32_t clocks     : 1;            /*!< [2..2] clocks */
      __IOM uint32_t resets     : 1;            /*!< [3..3] resets */
      __IOM uint32_t busfabric  : 1;            /*!< [4..4] busfabric */
      __IOM uint32_t rom        : 1;            /*!< [5..5] rom */
      __IOM uint32_t sram0      : 1;            /*!< [6..6] sram0 */
      __IOM uint32_t sram1      : 1;            /*!< [7..7] sram1 */
      __IOM uint32_t sram2      : 1;            /*!< [8..8] sram2 */
      __IOM uint32_t sram3      : 1;            /*!< [9..9] sram3 */
      __IOM uint32_t sram4      : 1;            /*!< [10..10] sram4 */
      __IOM uint32_t sram5      : 1;            /*!< [11..11] sram5 */
      __IOM uint32_t xip        : 1;            /*!< [12..12] xip */
      __IOM uint32_t vreg_and_chip_reset : 1;   /*!< [13..13] vreg_and_chip_reset */
      __IOM uint32_t sio        : 1;            /*!< [14..14] sio */
      __IOM uint32_t proc0      : 1;            /*!< [15..15] proc0 */
      __IOM uint32_t proc1      : 1;            /*!< [16..16] proc1 */
            uint32_t            : 15;
    } FRCE_OFF_b;
  } ;

  union {
    __IOM uint32_t WDSEL;                       /*!< (@ 0x00000008) Set to 1 if this peripheral should be reset when the watchdog fires. */

    struct {
      __IOM uint32_t rosc       : 1;            /*!< [0..0] rosc */
      __IOM uint32_t xosc       : 1;            /*!< [1..1] xosc */
      __IOM uint32_t clocks     : 1;            /*!< [2..2] clocks */
      __IOM uint32_t resets     : 1;            /*!< [3..3] resets */
      __IOM uint32_t busfabric  : 1;            /*!< [4..4] busfabric */
      __IOM uint32_t rom        : 1;            /*!< [5..5] rom */
      __IOM uint32_t sram0      : 1;            /*!< [6..6] sram0 */
      __IOM uint32_t sram1      : 1;            /*!< [7..7] sram1 */
      __IOM uint32_t sram2      : 1;            /*!< [8..8] sram2 */
      __IOM uint32_t sram3      : 1;            /*!< [9..9] sram3 */
      __IOM uint32_t sram4      : 1;            /*!< [10..10] sram4 */
      __IOM uint32_t sram5      : 1;            /*!< [11..11] sram5 */
      __IOM uint32_t xip        : 1;            /*!< [12..12] xip */
      __IOM uint32_t vreg_and_chip_reset : 1;   /*!< [13..13] vreg_and_chip_reset */
      __IOM uint32_t sio        : 1;            /*!< [14..14] sio */
      __IOM uint32_t proc0      : 1;            /*!< [15..15] proc0 */
      __IOM uint32_t proc1      : 1;            /*!< [16..16] proc1 */
            uint32_t            : 15;
    } WDSEL_b;
  } ;

  union {
    __IOM uint32_t DONE;                        /*!< (@ 0x0000000C) Indicates the peripheral's registers are ready to access. */

    struct {
      __IM  uint32_t rosc       : 1;            /*!< [0..0] rosc */
      __IM  uint32_t xosc       : 1;            /*!< [1..1] xosc */
      __IM  uint32_t clocks     : 1;            /*!< [2..2] clocks */
      __IM  uint32_t resets     : 1;            /*!< [3..3] resets */
      __IM  uint32_t busfabric  : 1;            /*!< [4..4] busfabric */
      __IM  uint32_t rom        : 1;            /*!< [5..5] rom */
      __IM  uint32_t sram0      : 1;            /*!< [6..6] sram0 */
      __IM  uint32_t sram1      : 1;            /*!< [7..7] sram1 */
      __IM  uint32_t sram2      : 1;            /*!< [8..8] sram2 */
      __IM  uint32_t sram3      : 1;            /*!< [9..9] sram3 */
      __IM  uint32_t sram4      : 1;            /*!< [10..10] sram4 */
      __IM  uint32_t sram5      : 1;            /*!< [11..11] sram5 */
      __IM  uint32_t xip        : 1;            /*!< [12..12] xip */
      __IM  uint32_t vreg_and_chip_reset : 1;   /*!< [13..13] vreg_and_chip_reset */
      __IM  uint32_t sio        : 1;            /*!< [14..14] sio */
      __IM  uint32_t proc0      : 1;            /*!< [15..15] proc0 */
      __IM  uint32_t proc1      : 1;            /*!< [16..16] proc1 */
            uint32_t            : 15;
    } DONE_b;
  } ;
} PSM_Type;                                     /*!< Size = 16 (0x10) */



/* =========================================================================================================================== */
/* ================                                         IO_BANK0                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief IO_BANK0 (IO_BANK0)
  */

typedef struct {                                /*!< (@ 0x40014000) IO_BANK0 Structure */

  union {
    __IOM uint32_t GPIO0_STATUS;                /*!< (@ 0x00000000) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO0_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO0_CTRL;                  /*!< (@ 0x00000004) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO0_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO1_STATUS;                /*!< (@ 0x00000008) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO1_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO1_CTRL;                  /*!< (@ 0x0000000C) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO1_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO2_STATUS;                /*!< (@ 0x00000010) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO2_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO2_CTRL;                  /*!< (@ 0x00000014) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO2_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO3_STATUS;                /*!< (@ 0x00000018) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO3_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO3_CTRL;                  /*!< (@ 0x0000001C) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO3_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO4_STATUS;                /*!< (@ 0x00000020) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO4_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO4_CTRL;                  /*!< (@ 0x00000024) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO4_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO5_STATUS;                /*!< (@ 0x00000028) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO5_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO5_CTRL;                  /*!< (@ 0x0000002C) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO5_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO6_STATUS;                /*!< (@ 0x00000030) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO6_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO6_CTRL;                  /*!< (@ 0x00000034) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO6_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO7_STATUS;                /*!< (@ 0x00000038) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO7_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO7_CTRL;                  /*!< (@ 0x0000003C) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO7_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO8_STATUS;                /*!< (@ 0x00000040) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO8_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO8_CTRL;                  /*!< (@ 0x00000044) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO8_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO9_STATUS;                /*!< (@ 0x00000048) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO9_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO9_CTRL;                  /*!< (@ 0x0000004C) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO9_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO10_STATUS;               /*!< (@ 0x00000050) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO10_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO10_CTRL;                 /*!< (@ 0x00000054) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO10_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO11_STATUS;               /*!< (@ 0x00000058) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO11_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO11_CTRL;                 /*!< (@ 0x0000005C) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO11_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO12_STATUS;               /*!< (@ 0x00000060) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO12_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO12_CTRL;                 /*!< (@ 0x00000064) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO12_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO13_STATUS;               /*!< (@ 0x00000068) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO13_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO13_CTRL;                 /*!< (@ 0x0000006C) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO13_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO14_STATUS;               /*!< (@ 0x00000070) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO14_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO14_CTRL;                 /*!< (@ 0x00000074) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO14_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO15_STATUS;               /*!< (@ 0x00000078) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO15_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO15_CTRL;                 /*!< (@ 0x0000007C) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO15_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO16_STATUS;               /*!< (@ 0x00000080) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO16_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO16_CTRL;                 /*!< (@ 0x00000084) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO16_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO17_STATUS;               /*!< (@ 0x00000088) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO17_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO17_CTRL;                 /*!< (@ 0x0000008C) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO17_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO18_STATUS;               /*!< (@ 0x00000090) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO18_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO18_CTRL;                 /*!< (@ 0x00000094) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO18_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO19_STATUS;               /*!< (@ 0x00000098) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO19_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO19_CTRL;                 /*!< (@ 0x0000009C) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO19_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO20_STATUS;               /*!< (@ 0x000000A0) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO20_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO20_CTRL;                 /*!< (@ 0x000000A4) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO20_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO21_STATUS;               /*!< (@ 0x000000A8) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO21_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO21_CTRL;                 /*!< (@ 0x000000AC) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO21_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO22_STATUS;               /*!< (@ 0x000000B0) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO22_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO22_CTRL;                 /*!< (@ 0x000000B4) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO22_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO23_STATUS;               /*!< (@ 0x000000B8) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO23_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO23_CTRL;                 /*!< (@ 0x000000BC) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO23_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO24_STATUS;               /*!< (@ 0x000000C0) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO24_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO24_CTRL;                 /*!< (@ 0x000000C4) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO24_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO25_STATUS;               /*!< (@ 0x000000C8) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO25_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO25_CTRL;                 /*!< (@ 0x000000CC) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO25_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO26_STATUS;               /*!< (@ 0x000000D0) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO26_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO26_CTRL;                 /*!< (@ 0x000000D4) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO26_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO27_STATUS;               /*!< (@ 0x000000D8) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO27_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO27_CTRL;                 /*!< (@ 0x000000DC) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO27_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO28_STATUS;               /*!< (@ 0x000000E0) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO28_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO28_CTRL;                 /*!< (@ 0x000000E4) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO28_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO29_STATUS;               /*!< (@ 0x000000E8) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO29_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO29_CTRL;                 /*!< (@ 0x000000EC) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO29_CTRL_b;
  } ;

  union {
    __IOM uint32_t INTR0;                       /*!< (@ 0x000000F0) Raw Interrupts */

    struct {
      __IM  uint32_t GPIO0_LEVEL_LOW : 1;       /*!< [0..0] GPIO0_LEVEL_LOW */
      __IM  uint32_t GPIO0_LEVEL_HIGH : 1;      /*!< [1..1] GPIO0_LEVEL_HIGH */
      __IOM uint32_t GPIO0_EDGE_LOW : 1;        /*!< [2..2] GPIO0_EDGE_LOW */
      __IOM uint32_t GPIO0_EDGE_HIGH : 1;       /*!< [3..3] GPIO0_EDGE_HIGH */
      __IM  uint32_t GPIO1_LEVEL_LOW : 1;       /*!< [4..4] GPIO1_LEVEL_LOW */
      __IM  uint32_t GPIO1_LEVEL_HIGH : 1;      /*!< [5..5] GPIO1_LEVEL_HIGH */
      __IOM uint32_t GPIO1_EDGE_LOW : 1;        /*!< [6..6] GPIO1_EDGE_LOW */
      __IOM uint32_t GPIO1_EDGE_HIGH : 1;       /*!< [7..7] GPIO1_EDGE_HIGH */
      __IM  uint32_t GPIO2_LEVEL_LOW : 1;       /*!< [8..8] GPIO2_LEVEL_LOW */
      __IM  uint32_t GPIO2_LEVEL_HIGH : 1;      /*!< [9..9] GPIO2_LEVEL_HIGH */
      __IOM uint32_t GPIO2_EDGE_LOW : 1;        /*!< [10..10] GPIO2_EDGE_LOW */
      __IOM uint32_t GPIO2_EDGE_HIGH : 1;       /*!< [11..11] GPIO2_EDGE_HIGH */
      __IM  uint32_t GPIO3_LEVEL_LOW : 1;       /*!< [12..12] GPIO3_LEVEL_LOW */
      __IM  uint32_t GPIO3_LEVEL_HIGH : 1;      /*!< [13..13] GPIO3_LEVEL_HIGH */
      __IOM uint32_t GPIO3_EDGE_LOW : 1;        /*!< [14..14] GPIO3_EDGE_LOW */
      __IOM uint32_t GPIO3_EDGE_HIGH : 1;       /*!< [15..15] GPIO3_EDGE_HIGH */
      __IM  uint32_t GPIO4_LEVEL_LOW : 1;       /*!< [16..16] GPIO4_LEVEL_LOW */
      __IM  uint32_t GPIO4_LEVEL_HIGH : 1;      /*!< [17..17] GPIO4_LEVEL_HIGH */
      __IOM uint32_t GPIO4_EDGE_LOW : 1;        /*!< [18..18] GPIO4_EDGE_LOW */
      __IOM uint32_t GPIO4_EDGE_HIGH : 1;       /*!< [19..19] GPIO4_EDGE_HIGH */
      __IM  uint32_t GPIO5_LEVEL_LOW : 1;       /*!< [20..20] GPIO5_LEVEL_LOW */
      __IM  uint32_t GPIO5_LEVEL_HIGH : 1;      /*!< [21..21] GPIO5_LEVEL_HIGH */
      __IOM uint32_t GPIO5_EDGE_LOW : 1;        /*!< [22..22] GPIO5_EDGE_LOW */
      __IOM uint32_t GPIO5_EDGE_HIGH : 1;       /*!< [23..23] GPIO5_EDGE_HIGH */
      __IM  uint32_t GPIO6_LEVEL_LOW : 1;       /*!< [24..24] GPIO6_LEVEL_LOW */
      __IM  uint32_t GPIO6_LEVEL_HIGH : 1;      /*!< [25..25] GPIO6_LEVEL_HIGH */
      __IOM uint32_t GPIO6_EDGE_LOW : 1;        /*!< [26..26] GPIO6_EDGE_LOW */
      __IOM uint32_t GPIO6_EDGE_HIGH : 1;       /*!< [27..27] GPIO6_EDGE_HIGH */
      __IM  uint32_t GPIO7_LEVEL_LOW : 1;       /*!< [28..28] GPIO7_LEVEL_LOW */
      __IM  uint32_t GPIO7_LEVEL_HIGH : 1;      /*!< [29..29] GPIO7_LEVEL_HIGH */
      __IOM uint32_t GPIO7_EDGE_LOW : 1;        /*!< [30..30] GPIO7_EDGE_LOW */
      __IOM uint32_t GPIO7_EDGE_HIGH : 1;       /*!< [31..31] GPIO7_EDGE_HIGH */
    } INTR0_b;
  } ;

  union {
    __IOM uint32_t INTR1;                       /*!< (@ 0x000000F4) Raw Interrupts */

    struct {
      __IM  uint32_t GPIO8_LEVEL_LOW : 1;       /*!< [0..0] GPIO8_LEVEL_LOW */
      __IM  uint32_t GPIO8_LEVEL_HIGH : 1;      /*!< [1..1] GPIO8_LEVEL_HIGH */
      __IOM uint32_t GPIO8_EDGE_LOW : 1;        /*!< [2..2] GPIO8_EDGE_LOW */
      __IOM uint32_t GPIO8_EDGE_HIGH : 1;       /*!< [3..3] GPIO8_EDGE_HIGH */
      __IM  uint32_t GPIO9_LEVEL_LOW : 1;       /*!< [4..4] GPIO9_LEVEL_LOW */
      __IM  uint32_t GPIO9_LEVEL_HIGH : 1;      /*!< [5..5] GPIO9_LEVEL_HIGH */
      __IOM uint32_t GPIO9_EDGE_LOW : 1;        /*!< [6..6] GPIO9_EDGE_LOW */
      __IOM uint32_t GPIO9_EDGE_HIGH : 1;       /*!< [7..7] GPIO9_EDGE_HIGH */
      __IM  uint32_t GPIO10_LEVEL_LOW : 1;      /*!< [8..8] GPIO10_LEVEL_LOW */
      __IM  uint32_t GPIO10_LEVEL_HIGH : 1;     /*!< [9..9] GPIO10_LEVEL_HIGH */
      __IOM uint32_t GPIO10_EDGE_LOW : 1;       /*!< [10..10] GPIO10_EDGE_LOW */
      __IOM uint32_t GPIO10_EDGE_HIGH : 1;      /*!< [11..11] GPIO10_EDGE_HIGH */
      __IM  uint32_t GPIO11_LEVEL_LOW : 1;      /*!< [12..12] GPIO11_LEVEL_LOW */
      __IM  uint32_t GPIO11_LEVEL_HIGH : 1;     /*!< [13..13] GPIO11_LEVEL_HIGH */
      __IOM uint32_t GPIO11_EDGE_LOW : 1;       /*!< [14..14] GPIO11_EDGE_LOW */
      __IOM uint32_t GPIO11_EDGE_HIGH : 1;      /*!< [15..15] GPIO11_EDGE_HIGH */
      __IM  uint32_t GPIO12_LEVEL_LOW : 1;      /*!< [16..16] GPIO12_LEVEL_LOW */
      __IM  uint32_t GPIO12_LEVEL_HIGH : 1;     /*!< [17..17] GPIO12_LEVEL_HIGH */
      __IOM uint32_t GPIO12_EDGE_LOW : 1;       /*!< [18..18] GPIO12_EDGE_LOW */
      __IOM uint32_t GPIO12_EDGE_HIGH : 1;      /*!< [19..19] GPIO12_EDGE_HIGH */
      __IM  uint32_t GPIO13_LEVEL_LOW : 1;      /*!< [20..20] GPIO13_LEVEL_LOW */
      __IM  uint32_t GPIO13_LEVEL_HIGH : 1;     /*!< [21..21] GPIO13_LEVEL_HIGH */
      __IOM uint32_t GPIO13_EDGE_LOW : 1;       /*!< [22..22] GPIO13_EDGE_LOW */
      __IOM uint32_t GPIO13_EDGE_HIGH : 1;      /*!< [23..23] GPIO13_EDGE_HIGH */
      __IM  uint32_t GPIO14_LEVEL_LOW : 1;      /*!< [24..24] GPIO14_LEVEL_LOW */
      __IM  uint32_t GPIO14_LEVEL_HIGH : 1;     /*!< [25..25] GPIO14_LEVEL_HIGH */
      __IOM uint32_t GPIO14_EDGE_LOW : 1;       /*!< [26..26] GPIO14_EDGE_LOW */
      __IOM uint32_t GPIO14_EDGE_HIGH : 1;      /*!< [27..27] GPIO14_EDGE_HIGH */
      __IM  uint32_t GPIO15_LEVEL_LOW : 1;      /*!< [28..28] GPIO15_LEVEL_LOW */
      __IM  uint32_t GPIO15_LEVEL_HIGH : 1;     /*!< [29..29] GPIO15_LEVEL_HIGH */
      __IOM uint32_t GPIO15_EDGE_LOW : 1;       /*!< [30..30] GPIO15_EDGE_LOW */
      __IOM uint32_t GPIO15_EDGE_HIGH : 1;      /*!< [31..31] GPIO15_EDGE_HIGH */
    } INTR1_b;
  } ;

  union {
    __IOM uint32_t INTR2;                       /*!< (@ 0x000000F8) Raw Interrupts */

    struct {
      __IM  uint32_t GPIO16_LEVEL_LOW : 1;      /*!< [0..0] GPIO16_LEVEL_LOW */
      __IM  uint32_t GPIO16_LEVEL_HIGH : 1;     /*!< [1..1] GPIO16_LEVEL_HIGH */
      __IOM uint32_t GPIO16_EDGE_LOW : 1;       /*!< [2..2] GPIO16_EDGE_LOW */
      __IOM uint32_t GPIO16_EDGE_HIGH : 1;      /*!< [3..3] GPIO16_EDGE_HIGH */
      __IM  uint32_t GPIO17_LEVEL_LOW : 1;      /*!< [4..4] GPIO17_LEVEL_LOW */
      __IM  uint32_t GPIO17_LEVEL_HIGH : 1;     /*!< [5..5] GPIO17_LEVEL_HIGH */
      __IOM uint32_t GPIO17_EDGE_LOW : 1;       /*!< [6..6] GPIO17_EDGE_LOW */
      __IOM uint32_t GPIO17_EDGE_HIGH : 1;      /*!< [7..7] GPIO17_EDGE_HIGH */
      __IM  uint32_t GPIO18_LEVEL_LOW : 1;      /*!< [8..8] GPIO18_LEVEL_LOW */
      __IM  uint32_t GPIO18_LEVEL_HIGH : 1;     /*!< [9..9] GPIO18_LEVEL_HIGH */
      __IOM uint32_t GPIO18_EDGE_LOW : 1;       /*!< [10..10] GPIO18_EDGE_LOW */
      __IOM uint32_t GPIO18_EDGE_HIGH : 1;      /*!< [11..11] GPIO18_EDGE_HIGH */
      __IM  uint32_t GPIO19_LEVEL_LOW : 1;      /*!< [12..12] GPIO19_LEVEL_LOW */
      __IM  uint32_t GPIO19_LEVEL_HIGH : 1;     /*!< [13..13] GPIO19_LEVEL_HIGH */
      __IOM uint32_t GPIO19_EDGE_LOW : 1;       /*!< [14..14] GPIO19_EDGE_LOW */
      __IOM uint32_t GPIO19_EDGE_HIGH : 1;      /*!< [15..15] GPIO19_EDGE_HIGH */
      __IM  uint32_t GPIO20_LEVEL_LOW : 1;      /*!< [16..16] GPIO20_LEVEL_LOW */
      __IM  uint32_t GPIO20_LEVEL_HIGH : 1;     /*!< [17..17] GPIO20_LEVEL_HIGH */
      __IOM uint32_t GPIO20_EDGE_LOW : 1;       /*!< [18..18] GPIO20_EDGE_LOW */
      __IOM uint32_t GPIO20_EDGE_HIGH : 1;      /*!< [19..19] GPIO20_EDGE_HIGH */
      __IM  uint32_t GPIO21_LEVEL_LOW : 1;      /*!< [20..20] GPIO21_LEVEL_LOW */
      __IM  uint32_t GPIO21_LEVEL_HIGH : 1;     /*!< [21..21] GPIO21_LEVEL_HIGH */
      __IOM uint32_t GPIO21_EDGE_LOW : 1;       /*!< [22..22] GPIO21_EDGE_LOW */
      __IOM uint32_t GPIO21_EDGE_HIGH : 1;      /*!< [23..23] GPIO21_EDGE_HIGH */
      __IM  uint32_t GPIO22_LEVEL_LOW : 1;      /*!< [24..24] GPIO22_LEVEL_LOW */
      __IM  uint32_t GPIO22_LEVEL_HIGH : 1;     /*!< [25..25] GPIO22_LEVEL_HIGH */
      __IOM uint32_t GPIO22_EDGE_LOW : 1;       /*!< [26..26] GPIO22_EDGE_LOW */
      __IOM uint32_t GPIO22_EDGE_HIGH : 1;      /*!< [27..27] GPIO22_EDGE_HIGH */
      __IM  uint32_t GPIO23_LEVEL_LOW : 1;      /*!< [28..28] GPIO23_LEVEL_LOW */
      __IM  uint32_t GPIO23_LEVEL_HIGH : 1;     /*!< [29..29] GPIO23_LEVEL_HIGH */
      __IOM uint32_t GPIO23_EDGE_LOW : 1;       /*!< [30..30] GPIO23_EDGE_LOW */
      __IOM uint32_t GPIO23_EDGE_HIGH : 1;      /*!< [31..31] GPIO23_EDGE_HIGH */
    } INTR2_b;
  } ;

  union {
    __IOM uint32_t INTR3;                       /*!< (@ 0x000000FC) Raw Interrupts */

    struct {
      __IM  uint32_t GPIO24_LEVEL_LOW : 1;      /*!< [0..0] GPIO24_LEVEL_LOW */
      __IM  uint32_t GPIO24_LEVEL_HIGH : 1;     /*!< [1..1] GPIO24_LEVEL_HIGH */
      __IOM uint32_t GPIO24_EDGE_LOW : 1;       /*!< [2..2] GPIO24_EDGE_LOW */
      __IOM uint32_t GPIO24_EDGE_HIGH : 1;      /*!< [3..3] GPIO24_EDGE_HIGH */
      __IM  uint32_t GPIO25_LEVEL_LOW : 1;      /*!< [4..4] GPIO25_LEVEL_LOW */
      __IM  uint32_t GPIO25_LEVEL_HIGH : 1;     /*!< [5..5] GPIO25_LEVEL_HIGH */
      __IOM uint32_t GPIO25_EDGE_LOW : 1;       /*!< [6..6] GPIO25_EDGE_LOW */
      __IOM uint32_t GPIO25_EDGE_HIGH : 1;      /*!< [7..7] GPIO25_EDGE_HIGH */
      __IM  uint32_t GPIO26_LEVEL_LOW : 1;      /*!< [8..8] GPIO26_LEVEL_LOW */
      __IM  uint32_t GPIO26_LEVEL_HIGH : 1;     /*!< [9..9] GPIO26_LEVEL_HIGH */
      __IOM uint32_t GPIO26_EDGE_LOW : 1;       /*!< [10..10] GPIO26_EDGE_LOW */
      __IOM uint32_t GPIO26_EDGE_HIGH : 1;      /*!< [11..11] GPIO26_EDGE_HIGH */
      __IM  uint32_t GPIO27_LEVEL_LOW : 1;      /*!< [12..12] GPIO27_LEVEL_LOW */
      __IM  uint32_t GPIO27_LEVEL_HIGH : 1;     /*!< [13..13] GPIO27_LEVEL_HIGH */
      __IOM uint32_t GPIO27_EDGE_LOW : 1;       /*!< [14..14] GPIO27_EDGE_LOW */
      __IOM uint32_t GPIO27_EDGE_HIGH : 1;      /*!< [15..15] GPIO27_EDGE_HIGH */
      __IM  uint32_t GPIO28_LEVEL_LOW : 1;      /*!< [16..16] GPIO28_LEVEL_LOW */
      __IM  uint32_t GPIO28_LEVEL_HIGH : 1;     /*!< [17..17] GPIO28_LEVEL_HIGH */
      __IOM uint32_t GPIO28_EDGE_LOW : 1;       /*!< [18..18] GPIO28_EDGE_LOW */
      __IOM uint32_t GPIO28_EDGE_HIGH : 1;      /*!< [19..19] GPIO28_EDGE_HIGH */
      __IM  uint32_t GPIO29_LEVEL_LOW : 1;      /*!< [20..20] GPIO29_LEVEL_LOW */
      __IM  uint32_t GPIO29_LEVEL_HIGH : 1;     /*!< [21..21] GPIO29_LEVEL_HIGH */
      __IOM uint32_t GPIO29_EDGE_LOW : 1;       /*!< [22..22] GPIO29_EDGE_LOW */
      __IOM uint32_t GPIO29_EDGE_HIGH : 1;      /*!< [23..23] GPIO29_EDGE_HIGH */
            uint32_t            : 8;
    } INTR3_b;
  } ;

  union {
    __IOM uint32_t PROC0_INTE0;                 /*!< (@ 0x00000100) Interrupt Enable for proc0 */

    struct {
      __IOM uint32_t GPIO0_LEVEL_LOW : 1;       /*!< [0..0] GPIO0_LEVEL_LOW */
      __IOM uint32_t GPIO0_LEVEL_HIGH : 1;      /*!< [1..1] GPIO0_LEVEL_HIGH */
      __IOM uint32_t GPIO0_EDGE_LOW : 1;        /*!< [2..2] GPIO0_EDGE_LOW */
      __IOM uint32_t GPIO0_EDGE_HIGH : 1;       /*!< [3..3] GPIO0_EDGE_HIGH */
      __IOM uint32_t GPIO1_LEVEL_LOW : 1;       /*!< [4..4] GPIO1_LEVEL_LOW */
      __IOM uint32_t GPIO1_LEVEL_HIGH : 1;      /*!< [5..5] GPIO1_LEVEL_HIGH */
      __IOM uint32_t GPIO1_EDGE_LOW : 1;        /*!< [6..6] GPIO1_EDGE_LOW */
      __IOM uint32_t GPIO1_EDGE_HIGH : 1;       /*!< [7..7] GPIO1_EDGE_HIGH */
      __IOM uint32_t GPIO2_LEVEL_LOW : 1;       /*!< [8..8] GPIO2_LEVEL_LOW */
      __IOM uint32_t GPIO2_LEVEL_HIGH : 1;      /*!< [9..9] GPIO2_LEVEL_HIGH */
      __IOM uint32_t GPIO2_EDGE_LOW : 1;        /*!< [10..10] GPIO2_EDGE_LOW */
      __IOM uint32_t GPIO2_EDGE_HIGH : 1;       /*!< [11..11] GPIO2_EDGE_HIGH */
      __IOM uint32_t GPIO3_LEVEL_LOW : 1;       /*!< [12..12] GPIO3_LEVEL_LOW */
      __IOM uint32_t GPIO3_LEVEL_HIGH : 1;      /*!< [13..13] GPIO3_LEVEL_HIGH */
      __IOM uint32_t GPIO3_EDGE_LOW : 1;        /*!< [14..14] GPIO3_EDGE_LOW */
      __IOM uint32_t GPIO3_EDGE_HIGH : 1;       /*!< [15..15] GPIO3_EDGE_HIGH */
      __IOM uint32_t GPIO4_LEVEL_LOW : 1;       /*!< [16..16] GPIO4_LEVEL_LOW */
      __IOM uint32_t GPIO4_LEVEL_HIGH : 1;      /*!< [17..17] GPIO4_LEVEL_HIGH */
      __IOM uint32_t GPIO4_EDGE_LOW : 1;        /*!< [18..18] GPIO4_EDGE_LOW */
      __IOM uint32_t GPIO4_EDGE_HIGH : 1;       /*!< [19..19] GPIO4_EDGE_HIGH */
      __IOM uint32_t GPIO5_LEVEL_LOW : 1;       /*!< [20..20] GPIO5_LEVEL_LOW */
      __IOM uint32_t GPIO5_LEVEL_HIGH : 1;      /*!< [21..21] GPIO5_LEVEL_HIGH */
      __IOM uint32_t GPIO5_EDGE_LOW : 1;        /*!< [22..22] GPIO5_EDGE_LOW */
      __IOM uint32_t GPIO5_EDGE_HIGH : 1;       /*!< [23..23] GPIO5_EDGE_HIGH */
      __IOM uint32_t GPIO6_LEVEL_LOW : 1;       /*!< [24..24] GPIO6_LEVEL_LOW */
      __IOM uint32_t GPIO6_LEVEL_HIGH : 1;      /*!< [25..25] GPIO6_LEVEL_HIGH */
      __IOM uint32_t GPIO6_EDGE_LOW : 1;        /*!< [26..26] GPIO6_EDGE_LOW */
      __IOM uint32_t GPIO6_EDGE_HIGH : 1;       /*!< [27..27] GPIO6_EDGE_HIGH */
      __IOM uint32_t GPIO7_LEVEL_LOW : 1;       /*!< [28..28] GPIO7_LEVEL_LOW */
      __IOM uint32_t GPIO7_LEVEL_HIGH : 1;      /*!< [29..29] GPIO7_LEVEL_HIGH */
      __IOM uint32_t GPIO7_EDGE_LOW : 1;        /*!< [30..30] GPIO7_EDGE_LOW */
      __IOM uint32_t GPIO7_EDGE_HIGH : 1;       /*!< [31..31] GPIO7_EDGE_HIGH */
    } PROC0_INTE0_b;
  } ;

  union {
    __IOM uint32_t PROC0_INTE1;                 /*!< (@ 0x00000104) Interrupt Enable for proc0 */

    struct {
      __IOM uint32_t GPIO8_LEVEL_LOW : 1;       /*!< [0..0] GPIO8_LEVEL_LOW */
      __IOM uint32_t GPIO8_LEVEL_HIGH : 1;      /*!< [1..1] GPIO8_LEVEL_HIGH */
      __IOM uint32_t GPIO8_EDGE_LOW : 1;        /*!< [2..2] GPIO8_EDGE_LOW */
      __IOM uint32_t GPIO8_EDGE_HIGH : 1;       /*!< [3..3] GPIO8_EDGE_HIGH */
      __IOM uint32_t GPIO9_LEVEL_LOW : 1;       /*!< [4..4] GPIO9_LEVEL_LOW */
      __IOM uint32_t GPIO9_LEVEL_HIGH : 1;      /*!< [5..5] GPIO9_LEVEL_HIGH */
      __IOM uint32_t GPIO9_EDGE_LOW : 1;        /*!< [6..6] GPIO9_EDGE_LOW */
      __IOM uint32_t GPIO9_EDGE_HIGH : 1;       /*!< [7..7] GPIO9_EDGE_HIGH */
      __IOM uint32_t GPIO10_LEVEL_LOW : 1;      /*!< [8..8] GPIO10_LEVEL_LOW */
      __IOM uint32_t GPIO10_LEVEL_HIGH : 1;     /*!< [9..9] GPIO10_LEVEL_HIGH */
      __IOM uint32_t GPIO10_EDGE_LOW : 1;       /*!< [10..10] GPIO10_EDGE_LOW */
      __IOM uint32_t GPIO10_EDGE_HIGH : 1;      /*!< [11..11] GPIO10_EDGE_HIGH */
      __IOM uint32_t GPIO11_LEVEL_LOW : 1;      /*!< [12..12] GPIO11_LEVEL_LOW */
      __IOM uint32_t GPIO11_LEVEL_HIGH : 1;     /*!< [13..13] GPIO11_LEVEL_HIGH */
      __IOM uint32_t GPIO11_EDGE_LOW : 1;       /*!< [14..14] GPIO11_EDGE_LOW */
      __IOM uint32_t GPIO11_EDGE_HIGH : 1;      /*!< [15..15] GPIO11_EDGE_HIGH */
      __IOM uint32_t GPIO12_LEVEL_LOW : 1;      /*!< [16..16] GPIO12_LEVEL_LOW */
      __IOM uint32_t GPIO12_LEVEL_HIGH : 1;     /*!< [17..17] GPIO12_LEVEL_HIGH */
      __IOM uint32_t GPIO12_EDGE_LOW : 1;       /*!< [18..18] GPIO12_EDGE_LOW */
      __IOM uint32_t GPIO12_EDGE_HIGH : 1;      /*!< [19..19] GPIO12_EDGE_HIGH */
      __IOM uint32_t GPIO13_LEVEL_LOW : 1;      /*!< [20..20] GPIO13_LEVEL_LOW */
      __IOM uint32_t GPIO13_LEVEL_HIGH : 1;     /*!< [21..21] GPIO13_LEVEL_HIGH */
      __IOM uint32_t GPIO13_EDGE_LOW : 1;       /*!< [22..22] GPIO13_EDGE_LOW */
      __IOM uint32_t GPIO13_EDGE_HIGH : 1;      /*!< [23..23] GPIO13_EDGE_HIGH */
      __IOM uint32_t GPIO14_LEVEL_LOW : 1;      /*!< [24..24] GPIO14_LEVEL_LOW */
      __IOM uint32_t GPIO14_LEVEL_HIGH : 1;     /*!< [25..25] GPIO14_LEVEL_HIGH */
      __IOM uint32_t GPIO14_EDGE_LOW : 1;       /*!< [26..26] GPIO14_EDGE_LOW */
      __IOM uint32_t GPIO14_EDGE_HIGH : 1;      /*!< [27..27] GPIO14_EDGE_HIGH */
      __IOM uint32_t GPIO15_LEVEL_LOW : 1;      /*!< [28..28] GPIO15_LEVEL_LOW */
      __IOM uint32_t GPIO15_LEVEL_HIGH : 1;     /*!< [29..29] GPIO15_LEVEL_HIGH */
      __IOM uint32_t GPIO15_EDGE_LOW : 1;       /*!< [30..30] GPIO15_EDGE_LOW */
      __IOM uint32_t GPIO15_EDGE_HIGH : 1;      /*!< [31..31] GPIO15_EDGE_HIGH */
    } PROC0_INTE1_b;
  } ;

  union {
    __IOM uint32_t PROC0_INTE2;                 /*!< (@ 0x00000108) Interrupt Enable for proc0 */

    struct {
      __IOM uint32_t GPIO16_LEVEL_LOW : 1;      /*!< [0..0] GPIO16_LEVEL_LOW */
      __IOM uint32_t GPIO16_LEVEL_HIGH : 1;     /*!< [1..1] GPIO16_LEVEL_HIGH */
      __IOM uint32_t GPIO16_EDGE_LOW : 1;       /*!< [2..2] GPIO16_EDGE_LOW */
      __IOM uint32_t GPIO16_EDGE_HIGH : 1;      /*!< [3..3] GPIO16_EDGE_HIGH */
      __IOM uint32_t GPIO17_LEVEL_LOW : 1;      /*!< [4..4] GPIO17_LEVEL_LOW */
      __IOM uint32_t GPIO17_LEVEL_HIGH : 1;     /*!< [5..5] GPIO17_LEVEL_HIGH */
      __IOM uint32_t GPIO17_EDGE_LOW : 1;       /*!< [6..6] GPIO17_EDGE_LOW */
      __IOM uint32_t GPIO17_EDGE_HIGH : 1;      /*!< [7..7] GPIO17_EDGE_HIGH */
      __IOM uint32_t GPIO18_LEVEL_LOW : 1;      /*!< [8..8] GPIO18_LEVEL_LOW */
      __IOM uint32_t GPIO18_LEVEL_HIGH : 1;     /*!< [9..9] GPIO18_LEVEL_HIGH */
      __IOM uint32_t GPIO18_EDGE_LOW : 1;       /*!< [10..10] GPIO18_EDGE_LOW */
      __IOM uint32_t GPIO18_EDGE_HIGH : 1;      /*!< [11..11] GPIO18_EDGE_HIGH */
      __IOM uint32_t GPIO19_LEVEL_LOW : 1;      /*!< [12..12] GPIO19_LEVEL_LOW */
      __IOM uint32_t GPIO19_LEVEL_HIGH : 1;     /*!< [13..13] GPIO19_LEVEL_HIGH */
      __IOM uint32_t GPIO19_EDGE_LOW : 1;       /*!< [14..14] GPIO19_EDGE_LOW */
      __IOM uint32_t GPIO19_EDGE_HIGH : 1;      /*!< [15..15] GPIO19_EDGE_HIGH */
      __IOM uint32_t GPIO20_LEVEL_LOW : 1;      /*!< [16..16] GPIO20_LEVEL_LOW */
      __IOM uint32_t GPIO20_LEVEL_HIGH : 1;     /*!< [17..17] GPIO20_LEVEL_HIGH */
      __IOM uint32_t GPIO20_EDGE_LOW : 1;       /*!< [18..18] GPIO20_EDGE_LOW */
      __IOM uint32_t GPIO20_EDGE_HIGH : 1;      /*!< [19..19] GPIO20_EDGE_HIGH */
      __IOM uint32_t GPIO21_LEVEL_LOW : 1;      /*!< [20..20] GPIO21_LEVEL_LOW */
      __IOM uint32_t GPIO21_LEVEL_HIGH : 1;     /*!< [21..21] GPIO21_LEVEL_HIGH */
      __IOM uint32_t GPIO21_EDGE_LOW : 1;       /*!< [22..22] GPIO21_EDGE_LOW */
      __IOM uint32_t GPIO21_EDGE_HIGH : 1;      /*!< [23..23] GPIO21_EDGE_HIGH */
      __IOM uint32_t GPIO22_LEVEL_LOW : 1;      /*!< [24..24] GPIO22_LEVEL_LOW */
      __IOM uint32_t GPIO22_LEVEL_HIGH : 1;     /*!< [25..25] GPIO22_LEVEL_HIGH */
      __IOM uint32_t GPIO22_EDGE_LOW : 1;       /*!< [26..26] GPIO22_EDGE_LOW */
      __IOM uint32_t GPIO22_EDGE_HIGH : 1;      /*!< [27..27] GPIO22_EDGE_HIGH */
      __IOM uint32_t GPIO23_LEVEL_LOW : 1;      /*!< [28..28] GPIO23_LEVEL_LOW */
      __IOM uint32_t GPIO23_LEVEL_HIGH : 1;     /*!< [29..29] GPIO23_LEVEL_HIGH */
      __IOM uint32_t GPIO23_EDGE_LOW : 1;       /*!< [30..30] GPIO23_EDGE_LOW */
      __IOM uint32_t GPIO23_EDGE_HIGH : 1;      /*!< [31..31] GPIO23_EDGE_HIGH */
    } PROC0_INTE2_b;
  } ;

  union {
    __IOM uint32_t PROC0_INTE3;                 /*!< (@ 0x0000010C) Interrupt Enable for proc0 */

    struct {
      __IOM uint32_t GPIO24_LEVEL_LOW : 1;      /*!< [0..0] GPIO24_LEVEL_LOW */
      __IOM uint32_t GPIO24_LEVEL_HIGH : 1;     /*!< [1..1] GPIO24_LEVEL_HIGH */
      __IOM uint32_t GPIO24_EDGE_LOW : 1;       /*!< [2..2] GPIO24_EDGE_LOW */
      __IOM uint32_t GPIO24_EDGE_HIGH : 1;      /*!< [3..3] GPIO24_EDGE_HIGH */
      __IOM uint32_t GPIO25_LEVEL_LOW : 1;      /*!< [4..4] GPIO25_LEVEL_LOW */
      __IOM uint32_t GPIO25_LEVEL_HIGH : 1;     /*!< [5..5] GPIO25_LEVEL_HIGH */
      __IOM uint32_t GPIO25_EDGE_LOW : 1;       /*!< [6..6] GPIO25_EDGE_LOW */
      __IOM uint32_t GPIO25_EDGE_HIGH : 1;      /*!< [7..7] GPIO25_EDGE_HIGH */
      __IOM uint32_t GPIO26_LEVEL_LOW : 1;      /*!< [8..8] GPIO26_LEVEL_LOW */
      __IOM uint32_t GPIO26_LEVEL_HIGH : 1;     /*!< [9..9] GPIO26_LEVEL_HIGH */
      __IOM uint32_t GPIO26_EDGE_LOW : 1;       /*!< [10..10] GPIO26_EDGE_LOW */
      __IOM uint32_t GPIO26_EDGE_HIGH : 1;      /*!< [11..11] GPIO26_EDGE_HIGH */
      __IOM uint32_t GPIO27_LEVEL_LOW : 1;      /*!< [12..12] GPIO27_LEVEL_LOW */
      __IOM uint32_t GPIO27_LEVEL_HIGH : 1;     /*!< [13..13] GPIO27_LEVEL_HIGH */
      __IOM uint32_t GPIO27_EDGE_LOW : 1;       /*!< [14..14] GPIO27_EDGE_LOW */
      __IOM uint32_t GPIO27_EDGE_HIGH : 1;      /*!< [15..15] GPIO27_EDGE_HIGH */
      __IOM uint32_t GPIO28_LEVEL_LOW : 1;      /*!< [16..16] GPIO28_LEVEL_LOW */
      __IOM uint32_t GPIO28_LEVEL_HIGH : 1;     /*!< [17..17] GPIO28_LEVEL_HIGH */
      __IOM uint32_t GPIO28_EDGE_LOW : 1;       /*!< [18..18] GPIO28_EDGE_LOW */
      __IOM uint32_t GPIO28_EDGE_HIGH : 1;      /*!< [19..19] GPIO28_EDGE_HIGH */
      __IOM uint32_t GPIO29_LEVEL_LOW : 1;      /*!< [20..20] GPIO29_LEVEL_LOW */
      __IOM uint32_t GPIO29_LEVEL_HIGH : 1;     /*!< [21..21] GPIO29_LEVEL_HIGH */
      __IOM uint32_t GPIO29_EDGE_LOW : 1;       /*!< [22..22] GPIO29_EDGE_LOW */
      __IOM uint32_t GPIO29_EDGE_HIGH : 1;      /*!< [23..23] GPIO29_EDGE_HIGH */
            uint32_t            : 8;
    } PROC0_INTE3_b;
  } ;

  union {
    __IOM uint32_t PROC0_INTF0;                 /*!< (@ 0x00000110) Interrupt Force for proc0 */

    struct {
      __IOM uint32_t GPIO0_LEVEL_LOW : 1;       /*!< [0..0] GPIO0_LEVEL_LOW */
      __IOM uint32_t GPIO0_LEVEL_HIGH : 1;      /*!< [1..1] GPIO0_LEVEL_HIGH */
      __IOM uint32_t GPIO0_EDGE_LOW : 1;        /*!< [2..2] GPIO0_EDGE_LOW */
      __IOM uint32_t GPIO0_EDGE_HIGH : 1;       /*!< [3..3] GPIO0_EDGE_HIGH */
      __IOM uint32_t GPIO1_LEVEL_LOW : 1;       /*!< [4..4] GPIO1_LEVEL_LOW */
      __IOM uint32_t GPIO1_LEVEL_HIGH : 1;      /*!< [5..5] GPIO1_LEVEL_HIGH */
      __IOM uint32_t GPIO1_EDGE_LOW : 1;        /*!< [6..6] GPIO1_EDGE_LOW */
      __IOM uint32_t GPIO1_EDGE_HIGH : 1;       /*!< [7..7] GPIO1_EDGE_HIGH */
      __IOM uint32_t GPIO2_LEVEL_LOW : 1;       /*!< [8..8] GPIO2_LEVEL_LOW */
      __IOM uint32_t GPIO2_LEVEL_HIGH : 1;      /*!< [9..9] GPIO2_LEVEL_HIGH */
      __IOM uint32_t GPIO2_EDGE_LOW : 1;        /*!< [10..10] GPIO2_EDGE_LOW */
      __IOM uint32_t GPIO2_EDGE_HIGH : 1;       /*!< [11..11] GPIO2_EDGE_HIGH */
      __IOM uint32_t GPIO3_LEVEL_LOW : 1;       /*!< [12..12] GPIO3_LEVEL_LOW */
      __IOM uint32_t GPIO3_LEVEL_HIGH : 1;      /*!< [13..13] GPIO3_LEVEL_HIGH */
      __IOM uint32_t GPIO3_EDGE_LOW : 1;        /*!< [14..14] GPIO3_EDGE_LOW */
      __IOM uint32_t GPIO3_EDGE_HIGH : 1;       /*!< [15..15] GPIO3_EDGE_HIGH */
      __IOM uint32_t GPIO4_LEVEL_LOW : 1;       /*!< [16..16] GPIO4_LEVEL_LOW */
      __IOM uint32_t GPIO4_LEVEL_HIGH : 1;      /*!< [17..17] GPIO4_LEVEL_HIGH */
      __IOM uint32_t GPIO4_EDGE_LOW : 1;        /*!< [18..18] GPIO4_EDGE_LOW */
      __IOM uint32_t GPIO4_EDGE_HIGH : 1;       /*!< [19..19] GPIO4_EDGE_HIGH */
      __IOM uint32_t GPIO5_LEVEL_LOW : 1;       /*!< [20..20] GPIO5_LEVEL_LOW */
      __IOM uint32_t GPIO5_LEVEL_HIGH : 1;      /*!< [21..21] GPIO5_LEVEL_HIGH */
      __IOM uint32_t GPIO5_EDGE_LOW : 1;        /*!< [22..22] GPIO5_EDGE_LOW */
      __IOM uint32_t GPIO5_EDGE_HIGH : 1;       /*!< [23..23] GPIO5_EDGE_HIGH */
      __IOM uint32_t GPIO6_LEVEL_LOW : 1;       /*!< [24..24] GPIO6_LEVEL_LOW */
      __IOM uint32_t GPIO6_LEVEL_HIGH : 1;      /*!< [25..25] GPIO6_LEVEL_HIGH */
      __IOM uint32_t GPIO6_EDGE_LOW : 1;        /*!< [26..26] GPIO6_EDGE_LOW */
      __IOM uint32_t GPIO6_EDGE_HIGH : 1;       /*!< [27..27] GPIO6_EDGE_HIGH */
      __IOM uint32_t GPIO7_LEVEL_LOW : 1;       /*!< [28..28] GPIO7_LEVEL_LOW */
      __IOM uint32_t GPIO7_LEVEL_HIGH : 1;      /*!< [29..29] GPIO7_LEVEL_HIGH */
      __IOM uint32_t GPIO7_EDGE_LOW : 1;        /*!< [30..30] GPIO7_EDGE_LOW */
      __IOM uint32_t GPIO7_EDGE_HIGH : 1;       /*!< [31..31] GPIO7_EDGE_HIGH */
    } PROC0_INTF0_b;
  } ;

  union {
    __IOM uint32_t PROC0_INTF1;                 /*!< (@ 0x00000114) Interrupt Force for proc0 */

    struct {
      __IOM uint32_t GPIO8_LEVEL_LOW : 1;       /*!< [0..0] GPIO8_LEVEL_LOW */
      __IOM uint32_t GPIO8_LEVEL_HIGH : 1;      /*!< [1..1] GPIO8_LEVEL_HIGH */
      __IOM uint32_t GPIO8_EDGE_LOW : 1;        /*!< [2..2] GPIO8_EDGE_LOW */
      __IOM uint32_t GPIO8_EDGE_HIGH : 1;       /*!< [3..3] GPIO8_EDGE_HIGH */
      __IOM uint32_t GPIO9_LEVEL_LOW : 1;       /*!< [4..4] GPIO9_LEVEL_LOW */
      __IOM uint32_t GPIO9_LEVEL_HIGH : 1;      /*!< [5..5] GPIO9_LEVEL_HIGH */
      __IOM uint32_t GPIO9_EDGE_LOW : 1;        /*!< [6..6] GPIO9_EDGE_LOW */
      __IOM uint32_t GPIO9_EDGE_HIGH : 1;       /*!< [7..7] GPIO9_EDGE_HIGH */
      __IOM uint32_t GPIO10_LEVEL_LOW : 1;      /*!< [8..8] GPIO10_LEVEL_LOW */
      __IOM uint32_t GPIO10_LEVEL_HIGH : 1;     /*!< [9..9] GPIO10_LEVEL_HIGH */
      __IOM uint32_t GPIO10_EDGE_LOW : 1;       /*!< [10..10] GPIO10_EDGE_LOW */
      __IOM uint32_t GPIO10_EDGE_HIGH : 1;      /*!< [11..11] GPIO10_EDGE_HIGH */
      __IOM uint32_t GPIO11_LEVEL_LOW : 1;      /*!< [12..12] GPIO11_LEVEL_LOW */
      __IOM uint32_t GPIO11_LEVEL_HIGH : 1;     /*!< [13..13] GPIO11_LEVEL_HIGH */
      __IOM uint32_t GPIO11_EDGE_LOW : 1;       /*!< [14..14] GPIO11_EDGE_LOW */
      __IOM uint32_t GPIO11_EDGE_HIGH : 1;      /*!< [15..15] GPIO11_EDGE_HIGH */
      __IOM uint32_t GPIO12_LEVEL_LOW : 1;      /*!< [16..16] GPIO12_LEVEL_LOW */
      __IOM uint32_t GPIO12_LEVEL_HIGH : 1;     /*!< [17..17] GPIO12_LEVEL_HIGH */
      __IOM uint32_t GPIO12_EDGE_LOW : 1;       /*!< [18..18] GPIO12_EDGE_LOW */
      __IOM uint32_t GPIO12_EDGE_HIGH : 1;      /*!< [19..19] GPIO12_EDGE_HIGH */
      __IOM uint32_t GPIO13_LEVEL_LOW : 1;      /*!< [20..20] GPIO13_LEVEL_LOW */
      __IOM uint32_t GPIO13_LEVEL_HIGH : 1;     /*!< [21..21] GPIO13_LEVEL_HIGH */
      __IOM uint32_t GPIO13_EDGE_LOW : 1;       /*!< [22..22] GPIO13_EDGE_LOW */
      __IOM uint32_t GPIO13_EDGE_HIGH : 1;      /*!< [23..23] GPIO13_EDGE_HIGH */
      __IOM uint32_t GPIO14_LEVEL_LOW : 1;      /*!< [24..24] GPIO14_LEVEL_LOW */
      __IOM uint32_t GPIO14_LEVEL_HIGH : 1;     /*!< [25..25] GPIO14_LEVEL_HIGH */
      __IOM uint32_t GPIO14_EDGE_LOW : 1;       /*!< [26..26] GPIO14_EDGE_LOW */
      __IOM uint32_t GPIO14_EDGE_HIGH : 1;      /*!< [27..27] GPIO14_EDGE_HIGH */
      __IOM uint32_t GPIO15_LEVEL_LOW : 1;      /*!< [28..28] GPIO15_LEVEL_LOW */
      __IOM uint32_t GPIO15_LEVEL_HIGH : 1;     /*!< [29..29] GPIO15_LEVEL_HIGH */
      __IOM uint32_t GPIO15_EDGE_LOW : 1;       /*!< [30..30] GPIO15_EDGE_LOW */
      __IOM uint32_t GPIO15_EDGE_HIGH : 1;      /*!< [31..31] GPIO15_EDGE_HIGH */
    } PROC0_INTF1_b;
  } ;

  union {
    __IOM uint32_t PROC0_INTF2;                 /*!< (@ 0x00000118) Interrupt Force for proc0 */

    struct {
      __IOM uint32_t GPIO16_LEVEL_LOW : 1;      /*!< [0..0] GPIO16_LEVEL_LOW */
      __IOM uint32_t GPIO16_LEVEL_HIGH : 1;     /*!< [1..1] GPIO16_LEVEL_HIGH */
      __IOM uint32_t GPIO16_EDGE_LOW : 1;       /*!< [2..2] GPIO16_EDGE_LOW */
      __IOM uint32_t GPIO16_EDGE_HIGH : 1;      /*!< [3..3] GPIO16_EDGE_HIGH */
      __IOM uint32_t GPIO17_LEVEL_LOW : 1;      /*!< [4..4] GPIO17_LEVEL_LOW */
      __IOM uint32_t GPIO17_LEVEL_HIGH : 1;     /*!< [5..5] GPIO17_LEVEL_HIGH */
      __IOM uint32_t GPIO17_EDGE_LOW : 1;       /*!< [6..6] GPIO17_EDGE_LOW */
      __IOM uint32_t GPIO17_EDGE_HIGH : 1;      /*!< [7..7] GPIO17_EDGE_HIGH */
      __IOM uint32_t GPIO18_LEVEL_LOW : 1;      /*!< [8..8] GPIO18_LEVEL_LOW */
      __IOM uint32_t GPIO18_LEVEL_HIGH : 1;     /*!< [9..9] GPIO18_LEVEL_HIGH */
      __IOM uint32_t GPIO18_EDGE_LOW : 1;       /*!< [10..10] GPIO18_EDGE_LOW */
      __IOM uint32_t GPIO18_EDGE_HIGH : 1;      /*!< [11..11] GPIO18_EDGE_HIGH */
      __IOM uint32_t GPIO19_LEVEL_LOW : 1;      /*!< [12..12] GPIO19_LEVEL_LOW */
      __IOM uint32_t GPIO19_LEVEL_HIGH : 1;     /*!< [13..13] GPIO19_LEVEL_HIGH */
      __IOM uint32_t GPIO19_EDGE_LOW : 1;       /*!< [14..14] GPIO19_EDGE_LOW */
      __IOM uint32_t GPIO19_EDGE_HIGH : 1;      /*!< [15..15] GPIO19_EDGE_HIGH */
      __IOM uint32_t GPIO20_LEVEL_LOW : 1;      /*!< [16..16] GPIO20_LEVEL_LOW */
      __IOM uint32_t GPIO20_LEVEL_HIGH : 1;     /*!< [17..17] GPIO20_LEVEL_HIGH */
      __IOM uint32_t GPIO20_EDGE_LOW : 1;       /*!< [18..18] GPIO20_EDGE_LOW */
      __IOM uint32_t GPIO20_EDGE_HIGH : 1;      /*!< [19..19] GPIO20_EDGE_HIGH */
      __IOM uint32_t GPIO21_LEVEL_LOW : 1;      /*!< [20..20] GPIO21_LEVEL_LOW */
      __IOM uint32_t GPIO21_LEVEL_HIGH : 1;     /*!< [21..21] GPIO21_LEVEL_HIGH */
      __IOM uint32_t GPIO21_EDGE_LOW : 1;       /*!< [22..22] GPIO21_EDGE_LOW */
      __IOM uint32_t GPIO21_EDGE_HIGH : 1;      /*!< [23..23] GPIO21_EDGE_HIGH */
      __IOM uint32_t GPIO22_LEVEL_LOW : 1;      /*!< [24..24] GPIO22_LEVEL_LOW */
      __IOM uint32_t GPIO22_LEVEL_HIGH : 1;     /*!< [25..25] GPIO22_LEVEL_HIGH */
      __IOM uint32_t GPIO22_EDGE_LOW : 1;       /*!< [26..26] GPIO22_EDGE_LOW */
      __IOM uint32_t GPIO22_EDGE_HIGH : 1;      /*!< [27..27] GPIO22_EDGE_HIGH */
      __IOM uint32_t GPIO23_LEVEL_LOW : 1;      /*!< [28..28] GPIO23_LEVEL_LOW */
      __IOM uint32_t GPIO23_LEVEL_HIGH : 1;     /*!< [29..29] GPIO23_LEVEL_HIGH */
      __IOM uint32_t GPIO23_EDGE_LOW : 1;       /*!< [30..30] GPIO23_EDGE_LOW */
      __IOM uint32_t GPIO23_EDGE_HIGH : 1;      /*!< [31..31] GPIO23_EDGE_HIGH */
    } PROC0_INTF2_b;
  } ;

  union {
    __IOM uint32_t PROC0_INTF3;                 /*!< (@ 0x0000011C) Interrupt Force for proc0 */

    struct {
      __IOM uint32_t GPIO24_LEVEL_LOW : 1;      /*!< [0..0] GPIO24_LEVEL_LOW */
      __IOM uint32_t GPIO24_LEVEL_HIGH : 1;     /*!< [1..1] GPIO24_LEVEL_HIGH */
      __IOM uint32_t GPIO24_EDGE_LOW : 1;       /*!< [2..2] GPIO24_EDGE_LOW */
      __IOM uint32_t GPIO24_EDGE_HIGH : 1;      /*!< [3..3] GPIO24_EDGE_HIGH */
      __IOM uint32_t GPIO25_LEVEL_LOW : 1;      /*!< [4..4] GPIO25_LEVEL_LOW */
      __IOM uint32_t GPIO25_LEVEL_HIGH : 1;     /*!< [5..5] GPIO25_LEVEL_HIGH */
      __IOM uint32_t GPIO25_EDGE_LOW : 1;       /*!< [6..6] GPIO25_EDGE_LOW */
      __IOM uint32_t GPIO25_EDGE_HIGH : 1;      /*!< [7..7] GPIO25_EDGE_HIGH */
      __IOM uint32_t GPIO26_LEVEL_LOW : 1;      /*!< [8..8] GPIO26_LEVEL_LOW */
      __IOM uint32_t GPIO26_LEVEL_HIGH : 1;     /*!< [9..9] GPIO26_LEVEL_HIGH */
      __IOM uint32_t GPIO26_EDGE_LOW : 1;       /*!< [10..10] GPIO26_EDGE_LOW */
      __IOM uint32_t GPIO26_EDGE_HIGH : 1;      /*!< [11..11] GPIO26_EDGE_HIGH */
      __IOM uint32_t GPIO27_LEVEL_LOW : 1;      /*!< [12..12] GPIO27_LEVEL_LOW */
      __IOM uint32_t GPIO27_LEVEL_HIGH : 1;     /*!< [13..13] GPIO27_LEVEL_HIGH */
      __IOM uint32_t GPIO27_EDGE_LOW : 1;       /*!< [14..14] GPIO27_EDGE_LOW */
      __IOM uint32_t GPIO27_EDGE_HIGH : 1;      /*!< [15..15] GPIO27_EDGE_HIGH */
      __IOM uint32_t GPIO28_LEVEL_LOW : 1;      /*!< [16..16] GPIO28_LEVEL_LOW */
      __IOM uint32_t GPIO28_LEVEL_HIGH : 1;     /*!< [17..17] GPIO28_LEVEL_HIGH */
      __IOM uint32_t GPIO28_EDGE_LOW : 1;       /*!< [18..18] GPIO28_EDGE_LOW */
      __IOM uint32_t GPIO28_EDGE_HIGH : 1;      /*!< [19..19] GPIO28_EDGE_HIGH */
      __IOM uint32_t GPIO29_LEVEL_LOW : 1;      /*!< [20..20] GPIO29_LEVEL_LOW */
      __IOM uint32_t GPIO29_LEVEL_HIGH : 1;     /*!< [21..21] GPIO29_LEVEL_HIGH */
      __IOM uint32_t GPIO29_EDGE_LOW : 1;       /*!< [22..22] GPIO29_EDGE_LOW */
      __IOM uint32_t GPIO29_EDGE_HIGH : 1;      /*!< [23..23] GPIO29_EDGE_HIGH */
            uint32_t            : 8;
    } PROC0_INTF3_b;
  } ;

  union {
    __IOM uint32_t PROC0_INTS0;                 /*!< (@ 0x00000120) Interrupt status after masking & forcing for proc0 */

    struct {
      __IM  uint32_t GPIO0_LEVEL_LOW : 1;       /*!< [0..0] GPIO0_LEVEL_LOW */
      __IM  uint32_t GPIO0_LEVEL_HIGH : 1;      /*!< [1..1] GPIO0_LEVEL_HIGH */
      __IM  uint32_t GPIO0_EDGE_LOW : 1;        /*!< [2..2] GPIO0_EDGE_LOW */
      __IM  uint32_t GPIO0_EDGE_HIGH : 1;       /*!< [3..3] GPIO0_EDGE_HIGH */
      __IM  uint32_t GPIO1_LEVEL_LOW : 1;       /*!< [4..4] GPIO1_LEVEL_LOW */
      __IM  uint32_t GPIO1_LEVEL_HIGH : 1;      /*!< [5..5] GPIO1_LEVEL_HIGH */
      __IM  uint32_t GPIO1_EDGE_LOW : 1;        /*!< [6..6] GPIO1_EDGE_LOW */
      __IM  uint32_t GPIO1_EDGE_HIGH : 1;       /*!< [7..7] GPIO1_EDGE_HIGH */
      __IM  uint32_t GPIO2_LEVEL_LOW : 1;       /*!< [8..8] GPIO2_LEVEL_LOW */
      __IM  uint32_t GPIO2_LEVEL_HIGH : 1;      /*!< [9..9] GPIO2_LEVEL_HIGH */
      __IM  uint32_t GPIO2_EDGE_LOW : 1;        /*!< [10..10] GPIO2_EDGE_LOW */
      __IM  uint32_t GPIO2_EDGE_HIGH : 1;       /*!< [11..11] GPIO2_EDGE_HIGH */
      __IM  uint32_t GPIO3_LEVEL_LOW : 1;       /*!< [12..12] GPIO3_LEVEL_LOW */
      __IM  uint32_t GPIO3_LEVEL_HIGH : 1;      /*!< [13..13] GPIO3_LEVEL_HIGH */
      __IM  uint32_t GPIO3_EDGE_LOW : 1;        /*!< [14..14] GPIO3_EDGE_LOW */
      __IM  uint32_t GPIO3_EDGE_HIGH : 1;       /*!< [15..15] GPIO3_EDGE_HIGH */
      __IM  uint32_t GPIO4_LEVEL_LOW : 1;       /*!< [16..16] GPIO4_LEVEL_LOW */
      __IM  uint32_t GPIO4_LEVEL_HIGH : 1;      /*!< [17..17] GPIO4_LEVEL_HIGH */
      __IM  uint32_t GPIO4_EDGE_LOW : 1;        /*!< [18..18] GPIO4_EDGE_LOW */
      __IM  uint32_t GPIO4_EDGE_HIGH : 1;       /*!< [19..19] GPIO4_EDGE_HIGH */
      __IM  uint32_t GPIO5_LEVEL_LOW : 1;       /*!< [20..20] GPIO5_LEVEL_LOW */
      __IM  uint32_t GPIO5_LEVEL_HIGH : 1;      /*!< [21..21] GPIO5_LEVEL_HIGH */
      __IM  uint32_t GPIO5_EDGE_LOW : 1;        /*!< [22..22] GPIO5_EDGE_LOW */
      __IM  uint32_t GPIO5_EDGE_HIGH : 1;       /*!< [23..23] GPIO5_EDGE_HIGH */
      __IM  uint32_t GPIO6_LEVEL_LOW : 1;       /*!< [24..24] GPIO6_LEVEL_LOW */
      __IM  uint32_t GPIO6_LEVEL_HIGH : 1;      /*!< [25..25] GPIO6_LEVEL_HIGH */
      __IM  uint32_t GPIO6_EDGE_LOW : 1;        /*!< [26..26] GPIO6_EDGE_LOW */
      __IM  uint32_t GPIO6_EDGE_HIGH : 1;       /*!< [27..27] GPIO6_EDGE_HIGH */
      __IM  uint32_t GPIO7_LEVEL_LOW : 1;       /*!< [28..28] GPIO7_LEVEL_LOW */
      __IM  uint32_t GPIO7_LEVEL_HIGH : 1;      /*!< [29..29] GPIO7_LEVEL_HIGH */
      __IM  uint32_t GPIO7_EDGE_LOW : 1;        /*!< [30..30] GPIO7_EDGE_LOW */
      __IM  uint32_t GPIO7_EDGE_HIGH : 1;       /*!< [31..31] GPIO7_EDGE_HIGH */
    } PROC0_INTS0_b;
  } ;

  union {
    __IOM uint32_t PROC0_INTS1;                 /*!< (@ 0x00000124) Interrupt status after masking & forcing for proc0 */

    struct {
      __IM  uint32_t GPIO8_LEVEL_LOW : 1;       /*!< [0..0] GPIO8_LEVEL_LOW */
      __IM  uint32_t GPIO8_LEVEL_HIGH : 1;      /*!< [1..1] GPIO8_LEVEL_HIGH */
      __IM  uint32_t GPIO8_EDGE_LOW : 1;        /*!< [2..2] GPIO8_EDGE_LOW */
      __IM  uint32_t GPIO8_EDGE_HIGH : 1;       /*!< [3..3] GPIO8_EDGE_HIGH */
      __IM  uint32_t GPIO9_LEVEL_LOW : 1;       /*!< [4..4] GPIO9_LEVEL_LOW */
      __IM  uint32_t GPIO9_LEVEL_HIGH : 1;      /*!< [5..5] GPIO9_LEVEL_HIGH */
      __IM  uint32_t GPIO9_EDGE_LOW : 1;        /*!< [6..6] GPIO9_EDGE_LOW */
      __IM  uint32_t GPIO9_EDGE_HIGH : 1;       /*!< [7..7] GPIO9_EDGE_HIGH */
      __IM  uint32_t GPIO10_LEVEL_LOW : 1;      /*!< [8..8] GPIO10_LEVEL_LOW */
      __IM  uint32_t GPIO10_LEVEL_HIGH : 1;     /*!< [9..9] GPIO10_LEVEL_HIGH */
      __IM  uint32_t GPIO10_EDGE_LOW : 1;       /*!< [10..10] GPIO10_EDGE_LOW */
      __IM  uint32_t GPIO10_EDGE_HIGH : 1;      /*!< [11..11] GPIO10_EDGE_HIGH */
      __IM  uint32_t GPIO11_LEVEL_LOW : 1;      /*!< [12..12] GPIO11_LEVEL_LOW */
      __IM  uint32_t GPIO11_LEVEL_HIGH : 1;     /*!< [13..13] GPIO11_LEVEL_HIGH */
      __IM  uint32_t GPIO11_EDGE_LOW : 1;       /*!< [14..14] GPIO11_EDGE_LOW */
      __IM  uint32_t GPIO11_EDGE_HIGH : 1;      /*!< [15..15] GPIO11_EDGE_HIGH */
      __IM  uint32_t GPIO12_LEVEL_LOW : 1;      /*!< [16..16] GPIO12_LEVEL_LOW */
      __IM  uint32_t GPIO12_LEVEL_HIGH : 1;     /*!< [17..17] GPIO12_LEVEL_HIGH */
      __IM  uint32_t GPIO12_EDGE_LOW : 1;       /*!< [18..18] GPIO12_EDGE_LOW */
      __IM  uint32_t GPIO12_EDGE_HIGH : 1;      /*!< [19..19] GPIO12_EDGE_HIGH */
      __IM  uint32_t GPIO13_LEVEL_LOW : 1;      /*!< [20..20] GPIO13_LEVEL_LOW */
      __IM  uint32_t GPIO13_LEVEL_HIGH : 1;     /*!< [21..21] GPIO13_LEVEL_HIGH */
      __IM  uint32_t GPIO13_EDGE_LOW : 1;       /*!< [22..22] GPIO13_EDGE_LOW */
      __IM  uint32_t GPIO13_EDGE_HIGH : 1;      /*!< [23..23] GPIO13_EDGE_HIGH */
      __IM  uint32_t GPIO14_LEVEL_LOW : 1;      /*!< [24..24] GPIO14_LEVEL_LOW */
      __IM  uint32_t GPIO14_LEVEL_HIGH : 1;     /*!< [25..25] GPIO14_LEVEL_HIGH */
      __IM  uint32_t GPIO14_EDGE_LOW : 1;       /*!< [26..26] GPIO14_EDGE_LOW */
      __IM  uint32_t GPIO14_EDGE_HIGH : 1;      /*!< [27..27] GPIO14_EDGE_HIGH */
      __IM  uint32_t GPIO15_LEVEL_LOW : 1;      /*!< [28..28] GPIO15_LEVEL_LOW */
      __IM  uint32_t GPIO15_LEVEL_HIGH : 1;     /*!< [29..29] GPIO15_LEVEL_HIGH */
      __IM  uint32_t GPIO15_EDGE_LOW : 1;       /*!< [30..30] GPIO15_EDGE_LOW */
      __IM  uint32_t GPIO15_EDGE_HIGH : 1;      /*!< [31..31] GPIO15_EDGE_HIGH */
    } PROC0_INTS1_b;
  } ;

  union {
    __IOM uint32_t PROC0_INTS2;                 /*!< (@ 0x00000128) Interrupt status after masking & forcing for proc0 */

    struct {
      __IM  uint32_t GPIO16_LEVEL_LOW : 1;      /*!< [0..0] GPIO16_LEVEL_LOW */
      __IM  uint32_t GPIO16_LEVEL_HIGH : 1;     /*!< [1..1] GPIO16_LEVEL_HIGH */
      __IM  uint32_t GPIO16_EDGE_LOW : 1;       /*!< [2..2] GPIO16_EDGE_LOW */
      __IM  uint32_t GPIO16_EDGE_HIGH : 1;      /*!< [3..3] GPIO16_EDGE_HIGH */
      __IM  uint32_t GPIO17_LEVEL_LOW : 1;      /*!< [4..4] GPIO17_LEVEL_LOW */
      __IM  uint32_t GPIO17_LEVEL_HIGH : 1;     /*!< [5..5] GPIO17_LEVEL_HIGH */
      __IM  uint32_t GPIO17_EDGE_LOW : 1;       /*!< [6..6] GPIO17_EDGE_LOW */
      __IM  uint32_t GPIO17_EDGE_HIGH : 1;      /*!< [7..7] GPIO17_EDGE_HIGH */
      __IM  uint32_t GPIO18_LEVEL_LOW : 1;      /*!< [8..8] GPIO18_LEVEL_LOW */
      __IM  uint32_t GPIO18_LEVEL_HIGH : 1;     /*!< [9..9] GPIO18_LEVEL_HIGH */
      __IM  uint32_t GPIO18_EDGE_LOW : 1;       /*!< [10..10] GPIO18_EDGE_LOW */
      __IM  uint32_t GPIO18_EDGE_HIGH : 1;      /*!< [11..11] GPIO18_EDGE_HIGH */
      __IM  uint32_t GPIO19_LEVEL_LOW : 1;      /*!< [12..12] GPIO19_LEVEL_LOW */
      __IM  uint32_t GPIO19_LEVEL_HIGH : 1;     /*!< [13..13] GPIO19_LEVEL_HIGH */
      __IM  uint32_t GPIO19_EDGE_LOW : 1;       /*!< [14..14] GPIO19_EDGE_LOW */
      __IM  uint32_t GPIO19_EDGE_HIGH : 1;      /*!< [15..15] GPIO19_EDGE_HIGH */
      __IM  uint32_t GPIO20_LEVEL_LOW : 1;      /*!< [16..16] GPIO20_LEVEL_LOW */
      __IM  uint32_t GPIO20_LEVEL_HIGH : 1;     /*!< [17..17] GPIO20_LEVEL_HIGH */
      __IM  uint32_t GPIO20_EDGE_LOW : 1;       /*!< [18..18] GPIO20_EDGE_LOW */
      __IM  uint32_t GPIO20_EDGE_HIGH : 1;      /*!< [19..19] GPIO20_EDGE_HIGH */
      __IM  uint32_t GPIO21_LEVEL_LOW : 1;      /*!< [20..20] GPIO21_LEVEL_LOW */
      __IM  uint32_t GPIO21_LEVEL_HIGH : 1;     /*!< [21..21] GPIO21_LEVEL_HIGH */
      __IM  uint32_t GPIO21_EDGE_LOW : 1;       /*!< [22..22] GPIO21_EDGE_LOW */
      __IM  uint32_t GPIO21_EDGE_HIGH : 1;      /*!< [23..23] GPIO21_EDGE_HIGH */
      __IM  uint32_t GPIO22_LEVEL_LOW : 1;      /*!< [24..24] GPIO22_LEVEL_LOW */
      __IM  uint32_t GPIO22_LEVEL_HIGH : 1;     /*!< [25..25] GPIO22_LEVEL_HIGH */
      __IM  uint32_t GPIO22_EDGE_LOW : 1;       /*!< [26..26] GPIO22_EDGE_LOW */
      __IM  uint32_t GPIO22_EDGE_HIGH : 1;      /*!< [27..27] GPIO22_EDGE_HIGH */
      __IM  uint32_t GPIO23_LEVEL_LOW : 1;      /*!< [28..28] GPIO23_LEVEL_LOW */
      __IM  uint32_t GPIO23_LEVEL_HIGH : 1;     /*!< [29..29] GPIO23_LEVEL_HIGH */
      __IM  uint32_t GPIO23_EDGE_LOW : 1;       /*!< [30..30] GPIO23_EDGE_LOW */
      __IM  uint32_t GPIO23_EDGE_HIGH : 1;      /*!< [31..31] GPIO23_EDGE_HIGH */
    } PROC0_INTS2_b;
  } ;

  union {
    __IOM uint32_t PROC0_INTS3;                 /*!< (@ 0x0000012C) Interrupt status after masking & forcing for proc0 */

    struct {
      __IM  uint32_t GPIO24_LEVEL_LOW : 1;      /*!< [0..0] GPIO24_LEVEL_LOW */
      __IM  uint32_t GPIO24_LEVEL_HIGH : 1;     /*!< [1..1] GPIO24_LEVEL_HIGH */
      __IM  uint32_t GPIO24_EDGE_LOW : 1;       /*!< [2..2] GPIO24_EDGE_LOW */
      __IM  uint32_t GPIO24_EDGE_HIGH : 1;      /*!< [3..3] GPIO24_EDGE_HIGH */
      __IM  uint32_t GPIO25_LEVEL_LOW : 1;      /*!< [4..4] GPIO25_LEVEL_LOW */
      __IM  uint32_t GPIO25_LEVEL_HIGH : 1;     /*!< [5..5] GPIO25_LEVEL_HIGH */
      __IM  uint32_t GPIO25_EDGE_LOW : 1;       /*!< [6..6] GPIO25_EDGE_LOW */
      __IM  uint32_t GPIO25_EDGE_HIGH : 1;      /*!< [7..7] GPIO25_EDGE_HIGH */
      __IM  uint32_t GPIO26_LEVEL_LOW : 1;      /*!< [8..8] GPIO26_LEVEL_LOW */
      __IM  uint32_t GPIO26_LEVEL_HIGH : 1;     /*!< [9..9] GPIO26_LEVEL_HIGH */
      __IM  uint32_t GPIO26_EDGE_LOW : 1;       /*!< [10..10] GPIO26_EDGE_LOW */
      __IM  uint32_t GPIO26_EDGE_HIGH : 1;      /*!< [11..11] GPIO26_EDGE_HIGH */
      __IM  uint32_t GPIO27_LEVEL_LOW : 1;      /*!< [12..12] GPIO27_LEVEL_LOW */
      __IM  uint32_t GPIO27_LEVEL_HIGH : 1;     /*!< [13..13] GPIO27_LEVEL_HIGH */
      __IM  uint32_t GPIO27_EDGE_LOW : 1;       /*!< [14..14] GPIO27_EDGE_LOW */
      __IM  uint32_t GPIO27_EDGE_HIGH : 1;      /*!< [15..15] GPIO27_EDGE_HIGH */
      __IM  uint32_t GPIO28_LEVEL_LOW : 1;      /*!< [16..16] GPIO28_LEVEL_LOW */
      __IM  uint32_t GPIO28_LEVEL_HIGH : 1;     /*!< [17..17] GPIO28_LEVEL_HIGH */
      __IM  uint32_t GPIO28_EDGE_LOW : 1;       /*!< [18..18] GPIO28_EDGE_LOW */
      __IM  uint32_t GPIO28_EDGE_HIGH : 1;      /*!< [19..19] GPIO28_EDGE_HIGH */
      __IM  uint32_t GPIO29_LEVEL_LOW : 1;      /*!< [20..20] GPIO29_LEVEL_LOW */
      __IM  uint32_t GPIO29_LEVEL_HIGH : 1;     /*!< [21..21] GPIO29_LEVEL_HIGH */
      __IM  uint32_t GPIO29_EDGE_LOW : 1;       /*!< [22..22] GPIO29_EDGE_LOW */
      __IM  uint32_t GPIO29_EDGE_HIGH : 1;      /*!< [23..23] GPIO29_EDGE_HIGH */
            uint32_t            : 8;
    } PROC0_INTS3_b;
  } ;

  union {
    __IOM uint32_t PROC1_INTE0;                 /*!< (@ 0x00000130) Interrupt Enable for proc1 */

    struct {
      __IOM uint32_t GPIO0_LEVEL_LOW : 1;       /*!< [0..0] GPIO0_LEVEL_LOW */
      __IOM uint32_t GPIO0_LEVEL_HIGH : 1;      /*!< [1..1] GPIO0_LEVEL_HIGH */
      __IOM uint32_t GPIO0_EDGE_LOW : 1;        /*!< [2..2] GPIO0_EDGE_LOW */
      __IOM uint32_t GPIO0_EDGE_HIGH : 1;       /*!< [3..3] GPIO0_EDGE_HIGH */
      __IOM uint32_t GPIO1_LEVEL_LOW : 1;       /*!< [4..4] GPIO1_LEVEL_LOW */
      __IOM uint32_t GPIO1_LEVEL_HIGH : 1;      /*!< [5..5] GPIO1_LEVEL_HIGH */
      __IOM uint32_t GPIO1_EDGE_LOW : 1;        /*!< [6..6] GPIO1_EDGE_LOW */
      __IOM uint32_t GPIO1_EDGE_HIGH : 1;       /*!< [7..7] GPIO1_EDGE_HIGH */
      __IOM uint32_t GPIO2_LEVEL_LOW : 1;       /*!< [8..8] GPIO2_LEVEL_LOW */
      __IOM uint32_t GPIO2_LEVEL_HIGH : 1;      /*!< [9..9] GPIO2_LEVEL_HIGH */
      __IOM uint32_t GPIO2_EDGE_LOW : 1;        /*!< [10..10] GPIO2_EDGE_LOW */
      __IOM uint32_t GPIO2_EDGE_HIGH : 1;       /*!< [11..11] GPIO2_EDGE_HIGH */
      __IOM uint32_t GPIO3_LEVEL_LOW : 1;       /*!< [12..12] GPIO3_LEVEL_LOW */
      __IOM uint32_t GPIO3_LEVEL_HIGH : 1;      /*!< [13..13] GPIO3_LEVEL_HIGH */
      __IOM uint32_t GPIO3_EDGE_LOW : 1;        /*!< [14..14] GPIO3_EDGE_LOW */
      __IOM uint32_t GPIO3_EDGE_HIGH : 1;       /*!< [15..15] GPIO3_EDGE_HIGH */
      __IOM uint32_t GPIO4_LEVEL_LOW : 1;       /*!< [16..16] GPIO4_LEVEL_LOW */
      __IOM uint32_t GPIO4_LEVEL_HIGH : 1;      /*!< [17..17] GPIO4_LEVEL_HIGH */
      __IOM uint32_t GPIO4_EDGE_LOW : 1;        /*!< [18..18] GPIO4_EDGE_LOW */
      __IOM uint32_t GPIO4_EDGE_HIGH : 1;       /*!< [19..19] GPIO4_EDGE_HIGH */
      __IOM uint32_t GPIO5_LEVEL_LOW : 1;       /*!< [20..20] GPIO5_LEVEL_LOW */
      __IOM uint32_t GPIO5_LEVEL_HIGH : 1;      /*!< [21..21] GPIO5_LEVEL_HIGH */
      __IOM uint32_t GPIO5_EDGE_LOW : 1;        /*!< [22..22] GPIO5_EDGE_LOW */
      __IOM uint32_t GPIO5_EDGE_HIGH : 1;       /*!< [23..23] GPIO5_EDGE_HIGH */
      __IOM uint32_t GPIO6_LEVEL_LOW : 1;       /*!< [24..24] GPIO6_LEVEL_LOW */
      __IOM uint32_t GPIO6_LEVEL_HIGH : 1;      /*!< [25..25] GPIO6_LEVEL_HIGH */
      __IOM uint32_t GPIO6_EDGE_LOW : 1;        /*!< [26..26] GPIO6_EDGE_LOW */
      __IOM uint32_t GPIO6_EDGE_HIGH : 1;       /*!< [27..27] GPIO6_EDGE_HIGH */
      __IOM uint32_t GPIO7_LEVEL_LOW : 1;       /*!< [28..28] GPIO7_LEVEL_LOW */
      __IOM uint32_t GPIO7_LEVEL_HIGH : 1;      /*!< [29..29] GPIO7_LEVEL_HIGH */
      __IOM uint32_t GPIO7_EDGE_LOW : 1;        /*!< [30..30] GPIO7_EDGE_LOW */
      __IOM uint32_t GPIO7_EDGE_HIGH : 1;       /*!< [31..31] GPIO7_EDGE_HIGH */
    } PROC1_INTE0_b;
  } ;

  union {
    __IOM uint32_t PROC1_INTE1;                 /*!< (@ 0x00000134) Interrupt Enable for proc1 */

    struct {
      __IOM uint32_t GPIO8_LEVEL_LOW : 1;       /*!< [0..0] GPIO8_LEVEL_LOW */
      __IOM uint32_t GPIO8_LEVEL_HIGH : 1;      /*!< [1..1] GPIO8_LEVEL_HIGH */
      __IOM uint32_t GPIO8_EDGE_LOW : 1;        /*!< [2..2] GPIO8_EDGE_LOW */
      __IOM uint32_t GPIO8_EDGE_HIGH : 1;       /*!< [3..3] GPIO8_EDGE_HIGH */
      __IOM uint32_t GPIO9_LEVEL_LOW : 1;       /*!< [4..4] GPIO9_LEVEL_LOW */
      __IOM uint32_t GPIO9_LEVEL_HIGH : 1;      /*!< [5..5] GPIO9_LEVEL_HIGH */
      __IOM uint32_t GPIO9_EDGE_LOW : 1;        /*!< [6..6] GPIO9_EDGE_LOW */
      __IOM uint32_t GPIO9_EDGE_HIGH : 1;       /*!< [7..7] GPIO9_EDGE_HIGH */
      __IOM uint32_t GPIO10_LEVEL_LOW : 1;      /*!< [8..8] GPIO10_LEVEL_LOW */
      __IOM uint32_t GPIO10_LEVEL_HIGH : 1;     /*!< [9..9] GPIO10_LEVEL_HIGH */
      __IOM uint32_t GPIO10_EDGE_LOW : 1;       /*!< [10..10] GPIO10_EDGE_LOW */
      __IOM uint32_t GPIO10_EDGE_HIGH : 1;      /*!< [11..11] GPIO10_EDGE_HIGH */
      __IOM uint32_t GPIO11_LEVEL_LOW : 1;      /*!< [12..12] GPIO11_LEVEL_LOW */
      __IOM uint32_t GPIO11_LEVEL_HIGH : 1;     /*!< [13..13] GPIO11_LEVEL_HIGH */
      __IOM uint32_t GPIO11_EDGE_LOW : 1;       /*!< [14..14] GPIO11_EDGE_LOW */
      __IOM uint32_t GPIO11_EDGE_HIGH : 1;      /*!< [15..15] GPIO11_EDGE_HIGH */
      __IOM uint32_t GPIO12_LEVEL_LOW : 1;      /*!< [16..16] GPIO12_LEVEL_LOW */
      __IOM uint32_t GPIO12_LEVEL_HIGH : 1;     /*!< [17..17] GPIO12_LEVEL_HIGH */
      __IOM uint32_t GPIO12_EDGE_LOW : 1;       /*!< [18..18] GPIO12_EDGE_LOW */
      __IOM uint32_t GPIO12_EDGE_HIGH : 1;      /*!< [19..19] GPIO12_EDGE_HIGH */
      __IOM uint32_t GPIO13_LEVEL_LOW : 1;      /*!< [20..20] GPIO13_LEVEL_LOW */
      __IOM uint32_t GPIO13_LEVEL_HIGH : 1;     /*!< [21..21] GPIO13_LEVEL_HIGH */
      __IOM uint32_t GPIO13_EDGE_LOW : 1;       /*!< [22..22] GPIO13_EDGE_LOW */
      __IOM uint32_t GPIO13_EDGE_HIGH : 1;      /*!< [23..23] GPIO13_EDGE_HIGH */
      __IOM uint32_t GPIO14_LEVEL_LOW : 1;      /*!< [24..24] GPIO14_LEVEL_LOW */
      __IOM uint32_t GPIO14_LEVEL_HIGH : 1;     /*!< [25..25] GPIO14_LEVEL_HIGH */
      __IOM uint32_t GPIO14_EDGE_LOW : 1;       /*!< [26..26] GPIO14_EDGE_LOW */
      __IOM uint32_t GPIO14_EDGE_HIGH : 1;      /*!< [27..27] GPIO14_EDGE_HIGH */
      __IOM uint32_t GPIO15_LEVEL_LOW : 1;      /*!< [28..28] GPIO15_LEVEL_LOW */
      __IOM uint32_t GPIO15_LEVEL_HIGH : 1;     /*!< [29..29] GPIO15_LEVEL_HIGH */
      __IOM uint32_t GPIO15_EDGE_LOW : 1;       /*!< [30..30] GPIO15_EDGE_LOW */
      __IOM uint32_t GPIO15_EDGE_HIGH : 1;      /*!< [31..31] GPIO15_EDGE_HIGH */
    } PROC1_INTE1_b;
  } ;

  union {
    __IOM uint32_t PROC1_INTE2;                 /*!< (@ 0x00000138) Interrupt Enable for proc1 */

    struct {
      __IOM uint32_t GPIO16_LEVEL_LOW : 1;      /*!< [0..0] GPIO16_LEVEL_LOW */
      __IOM uint32_t GPIO16_LEVEL_HIGH : 1;     /*!< [1..1] GPIO16_LEVEL_HIGH */
      __IOM uint32_t GPIO16_EDGE_LOW : 1;       /*!< [2..2] GPIO16_EDGE_LOW */
      __IOM uint32_t GPIO16_EDGE_HIGH : 1;      /*!< [3..3] GPIO16_EDGE_HIGH */
      __IOM uint32_t GPIO17_LEVEL_LOW : 1;      /*!< [4..4] GPIO17_LEVEL_LOW */
      __IOM uint32_t GPIO17_LEVEL_HIGH : 1;     /*!< [5..5] GPIO17_LEVEL_HIGH */
      __IOM uint32_t GPIO17_EDGE_LOW : 1;       /*!< [6..6] GPIO17_EDGE_LOW */
      __IOM uint32_t GPIO17_EDGE_HIGH : 1;      /*!< [7..7] GPIO17_EDGE_HIGH */
      __IOM uint32_t GPIO18_LEVEL_LOW : 1;      /*!< [8..8] GPIO18_LEVEL_LOW */
      __IOM uint32_t GPIO18_LEVEL_HIGH : 1;     /*!< [9..9] GPIO18_LEVEL_HIGH */
      __IOM uint32_t GPIO18_EDGE_LOW : 1;       /*!< [10..10] GPIO18_EDGE_LOW */
      __IOM uint32_t GPIO18_EDGE_HIGH : 1;      /*!< [11..11] GPIO18_EDGE_HIGH */
      __IOM uint32_t GPIO19_LEVEL_LOW : 1;      /*!< [12..12] GPIO19_LEVEL_LOW */
      __IOM uint32_t GPIO19_LEVEL_HIGH : 1;     /*!< [13..13] GPIO19_LEVEL_HIGH */
      __IOM uint32_t GPIO19_EDGE_LOW : 1;       /*!< [14..14] GPIO19_EDGE_LOW */
      __IOM uint32_t GPIO19_EDGE_HIGH : 1;      /*!< [15..15] GPIO19_EDGE_HIGH */
      __IOM uint32_t GPIO20_LEVEL_LOW : 1;      /*!< [16..16] GPIO20_LEVEL_LOW */
      __IOM uint32_t GPIO20_LEVEL_HIGH : 1;     /*!< [17..17] GPIO20_LEVEL_HIGH */
      __IOM uint32_t GPIO20_EDGE_LOW : 1;       /*!< [18..18] GPIO20_EDGE_LOW */
      __IOM uint32_t GPIO20_EDGE_HIGH : 1;      /*!< [19..19] GPIO20_EDGE_HIGH */
      __IOM uint32_t GPIO21_LEVEL_LOW : 1;      /*!< [20..20] GPIO21_LEVEL_LOW */
      __IOM uint32_t GPIO21_LEVEL_HIGH : 1;     /*!< [21..21] GPIO21_LEVEL_HIGH */
      __IOM uint32_t GPIO21_EDGE_LOW : 1;       /*!< [22..22] GPIO21_EDGE_LOW */
      __IOM uint32_t GPIO21_EDGE_HIGH : 1;      /*!< [23..23] GPIO21_EDGE_HIGH */
      __IOM uint32_t GPIO22_LEVEL_LOW : 1;      /*!< [24..24] GPIO22_LEVEL_LOW */
      __IOM uint32_t GPIO22_LEVEL_HIGH : 1;     /*!< [25..25] GPIO22_LEVEL_HIGH */
      __IOM uint32_t GPIO22_EDGE_LOW : 1;       /*!< [26..26] GPIO22_EDGE_LOW */
      __IOM uint32_t GPIO22_EDGE_HIGH : 1;      /*!< [27..27] GPIO22_EDGE_HIGH */
      __IOM uint32_t GPIO23_LEVEL_LOW : 1;      /*!< [28..28] GPIO23_LEVEL_LOW */
      __IOM uint32_t GPIO23_LEVEL_HIGH : 1;     /*!< [29..29] GPIO23_LEVEL_HIGH */
      __IOM uint32_t GPIO23_EDGE_LOW : 1;       /*!< [30..30] GPIO23_EDGE_LOW */
      __IOM uint32_t GPIO23_EDGE_HIGH : 1;      /*!< [31..31] GPIO23_EDGE_HIGH */
    } PROC1_INTE2_b;
  } ;

  union {
    __IOM uint32_t PROC1_INTE3;                 /*!< (@ 0x0000013C) Interrupt Enable for proc1 */

    struct {
      __IOM uint32_t GPIO24_LEVEL_LOW : 1;      /*!< [0..0] GPIO24_LEVEL_LOW */
      __IOM uint32_t GPIO24_LEVEL_HIGH : 1;     /*!< [1..1] GPIO24_LEVEL_HIGH */
      __IOM uint32_t GPIO24_EDGE_LOW : 1;       /*!< [2..2] GPIO24_EDGE_LOW */
      __IOM uint32_t GPIO24_EDGE_HIGH : 1;      /*!< [3..3] GPIO24_EDGE_HIGH */
      __IOM uint32_t GPIO25_LEVEL_LOW : 1;      /*!< [4..4] GPIO25_LEVEL_LOW */
      __IOM uint32_t GPIO25_LEVEL_HIGH : 1;     /*!< [5..5] GPIO25_LEVEL_HIGH */
      __IOM uint32_t GPIO25_EDGE_LOW : 1;       /*!< [6..6] GPIO25_EDGE_LOW */
      __IOM uint32_t GPIO25_EDGE_HIGH : 1;      /*!< [7..7] GPIO25_EDGE_HIGH */
      __IOM uint32_t GPIO26_LEVEL_LOW : 1;      /*!< [8..8] GPIO26_LEVEL_LOW */
      __IOM uint32_t GPIO26_LEVEL_HIGH : 1;     /*!< [9..9] GPIO26_LEVEL_HIGH */
      __IOM uint32_t GPIO26_EDGE_LOW : 1;       /*!< [10..10] GPIO26_EDGE_LOW */
      __IOM uint32_t GPIO26_EDGE_HIGH : 1;      /*!< [11..11] GPIO26_EDGE_HIGH */
      __IOM uint32_t GPIO27_LEVEL_LOW : 1;      /*!< [12..12] GPIO27_LEVEL_LOW */
      __IOM uint32_t GPIO27_LEVEL_HIGH : 1;     /*!< [13..13] GPIO27_LEVEL_HIGH */
      __IOM uint32_t GPIO27_EDGE_LOW : 1;       /*!< [14..14] GPIO27_EDGE_LOW */
      __IOM uint32_t GPIO27_EDGE_HIGH : 1;      /*!< [15..15] GPIO27_EDGE_HIGH */
      __IOM uint32_t GPIO28_LEVEL_LOW : 1;      /*!< [16..16] GPIO28_LEVEL_LOW */
      __IOM uint32_t GPIO28_LEVEL_HIGH : 1;     /*!< [17..17] GPIO28_LEVEL_HIGH */
      __IOM uint32_t GPIO28_EDGE_LOW : 1;       /*!< [18..18] GPIO28_EDGE_LOW */
      __IOM uint32_t GPIO28_EDGE_HIGH : 1;      /*!< [19..19] GPIO28_EDGE_HIGH */
      __IOM uint32_t GPIO29_LEVEL_LOW : 1;      /*!< [20..20] GPIO29_LEVEL_LOW */
      __IOM uint32_t GPIO29_LEVEL_HIGH : 1;     /*!< [21..21] GPIO29_LEVEL_HIGH */
      __IOM uint32_t GPIO29_EDGE_LOW : 1;       /*!< [22..22] GPIO29_EDGE_LOW */
      __IOM uint32_t GPIO29_EDGE_HIGH : 1;      /*!< [23..23] GPIO29_EDGE_HIGH */
            uint32_t            : 8;
    } PROC1_INTE3_b;
  } ;

  union {
    __IOM uint32_t PROC1_INTF0;                 /*!< (@ 0x00000140) Interrupt Force for proc1 */

    struct {
      __IOM uint32_t GPIO0_LEVEL_LOW : 1;       /*!< [0..0] GPIO0_LEVEL_LOW */
      __IOM uint32_t GPIO0_LEVEL_HIGH : 1;      /*!< [1..1] GPIO0_LEVEL_HIGH */
      __IOM uint32_t GPIO0_EDGE_LOW : 1;        /*!< [2..2] GPIO0_EDGE_LOW */
      __IOM uint32_t GPIO0_EDGE_HIGH : 1;       /*!< [3..3] GPIO0_EDGE_HIGH */
      __IOM uint32_t GPIO1_LEVEL_LOW : 1;       /*!< [4..4] GPIO1_LEVEL_LOW */
      __IOM uint32_t GPIO1_LEVEL_HIGH : 1;      /*!< [5..5] GPIO1_LEVEL_HIGH */
      __IOM uint32_t GPIO1_EDGE_LOW : 1;        /*!< [6..6] GPIO1_EDGE_LOW */
      __IOM uint32_t GPIO1_EDGE_HIGH : 1;       /*!< [7..7] GPIO1_EDGE_HIGH */
      __IOM uint32_t GPIO2_LEVEL_LOW : 1;       /*!< [8..8] GPIO2_LEVEL_LOW */
      __IOM uint32_t GPIO2_LEVEL_HIGH : 1;      /*!< [9..9] GPIO2_LEVEL_HIGH */
      __IOM uint32_t GPIO2_EDGE_LOW : 1;        /*!< [10..10] GPIO2_EDGE_LOW */
      __IOM uint32_t GPIO2_EDGE_HIGH : 1;       /*!< [11..11] GPIO2_EDGE_HIGH */
      __IOM uint32_t GPIO3_LEVEL_LOW : 1;       /*!< [12..12] GPIO3_LEVEL_LOW */
      __IOM uint32_t GPIO3_LEVEL_HIGH : 1;      /*!< [13..13] GPIO3_LEVEL_HIGH */
      __IOM uint32_t GPIO3_EDGE_LOW : 1;        /*!< [14..14] GPIO3_EDGE_LOW */
      __IOM uint32_t GPIO3_EDGE_HIGH : 1;       /*!< [15..15] GPIO3_EDGE_HIGH */
      __IOM uint32_t GPIO4_LEVEL_LOW : 1;       /*!< [16..16] GPIO4_LEVEL_LOW */
      __IOM uint32_t GPIO4_LEVEL_HIGH : 1;      /*!< [17..17] GPIO4_LEVEL_HIGH */
      __IOM uint32_t GPIO4_EDGE_LOW : 1;        /*!< [18..18] GPIO4_EDGE_LOW */
      __IOM uint32_t GPIO4_EDGE_HIGH : 1;       /*!< [19..19] GPIO4_EDGE_HIGH */
      __IOM uint32_t GPIO5_LEVEL_LOW : 1;       /*!< [20..20] GPIO5_LEVEL_LOW */
      __IOM uint32_t GPIO5_LEVEL_HIGH : 1;      /*!< [21..21] GPIO5_LEVEL_HIGH */
      __IOM uint32_t GPIO5_EDGE_LOW : 1;        /*!< [22..22] GPIO5_EDGE_LOW */
      __IOM uint32_t GPIO5_EDGE_HIGH : 1;       /*!< [23..23] GPIO5_EDGE_HIGH */
      __IOM uint32_t GPIO6_LEVEL_LOW : 1;       /*!< [24..24] GPIO6_LEVEL_LOW */
      __IOM uint32_t GPIO6_LEVEL_HIGH : 1;      /*!< [25..25] GPIO6_LEVEL_HIGH */
      __IOM uint32_t GPIO6_EDGE_LOW : 1;        /*!< [26..26] GPIO6_EDGE_LOW */
      __IOM uint32_t GPIO6_EDGE_HIGH : 1;       /*!< [27..27] GPIO6_EDGE_HIGH */
      __IOM uint32_t GPIO7_LEVEL_LOW : 1;       /*!< [28..28] GPIO7_LEVEL_LOW */
      __IOM uint32_t GPIO7_LEVEL_HIGH : 1;      /*!< [29..29] GPIO7_LEVEL_HIGH */
      __IOM uint32_t GPIO7_EDGE_LOW : 1;        /*!< [30..30] GPIO7_EDGE_LOW */
      __IOM uint32_t GPIO7_EDGE_HIGH : 1;       /*!< [31..31] GPIO7_EDGE_HIGH */
    } PROC1_INTF0_b;
  } ;

  union {
    __IOM uint32_t PROC1_INTF1;                 /*!< (@ 0x00000144) Interrupt Force for proc1 */

    struct {
      __IOM uint32_t GPIO8_LEVEL_LOW : 1;       /*!< [0..0] GPIO8_LEVEL_LOW */
      __IOM uint32_t GPIO8_LEVEL_HIGH : 1;      /*!< [1..1] GPIO8_LEVEL_HIGH */
      __IOM uint32_t GPIO8_EDGE_LOW : 1;        /*!< [2..2] GPIO8_EDGE_LOW */
      __IOM uint32_t GPIO8_EDGE_HIGH : 1;       /*!< [3..3] GPIO8_EDGE_HIGH */
      __IOM uint32_t GPIO9_LEVEL_LOW : 1;       /*!< [4..4] GPIO9_LEVEL_LOW */
      __IOM uint32_t GPIO9_LEVEL_HIGH : 1;      /*!< [5..5] GPIO9_LEVEL_HIGH */
      __IOM uint32_t GPIO9_EDGE_LOW : 1;        /*!< [6..6] GPIO9_EDGE_LOW */
      __IOM uint32_t GPIO9_EDGE_HIGH : 1;       /*!< [7..7] GPIO9_EDGE_HIGH */
      __IOM uint32_t GPIO10_LEVEL_LOW : 1;      /*!< [8..8] GPIO10_LEVEL_LOW */
      __IOM uint32_t GPIO10_LEVEL_HIGH : 1;     /*!< [9..9] GPIO10_LEVEL_HIGH */
      __IOM uint32_t GPIO10_EDGE_LOW : 1;       /*!< [10..10] GPIO10_EDGE_LOW */
      __IOM uint32_t GPIO10_EDGE_HIGH : 1;      /*!< [11..11] GPIO10_EDGE_HIGH */
      __IOM uint32_t GPIO11_LEVEL_LOW : 1;      /*!< [12..12] GPIO11_LEVEL_LOW */
      __IOM uint32_t GPIO11_LEVEL_HIGH : 1;     /*!< [13..13] GPIO11_LEVEL_HIGH */
      __IOM uint32_t GPIO11_EDGE_LOW : 1;       /*!< [14..14] GPIO11_EDGE_LOW */
      __IOM uint32_t GPIO11_EDGE_HIGH : 1;      /*!< [15..15] GPIO11_EDGE_HIGH */
      __IOM uint32_t GPIO12_LEVEL_LOW : 1;      /*!< [16..16] GPIO12_LEVEL_LOW */
      __IOM uint32_t GPIO12_LEVEL_HIGH : 1;     /*!< [17..17] GPIO12_LEVEL_HIGH */
      __IOM uint32_t GPIO12_EDGE_LOW : 1;       /*!< [18..18] GPIO12_EDGE_LOW */
      __IOM uint32_t GPIO12_EDGE_HIGH : 1;      /*!< [19..19] GPIO12_EDGE_HIGH */
      __IOM uint32_t GPIO13_LEVEL_LOW : 1;      /*!< [20..20] GPIO13_LEVEL_LOW */
      __IOM uint32_t GPIO13_LEVEL_HIGH : 1;     /*!< [21..21] GPIO13_LEVEL_HIGH */
      __IOM uint32_t GPIO13_EDGE_LOW : 1;       /*!< [22..22] GPIO13_EDGE_LOW */
      __IOM uint32_t GPIO13_EDGE_HIGH : 1;      /*!< [23..23] GPIO13_EDGE_HIGH */
      __IOM uint32_t GPIO14_LEVEL_LOW : 1;      /*!< [24..24] GPIO14_LEVEL_LOW */
      __IOM uint32_t GPIO14_LEVEL_HIGH : 1;     /*!< [25..25] GPIO14_LEVEL_HIGH */
      __IOM uint32_t GPIO14_EDGE_LOW : 1;       /*!< [26..26] GPIO14_EDGE_LOW */
      __IOM uint32_t GPIO14_EDGE_HIGH : 1;      /*!< [27..27] GPIO14_EDGE_HIGH */
      __IOM uint32_t GPIO15_LEVEL_LOW : 1;      /*!< [28..28] GPIO15_LEVEL_LOW */
      __IOM uint32_t GPIO15_LEVEL_HIGH : 1;     /*!< [29..29] GPIO15_LEVEL_HIGH */
      __IOM uint32_t GPIO15_EDGE_LOW : 1;       /*!< [30..30] GPIO15_EDGE_LOW */
      __IOM uint32_t GPIO15_EDGE_HIGH : 1;      /*!< [31..31] GPIO15_EDGE_HIGH */
    } PROC1_INTF1_b;
  } ;

  union {
    __IOM uint32_t PROC1_INTF2;                 /*!< (@ 0x00000148) Interrupt Force for proc1 */

    struct {
      __IOM uint32_t GPIO16_LEVEL_LOW : 1;      /*!< [0..0] GPIO16_LEVEL_LOW */
      __IOM uint32_t GPIO16_LEVEL_HIGH : 1;     /*!< [1..1] GPIO16_LEVEL_HIGH */
      __IOM uint32_t GPIO16_EDGE_LOW : 1;       /*!< [2..2] GPIO16_EDGE_LOW */
      __IOM uint32_t GPIO16_EDGE_HIGH : 1;      /*!< [3..3] GPIO16_EDGE_HIGH */
      __IOM uint32_t GPIO17_LEVEL_LOW : 1;      /*!< [4..4] GPIO17_LEVEL_LOW */
      __IOM uint32_t GPIO17_LEVEL_HIGH : 1;     /*!< [5..5] GPIO17_LEVEL_HIGH */
      __IOM uint32_t GPIO17_EDGE_LOW : 1;       /*!< [6..6] GPIO17_EDGE_LOW */
      __IOM uint32_t GPIO17_EDGE_HIGH : 1;      /*!< [7..7] GPIO17_EDGE_HIGH */
      __IOM uint32_t GPIO18_LEVEL_LOW : 1;      /*!< [8..8] GPIO18_LEVEL_LOW */
      __IOM uint32_t GPIO18_LEVEL_HIGH : 1;     /*!< [9..9] GPIO18_LEVEL_HIGH */
      __IOM uint32_t GPIO18_EDGE_LOW : 1;       /*!< [10..10] GPIO18_EDGE_LOW */
      __IOM uint32_t GPIO18_EDGE_HIGH : 1;      /*!< [11..11] GPIO18_EDGE_HIGH */
      __IOM uint32_t GPIO19_LEVEL_LOW : 1;      /*!< [12..12] GPIO19_LEVEL_LOW */
      __IOM uint32_t GPIO19_LEVEL_HIGH : 1;     /*!< [13..13] GPIO19_LEVEL_HIGH */
      __IOM uint32_t GPIO19_EDGE_LOW : 1;       /*!< [14..14] GPIO19_EDGE_LOW */
      __IOM uint32_t GPIO19_EDGE_HIGH : 1;      /*!< [15..15] GPIO19_EDGE_HIGH */
      __IOM uint32_t GPIO20_LEVEL_LOW : 1;      /*!< [16..16] GPIO20_LEVEL_LOW */
      __IOM uint32_t GPIO20_LEVEL_HIGH : 1;     /*!< [17..17] GPIO20_LEVEL_HIGH */
      __IOM uint32_t GPIO20_EDGE_LOW : 1;       /*!< [18..18] GPIO20_EDGE_LOW */
      __IOM uint32_t GPIO20_EDGE_HIGH : 1;      /*!< [19..19] GPIO20_EDGE_HIGH */
      __IOM uint32_t GPIO21_LEVEL_LOW : 1;      /*!< [20..20] GPIO21_LEVEL_LOW */
      __IOM uint32_t GPIO21_LEVEL_HIGH : 1;     /*!< [21..21] GPIO21_LEVEL_HIGH */
      __IOM uint32_t GPIO21_EDGE_LOW : 1;       /*!< [22..22] GPIO21_EDGE_LOW */
      __IOM uint32_t GPIO21_EDGE_HIGH : 1;      /*!< [23..23] GPIO21_EDGE_HIGH */
      __IOM uint32_t GPIO22_LEVEL_LOW : 1;      /*!< [24..24] GPIO22_LEVEL_LOW */
      __IOM uint32_t GPIO22_LEVEL_HIGH : 1;     /*!< [25..25] GPIO22_LEVEL_HIGH */
      __IOM uint32_t GPIO22_EDGE_LOW : 1;       /*!< [26..26] GPIO22_EDGE_LOW */
      __IOM uint32_t GPIO22_EDGE_HIGH : 1;      /*!< [27..27] GPIO22_EDGE_HIGH */
      __IOM uint32_t GPIO23_LEVEL_LOW : 1;      /*!< [28..28] GPIO23_LEVEL_LOW */
      __IOM uint32_t GPIO23_LEVEL_HIGH : 1;     /*!< [29..29] GPIO23_LEVEL_HIGH */
      __IOM uint32_t GPIO23_EDGE_LOW : 1;       /*!< [30..30] GPIO23_EDGE_LOW */
      __IOM uint32_t GPIO23_EDGE_HIGH : 1;      /*!< [31..31] GPIO23_EDGE_HIGH */
    } PROC1_INTF2_b;
  } ;

  union {
    __IOM uint32_t PROC1_INTF3;                 /*!< (@ 0x0000014C) Interrupt Force for proc1 */

    struct {
      __IOM uint32_t GPIO24_LEVEL_LOW : 1;      /*!< [0..0] GPIO24_LEVEL_LOW */
      __IOM uint32_t GPIO24_LEVEL_HIGH : 1;     /*!< [1..1] GPIO24_LEVEL_HIGH */
      __IOM uint32_t GPIO24_EDGE_LOW : 1;       /*!< [2..2] GPIO24_EDGE_LOW */
      __IOM uint32_t GPIO24_EDGE_HIGH : 1;      /*!< [3..3] GPIO24_EDGE_HIGH */
      __IOM uint32_t GPIO25_LEVEL_LOW : 1;      /*!< [4..4] GPIO25_LEVEL_LOW */
      __IOM uint32_t GPIO25_LEVEL_HIGH : 1;     /*!< [5..5] GPIO25_LEVEL_HIGH */
      __IOM uint32_t GPIO25_EDGE_LOW : 1;       /*!< [6..6] GPIO25_EDGE_LOW */
      __IOM uint32_t GPIO25_EDGE_HIGH : 1;      /*!< [7..7] GPIO25_EDGE_HIGH */
      __IOM uint32_t GPIO26_LEVEL_LOW : 1;      /*!< [8..8] GPIO26_LEVEL_LOW */
      __IOM uint32_t GPIO26_LEVEL_HIGH : 1;     /*!< [9..9] GPIO26_LEVEL_HIGH */
      __IOM uint32_t GPIO26_EDGE_LOW : 1;       /*!< [10..10] GPIO26_EDGE_LOW */
      __IOM uint32_t GPIO26_EDGE_HIGH : 1;      /*!< [11..11] GPIO26_EDGE_HIGH */
      __IOM uint32_t GPIO27_LEVEL_LOW : 1;      /*!< [12..12] GPIO27_LEVEL_LOW */
      __IOM uint32_t GPIO27_LEVEL_HIGH : 1;     /*!< [13..13] GPIO27_LEVEL_HIGH */
      __IOM uint32_t GPIO27_EDGE_LOW : 1;       /*!< [14..14] GPIO27_EDGE_LOW */
      __IOM uint32_t GPIO27_EDGE_HIGH : 1;      /*!< [15..15] GPIO27_EDGE_HIGH */
      __IOM uint32_t GPIO28_LEVEL_LOW : 1;      /*!< [16..16] GPIO28_LEVEL_LOW */
      __IOM uint32_t GPIO28_LEVEL_HIGH : 1;     /*!< [17..17] GPIO28_LEVEL_HIGH */
      __IOM uint32_t GPIO28_EDGE_LOW : 1;       /*!< [18..18] GPIO28_EDGE_LOW */
      __IOM uint32_t GPIO28_EDGE_HIGH : 1;      /*!< [19..19] GPIO28_EDGE_HIGH */
      __IOM uint32_t GPIO29_LEVEL_LOW : 1;      /*!< [20..20] GPIO29_LEVEL_LOW */
      __IOM uint32_t GPIO29_LEVEL_HIGH : 1;     /*!< [21..21] GPIO29_LEVEL_HIGH */
      __IOM uint32_t GPIO29_EDGE_LOW : 1;       /*!< [22..22] GPIO29_EDGE_LOW */
      __IOM uint32_t GPIO29_EDGE_HIGH : 1;      /*!< [23..23] GPIO29_EDGE_HIGH */
            uint32_t            : 8;
    } PROC1_INTF3_b;
  } ;

  union {
    __IOM uint32_t PROC1_INTS0;                 /*!< (@ 0x00000150) Interrupt status after masking & forcing for proc1 */

    struct {
      __IM  uint32_t GPIO0_LEVEL_LOW : 1;       /*!< [0..0] GPIO0_LEVEL_LOW */
      __IM  uint32_t GPIO0_LEVEL_HIGH : 1;      /*!< [1..1] GPIO0_LEVEL_HIGH */
      __IM  uint32_t GPIO0_EDGE_LOW : 1;        /*!< [2..2] GPIO0_EDGE_LOW */
      __IM  uint32_t GPIO0_EDGE_HIGH : 1;       /*!< [3..3] GPIO0_EDGE_HIGH */
      __IM  uint32_t GPIO1_LEVEL_LOW : 1;       /*!< [4..4] GPIO1_LEVEL_LOW */
      __IM  uint32_t GPIO1_LEVEL_HIGH : 1;      /*!< [5..5] GPIO1_LEVEL_HIGH */
      __IM  uint32_t GPIO1_EDGE_LOW : 1;        /*!< [6..6] GPIO1_EDGE_LOW */
      __IM  uint32_t GPIO1_EDGE_HIGH : 1;       /*!< [7..7] GPIO1_EDGE_HIGH */
      __IM  uint32_t GPIO2_LEVEL_LOW : 1;       /*!< [8..8] GPIO2_LEVEL_LOW */
      __IM  uint32_t GPIO2_LEVEL_HIGH : 1;      /*!< [9..9] GPIO2_LEVEL_HIGH */
      __IM  uint32_t GPIO2_EDGE_LOW : 1;        /*!< [10..10] GPIO2_EDGE_LOW */
      __IM  uint32_t GPIO2_EDGE_HIGH : 1;       /*!< [11..11] GPIO2_EDGE_HIGH */
      __IM  uint32_t GPIO3_LEVEL_LOW : 1;       /*!< [12..12] GPIO3_LEVEL_LOW */
      __IM  uint32_t GPIO3_LEVEL_HIGH : 1;      /*!< [13..13] GPIO3_LEVEL_HIGH */
      __IM  uint32_t GPIO3_EDGE_LOW : 1;        /*!< [14..14] GPIO3_EDGE_LOW */
      __IM  uint32_t GPIO3_EDGE_HIGH : 1;       /*!< [15..15] GPIO3_EDGE_HIGH */
      __IM  uint32_t GPIO4_LEVEL_LOW : 1;       /*!< [16..16] GPIO4_LEVEL_LOW */
      __IM  uint32_t GPIO4_LEVEL_HIGH : 1;      /*!< [17..17] GPIO4_LEVEL_HIGH */
      __IM  uint32_t GPIO4_EDGE_LOW : 1;        /*!< [18..18] GPIO4_EDGE_LOW */
      __IM  uint32_t GPIO4_EDGE_HIGH : 1;       /*!< [19..19] GPIO4_EDGE_HIGH */
      __IM  uint32_t GPIO5_LEVEL_LOW : 1;       /*!< [20..20] GPIO5_LEVEL_LOW */
      __IM  uint32_t GPIO5_LEVEL_HIGH : 1;      /*!< [21..21] GPIO5_LEVEL_HIGH */
      __IM  uint32_t GPIO5_EDGE_LOW : 1;        /*!< [22..22] GPIO5_EDGE_LOW */
      __IM  uint32_t GPIO5_EDGE_HIGH : 1;       /*!< [23..23] GPIO5_EDGE_HIGH */
      __IM  uint32_t GPIO6_LEVEL_LOW : 1;       /*!< [24..24] GPIO6_LEVEL_LOW */
      __IM  uint32_t GPIO6_LEVEL_HIGH : 1;      /*!< [25..25] GPIO6_LEVEL_HIGH */
      __IM  uint32_t GPIO6_EDGE_LOW : 1;        /*!< [26..26] GPIO6_EDGE_LOW */
      __IM  uint32_t GPIO6_EDGE_HIGH : 1;       /*!< [27..27] GPIO6_EDGE_HIGH */
      __IM  uint32_t GPIO7_LEVEL_LOW : 1;       /*!< [28..28] GPIO7_LEVEL_LOW */
      __IM  uint32_t GPIO7_LEVEL_HIGH : 1;      /*!< [29..29] GPIO7_LEVEL_HIGH */
      __IM  uint32_t GPIO7_EDGE_LOW : 1;        /*!< [30..30] GPIO7_EDGE_LOW */
      __IM  uint32_t GPIO7_EDGE_HIGH : 1;       /*!< [31..31] GPIO7_EDGE_HIGH */
    } PROC1_INTS0_b;
  } ;

  union {
    __IOM uint32_t PROC1_INTS1;                 /*!< (@ 0x00000154) Interrupt status after masking & forcing for proc1 */

    struct {
      __IM  uint32_t GPIO8_LEVEL_LOW : 1;       /*!< [0..0] GPIO8_LEVEL_LOW */
      __IM  uint32_t GPIO8_LEVEL_HIGH : 1;      /*!< [1..1] GPIO8_LEVEL_HIGH */
      __IM  uint32_t GPIO8_EDGE_LOW : 1;        /*!< [2..2] GPIO8_EDGE_LOW */
      __IM  uint32_t GPIO8_EDGE_HIGH : 1;       /*!< [3..3] GPIO8_EDGE_HIGH */
      __IM  uint32_t GPIO9_LEVEL_LOW : 1;       /*!< [4..4] GPIO9_LEVEL_LOW */
      __IM  uint32_t GPIO9_LEVEL_HIGH : 1;      /*!< [5..5] GPIO9_LEVEL_HIGH */
      __IM  uint32_t GPIO9_EDGE_LOW : 1;        /*!< [6..6] GPIO9_EDGE_LOW */
      __IM  uint32_t GPIO9_EDGE_HIGH : 1;       /*!< [7..7] GPIO9_EDGE_HIGH */
      __IM  uint32_t GPIO10_LEVEL_LOW : 1;      /*!< [8..8] GPIO10_LEVEL_LOW */
      __IM  uint32_t GPIO10_LEVEL_HIGH : 1;     /*!< [9..9] GPIO10_LEVEL_HIGH */
      __IM  uint32_t GPIO10_EDGE_LOW : 1;       /*!< [10..10] GPIO10_EDGE_LOW */
      __IM  uint32_t GPIO10_EDGE_HIGH : 1;      /*!< [11..11] GPIO10_EDGE_HIGH */
      __IM  uint32_t GPIO11_LEVEL_LOW : 1;      /*!< [12..12] GPIO11_LEVEL_LOW */
      __IM  uint32_t GPIO11_LEVEL_HIGH : 1;     /*!< [13..13] GPIO11_LEVEL_HIGH */
      __IM  uint32_t GPIO11_EDGE_LOW : 1;       /*!< [14..14] GPIO11_EDGE_LOW */
      __IM  uint32_t GPIO11_EDGE_HIGH : 1;      /*!< [15..15] GPIO11_EDGE_HIGH */
      __IM  uint32_t GPIO12_LEVEL_LOW : 1;      /*!< [16..16] GPIO12_LEVEL_LOW */
      __IM  uint32_t GPIO12_LEVEL_HIGH : 1;     /*!< [17..17] GPIO12_LEVEL_HIGH */
      __IM  uint32_t GPIO12_EDGE_LOW : 1;       /*!< [18..18] GPIO12_EDGE_LOW */
      __IM  uint32_t GPIO12_EDGE_HIGH : 1;      /*!< [19..19] GPIO12_EDGE_HIGH */
      __IM  uint32_t GPIO13_LEVEL_LOW : 1;      /*!< [20..20] GPIO13_LEVEL_LOW */
      __IM  uint32_t GPIO13_LEVEL_HIGH : 1;     /*!< [21..21] GPIO13_LEVEL_HIGH */
      __IM  uint32_t GPIO13_EDGE_LOW : 1;       /*!< [22..22] GPIO13_EDGE_LOW */
      __IM  uint32_t GPIO13_EDGE_HIGH : 1;      /*!< [23..23] GPIO13_EDGE_HIGH */
      __IM  uint32_t GPIO14_LEVEL_LOW : 1;      /*!< [24..24] GPIO14_LEVEL_LOW */
      __IM  uint32_t GPIO14_LEVEL_HIGH : 1;     /*!< [25..25] GPIO14_LEVEL_HIGH */
      __IM  uint32_t GPIO14_EDGE_LOW : 1;       /*!< [26..26] GPIO14_EDGE_LOW */
      __IM  uint32_t GPIO14_EDGE_HIGH : 1;      /*!< [27..27] GPIO14_EDGE_HIGH */
      __IM  uint32_t GPIO15_LEVEL_LOW : 1;      /*!< [28..28] GPIO15_LEVEL_LOW */
      __IM  uint32_t GPIO15_LEVEL_HIGH : 1;     /*!< [29..29] GPIO15_LEVEL_HIGH */
      __IM  uint32_t GPIO15_EDGE_LOW : 1;       /*!< [30..30] GPIO15_EDGE_LOW */
      __IM  uint32_t GPIO15_EDGE_HIGH : 1;      /*!< [31..31] GPIO15_EDGE_HIGH */
    } PROC1_INTS1_b;
  } ;

  union {
    __IOM uint32_t PROC1_INTS2;                 /*!< (@ 0x00000158) Interrupt status after masking & forcing for proc1 */

    struct {
      __IM  uint32_t GPIO16_LEVEL_LOW : 1;      /*!< [0..0] GPIO16_LEVEL_LOW */
      __IM  uint32_t GPIO16_LEVEL_HIGH : 1;     /*!< [1..1] GPIO16_LEVEL_HIGH */
      __IM  uint32_t GPIO16_EDGE_LOW : 1;       /*!< [2..2] GPIO16_EDGE_LOW */
      __IM  uint32_t GPIO16_EDGE_HIGH : 1;      /*!< [3..3] GPIO16_EDGE_HIGH */
      __IM  uint32_t GPIO17_LEVEL_LOW : 1;      /*!< [4..4] GPIO17_LEVEL_LOW */
      __IM  uint32_t GPIO17_LEVEL_HIGH : 1;     /*!< [5..5] GPIO17_LEVEL_HIGH */
      __IM  uint32_t GPIO17_EDGE_LOW : 1;       /*!< [6..6] GPIO17_EDGE_LOW */
      __IM  uint32_t GPIO17_EDGE_HIGH : 1;      /*!< [7..7] GPIO17_EDGE_HIGH */
      __IM  uint32_t GPIO18_LEVEL_LOW : 1;      /*!< [8..8] GPIO18_LEVEL_LOW */
      __IM  uint32_t GPIO18_LEVEL_HIGH : 1;     /*!< [9..9] GPIO18_LEVEL_HIGH */
      __IM  uint32_t GPIO18_EDGE_LOW : 1;       /*!< [10..10] GPIO18_EDGE_LOW */
      __IM  uint32_t GPIO18_EDGE_HIGH : 1;      /*!< [11..11] GPIO18_EDGE_HIGH */
      __IM  uint32_t GPIO19_LEVEL_LOW : 1;      /*!< [12..12] GPIO19_LEVEL_LOW */
      __IM  uint32_t GPIO19_LEVEL_HIGH : 1;     /*!< [13..13] GPIO19_LEVEL_HIGH */
      __IM  uint32_t GPIO19_EDGE_LOW : 1;       /*!< [14..14] GPIO19_EDGE_LOW */
      __IM  uint32_t GPIO19_EDGE_HIGH : 1;      /*!< [15..15] GPIO19_EDGE_HIGH */
      __IM  uint32_t GPIO20_LEVEL_LOW : 1;      /*!< [16..16] GPIO20_LEVEL_LOW */
      __IM  uint32_t GPIO20_LEVEL_HIGH : 1;     /*!< [17..17] GPIO20_LEVEL_HIGH */
      __IM  uint32_t GPIO20_EDGE_LOW : 1;       /*!< [18..18] GPIO20_EDGE_LOW */
      __IM  uint32_t GPIO20_EDGE_HIGH : 1;      /*!< [19..19] GPIO20_EDGE_HIGH */
      __IM  uint32_t GPIO21_LEVEL_LOW : 1;      /*!< [20..20] GPIO21_LEVEL_LOW */
      __IM  uint32_t GPIO21_LEVEL_HIGH : 1;     /*!< [21..21] GPIO21_LEVEL_HIGH */
      __IM  uint32_t GPIO21_EDGE_LOW : 1;       /*!< [22..22] GPIO21_EDGE_LOW */
      __IM  uint32_t GPIO21_EDGE_HIGH : 1;      /*!< [23..23] GPIO21_EDGE_HIGH */
      __IM  uint32_t GPIO22_LEVEL_LOW : 1;      /*!< [24..24] GPIO22_LEVEL_LOW */
      __IM  uint32_t GPIO22_LEVEL_HIGH : 1;     /*!< [25..25] GPIO22_LEVEL_HIGH */
      __IM  uint32_t GPIO22_EDGE_LOW : 1;       /*!< [26..26] GPIO22_EDGE_LOW */
      __IM  uint32_t GPIO22_EDGE_HIGH : 1;      /*!< [27..27] GPIO22_EDGE_HIGH */
      __IM  uint32_t GPIO23_LEVEL_LOW : 1;      /*!< [28..28] GPIO23_LEVEL_LOW */
      __IM  uint32_t GPIO23_LEVEL_HIGH : 1;     /*!< [29..29] GPIO23_LEVEL_HIGH */
      __IM  uint32_t GPIO23_EDGE_LOW : 1;       /*!< [30..30] GPIO23_EDGE_LOW */
      __IM  uint32_t GPIO23_EDGE_HIGH : 1;      /*!< [31..31] GPIO23_EDGE_HIGH */
    } PROC1_INTS2_b;
  } ;

  union {
    __IOM uint32_t PROC1_INTS3;                 /*!< (@ 0x0000015C) Interrupt status after masking & forcing for proc1 */

    struct {
      __IM  uint32_t GPIO24_LEVEL_LOW : 1;      /*!< [0..0] GPIO24_LEVEL_LOW */
      __IM  uint32_t GPIO24_LEVEL_HIGH : 1;     /*!< [1..1] GPIO24_LEVEL_HIGH */
      __IM  uint32_t GPIO24_EDGE_LOW : 1;       /*!< [2..2] GPIO24_EDGE_LOW */
      __IM  uint32_t GPIO24_EDGE_HIGH : 1;      /*!< [3..3] GPIO24_EDGE_HIGH */
      __IM  uint32_t GPIO25_LEVEL_LOW : 1;      /*!< [4..4] GPIO25_LEVEL_LOW */
      __IM  uint32_t GPIO25_LEVEL_HIGH : 1;     /*!< [5..5] GPIO25_LEVEL_HIGH */
      __IM  uint32_t GPIO25_EDGE_LOW : 1;       /*!< [6..6] GPIO25_EDGE_LOW */
      __IM  uint32_t GPIO25_EDGE_HIGH : 1;      /*!< [7..7] GPIO25_EDGE_HIGH */
      __IM  uint32_t GPIO26_LEVEL_LOW : 1;      /*!< [8..8] GPIO26_LEVEL_LOW */
      __IM  uint32_t GPIO26_LEVEL_HIGH : 1;     /*!< [9..9] GPIO26_LEVEL_HIGH */
      __IM  uint32_t GPIO26_EDGE_LOW : 1;       /*!< [10..10] GPIO26_EDGE_LOW */
      __IM  uint32_t GPIO26_EDGE_HIGH : 1;      /*!< [11..11] GPIO26_EDGE_HIGH */
      __IM  uint32_t GPIO27_LEVEL_LOW : 1;      /*!< [12..12] GPIO27_LEVEL_LOW */
      __IM  uint32_t GPIO27_LEVEL_HIGH : 1;     /*!< [13..13] GPIO27_LEVEL_HIGH */
      __IM  uint32_t GPIO27_EDGE_LOW : 1;       /*!< [14..14] GPIO27_EDGE_LOW */
      __IM  uint32_t GPIO27_EDGE_HIGH : 1;      /*!< [15..15] GPIO27_EDGE_HIGH */
      __IM  uint32_t GPIO28_LEVEL_LOW : 1;      /*!< [16..16] GPIO28_LEVEL_LOW */
      __IM  uint32_t GPIO28_LEVEL_HIGH : 1;     /*!< [17..17] GPIO28_LEVEL_HIGH */
      __IM  uint32_t GPIO28_EDGE_LOW : 1;       /*!< [18..18] GPIO28_EDGE_LOW */
      __IM  uint32_t GPIO28_EDGE_HIGH : 1;      /*!< [19..19] GPIO28_EDGE_HIGH */
      __IM  uint32_t GPIO29_LEVEL_LOW : 1;      /*!< [20..20] GPIO29_LEVEL_LOW */
      __IM  uint32_t GPIO29_LEVEL_HIGH : 1;     /*!< [21..21] GPIO29_LEVEL_HIGH */
      __IM  uint32_t GPIO29_EDGE_LOW : 1;       /*!< [22..22] GPIO29_EDGE_LOW */
      __IM  uint32_t GPIO29_EDGE_HIGH : 1;      /*!< [23..23] GPIO29_EDGE_HIGH */
            uint32_t            : 8;
    } PROC1_INTS3_b;
  } ;

  union {
    __IOM uint32_t DORMANT_WAKE_INTE0;          /*!< (@ 0x00000160) Interrupt Enable for dormant_wake */

    struct {
      __IOM uint32_t GPIO0_LEVEL_LOW : 1;       /*!< [0..0] GPIO0_LEVEL_LOW */
      __IOM uint32_t GPIO0_LEVEL_HIGH : 1;      /*!< [1..1] GPIO0_LEVEL_HIGH */
      __IOM uint32_t GPIO0_EDGE_LOW : 1;        /*!< [2..2] GPIO0_EDGE_LOW */
      __IOM uint32_t GPIO0_EDGE_HIGH : 1;       /*!< [3..3] GPIO0_EDGE_HIGH */
      __IOM uint32_t GPIO1_LEVEL_LOW : 1;       /*!< [4..4] GPIO1_LEVEL_LOW */
      __IOM uint32_t GPIO1_LEVEL_HIGH : 1;      /*!< [5..5] GPIO1_LEVEL_HIGH */
      __IOM uint32_t GPIO1_EDGE_LOW : 1;        /*!< [6..6] GPIO1_EDGE_LOW */
      __IOM uint32_t GPIO1_EDGE_HIGH : 1;       /*!< [7..7] GPIO1_EDGE_HIGH */
      __IOM uint32_t GPIO2_LEVEL_LOW : 1;       /*!< [8..8] GPIO2_LEVEL_LOW */
      __IOM uint32_t GPIO2_LEVEL_HIGH : 1;      /*!< [9..9] GPIO2_LEVEL_HIGH */
      __IOM uint32_t GPIO2_EDGE_LOW : 1;        /*!< [10..10] GPIO2_EDGE_LOW */
      __IOM uint32_t GPIO2_EDGE_HIGH : 1;       /*!< [11..11] GPIO2_EDGE_HIGH */
      __IOM uint32_t GPIO3_LEVEL_LOW : 1;       /*!< [12..12] GPIO3_LEVEL_LOW */
      __IOM uint32_t GPIO3_LEVEL_HIGH : 1;      /*!< [13..13] GPIO3_LEVEL_HIGH */
      __IOM uint32_t GPIO3_EDGE_LOW : 1;        /*!< [14..14] GPIO3_EDGE_LOW */
      __IOM uint32_t GPIO3_EDGE_HIGH : 1;       /*!< [15..15] GPIO3_EDGE_HIGH */
      __IOM uint32_t GPIO4_LEVEL_LOW : 1;       /*!< [16..16] GPIO4_LEVEL_LOW */
      __IOM uint32_t GPIO4_LEVEL_HIGH : 1;      /*!< [17..17] GPIO4_LEVEL_HIGH */
      __IOM uint32_t GPIO4_EDGE_LOW : 1;        /*!< [18..18] GPIO4_EDGE_LOW */
      __IOM uint32_t GPIO4_EDGE_HIGH : 1;       /*!< [19..19] GPIO4_EDGE_HIGH */
      __IOM uint32_t GPIO5_LEVEL_LOW : 1;       /*!< [20..20] GPIO5_LEVEL_LOW */
      __IOM uint32_t GPIO5_LEVEL_HIGH : 1;      /*!< [21..21] GPIO5_LEVEL_HIGH */
      __IOM uint32_t GPIO5_EDGE_LOW : 1;        /*!< [22..22] GPIO5_EDGE_LOW */
      __IOM uint32_t GPIO5_EDGE_HIGH : 1;       /*!< [23..23] GPIO5_EDGE_HIGH */
      __IOM uint32_t GPIO6_LEVEL_LOW : 1;       /*!< [24..24] GPIO6_LEVEL_LOW */
      __IOM uint32_t GPIO6_LEVEL_HIGH : 1;      /*!< [25..25] GPIO6_LEVEL_HIGH */
      __IOM uint32_t GPIO6_EDGE_LOW : 1;        /*!< [26..26] GPIO6_EDGE_LOW */
      __IOM uint32_t GPIO6_EDGE_HIGH : 1;       /*!< [27..27] GPIO6_EDGE_HIGH */
      __IOM uint32_t GPIO7_LEVEL_LOW : 1;       /*!< [28..28] GPIO7_LEVEL_LOW */
      __IOM uint32_t GPIO7_LEVEL_HIGH : 1;      /*!< [29..29] GPIO7_LEVEL_HIGH */
      __IOM uint32_t GPIO7_EDGE_LOW : 1;        /*!< [30..30] GPIO7_EDGE_LOW */
      __IOM uint32_t GPIO7_EDGE_HIGH : 1;       /*!< [31..31] GPIO7_EDGE_HIGH */
    } DORMANT_WAKE_INTE0_b;
  } ;

  union {
    __IOM uint32_t DORMANT_WAKE_INTE1;          /*!< (@ 0x00000164) Interrupt Enable for dormant_wake */

    struct {
      __IOM uint32_t GPIO8_LEVEL_LOW : 1;       /*!< [0..0] GPIO8_LEVEL_LOW */
      __IOM uint32_t GPIO8_LEVEL_HIGH : 1;      /*!< [1..1] GPIO8_LEVEL_HIGH */
      __IOM uint32_t GPIO8_EDGE_LOW : 1;        /*!< [2..2] GPIO8_EDGE_LOW */
      __IOM uint32_t GPIO8_EDGE_HIGH : 1;       /*!< [3..3] GPIO8_EDGE_HIGH */
      __IOM uint32_t GPIO9_LEVEL_LOW : 1;       /*!< [4..4] GPIO9_LEVEL_LOW */
      __IOM uint32_t GPIO9_LEVEL_HIGH : 1;      /*!< [5..5] GPIO9_LEVEL_HIGH */
      __IOM uint32_t GPIO9_EDGE_LOW : 1;        /*!< [6..6] GPIO9_EDGE_LOW */
      __IOM uint32_t GPIO9_EDGE_HIGH : 1;       /*!< [7..7] GPIO9_EDGE_HIGH */
      __IOM uint32_t GPIO10_LEVEL_LOW : 1;      /*!< [8..8] GPIO10_LEVEL_LOW */
      __IOM uint32_t GPIO10_LEVEL_HIGH : 1;     /*!< [9..9] GPIO10_LEVEL_HIGH */
      __IOM uint32_t GPIO10_EDGE_LOW : 1;       /*!< [10..10] GPIO10_EDGE_LOW */
      __IOM uint32_t GPIO10_EDGE_HIGH : 1;      /*!< [11..11] GPIO10_EDGE_HIGH */
      __IOM uint32_t GPIO11_LEVEL_LOW : 1;      /*!< [12..12] GPIO11_LEVEL_LOW */
      __IOM uint32_t GPIO11_LEVEL_HIGH : 1;     /*!< [13..13] GPIO11_LEVEL_HIGH */
      __IOM uint32_t GPIO11_EDGE_LOW : 1;       /*!< [14..14] GPIO11_EDGE_LOW */
      __IOM uint32_t GPIO11_EDGE_HIGH : 1;      /*!< [15..15] GPIO11_EDGE_HIGH */
      __IOM uint32_t GPIO12_LEVEL_LOW : 1;      /*!< [16..16] GPIO12_LEVEL_LOW */
      __IOM uint32_t GPIO12_LEVEL_HIGH : 1;     /*!< [17..17] GPIO12_LEVEL_HIGH */
      __IOM uint32_t GPIO12_EDGE_LOW : 1;       /*!< [18..18] GPIO12_EDGE_LOW */
      __IOM uint32_t GPIO12_EDGE_HIGH : 1;      /*!< [19..19] GPIO12_EDGE_HIGH */
      __IOM uint32_t GPIO13_LEVEL_LOW : 1;      /*!< [20..20] GPIO13_LEVEL_LOW */
      __IOM uint32_t GPIO13_LEVEL_HIGH : 1;     /*!< [21..21] GPIO13_LEVEL_HIGH */
      __IOM uint32_t GPIO13_EDGE_LOW : 1;       /*!< [22..22] GPIO13_EDGE_LOW */
      __IOM uint32_t GPIO13_EDGE_HIGH : 1;      /*!< [23..23] GPIO13_EDGE_HIGH */
      __IOM uint32_t GPIO14_LEVEL_LOW : 1;      /*!< [24..24] GPIO14_LEVEL_LOW */
      __IOM uint32_t GPIO14_LEVEL_HIGH : 1;     /*!< [25..25] GPIO14_LEVEL_HIGH */
      __IOM uint32_t GPIO14_EDGE_LOW : 1;       /*!< [26..26] GPIO14_EDGE_LOW */
      __IOM uint32_t GPIO14_EDGE_HIGH : 1;      /*!< [27..27] GPIO14_EDGE_HIGH */
      __IOM uint32_t GPIO15_LEVEL_LOW : 1;      /*!< [28..28] GPIO15_LEVEL_LOW */
      __IOM uint32_t GPIO15_LEVEL_HIGH : 1;     /*!< [29..29] GPIO15_LEVEL_HIGH */
      __IOM uint32_t GPIO15_EDGE_LOW : 1;       /*!< [30..30] GPIO15_EDGE_LOW */
      __IOM uint32_t GPIO15_EDGE_HIGH : 1;      /*!< [31..31] GPIO15_EDGE_HIGH */
    } DORMANT_WAKE_INTE1_b;
  } ;

  union {
    __IOM uint32_t DORMANT_WAKE_INTE2;          /*!< (@ 0x00000168) Interrupt Enable for dormant_wake */

    struct {
      __IOM uint32_t GPIO16_LEVEL_LOW : 1;      /*!< [0..0] GPIO16_LEVEL_LOW */
      __IOM uint32_t GPIO16_LEVEL_HIGH : 1;     /*!< [1..1] GPIO16_LEVEL_HIGH */
      __IOM uint32_t GPIO16_EDGE_LOW : 1;       /*!< [2..2] GPIO16_EDGE_LOW */
      __IOM uint32_t GPIO16_EDGE_HIGH : 1;      /*!< [3..3] GPIO16_EDGE_HIGH */
      __IOM uint32_t GPIO17_LEVEL_LOW : 1;      /*!< [4..4] GPIO17_LEVEL_LOW */
      __IOM uint32_t GPIO17_LEVEL_HIGH : 1;     /*!< [5..5] GPIO17_LEVEL_HIGH */
      __IOM uint32_t GPIO17_EDGE_LOW : 1;       /*!< [6..6] GPIO17_EDGE_LOW */
      __IOM uint32_t GPIO17_EDGE_HIGH : 1;      /*!< [7..7] GPIO17_EDGE_HIGH */
      __IOM uint32_t GPIO18_LEVEL_LOW : 1;      /*!< [8..8] GPIO18_LEVEL_LOW */
      __IOM uint32_t GPIO18_LEVEL_HIGH : 1;     /*!< [9..9] GPIO18_LEVEL_HIGH */
      __IOM uint32_t GPIO18_EDGE_LOW : 1;       /*!< [10..10] GPIO18_EDGE_LOW */
      __IOM uint32_t GPIO18_EDGE_HIGH : 1;      /*!< [11..11] GPIO18_EDGE_HIGH */
      __IOM uint32_t GPIO19_LEVEL_LOW : 1;      /*!< [12..12] GPIO19_LEVEL_LOW */
      __IOM uint32_t GPIO19_LEVEL_HIGH : 1;     /*!< [13..13] GPIO19_LEVEL_HIGH */
      __IOM uint32_t GPIO19_EDGE_LOW : 1;       /*!< [14..14] GPIO19_EDGE_LOW */
      __IOM uint32_t GPIO19_EDGE_HIGH : 1;      /*!< [15..15] GPIO19_EDGE_HIGH */
      __IOM uint32_t GPIO20_LEVEL_LOW : 1;      /*!< [16..16] GPIO20_LEVEL_LOW */
      __IOM uint32_t GPIO20_LEVEL_HIGH : 1;     /*!< [17..17] GPIO20_LEVEL_HIGH */
      __IOM uint32_t GPIO20_EDGE_LOW : 1;       /*!< [18..18] GPIO20_EDGE_LOW */
      __IOM uint32_t GPIO20_EDGE_HIGH : 1;      /*!< [19..19] GPIO20_EDGE_HIGH */
      __IOM uint32_t GPIO21_LEVEL_LOW : 1;      /*!< [20..20] GPIO21_LEVEL_LOW */
      __IOM uint32_t GPIO21_LEVEL_HIGH : 1;     /*!< [21..21] GPIO21_LEVEL_HIGH */
      __IOM uint32_t GPIO21_EDGE_LOW : 1;       /*!< [22..22] GPIO21_EDGE_LOW */
      __IOM uint32_t GPIO21_EDGE_HIGH : 1;      /*!< [23..23] GPIO21_EDGE_HIGH */
      __IOM uint32_t GPIO22_LEVEL_LOW : 1;      /*!< [24..24] GPIO22_LEVEL_LOW */
      __IOM uint32_t GPIO22_LEVEL_HIGH : 1;     /*!< [25..25] GPIO22_LEVEL_HIGH */
      __IOM uint32_t GPIO22_EDGE_LOW : 1;       /*!< [26..26] GPIO22_EDGE_LOW */
      __IOM uint32_t GPIO22_EDGE_HIGH : 1;      /*!< [27..27] GPIO22_EDGE_HIGH */
      __IOM uint32_t GPIO23_LEVEL_LOW : 1;      /*!< [28..28] GPIO23_LEVEL_LOW */
      __IOM uint32_t GPIO23_LEVEL_HIGH : 1;     /*!< [29..29] GPIO23_LEVEL_HIGH */
      __IOM uint32_t GPIO23_EDGE_LOW : 1;       /*!< [30..30] GPIO23_EDGE_LOW */
      __IOM uint32_t GPIO23_EDGE_HIGH : 1;      /*!< [31..31] GPIO23_EDGE_HIGH */
    } DORMANT_WAKE_INTE2_b;
  } ;

  union {
    __IOM uint32_t DORMANT_WAKE_INTE3;          /*!< (@ 0x0000016C) Interrupt Enable for dormant_wake */

    struct {
      __IOM uint32_t GPIO24_LEVEL_LOW : 1;      /*!< [0..0] GPIO24_LEVEL_LOW */
      __IOM uint32_t GPIO24_LEVEL_HIGH : 1;     /*!< [1..1] GPIO24_LEVEL_HIGH */
      __IOM uint32_t GPIO24_EDGE_LOW : 1;       /*!< [2..2] GPIO24_EDGE_LOW */
      __IOM uint32_t GPIO24_EDGE_HIGH : 1;      /*!< [3..3] GPIO24_EDGE_HIGH */
      __IOM uint32_t GPIO25_LEVEL_LOW : 1;      /*!< [4..4] GPIO25_LEVEL_LOW */
      __IOM uint32_t GPIO25_LEVEL_HIGH : 1;     /*!< [5..5] GPIO25_LEVEL_HIGH */
      __IOM uint32_t GPIO25_EDGE_LOW : 1;       /*!< [6..6] GPIO25_EDGE_LOW */
      __IOM uint32_t GPIO25_EDGE_HIGH : 1;      /*!< [7..7] GPIO25_EDGE_HIGH */
      __IOM uint32_t GPIO26_LEVEL_LOW : 1;      /*!< [8..8] GPIO26_LEVEL_LOW */
      __IOM uint32_t GPIO26_LEVEL_HIGH : 1;     /*!< [9..9] GPIO26_LEVEL_HIGH */
      __IOM uint32_t GPIO26_EDGE_LOW : 1;       /*!< [10..10] GPIO26_EDGE_LOW */
      __IOM uint32_t GPIO26_EDGE_HIGH : 1;      /*!< [11..11] GPIO26_EDGE_HIGH */
      __IOM uint32_t GPIO27_LEVEL_LOW : 1;      /*!< [12..12] GPIO27_LEVEL_LOW */
      __IOM uint32_t GPIO27_LEVEL_HIGH : 1;     /*!< [13..13] GPIO27_LEVEL_HIGH */
      __IOM uint32_t GPIO27_EDGE_LOW : 1;       /*!< [14..14] GPIO27_EDGE_LOW */
      __IOM uint32_t GPIO27_EDGE_HIGH : 1;      /*!< [15..15] GPIO27_EDGE_HIGH */
      __IOM uint32_t GPIO28_LEVEL_LOW : 1;      /*!< [16..16] GPIO28_LEVEL_LOW */
      __IOM uint32_t GPIO28_LEVEL_HIGH : 1;     /*!< [17..17] GPIO28_LEVEL_HIGH */
      __IOM uint32_t GPIO28_EDGE_LOW : 1;       /*!< [18..18] GPIO28_EDGE_LOW */
      __IOM uint32_t GPIO28_EDGE_HIGH : 1;      /*!< [19..19] GPIO28_EDGE_HIGH */
      __IOM uint32_t GPIO29_LEVEL_LOW : 1;      /*!< [20..20] GPIO29_LEVEL_LOW */
      __IOM uint32_t GPIO29_LEVEL_HIGH : 1;     /*!< [21..21] GPIO29_LEVEL_HIGH */
      __IOM uint32_t GPIO29_EDGE_LOW : 1;       /*!< [22..22] GPIO29_EDGE_LOW */
      __IOM uint32_t GPIO29_EDGE_HIGH : 1;      /*!< [23..23] GPIO29_EDGE_HIGH */
            uint32_t            : 8;
    } DORMANT_WAKE_INTE3_b;
  } ;

  union {
    __IOM uint32_t DORMANT_WAKE_INTF0;          /*!< (@ 0x00000170) Interrupt Force for dormant_wake */

    struct {
      __IOM uint32_t GPIO0_LEVEL_LOW : 1;       /*!< [0..0] GPIO0_LEVEL_LOW */
      __IOM uint32_t GPIO0_LEVEL_HIGH : 1;      /*!< [1..1] GPIO0_LEVEL_HIGH */
      __IOM uint32_t GPIO0_EDGE_LOW : 1;        /*!< [2..2] GPIO0_EDGE_LOW */
      __IOM uint32_t GPIO0_EDGE_HIGH : 1;       /*!< [3..3] GPIO0_EDGE_HIGH */
      __IOM uint32_t GPIO1_LEVEL_LOW : 1;       /*!< [4..4] GPIO1_LEVEL_LOW */
      __IOM uint32_t GPIO1_LEVEL_HIGH : 1;      /*!< [5..5] GPIO1_LEVEL_HIGH */
      __IOM uint32_t GPIO1_EDGE_LOW : 1;        /*!< [6..6] GPIO1_EDGE_LOW */
      __IOM uint32_t GPIO1_EDGE_HIGH : 1;       /*!< [7..7] GPIO1_EDGE_HIGH */
      __IOM uint32_t GPIO2_LEVEL_LOW : 1;       /*!< [8..8] GPIO2_LEVEL_LOW */
      __IOM uint32_t GPIO2_LEVEL_HIGH : 1;      /*!< [9..9] GPIO2_LEVEL_HIGH */
      __IOM uint32_t GPIO2_EDGE_LOW : 1;        /*!< [10..10] GPIO2_EDGE_LOW */
      __IOM uint32_t GPIO2_EDGE_HIGH : 1;       /*!< [11..11] GPIO2_EDGE_HIGH */
      __IOM uint32_t GPIO3_LEVEL_LOW : 1;       /*!< [12..12] GPIO3_LEVEL_LOW */
      __IOM uint32_t GPIO3_LEVEL_HIGH : 1;      /*!< [13..13] GPIO3_LEVEL_HIGH */
      __IOM uint32_t GPIO3_EDGE_LOW : 1;        /*!< [14..14] GPIO3_EDGE_LOW */
      __IOM uint32_t GPIO3_EDGE_HIGH : 1;       /*!< [15..15] GPIO3_EDGE_HIGH */
      __IOM uint32_t GPIO4_LEVEL_LOW : 1;       /*!< [16..16] GPIO4_LEVEL_LOW */
      __IOM uint32_t GPIO4_LEVEL_HIGH : 1;      /*!< [17..17] GPIO4_LEVEL_HIGH */
      __IOM uint32_t GPIO4_EDGE_LOW : 1;        /*!< [18..18] GPIO4_EDGE_LOW */
      __IOM uint32_t GPIO4_EDGE_HIGH : 1;       /*!< [19..19] GPIO4_EDGE_HIGH */
      __IOM uint32_t GPIO5_LEVEL_LOW : 1;       /*!< [20..20] GPIO5_LEVEL_LOW */
      __IOM uint32_t GPIO5_LEVEL_HIGH : 1;      /*!< [21..21] GPIO5_LEVEL_HIGH */
      __IOM uint32_t GPIO5_EDGE_LOW : 1;        /*!< [22..22] GPIO5_EDGE_LOW */
      __IOM uint32_t GPIO5_EDGE_HIGH : 1;       /*!< [23..23] GPIO5_EDGE_HIGH */
      __IOM uint32_t GPIO6_LEVEL_LOW : 1;       /*!< [24..24] GPIO6_LEVEL_LOW */
      __IOM uint32_t GPIO6_LEVEL_HIGH : 1;      /*!< [25..25] GPIO6_LEVEL_HIGH */
      __IOM uint32_t GPIO6_EDGE_LOW : 1;        /*!< [26..26] GPIO6_EDGE_LOW */
      __IOM uint32_t GPIO6_EDGE_HIGH : 1;       /*!< [27..27] GPIO6_EDGE_HIGH */
      __IOM uint32_t GPIO7_LEVEL_LOW : 1;       /*!< [28..28] GPIO7_LEVEL_LOW */
      __IOM uint32_t GPIO7_LEVEL_HIGH : 1;      /*!< [29..29] GPIO7_LEVEL_HIGH */
      __IOM uint32_t GPIO7_EDGE_LOW : 1;        /*!< [30..30] GPIO7_EDGE_LOW */
      __IOM uint32_t GPIO7_EDGE_HIGH : 1;       /*!< [31..31] GPIO7_EDGE_HIGH */
    } DORMANT_WAKE_INTF0_b;
  } ;

  union {
    __IOM uint32_t DORMANT_WAKE_INTF1;          /*!< (@ 0x00000174) Interrupt Force for dormant_wake */

    struct {
      __IOM uint32_t GPIO8_LEVEL_LOW : 1;       /*!< [0..0] GPIO8_LEVEL_LOW */
      __IOM uint32_t GPIO8_LEVEL_HIGH : 1;      /*!< [1..1] GPIO8_LEVEL_HIGH */
      __IOM uint32_t GPIO8_EDGE_LOW : 1;        /*!< [2..2] GPIO8_EDGE_LOW */
      __IOM uint32_t GPIO8_EDGE_HIGH : 1;       /*!< [3..3] GPIO8_EDGE_HIGH */
      __IOM uint32_t GPIO9_LEVEL_LOW : 1;       /*!< [4..4] GPIO9_LEVEL_LOW */
      __IOM uint32_t GPIO9_LEVEL_HIGH : 1;      /*!< [5..5] GPIO9_LEVEL_HIGH */
      __IOM uint32_t GPIO9_EDGE_LOW : 1;        /*!< [6..6] GPIO9_EDGE_LOW */
      __IOM uint32_t GPIO9_EDGE_HIGH : 1;       /*!< [7..7] GPIO9_EDGE_HIGH */
      __IOM uint32_t GPIO10_LEVEL_LOW : 1;      /*!< [8..8] GPIO10_LEVEL_LOW */
      __IOM uint32_t GPIO10_LEVEL_HIGH : 1;     /*!< [9..9] GPIO10_LEVEL_HIGH */
      __IOM uint32_t GPIO10_EDGE_LOW : 1;       /*!< [10..10] GPIO10_EDGE_LOW */
      __IOM uint32_t GPIO10_EDGE_HIGH : 1;      /*!< [11..11] GPIO10_EDGE_HIGH */
      __IOM uint32_t GPIO11_LEVEL_LOW : 1;      /*!< [12..12] GPIO11_LEVEL_LOW */
      __IOM uint32_t GPIO11_LEVEL_HIGH : 1;     /*!< [13..13] GPIO11_LEVEL_HIGH */
      __IOM uint32_t GPIO11_EDGE_LOW : 1;       /*!< [14..14] GPIO11_EDGE_LOW */
      __IOM uint32_t GPIO11_EDGE_HIGH : 1;      /*!< [15..15] GPIO11_EDGE_HIGH */
      __IOM uint32_t GPIO12_LEVEL_LOW : 1;      /*!< [16..16] GPIO12_LEVEL_LOW */
      __IOM uint32_t GPIO12_LEVEL_HIGH : 1;     /*!< [17..17] GPIO12_LEVEL_HIGH */
      __IOM uint32_t GPIO12_EDGE_LOW : 1;       /*!< [18..18] GPIO12_EDGE_LOW */
      __IOM uint32_t GPIO12_EDGE_HIGH : 1;      /*!< [19..19] GPIO12_EDGE_HIGH */
      __IOM uint32_t GPIO13_LEVEL_LOW : 1;      /*!< [20..20] GPIO13_LEVEL_LOW */
      __IOM uint32_t GPIO13_LEVEL_HIGH : 1;     /*!< [21..21] GPIO13_LEVEL_HIGH */
      __IOM uint32_t GPIO13_EDGE_LOW : 1;       /*!< [22..22] GPIO13_EDGE_LOW */
      __IOM uint32_t GPIO13_EDGE_HIGH : 1;      /*!< [23..23] GPIO13_EDGE_HIGH */
      __IOM uint32_t GPIO14_LEVEL_LOW : 1;      /*!< [24..24] GPIO14_LEVEL_LOW */
      __IOM uint32_t GPIO14_LEVEL_HIGH : 1;     /*!< [25..25] GPIO14_LEVEL_HIGH */
      __IOM uint32_t GPIO14_EDGE_LOW : 1;       /*!< [26..26] GPIO14_EDGE_LOW */
      __IOM uint32_t GPIO14_EDGE_HIGH : 1;      /*!< [27..27] GPIO14_EDGE_HIGH */
      __IOM uint32_t GPIO15_LEVEL_LOW : 1;      /*!< [28..28] GPIO15_LEVEL_LOW */
      __IOM uint32_t GPIO15_LEVEL_HIGH : 1;     /*!< [29..29] GPIO15_LEVEL_HIGH */
      __IOM uint32_t GPIO15_EDGE_LOW : 1;       /*!< [30..30] GPIO15_EDGE_LOW */
      __IOM uint32_t GPIO15_EDGE_HIGH : 1;      /*!< [31..31] GPIO15_EDGE_HIGH */
    } DORMANT_WAKE_INTF1_b;
  } ;

  union {
    __IOM uint32_t DORMANT_WAKE_INTF2;          /*!< (@ 0x00000178) Interrupt Force for dormant_wake */

    struct {
      __IOM uint32_t GPIO16_LEVEL_LOW : 1;      /*!< [0..0] GPIO16_LEVEL_LOW */
      __IOM uint32_t GPIO16_LEVEL_HIGH : 1;     /*!< [1..1] GPIO16_LEVEL_HIGH */
      __IOM uint32_t GPIO16_EDGE_LOW : 1;       /*!< [2..2] GPIO16_EDGE_LOW */
      __IOM uint32_t GPIO16_EDGE_HIGH : 1;      /*!< [3..3] GPIO16_EDGE_HIGH */
      __IOM uint32_t GPIO17_LEVEL_LOW : 1;      /*!< [4..4] GPIO17_LEVEL_LOW */
      __IOM uint32_t GPIO17_LEVEL_HIGH : 1;     /*!< [5..5] GPIO17_LEVEL_HIGH */
      __IOM uint32_t GPIO17_EDGE_LOW : 1;       /*!< [6..6] GPIO17_EDGE_LOW */
      __IOM uint32_t GPIO17_EDGE_HIGH : 1;      /*!< [7..7] GPIO17_EDGE_HIGH */
      __IOM uint32_t GPIO18_LEVEL_LOW : 1;      /*!< [8..8] GPIO18_LEVEL_LOW */
      __IOM uint32_t GPIO18_LEVEL_HIGH : 1;     /*!< [9..9] GPIO18_LEVEL_HIGH */
      __IOM uint32_t GPIO18_EDGE_LOW : 1;       /*!< [10..10] GPIO18_EDGE_LOW */
      __IOM uint32_t GPIO18_EDGE_HIGH : 1;      /*!< [11..11] GPIO18_EDGE_HIGH */
      __IOM uint32_t GPIO19_LEVEL_LOW : 1;      /*!< [12..12] GPIO19_LEVEL_LOW */
      __IOM uint32_t GPIO19_LEVEL_HIGH : 1;     /*!< [13..13] GPIO19_LEVEL_HIGH */
      __IOM uint32_t GPIO19_EDGE_LOW : 1;       /*!< [14..14] GPIO19_EDGE_LOW */
      __IOM uint32_t GPIO19_EDGE_HIGH : 1;      /*!< [15..15] GPIO19_EDGE_HIGH */
      __IOM uint32_t GPIO20_LEVEL_LOW : 1;      /*!< [16..16] GPIO20_LEVEL_LOW */
      __IOM uint32_t GPIO20_LEVEL_HIGH : 1;     /*!< [17..17] GPIO20_LEVEL_HIGH */
      __IOM uint32_t GPIO20_EDGE_LOW : 1;       /*!< [18..18] GPIO20_EDGE_LOW */
      __IOM uint32_t GPIO20_EDGE_HIGH : 1;      /*!< [19..19] GPIO20_EDGE_HIGH */
      __IOM uint32_t GPIO21_LEVEL_LOW : 1;      /*!< [20..20] GPIO21_LEVEL_LOW */
      __IOM uint32_t GPIO21_LEVEL_HIGH : 1;     /*!< [21..21] GPIO21_LEVEL_HIGH */
      __IOM uint32_t GPIO21_EDGE_LOW : 1;       /*!< [22..22] GPIO21_EDGE_LOW */
      __IOM uint32_t GPIO21_EDGE_HIGH : 1;      /*!< [23..23] GPIO21_EDGE_HIGH */
      __IOM uint32_t GPIO22_LEVEL_LOW : 1;      /*!< [24..24] GPIO22_LEVEL_LOW */
      __IOM uint32_t GPIO22_LEVEL_HIGH : 1;     /*!< [25..25] GPIO22_LEVEL_HIGH */
      __IOM uint32_t GPIO22_EDGE_LOW : 1;       /*!< [26..26] GPIO22_EDGE_LOW */
      __IOM uint32_t GPIO22_EDGE_HIGH : 1;      /*!< [27..27] GPIO22_EDGE_HIGH */
      __IOM uint32_t GPIO23_LEVEL_LOW : 1;      /*!< [28..28] GPIO23_LEVEL_LOW */
      __IOM uint32_t GPIO23_LEVEL_HIGH : 1;     /*!< [29..29] GPIO23_LEVEL_HIGH */
      __IOM uint32_t GPIO23_EDGE_LOW : 1;       /*!< [30..30] GPIO23_EDGE_LOW */
      __IOM uint32_t GPIO23_EDGE_HIGH : 1;      /*!< [31..31] GPIO23_EDGE_HIGH */
    } DORMANT_WAKE_INTF2_b;
  } ;

  union {
    __IOM uint32_t DORMANT_WAKE_INTF3;          /*!< (@ 0x0000017C) Interrupt Force for dormant_wake */

    struct {
      __IOM uint32_t GPIO24_LEVEL_LOW : 1;      /*!< [0..0] GPIO24_LEVEL_LOW */
      __IOM uint32_t GPIO24_LEVEL_HIGH : 1;     /*!< [1..1] GPIO24_LEVEL_HIGH */
      __IOM uint32_t GPIO24_EDGE_LOW : 1;       /*!< [2..2] GPIO24_EDGE_LOW */
      __IOM uint32_t GPIO24_EDGE_HIGH : 1;      /*!< [3..3] GPIO24_EDGE_HIGH */
      __IOM uint32_t GPIO25_LEVEL_LOW : 1;      /*!< [4..4] GPIO25_LEVEL_LOW */
      __IOM uint32_t GPIO25_LEVEL_HIGH : 1;     /*!< [5..5] GPIO25_LEVEL_HIGH */
      __IOM uint32_t GPIO25_EDGE_LOW : 1;       /*!< [6..6] GPIO25_EDGE_LOW */
      __IOM uint32_t GPIO25_EDGE_HIGH : 1;      /*!< [7..7] GPIO25_EDGE_HIGH */
      __IOM uint32_t GPIO26_LEVEL_LOW : 1;      /*!< [8..8] GPIO26_LEVEL_LOW */
      __IOM uint32_t GPIO26_LEVEL_HIGH : 1;     /*!< [9..9] GPIO26_LEVEL_HIGH */
      __IOM uint32_t GPIO26_EDGE_LOW : 1;       /*!< [10..10] GPIO26_EDGE_LOW */
      __IOM uint32_t GPIO26_EDGE_HIGH : 1;      /*!< [11..11] GPIO26_EDGE_HIGH */
      __IOM uint32_t GPIO27_LEVEL_LOW : 1;      /*!< [12..12] GPIO27_LEVEL_LOW */
      __IOM uint32_t GPIO27_LEVEL_HIGH : 1;     /*!< [13..13] GPIO27_LEVEL_HIGH */
      __IOM uint32_t GPIO27_EDGE_LOW : 1;       /*!< [14..14] GPIO27_EDGE_LOW */
      __IOM uint32_t GPIO27_EDGE_HIGH : 1;      /*!< [15..15] GPIO27_EDGE_HIGH */
      __IOM uint32_t GPIO28_LEVEL_LOW : 1;      /*!< [16..16] GPIO28_LEVEL_LOW */
      __IOM uint32_t GPIO28_LEVEL_HIGH : 1;     /*!< [17..17] GPIO28_LEVEL_HIGH */
      __IOM uint32_t GPIO28_EDGE_LOW : 1;       /*!< [18..18] GPIO28_EDGE_LOW */
      __IOM uint32_t GPIO28_EDGE_HIGH : 1;      /*!< [19..19] GPIO28_EDGE_HIGH */
      __IOM uint32_t GPIO29_LEVEL_LOW : 1;      /*!< [20..20] GPIO29_LEVEL_LOW */
      __IOM uint32_t GPIO29_LEVEL_HIGH : 1;     /*!< [21..21] GPIO29_LEVEL_HIGH */
      __IOM uint32_t GPIO29_EDGE_LOW : 1;       /*!< [22..22] GPIO29_EDGE_LOW */
      __IOM uint32_t GPIO29_EDGE_HIGH : 1;      /*!< [23..23] GPIO29_EDGE_HIGH */
            uint32_t            : 8;
    } DORMANT_WAKE_INTF3_b;
  } ;

  union {
    __IOM uint32_t DORMANT_WAKE_INTS0;          /*!< (@ 0x00000180) Interrupt status after masking & forcing for dormant_wake */

    struct {
      __IM  uint32_t GPIO0_LEVEL_LOW : 1;       /*!< [0..0] GPIO0_LEVEL_LOW */
      __IM  uint32_t GPIO0_LEVEL_HIGH : 1;      /*!< [1..1] GPIO0_LEVEL_HIGH */
      __IM  uint32_t GPIO0_EDGE_LOW : 1;        /*!< [2..2] GPIO0_EDGE_LOW */
      __IM  uint32_t GPIO0_EDGE_HIGH : 1;       /*!< [3..3] GPIO0_EDGE_HIGH */
      __IM  uint32_t GPIO1_LEVEL_LOW : 1;       /*!< [4..4] GPIO1_LEVEL_LOW */
      __IM  uint32_t GPIO1_LEVEL_HIGH : 1;      /*!< [5..5] GPIO1_LEVEL_HIGH */
      __IM  uint32_t GPIO1_EDGE_LOW : 1;        /*!< [6..6] GPIO1_EDGE_LOW */
      __IM  uint32_t GPIO1_EDGE_HIGH : 1;       /*!< [7..7] GPIO1_EDGE_HIGH */
      __IM  uint32_t GPIO2_LEVEL_LOW : 1;       /*!< [8..8] GPIO2_LEVEL_LOW */
      __IM  uint32_t GPIO2_LEVEL_HIGH : 1;      /*!< [9..9] GPIO2_LEVEL_HIGH */
      __IM  uint32_t GPIO2_EDGE_LOW : 1;        /*!< [10..10] GPIO2_EDGE_LOW */
      __IM  uint32_t GPIO2_EDGE_HIGH : 1;       /*!< [11..11] GPIO2_EDGE_HIGH */
      __IM  uint32_t GPIO3_LEVEL_LOW : 1;       /*!< [12..12] GPIO3_LEVEL_LOW */
      __IM  uint32_t GPIO3_LEVEL_HIGH : 1;      /*!< [13..13] GPIO3_LEVEL_HIGH */
      __IM  uint32_t GPIO3_EDGE_LOW : 1;        /*!< [14..14] GPIO3_EDGE_LOW */
      __IM  uint32_t GPIO3_EDGE_HIGH : 1;       /*!< [15..15] GPIO3_EDGE_HIGH */
      __IM  uint32_t GPIO4_LEVEL_LOW : 1;       /*!< [16..16] GPIO4_LEVEL_LOW */
      __IM  uint32_t GPIO4_LEVEL_HIGH : 1;      /*!< [17..17] GPIO4_LEVEL_HIGH */
      __IM  uint32_t GPIO4_EDGE_LOW : 1;        /*!< [18..18] GPIO4_EDGE_LOW */
      __IM  uint32_t GPIO4_EDGE_HIGH : 1;       /*!< [19..19] GPIO4_EDGE_HIGH */
      __IM  uint32_t GPIO5_LEVEL_LOW : 1;       /*!< [20..20] GPIO5_LEVEL_LOW */
      __IM  uint32_t GPIO5_LEVEL_HIGH : 1;      /*!< [21..21] GPIO5_LEVEL_HIGH */
      __IM  uint32_t GPIO5_EDGE_LOW : 1;        /*!< [22..22] GPIO5_EDGE_LOW */
      __IM  uint32_t GPIO5_EDGE_HIGH : 1;       /*!< [23..23] GPIO5_EDGE_HIGH */
      __IM  uint32_t GPIO6_LEVEL_LOW : 1;       /*!< [24..24] GPIO6_LEVEL_LOW */
      __IM  uint32_t GPIO6_LEVEL_HIGH : 1;      /*!< [25..25] GPIO6_LEVEL_HIGH */
      __IM  uint32_t GPIO6_EDGE_LOW : 1;        /*!< [26..26] GPIO6_EDGE_LOW */
      __IM  uint32_t GPIO6_EDGE_HIGH : 1;       /*!< [27..27] GPIO6_EDGE_HIGH */
      __IM  uint32_t GPIO7_LEVEL_LOW : 1;       /*!< [28..28] GPIO7_LEVEL_LOW */
      __IM  uint32_t GPIO7_LEVEL_HIGH : 1;      /*!< [29..29] GPIO7_LEVEL_HIGH */
      __IM  uint32_t GPIO7_EDGE_LOW : 1;        /*!< [30..30] GPIO7_EDGE_LOW */
      __IM  uint32_t GPIO7_EDGE_HIGH : 1;       /*!< [31..31] GPIO7_EDGE_HIGH */
    } DORMANT_WAKE_INTS0_b;
  } ;

  union {
    __IOM uint32_t DORMANT_WAKE_INTS1;          /*!< (@ 0x00000184) Interrupt status after masking & forcing for dormant_wake */

    struct {
      __IM  uint32_t GPIO8_LEVEL_LOW : 1;       /*!< [0..0] GPIO8_LEVEL_LOW */
      __IM  uint32_t GPIO8_LEVEL_HIGH : 1;      /*!< [1..1] GPIO8_LEVEL_HIGH */
      __IM  uint32_t GPIO8_EDGE_LOW : 1;        /*!< [2..2] GPIO8_EDGE_LOW */
      __IM  uint32_t GPIO8_EDGE_HIGH : 1;       /*!< [3..3] GPIO8_EDGE_HIGH */
      __IM  uint32_t GPIO9_LEVEL_LOW : 1;       /*!< [4..4] GPIO9_LEVEL_LOW */
      __IM  uint32_t GPIO9_LEVEL_HIGH : 1;      /*!< [5..5] GPIO9_LEVEL_HIGH */
      __IM  uint32_t GPIO9_EDGE_LOW : 1;        /*!< [6..6] GPIO9_EDGE_LOW */
      __IM  uint32_t GPIO9_EDGE_HIGH : 1;       /*!< [7..7] GPIO9_EDGE_HIGH */
      __IM  uint32_t GPIO10_LEVEL_LOW : 1;      /*!< [8..8] GPIO10_LEVEL_LOW */
      __IM  uint32_t GPIO10_LEVEL_HIGH : 1;     /*!< [9..9] GPIO10_LEVEL_HIGH */
      __IM  uint32_t GPIO10_EDGE_LOW : 1;       /*!< [10..10] GPIO10_EDGE_LOW */
      __IM  uint32_t GPIO10_EDGE_HIGH : 1;      /*!< [11..11] GPIO10_EDGE_HIGH */
      __IM  uint32_t GPIO11_LEVEL_LOW : 1;      /*!< [12..12] GPIO11_LEVEL_LOW */
      __IM  uint32_t GPIO11_LEVEL_HIGH : 1;     /*!< [13..13] GPIO11_LEVEL_HIGH */
      __IM  uint32_t GPIO11_EDGE_LOW : 1;       /*!< [14..14] GPIO11_EDGE_LOW */
      __IM  uint32_t GPIO11_EDGE_HIGH : 1;      /*!< [15..15] GPIO11_EDGE_HIGH */
      __IM  uint32_t GPIO12_LEVEL_LOW : 1;      /*!< [16..16] GPIO12_LEVEL_LOW */
      __IM  uint32_t GPIO12_LEVEL_HIGH : 1;     /*!< [17..17] GPIO12_LEVEL_HIGH */
      __IM  uint32_t GPIO12_EDGE_LOW : 1;       /*!< [18..18] GPIO12_EDGE_LOW */
      __IM  uint32_t GPIO12_EDGE_HIGH : 1;      /*!< [19..19] GPIO12_EDGE_HIGH */
      __IM  uint32_t GPIO13_LEVEL_LOW : 1;      /*!< [20..20] GPIO13_LEVEL_LOW */
      __IM  uint32_t GPIO13_LEVEL_HIGH : 1;     /*!< [21..21] GPIO13_LEVEL_HIGH */
      __IM  uint32_t GPIO13_EDGE_LOW : 1;       /*!< [22..22] GPIO13_EDGE_LOW */
      __IM  uint32_t GPIO13_EDGE_HIGH : 1;      /*!< [23..23] GPIO13_EDGE_HIGH */
      __IM  uint32_t GPIO14_LEVEL_LOW : 1;      /*!< [24..24] GPIO14_LEVEL_LOW */
      __IM  uint32_t GPIO14_LEVEL_HIGH : 1;     /*!< [25..25] GPIO14_LEVEL_HIGH */
      __IM  uint32_t GPIO14_EDGE_LOW : 1;       /*!< [26..26] GPIO14_EDGE_LOW */
      __IM  uint32_t GPIO14_EDGE_HIGH : 1;      /*!< [27..27] GPIO14_EDGE_HIGH */
      __IM  uint32_t GPIO15_LEVEL_LOW : 1;      /*!< [28..28] GPIO15_LEVEL_LOW */
      __IM  uint32_t GPIO15_LEVEL_HIGH : 1;     /*!< [29..29] GPIO15_LEVEL_HIGH */
      __IM  uint32_t GPIO15_EDGE_LOW : 1;       /*!< [30..30] GPIO15_EDGE_LOW */
      __IM  uint32_t GPIO15_EDGE_HIGH : 1;      /*!< [31..31] GPIO15_EDGE_HIGH */
    } DORMANT_WAKE_INTS1_b;
  } ;

  union {
    __IOM uint32_t DORMANT_WAKE_INTS2;          /*!< (@ 0x00000188) Interrupt status after masking & forcing for dormant_wake */

    struct {
      __IM  uint32_t GPIO16_LEVEL_LOW : 1;      /*!< [0..0] GPIO16_LEVEL_LOW */
      __IM  uint32_t GPIO16_LEVEL_HIGH : 1;     /*!< [1..1] GPIO16_LEVEL_HIGH */
      __IM  uint32_t GPIO16_EDGE_LOW : 1;       /*!< [2..2] GPIO16_EDGE_LOW */
      __IM  uint32_t GPIO16_EDGE_HIGH : 1;      /*!< [3..3] GPIO16_EDGE_HIGH */
      __IM  uint32_t GPIO17_LEVEL_LOW : 1;      /*!< [4..4] GPIO17_LEVEL_LOW */
      __IM  uint32_t GPIO17_LEVEL_HIGH : 1;     /*!< [5..5] GPIO17_LEVEL_HIGH */
      __IM  uint32_t GPIO17_EDGE_LOW : 1;       /*!< [6..6] GPIO17_EDGE_LOW */
      __IM  uint32_t GPIO17_EDGE_HIGH : 1;      /*!< [7..7] GPIO17_EDGE_HIGH */
      __IM  uint32_t GPIO18_LEVEL_LOW : 1;      /*!< [8..8] GPIO18_LEVEL_LOW */
      __IM  uint32_t GPIO18_LEVEL_HIGH : 1;     /*!< [9..9] GPIO18_LEVEL_HIGH */
      __IM  uint32_t GPIO18_EDGE_LOW : 1;       /*!< [10..10] GPIO18_EDGE_LOW */
      __IM  uint32_t GPIO18_EDGE_HIGH : 1;      /*!< [11..11] GPIO18_EDGE_HIGH */
      __IM  uint32_t GPIO19_LEVEL_LOW : 1;      /*!< [12..12] GPIO19_LEVEL_LOW */
      __IM  uint32_t GPIO19_LEVEL_HIGH : 1;     /*!< [13..13] GPIO19_LEVEL_HIGH */
      __IM  uint32_t GPIO19_EDGE_LOW : 1;       /*!< [14..14] GPIO19_EDGE_LOW */
      __IM  uint32_t GPIO19_EDGE_HIGH : 1;      /*!< [15..15] GPIO19_EDGE_HIGH */
      __IM  uint32_t GPIO20_LEVEL_LOW : 1;      /*!< [16..16] GPIO20_LEVEL_LOW */
      __IM  uint32_t GPIO20_LEVEL_HIGH : 1;     /*!< [17..17] GPIO20_LEVEL_HIGH */
      __IM  uint32_t GPIO20_EDGE_LOW : 1;       /*!< [18..18] GPIO20_EDGE_LOW */
      __IM  uint32_t GPIO20_EDGE_HIGH : 1;      /*!< [19..19] GPIO20_EDGE_HIGH */
      __IM  uint32_t GPIO21_LEVEL_LOW : 1;      /*!< [20..20] GPIO21_LEVEL_LOW */
      __IM  uint32_t GPIO21_LEVEL_HIGH : 1;     /*!< [21..21] GPIO21_LEVEL_HIGH */
      __IM  uint32_t GPIO21_EDGE_LOW : 1;       /*!< [22..22] GPIO21_EDGE_LOW */
      __IM  uint32_t GPIO21_EDGE_HIGH : 1;      /*!< [23..23] GPIO21_EDGE_HIGH */
      __IM  uint32_t GPIO22_LEVEL_LOW : 1;      /*!< [24..24] GPIO22_LEVEL_LOW */
      __IM  uint32_t GPIO22_LEVEL_HIGH : 1;     /*!< [25..25] GPIO22_LEVEL_HIGH */
      __IM  uint32_t GPIO22_EDGE_LOW : 1;       /*!< [26..26] GPIO22_EDGE_LOW */
      __IM  uint32_t GPIO22_EDGE_HIGH : 1;      /*!< [27..27] GPIO22_EDGE_HIGH */
      __IM  uint32_t GPIO23_LEVEL_LOW : 1;      /*!< [28..28] GPIO23_LEVEL_LOW */
      __IM  uint32_t GPIO23_LEVEL_HIGH : 1;     /*!< [29..29] GPIO23_LEVEL_HIGH */
      __IM  uint32_t GPIO23_EDGE_LOW : 1;       /*!< [30..30] GPIO23_EDGE_LOW */
      __IM  uint32_t GPIO23_EDGE_HIGH : 1;      /*!< [31..31] GPIO23_EDGE_HIGH */
    } DORMANT_WAKE_INTS2_b;
  } ;

  union {
    __IOM uint32_t DORMANT_WAKE_INTS3;          /*!< (@ 0x0000018C) Interrupt status after masking & forcing for dormant_wake */

    struct {
      __IM  uint32_t GPIO24_LEVEL_LOW : 1;      /*!< [0..0] GPIO24_LEVEL_LOW */
      __IM  uint32_t GPIO24_LEVEL_HIGH : 1;     /*!< [1..1] GPIO24_LEVEL_HIGH */
      __IM  uint32_t GPIO24_EDGE_LOW : 1;       /*!< [2..2] GPIO24_EDGE_LOW */
      __IM  uint32_t GPIO24_EDGE_HIGH : 1;      /*!< [3..3] GPIO24_EDGE_HIGH */
      __IM  uint32_t GPIO25_LEVEL_LOW : 1;      /*!< [4..4] GPIO25_LEVEL_LOW */
      __IM  uint32_t GPIO25_LEVEL_HIGH : 1;     /*!< [5..5] GPIO25_LEVEL_HIGH */
      __IM  uint32_t GPIO25_EDGE_LOW : 1;       /*!< [6..6] GPIO25_EDGE_LOW */
      __IM  uint32_t GPIO25_EDGE_HIGH : 1;      /*!< [7..7] GPIO25_EDGE_HIGH */
      __IM  uint32_t GPIO26_LEVEL_LOW : 1;      /*!< [8..8] GPIO26_LEVEL_LOW */
      __IM  uint32_t GPIO26_LEVEL_HIGH : 1;     /*!< [9..9] GPIO26_LEVEL_HIGH */
      __IM  uint32_t GPIO26_EDGE_LOW : 1;       /*!< [10..10] GPIO26_EDGE_LOW */
      __IM  uint32_t GPIO26_EDGE_HIGH : 1;      /*!< [11..11] GPIO26_EDGE_HIGH */
      __IM  uint32_t GPIO27_LEVEL_LOW : 1;      /*!< [12..12] GPIO27_LEVEL_LOW */
      __IM  uint32_t GPIO27_LEVEL_HIGH : 1;     /*!< [13..13] GPIO27_LEVEL_HIGH */
      __IM  uint32_t GPIO27_EDGE_LOW : 1;       /*!< [14..14] GPIO27_EDGE_LOW */
      __IM  uint32_t GPIO27_EDGE_HIGH : 1;      /*!< [15..15] GPIO27_EDGE_HIGH */
      __IM  uint32_t GPIO28_LEVEL_LOW : 1;      /*!< [16..16] GPIO28_LEVEL_LOW */
      __IM  uint32_t GPIO28_LEVEL_HIGH : 1;     /*!< [17..17] GPIO28_LEVEL_HIGH */
      __IM  uint32_t GPIO28_EDGE_LOW : 1;       /*!< [18..18] GPIO28_EDGE_LOW */
      __IM  uint32_t GPIO28_EDGE_HIGH : 1;      /*!< [19..19] GPIO28_EDGE_HIGH */
      __IM  uint32_t GPIO29_LEVEL_LOW : 1;      /*!< [20..20] GPIO29_LEVEL_LOW */
      __IM  uint32_t GPIO29_LEVEL_HIGH : 1;     /*!< [21..21] GPIO29_LEVEL_HIGH */
      __IM  uint32_t GPIO29_EDGE_LOW : 1;       /*!< [22..22] GPIO29_EDGE_LOW */
      __IM  uint32_t GPIO29_EDGE_HIGH : 1;      /*!< [23..23] GPIO29_EDGE_HIGH */
            uint32_t            : 8;
    } DORMANT_WAKE_INTS3_b;
  } ;
} IO_BANK0_Type;                                /*!< Size = 400 (0x190) */



/* =========================================================================================================================== */
/* ================                                          IO_QSPI                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief IO_QSPI (IO_QSPI)
  */

typedef struct {                                /*!< (@ 0x40018000) IO_QSPI Structure */

  union {
    __IOM uint32_t GPIO_QSPI_SCLK_STATUS;       /*!< (@ 0x00000000) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO_QSPI_SCLK_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO_QSPI_SCLK_CTRL;         /*!< (@ 0x00000004) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO_QSPI_SCLK_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO_QSPI_SS_STATUS;         /*!< (@ 0x00000008) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO_QSPI_SS_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO_QSPI_SS_CTRL;           /*!< (@ 0x0000000C) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO_QSPI_SS_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO_QSPI_SD0_STATUS;        /*!< (@ 0x00000010) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO_QSPI_SD0_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO_QSPI_SD0_CTRL;          /*!< (@ 0x00000014) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO_QSPI_SD0_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO_QSPI_SD1_STATUS;        /*!< (@ 0x00000018) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO_QSPI_SD1_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO_QSPI_SD1_CTRL;          /*!< (@ 0x0000001C) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO_QSPI_SD1_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO_QSPI_SD2_STATUS;        /*!< (@ 0x00000020) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO_QSPI_SD2_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO_QSPI_SD2_CTRL;          /*!< (@ 0x00000024) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO_QSPI_SD2_CTRL_b;
  } ;

  union {
    __IOM uint32_t GPIO_QSPI_SD3_STATUS;        /*!< (@ 0x00000028) GPIO status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register override is applied */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register override is applied */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied */
            uint32_t            : 5;
    } GPIO_QSPI_SD3_STATUS_b;
  } ;

  union {
    __IOM uint32_t GPIO_QSPI_SD3_CTRL;          /*!< (@ 0x0000002C) GPIO control including function select and overrides. */

    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table 31 == NULL */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER */
            uint32_t            : 2;
    } GPIO_QSPI_SD3_CTRL_b;
  } ;

  union {
    __IOM uint32_t INTR;                        /*!< (@ 0x00000030) Raw Interrupts */

    struct {
      __IM  uint32_t GPIO_QSPI_SCLK_LEVEL_LOW : 1;/*!< [0..0] GPIO_QSPI_SCLK_LEVEL_LOW */
      __IM  uint32_t GPIO_QSPI_SCLK_LEVEL_HIGH : 1;/*!< [1..1] GPIO_QSPI_SCLK_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_LOW : 1;/*!< [2..2] GPIO_QSPI_SCLK_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_HIGH : 1;/*!< [3..3] GPIO_QSPI_SCLK_EDGE_HIGH */
      __IM  uint32_t GPIO_QSPI_SS_LEVEL_LOW : 1;/*!< [4..4] GPIO_QSPI_SS_LEVEL_LOW */
      __IM  uint32_t GPIO_QSPI_SS_LEVEL_HIGH : 1;/*!< [5..5] GPIO_QSPI_SS_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_LOW : 1; /*!< [6..6] GPIO_QSPI_SS_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_HIGH : 1;/*!< [7..7] GPIO_QSPI_SS_EDGE_HIGH */
      __IM  uint32_t GPIO_QSPI_SD0_LEVEL_LOW : 1;/*!< [8..8] GPIO_QSPI_SD0_LEVEL_LOW */
      __IM  uint32_t GPIO_QSPI_SD0_LEVEL_HIGH : 1;/*!< [9..9] GPIO_QSPI_SD0_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_LOW : 1;/*!< [10..10] GPIO_QSPI_SD0_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_HIGH : 1;/*!< [11..11] GPIO_QSPI_SD0_EDGE_HIGH */
      __IM  uint32_t GPIO_QSPI_SD1_LEVEL_LOW : 1;/*!< [12..12] GPIO_QSPI_SD1_LEVEL_LOW */
      __IM  uint32_t GPIO_QSPI_SD1_LEVEL_HIGH : 1;/*!< [13..13] GPIO_QSPI_SD1_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_LOW : 1;/*!< [14..14] GPIO_QSPI_SD1_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_HIGH : 1;/*!< [15..15] GPIO_QSPI_SD1_EDGE_HIGH */
      __IM  uint32_t GPIO_QSPI_SD2_LEVEL_LOW : 1;/*!< [16..16] GPIO_QSPI_SD2_LEVEL_LOW */
      __IM  uint32_t GPIO_QSPI_SD2_LEVEL_HIGH : 1;/*!< [17..17] GPIO_QSPI_SD2_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_LOW : 1;/*!< [18..18] GPIO_QSPI_SD2_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_HIGH : 1;/*!< [19..19] GPIO_QSPI_SD2_EDGE_HIGH */
      __IM  uint32_t GPIO_QSPI_SD3_LEVEL_LOW : 1;/*!< [20..20] GPIO_QSPI_SD3_LEVEL_LOW */
      __IM  uint32_t GPIO_QSPI_SD3_LEVEL_HIGH : 1;/*!< [21..21] GPIO_QSPI_SD3_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_LOW : 1;/*!< [22..22] GPIO_QSPI_SD3_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_HIGH : 1;/*!< [23..23] GPIO_QSPI_SD3_EDGE_HIGH */
            uint32_t            : 8;
    } INTR_b;
  } ;

  union {
    __IOM uint32_t PROC0_INTE;                  /*!< (@ 0x00000034) Interrupt Enable for proc0 */

    struct {
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_LOW : 1;/*!< [0..0] GPIO_QSPI_SCLK_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_HIGH : 1;/*!< [1..1] GPIO_QSPI_SCLK_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_LOW : 1;/*!< [2..2] GPIO_QSPI_SCLK_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_HIGH : 1;/*!< [3..3] GPIO_QSPI_SCLK_EDGE_HIGH */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_LOW : 1;/*!< [4..4] GPIO_QSPI_SS_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_HIGH : 1;/*!< [5..5] GPIO_QSPI_SS_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_LOW : 1; /*!< [6..6] GPIO_QSPI_SS_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_HIGH : 1;/*!< [7..7] GPIO_QSPI_SS_EDGE_HIGH */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_LOW : 1;/*!< [8..8] GPIO_QSPI_SD0_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_HIGH : 1;/*!< [9..9] GPIO_QSPI_SD0_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_LOW : 1;/*!< [10..10] GPIO_QSPI_SD0_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_HIGH : 1;/*!< [11..11] GPIO_QSPI_SD0_EDGE_HIGH */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_LOW : 1;/*!< [12..12] GPIO_QSPI_SD1_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_HIGH : 1;/*!< [13..13] GPIO_QSPI_SD1_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_LOW : 1;/*!< [14..14] GPIO_QSPI_SD1_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_HIGH : 1;/*!< [15..15] GPIO_QSPI_SD1_EDGE_HIGH */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_LOW : 1;/*!< [16..16] GPIO_QSPI_SD2_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_HIGH : 1;/*!< [17..17] GPIO_QSPI_SD2_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_LOW : 1;/*!< [18..18] GPIO_QSPI_SD2_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_HIGH : 1;/*!< [19..19] GPIO_QSPI_SD2_EDGE_HIGH */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_LOW : 1;/*!< [20..20] GPIO_QSPI_SD3_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_HIGH : 1;/*!< [21..21] GPIO_QSPI_SD3_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_LOW : 1;/*!< [22..22] GPIO_QSPI_SD3_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_HIGH : 1;/*!< [23..23] GPIO_QSPI_SD3_EDGE_HIGH */
            uint32_t            : 8;
    } PROC0_INTE_b;
  } ;

  union {
    __IOM uint32_t PROC0_INTF;                  /*!< (@ 0x00000038) Interrupt Force for proc0 */

    struct {
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_LOW : 1;/*!< [0..0] GPIO_QSPI_SCLK_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_HIGH : 1;/*!< [1..1] GPIO_QSPI_SCLK_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_LOW : 1;/*!< [2..2] GPIO_QSPI_SCLK_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_HIGH : 1;/*!< [3..3] GPIO_QSPI_SCLK_EDGE_HIGH */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_LOW : 1;/*!< [4..4] GPIO_QSPI_SS_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_HIGH : 1;/*!< [5..5] GPIO_QSPI_SS_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_LOW : 1; /*!< [6..6] GPIO_QSPI_SS_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_HIGH : 1;/*!< [7..7] GPIO_QSPI_SS_EDGE_HIGH */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_LOW : 1;/*!< [8..8] GPIO_QSPI_SD0_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_HIGH : 1;/*!< [9..9] GPIO_QSPI_SD0_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_LOW : 1;/*!< [10..10] GPIO_QSPI_SD0_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_HIGH : 1;/*!< [11..11] GPIO_QSPI_SD0_EDGE_HIGH */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_LOW : 1;/*!< [12..12] GPIO_QSPI_SD1_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_HIGH : 1;/*!< [13..13] GPIO_QSPI_SD1_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_LOW : 1;/*!< [14..14] GPIO_QSPI_SD1_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_HIGH : 1;/*!< [15..15] GPIO_QSPI_SD1_EDGE_HIGH */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_LOW : 1;/*!< [16..16] GPIO_QSPI_SD2_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_HIGH : 1;/*!< [17..17] GPIO_QSPI_SD2_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_LOW : 1;/*!< [18..18] GPIO_QSPI_SD2_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_HIGH : 1;/*!< [19..19] GPIO_QSPI_SD2_EDGE_HIGH */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_LOW : 1;/*!< [20..20] GPIO_QSPI_SD3_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_HIGH : 1;/*!< [21..21] GPIO_QSPI_SD3_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_LOW : 1;/*!< [22..22] GPIO_QSPI_SD3_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_HIGH : 1;/*!< [23..23] GPIO_QSPI_SD3_EDGE_HIGH */
            uint32_t            : 8;
    } PROC0_INTF_b;
  } ;

  union {
    __IOM uint32_t PROC0_INTS;                  /*!< (@ 0x0000003C) Interrupt status after masking & forcing for proc0 */

    struct {
      __IM  uint32_t GPIO_QSPI_SCLK_LEVEL_LOW : 1;/*!< [0..0] GPIO_QSPI_SCLK_LEVEL_LOW */
      __IM  uint32_t GPIO_QSPI_SCLK_LEVEL_HIGH : 1;/*!< [1..1] GPIO_QSPI_SCLK_LEVEL_HIGH */
      __IM  uint32_t GPIO_QSPI_SCLK_EDGE_LOW : 1;/*!< [2..2] GPIO_QSPI_SCLK_EDGE_LOW */
      __IM  uint32_t GPIO_QSPI_SCLK_EDGE_HIGH : 1;/*!< [3..3] GPIO_QSPI_SCLK_EDGE_HIGH */
      __IM  uint32_t GPIO_QSPI_SS_LEVEL_LOW : 1;/*!< [4..4] GPIO_QSPI_SS_LEVEL_LOW */
      __IM  uint32_t GPIO_QSPI_SS_LEVEL_HIGH : 1;/*!< [5..5] GPIO_QSPI_SS_LEVEL_HIGH */
      __IM  uint32_t GPIO_QSPI_SS_EDGE_LOW : 1; /*!< [6..6] GPIO_QSPI_SS_EDGE_LOW */
      __IM  uint32_t GPIO_QSPI_SS_EDGE_HIGH : 1;/*!< [7..7] GPIO_QSPI_SS_EDGE_HIGH */
      __IM  uint32_t GPIO_QSPI_SD0_LEVEL_LOW : 1;/*!< [8..8] GPIO_QSPI_SD0_LEVEL_LOW */
      __IM  uint32_t GPIO_QSPI_SD0_LEVEL_HIGH : 1;/*!< [9..9] GPIO_QSPI_SD0_LEVEL_HIGH */
      __IM  uint32_t GPIO_QSPI_SD0_EDGE_LOW : 1;/*!< [10..10] GPIO_QSPI_SD0_EDGE_LOW */
      __IM  uint32_t GPIO_QSPI_SD0_EDGE_HIGH : 1;/*!< [11..11] GPIO_QSPI_SD0_EDGE_HIGH */
      __IM  uint32_t GPIO_QSPI_SD1_LEVEL_LOW : 1;/*!< [12..12] GPIO_QSPI_SD1_LEVEL_LOW */
      __IM  uint32_t GPIO_QSPI_SD1_LEVEL_HIGH : 1;/*!< [13..13] GPIO_QSPI_SD1_LEVEL_HIGH */
      __IM  uint32_t GPIO_QSPI_SD1_EDGE_LOW : 1;/*!< [14..14] GPIO_QSPI_SD1_EDGE_LOW */
      __IM  uint32_t GPIO_QSPI_SD1_EDGE_HIGH : 1;/*!< [15..15] GPIO_QSPI_SD1_EDGE_HIGH */
      __IM  uint32_t GPIO_QSPI_SD2_LEVEL_LOW : 1;/*!< [16..16] GPIO_QSPI_SD2_LEVEL_LOW */
      __IM  uint32_t GPIO_QSPI_SD2_LEVEL_HIGH : 1;/*!< [17..17] GPIO_QSPI_SD2_LEVEL_HIGH */
      __IM  uint32_t GPIO_QSPI_SD2_EDGE_LOW : 1;/*!< [18..18] GPIO_QSPI_SD2_EDGE_LOW */
      __IM  uint32_t GPIO_QSPI_SD2_EDGE_HIGH : 1;/*!< [19..19] GPIO_QSPI_SD2_EDGE_HIGH */
      __IM  uint32_t GPIO_QSPI_SD3_LEVEL_LOW : 1;/*!< [20..20] GPIO_QSPI_SD3_LEVEL_LOW */
      __IM  uint32_t GPIO_QSPI_SD3_LEVEL_HIGH : 1;/*!< [21..21] GPIO_QSPI_SD3_LEVEL_HIGH */
      __IM  uint32_t GPIO_QSPI_SD3_EDGE_LOW : 1;/*!< [22..22] GPIO_QSPI_SD3_EDGE_LOW */
      __IM  uint32_t GPIO_QSPI_SD3_EDGE_HIGH : 1;/*!< [23..23] GPIO_QSPI_SD3_EDGE_HIGH */
            uint32_t            : 8;
    } PROC0_INTS_b;
  } ;

  union {
    __IOM uint32_t PROC1_INTE;                  /*!< (@ 0x00000040) Interrupt Enable for proc1 */

    struct {
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_LOW : 1;/*!< [0..0] GPIO_QSPI_SCLK_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_HIGH : 1;/*!< [1..1] GPIO_QSPI_SCLK_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_LOW : 1;/*!< [2..2] GPIO_QSPI_SCLK_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_HIGH : 1;/*!< [3..3] GPIO_QSPI_SCLK_EDGE_HIGH */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_LOW : 1;/*!< [4..4] GPIO_QSPI_SS_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_HIGH : 1;/*!< [5..5] GPIO_QSPI_SS_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_LOW : 1; /*!< [6..6] GPIO_QSPI_SS_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_HIGH : 1;/*!< [7..7] GPIO_QSPI_SS_EDGE_HIGH */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_LOW : 1;/*!< [8..8] GPIO_QSPI_SD0_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_HIGH : 1;/*!< [9..9] GPIO_QSPI_SD0_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_LOW : 1;/*!< [10..10] GPIO_QSPI_SD0_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_HIGH : 1;/*!< [11..11] GPIO_QSPI_SD0_EDGE_HIGH */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_LOW : 1;/*!< [12..12] GPIO_QSPI_SD1_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_HIGH : 1;/*!< [13..13] GPIO_QSPI_SD1_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_LOW : 1;/*!< [14..14] GPIO_QSPI_SD1_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_HIGH : 1;/*!< [15..15] GPIO_QSPI_SD1_EDGE_HIGH */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_LOW : 1;/*!< [16..16] GPIO_QSPI_SD2_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_HIGH : 1;/*!< [17..17] GPIO_QSPI_SD2_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_LOW : 1;/*!< [18..18] GPIO_QSPI_SD2_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_HIGH : 1;/*!< [19..19] GPIO_QSPI_SD2_EDGE_HIGH */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_LOW : 1;/*!< [20..20] GPIO_QSPI_SD3_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_HIGH : 1;/*!< [21..21] GPIO_QSPI_SD3_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_LOW : 1;/*!< [22..22] GPIO_QSPI_SD3_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_HIGH : 1;/*!< [23..23] GPIO_QSPI_SD3_EDGE_HIGH */
            uint32_t            : 8;
    } PROC1_INTE_b;
  } ;

  union {
    __IOM uint32_t PROC1_INTF;                  /*!< (@ 0x00000044) Interrupt Force for proc1 */

    struct {
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_LOW : 1;/*!< [0..0] GPIO_QSPI_SCLK_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_HIGH : 1;/*!< [1..1] GPIO_QSPI_SCLK_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_LOW : 1;/*!< [2..2] GPIO_QSPI_SCLK_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_HIGH : 1;/*!< [3..3] GPIO_QSPI_SCLK_EDGE_HIGH */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_LOW : 1;/*!< [4..4] GPIO_QSPI_SS_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_HIGH : 1;/*!< [5..5] GPIO_QSPI_SS_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_LOW : 1; /*!< [6..6] GPIO_QSPI_SS_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_HIGH : 1;/*!< [7..7] GPIO_QSPI_SS_EDGE_HIGH */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_LOW : 1;/*!< [8..8] GPIO_QSPI_SD0_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_HIGH : 1;/*!< [9..9] GPIO_QSPI_SD0_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_LOW : 1;/*!< [10..10] GPIO_QSPI_SD0_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_HIGH : 1;/*!< [11..11] GPIO_QSPI_SD0_EDGE_HIGH */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_LOW : 1;/*!< [12..12] GPIO_QSPI_SD1_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_HIGH : 1;/*!< [13..13] GPIO_QSPI_SD1_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_LOW : 1;/*!< [14..14] GPIO_QSPI_SD1_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_HIGH : 1;/*!< [15..15] GPIO_QSPI_SD1_EDGE_HIGH */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_LOW : 1;/*!< [16..16] GPIO_QSPI_SD2_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_HIGH : 1;/*!< [17..17] GPIO_QSPI_SD2_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_LOW : 1;/*!< [18..18] GPIO_QSPI_SD2_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_HIGH : 1;/*!< [19..19] GPIO_QSPI_SD2_EDGE_HIGH */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_LOW : 1;/*!< [20..20] GPIO_QSPI_SD3_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_HIGH : 1;/*!< [21..21] GPIO_QSPI_SD3_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_LOW : 1;/*!< [22..22] GPIO_QSPI_SD3_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_HIGH : 1;/*!< [23..23] GPIO_QSPI_SD3_EDGE_HIGH */
            uint32_t            : 8;
    } PROC1_INTF_b;
  } ;

  union {
    __IOM uint32_t PROC1_INTS;                  /*!< (@ 0x00000048) Interrupt status after masking & forcing for proc1 */

    struct {
      __IM  uint32_t GPIO_QSPI_SCLK_LEVEL_LOW : 1;/*!< [0..0] GPIO_QSPI_SCLK_LEVEL_LOW */
      __IM  uint32_t GPIO_QSPI_SCLK_LEVEL_HIGH : 1;/*!< [1..1] GPIO_QSPI_SCLK_LEVEL_HIGH */
      __IM  uint32_t GPIO_QSPI_SCLK_EDGE_LOW : 1;/*!< [2..2] GPIO_QSPI_SCLK_EDGE_LOW */
      __IM  uint32_t GPIO_QSPI_SCLK_EDGE_HIGH : 1;/*!< [3..3] GPIO_QSPI_SCLK_EDGE_HIGH */
      __IM  uint32_t GPIO_QSPI_SS_LEVEL_LOW : 1;/*!< [4..4] GPIO_QSPI_SS_LEVEL_LOW */
      __IM  uint32_t GPIO_QSPI_SS_LEVEL_HIGH : 1;/*!< [5..5] GPIO_QSPI_SS_LEVEL_HIGH */
      __IM  uint32_t GPIO_QSPI_SS_EDGE_LOW : 1; /*!< [6..6] GPIO_QSPI_SS_EDGE_LOW */
      __IM  uint32_t GPIO_QSPI_SS_EDGE_HIGH : 1;/*!< [7..7] GPIO_QSPI_SS_EDGE_HIGH */
      __IM  uint32_t GPIO_QSPI_SD0_LEVEL_LOW : 1;/*!< [8..8] GPIO_QSPI_SD0_LEVEL_LOW */
      __IM  uint32_t GPIO_QSPI_SD0_LEVEL_HIGH : 1;/*!< [9..9] GPIO_QSPI_SD0_LEVEL_HIGH */
      __IM  uint32_t GPIO_QSPI_SD0_EDGE_LOW : 1;/*!< [10..10] GPIO_QSPI_SD0_EDGE_LOW */
      __IM  uint32_t GPIO_QSPI_SD0_EDGE_HIGH : 1;/*!< [11..11] GPIO_QSPI_SD0_EDGE_HIGH */
      __IM  uint32_t GPIO_QSPI_SD1_LEVEL_LOW : 1;/*!< [12..12] GPIO_QSPI_SD1_LEVEL_LOW */
      __IM  uint32_t GPIO_QSPI_SD1_LEVEL_HIGH : 1;/*!< [13..13] GPIO_QSPI_SD1_LEVEL_HIGH */
      __IM  uint32_t GPIO_QSPI_SD1_EDGE_LOW : 1;/*!< [14..14] GPIO_QSPI_SD1_EDGE_LOW */
      __IM  uint32_t GPIO_QSPI_SD1_EDGE_HIGH : 1;/*!< [15..15] GPIO_QSPI_SD1_EDGE_HIGH */
      __IM  uint32_t GPIO_QSPI_SD2_LEVEL_LOW : 1;/*!< [16..16] GPIO_QSPI_SD2_LEVEL_LOW */
      __IM  uint32_t GPIO_QSPI_SD2_LEVEL_HIGH : 1;/*!< [17..17] GPIO_QSPI_SD2_LEVEL_HIGH */
      __IM  uint32_t GPIO_QSPI_SD2_EDGE_LOW : 1;/*!< [18..18] GPIO_QSPI_SD2_EDGE_LOW */
      __IM  uint32_t GPIO_QSPI_SD2_EDGE_HIGH : 1;/*!< [19..19] GPIO_QSPI_SD2_EDGE_HIGH */
      __IM  uint32_t GPIO_QSPI_SD3_LEVEL_LOW : 1;/*!< [20..20] GPIO_QSPI_SD3_LEVEL_LOW */
      __IM  uint32_t GPIO_QSPI_SD3_LEVEL_HIGH : 1;/*!< [21..21] GPIO_QSPI_SD3_LEVEL_HIGH */
      __IM  uint32_t GPIO_QSPI_SD3_EDGE_LOW : 1;/*!< [22..22] GPIO_QSPI_SD3_EDGE_LOW */
      __IM  uint32_t GPIO_QSPI_SD3_EDGE_HIGH : 1;/*!< [23..23] GPIO_QSPI_SD3_EDGE_HIGH */
            uint32_t            : 8;
    } PROC1_INTS_b;
  } ;

  union {
    __IOM uint32_t DORMANT_WAKE_INTE;           /*!< (@ 0x0000004C) Interrupt Enable for dormant_wake */

    struct {
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_LOW : 1;/*!< [0..0] GPIO_QSPI_SCLK_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_HIGH : 1;/*!< [1..1] GPIO_QSPI_SCLK_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_LOW : 1;/*!< [2..2] GPIO_QSPI_SCLK_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_HIGH : 1;/*!< [3..3] GPIO_QSPI_SCLK_EDGE_HIGH */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_LOW : 1;/*!< [4..4] GPIO_QSPI_SS_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_HIGH : 1;/*!< [5..5] GPIO_QSPI_SS_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_LOW : 1; /*!< [6..6] GPIO_QSPI_SS_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_HIGH : 1;/*!< [7..7] GPIO_QSPI_SS_EDGE_HIGH */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_LOW : 1;/*!< [8..8] GPIO_QSPI_SD0_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_HIGH : 1;/*!< [9..9] GPIO_QSPI_SD0_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_LOW : 1;/*!< [10..10] GPIO_QSPI_SD0_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_HIGH : 1;/*!< [11..11] GPIO_QSPI_SD0_EDGE_HIGH */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_LOW : 1;/*!< [12..12] GPIO_QSPI_SD1_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_HIGH : 1;/*!< [13..13] GPIO_QSPI_SD1_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_LOW : 1;/*!< [14..14] GPIO_QSPI_SD1_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_HIGH : 1;/*!< [15..15] GPIO_QSPI_SD1_EDGE_HIGH */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_LOW : 1;/*!< [16..16] GPIO_QSPI_SD2_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_HIGH : 1;/*!< [17..17] GPIO_QSPI_SD2_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_LOW : 1;/*!< [18..18] GPIO_QSPI_SD2_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_HIGH : 1;/*!< [19..19] GPIO_QSPI_SD2_EDGE_HIGH */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_LOW : 1;/*!< [20..20] GPIO_QSPI_SD3_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_HIGH : 1;/*!< [21..21] GPIO_QSPI_SD3_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_LOW : 1;/*!< [22..22] GPIO_QSPI_SD3_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_HIGH : 1;/*!< [23..23] GPIO_QSPI_SD3_EDGE_HIGH */
            uint32_t            : 8;
    } DORMANT_WAKE_INTE_b;
  } ;

  union {
    __IOM uint32_t DORMANT_WAKE_INTF;           /*!< (@ 0x00000050) Interrupt Force for dormant_wake */

    struct {
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_LOW : 1;/*!< [0..0] GPIO_QSPI_SCLK_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_HIGH : 1;/*!< [1..1] GPIO_QSPI_SCLK_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_LOW : 1;/*!< [2..2] GPIO_QSPI_SCLK_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_HIGH : 1;/*!< [3..3] GPIO_QSPI_SCLK_EDGE_HIGH */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_LOW : 1;/*!< [4..4] GPIO_QSPI_SS_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_HIGH : 1;/*!< [5..5] GPIO_QSPI_SS_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_LOW : 1; /*!< [6..6] GPIO_QSPI_SS_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_HIGH : 1;/*!< [7..7] GPIO_QSPI_SS_EDGE_HIGH */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_LOW : 1;/*!< [8..8] GPIO_QSPI_SD0_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_HIGH : 1;/*!< [9..9] GPIO_QSPI_SD0_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_LOW : 1;/*!< [10..10] GPIO_QSPI_SD0_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_HIGH : 1;/*!< [11..11] GPIO_QSPI_SD0_EDGE_HIGH */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_LOW : 1;/*!< [12..12] GPIO_QSPI_SD1_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_HIGH : 1;/*!< [13..13] GPIO_QSPI_SD1_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_LOW : 1;/*!< [14..14] GPIO_QSPI_SD1_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_HIGH : 1;/*!< [15..15] GPIO_QSPI_SD1_EDGE_HIGH */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_LOW : 1;/*!< [16..16] GPIO_QSPI_SD2_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_HIGH : 1;/*!< [17..17] GPIO_QSPI_SD2_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_LOW : 1;/*!< [18..18] GPIO_QSPI_SD2_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_HIGH : 1;/*!< [19..19] GPIO_QSPI_SD2_EDGE_HIGH */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_LOW : 1;/*!< [20..20] GPIO_QSPI_SD3_LEVEL_LOW */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_HIGH : 1;/*!< [21..21] GPIO_QSPI_SD3_LEVEL_HIGH */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_LOW : 1;/*!< [22..22] GPIO_QSPI_SD3_EDGE_LOW */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_HIGH : 1;/*!< [23..23] GPIO_QSPI_SD3_EDGE_HIGH */
            uint32_t            : 8;
    } DORMANT_WAKE_INTF_b;
  } ;

  union {
    __IOM uint32_t DORMANT_WAKE_INTS;           /*!< (@ 0x00000054) Interrupt status after masking & forcing for dormant_wake */

    struct {
      __IM  uint32_t GPIO_QSPI_SCLK_LEVEL_LOW : 1;/*!< [0..0] GPIO_QSPI_SCLK_LEVEL_LOW */
      __IM  uint32_t GPIO_QSPI_SCLK_LEVEL_HIGH : 1;/*!< [1..1] GPIO_QSPI_SCLK_LEVEL_HIGH */
      __IM  uint32_t GPIO_QSPI_SCLK_EDGE_LOW : 1;/*!< [2..2] GPIO_QSPI_SCLK_EDGE_LOW */
      __IM  uint32_t GPIO_QSPI_SCLK_EDGE_HIGH : 1;/*!< [3..3] GPIO_QSPI_SCLK_EDGE_HIGH */
      __IM  uint32_t GPIO_QSPI_SS_LEVEL_LOW : 1;/*!< [4..4] GPIO_QSPI_SS_LEVEL_LOW */
      __IM  uint32_t GPIO_QSPI_SS_LEVEL_HIGH : 1;/*!< [5..5] GPIO_QSPI_SS_LEVEL_HIGH */
      __IM  uint32_t GPIO_QSPI_SS_EDGE_LOW : 1; /*!< [6..6] GPIO_QSPI_SS_EDGE_LOW */
      __IM  uint32_t GPIO_QSPI_SS_EDGE_HIGH : 1;/*!< [7..7] GPIO_QSPI_SS_EDGE_HIGH */
      __IM  uint32_t GPIO_QSPI_SD0_LEVEL_LOW : 1;/*!< [8..8] GPIO_QSPI_SD0_LEVEL_LOW */
      __IM  uint32_t GPIO_QSPI_SD0_LEVEL_HIGH : 1;/*!< [9..9] GPIO_QSPI_SD0_LEVEL_HIGH */
      __IM  uint32_t GPIO_QSPI_SD0_EDGE_LOW : 1;/*!< [10..10] GPIO_QSPI_SD0_EDGE_LOW */
      __IM  uint32_t GPIO_QSPI_SD0_EDGE_HIGH : 1;/*!< [11..11] GPIO_QSPI_SD0_EDGE_HIGH */
      __IM  uint32_t GPIO_QSPI_SD1_LEVEL_LOW : 1;/*!< [12..12] GPIO_QSPI_SD1_LEVEL_LOW */
      __IM  uint32_t GPIO_QSPI_SD1_LEVEL_HIGH : 1;/*!< [13..13] GPIO_QSPI_SD1_LEVEL_HIGH */
      __IM  uint32_t GPIO_QSPI_SD1_EDGE_LOW : 1;/*!< [14..14] GPIO_QSPI_SD1_EDGE_LOW */
      __IM  uint32_t GPIO_QSPI_SD1_EDGE_HIGH : 1;/*!< [15..15] GPIO_QSPI_SD1_EDGE_HIGH */
      __IM  uint32_t GPIO_QSPI_SD2_LEVEL_LOW : 1;/*!< [16..16] GPIO_QSPI_SD2_LEVEL_LOW */
      __IM  uint32_t GPIO_QSPI_SD2_LEVEL_HIGH : 1;/*!< [17..17] GPIO_QSPI_SD2_LEVEL_HIGH */
      __IM  uint32_t GPIO_QSPI_SD2_EDGE_LOW : 1;/*!< [18..18] GPIO_QSPI_SD2_EDGE_LOW */
      __IM  uint32_t GPIO_QSPI_SD2_EDGE_HIGH : 1;/*!< [19..19] GPIO_QSPI_SD2_EDGE_HIGH */
      __IM  uint32_t GPIO_QSPI_SD3_LEVEL_LOW : 1;/*!< [20..20] GPIO_QSPI_SD3_LEVEL_LOW */
      __IM  uint32_t GPIO_QSPI_SD3_LEVEL_HIGH : 1;/*!< [21..21] GPIO_QSPI_SD3_LEVEL_HIGH */
      __IM  uint32_t GPIO_QSPI_SD3_EDGE_LOW : 1;/*!< [22..22] GPIO_QSPI_SD3_EDGE_LOW */
      __IM  uint32_t GPIO_QSPI_SD3_EDGE_HIGH : 1;/*!< [23..23] GPIO_QSPI_SD3_EDGE_HIGH */
            uint32_t            : 8;
    } DORMANT_WAKE_INTS_b;
  } ;
} IO_QSPI_Type;                                 /*!< Size = 88 (0x58) */



/* =========================================================================================================================== */
/* ================                                        PADS_BANK0                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief PADS_BANK0 (PADS_BANK0)
  */

typedef struct {                                /*!< (@ 0x4001C000) PADS_BANK0 Structure */

  union {
    __IOM uint32_t VOLTAGE_SELECT;              /*!< (@ 0x00000000) Voltage select. Per bank control */

    struct {
      __IOM uint32_t VOLTAGE_SELECT : 1;        /*!< [0..0] VOLTAGE_SELECT */
            uint32_t            : 31;
    } VOLTAGE_SELECT_b;
  } ;

  union {
    __IOM uint32_t GPIO0;                       /*!< (@ 0x00000004) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO0_b;
  } ;

  union {
    __IOM uint32_t GPIO1;                       /*!< (@ 0x00000008) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO1_b;
  } ;

  union {
    __IOM uint32_t GPIO2;                       /*!< (@ 0x0000000C) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO2_b;
  } ;

  union {
    __IOM uint32_t GPIO3;                       /*!< (@ 0x00000010) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO3_b;
  } ;

  union {
    __IOM uint32_t GPIO4;                       /*!< (@ 0x00000014) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO4_b;
  } ;

  union {
    __IOM uint32_t GPIO5;                       /*!< (@ 0x00000018) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO5_b;
  } ;

  union {
    __IOM uint32_t GPIO6;                       /*!< (@ 0x0000001C) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO6_b;
  } ;

  union {
    __IOM uint32_t GPIO7;                       /*!< (@ 0x00000020) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO7_b;
  } ;

  union {
    __IOM uint32_t GPIO8;                       /*!< (@ 0x00000024) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO8_b;
  } ;

  union {
    __IOM uint32_t GPIO9;                       /*!< (@ 0x00000028) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO9_b;
  } ;

  union {
    __IOM uint32_t GPIO10;                      /*!< (@ 0x0000002C) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO10_b;
  } ;

  union {
    __IOM uint32_t GPIO11;                      /*!< (@ 0x00000030) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO11_b;
  } ;

  union {
    __IOM uint32_t GPIO12;                      /*!< (@ 0x00000034) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO12_b;
  } ;

  union {
    __IOM uint32_t GPIO13;                      /*!< (@ 0x00000038) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO13_b;
  } ;

  union {
    __IOM uint32_t GPIO14;                      /*!< (@ 0x0000003C) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO14_b;
  } ;

  union {
    __IOM uint32_t GPIO15;                      /*!< (@ 0x00000040) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO15_b;
  } ;

  union {
    __IOM uint32_t GPIO16;                      /*!< (@ 0x00000044) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO16_b;
  } ;

  union {
    __IOM uint32_t GPIO17;                      /*!< (@ 0x00000048) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO17_b;
  } ;

  union {
    __IOM uint32_t GPIO18;                      /*!< (@ 0x0000004C) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO18_b;
  } ;

  union {
    __IOM uint32_t GPIO19;                      /*!< (@ 0x00000050) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO19_b;
  } ;

  union {
    __IOM uint32_t GPIO20;                      /*!< (@ 0x00000054) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO20_b;
  } ;

  union {
    __IOM uint32_t GPIO21;                      /*!< (@ 0x00000058) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO21_b;
  } ;

  union {
    __IOM uint32_t GPIO22;                      /*!< (@ 0x0000005C) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO22_b;
  } ;

  union {
    __IOM uint32_t GPIO23;                      /*!< (@ 0x00000060) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO23_b;
  } ;

  union {
    __IOM uint32_t GPIO24;                      /*!< (@ 0x00000064) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO24_b;
  } ;

  union {
    __IOM uint32_t GPIO25;                      /*!< (@ 0x00000068) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO25_b;
  } ;

  union {
    __IOM uint32_t GPIO26;                      /*!< (@ 0x0000006C) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO26_b;
  } ;

  union {
    __IOM uint32_t GPIO27;                      /*!< (@ 0x00000070) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO27_b;
  } ;

  union {
    __IOM uint32_t GPIO28;                      /*!< (@ 0x00000074) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO28_b;
  } ;

  union {
    __IOM uint32_t GPIO29;                      /*!< (@ 0x00000078) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO29_b;
  } ;

  union {
    __IOM uint32_t SWCLK;                       /*!< (@ 0x0000007C) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } SWCLK_b;
  } ;

  union {
    __IOM uint32_t SWD;                         /*!< (@ 0x00000080) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } SWD_b;
  } ;
} PADS_BANK0_Type;                              /*!< Size = 132 (0x84) */



/* =========================================================================================================================== */
/* ================                                         PADS_QSPI                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief PADS_QSPI (PADS_QSPI)
  */

typedef struct {                                /*!< (@ 0x40020000) PADS_QSPI Structure */

  union {
    __IOM uint32_t VOLTAGE_SELECT;              /*!< (@ 0x00000000) Voltage select. Per bank control */

    struct {
      __IOM uint32_t VOLTAGE_SELECT : 1;        /*!< [0..0] VOLTAGE_SELECT */
            uint32_t            : 31;
    } VOLTAGE_SELECT_b;
  } ;

  union {
    __IOM uint32_t GPIO_QSPI_SCLK;              /*!< (@ 0x00000004) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO_QSPI_SCLK_b;
  } ;

  union {
    __IOM uint32_t GPIO_QSPI_SD0;               /*!< (@ 0x00000008) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO_QSPI_SD0_b;
  } ;

  union {
    __IOM uint32_t GPIO_QSPI_SD1;               /*!< (@ 0x0000000C) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO_QSPI_SD1_b;
  } ;

  union {
    __IOM uint32_t GPIO_QSPI_SD2;               /*!< (@ 0x00000010) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO_QSPI_SD2_b;
  } ;

  union {
    __IOM uint32_t GPIO_QSPI_SD3;               /*!< (@ 0x00000014) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO_QSPI_SD3_b;
  } ;

  union {
    __IOM uint32_t GPIO_QSPI_SS;                /*!< (@ 0x00000018) Pad control register */

    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength. */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from peripherals */
            uint32_t            : 24;
    } GPIO_QSPI_SS_b;
  } ;
} PADS_QSPI_Type;                               /*!< Size = 28 (0x1c) */



/* =========================================================================================================================== */
/* ================                                           XOSC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Controls the crystal oscillator (XOSC)
  */

typedef struct {                                /*!< (@ 0x40024000) XOSC Structure */

  union {
    __IOM uint32_t CTRL;                        /*!< (@ 0x00000000) Crystal Oscillator Control */

    struct {
      __IOM uint32_t FREQ_RANGE : 12;           /*!< [11..0] Frequency range. This resets to 0xAA0 and cannot be changed. */
      __IOM uint32_t ENABLE     : 12;           /*!< [23..12] On power-up this field is initialised to DISABLE and the chip runs from the ROSC. If the chip has subsequently been programmed to run from the XOSC then setting this field to DISABLE may lock-up the chip. If this is a concern then run the clk_ref from the ROSC and enable the clk_sys RESUS feature. The 12-bit code is intended to give some protection against accidental writes. An invalid setting will enable the oscillator. */
            uint32_t            : 8;
    } CTRL_b;
  } ;

  union {
    __IOM uint32_t STATUS;                      /*!< (@ 0x00000004) Crystal Oscillator Status */

    struct {
      __IM  uint32_t FREQ_RANGE : 2;            /*!< [1..0] The current frequency range setting, always reads 0 */
            uint32_t            : 10;
      __IM  uint32_t ENABLED    : 1;            /*!< [12..12] Oscillator is enabled but not necessarily running and stable, resets to 0 */
            uint32_t            : 11;
      __IOM uint32_t BADWRITE   : 1;            /*!< [24..24] An invalid value has been written to CTRL_ENABLE or CTRL_FREQ_RANGE or DORMANT */
            uint32_t            : 6;
      __IM  uint32_t STABLE     : 1;            /*!< [31..31] Oscillator is running and stable */
    } STATUS_b;
  } ;
  __IOM uint32_t  DORMANT;                      /*!< (@ 0x00000008) Crystal Oscillator pause control This is used to save power by pausing the XOSC On power-up this field is initialised to WAKE An invalid write will also select WAKE WARNING: stop the PLLs before selecting dormant mode WARNING: setup the irq before selecting dormant mode */

  union {
    __IOM uint32_t STARTUP;                     /*!< (@ 0x0000000C) Controls the startup delay */

    struct {
      __IOM uint32_t DELAY      : 14;           /*!< [13..0] in multiples of 256*xtal_period. The reset value of 0xc4 corresponds to approx 50 000 cycles. */
            uint32_t            : 6;
      __IOM uint32_t X4         : 1;            /*!< [20..20] Multiplies the startup_delay by 4. This is of little value to the user given that the delay can be programmed directly. */
            uint32_t            : 11;
    } STARTUP_b;
  } ;
  __IM  uint32_t  RESERVED[3];

  union {
    __IOM uint32_t COUNT;                       /*!< (@ 0x0000001C) A down counter running at the xosc frequency which counts to zero and stops. To start the counter write a non-zero value. Can be used for short software pauses when setting up time sensitive hardware. */

    struct {
      __IOM uint32_t COUNT      : 8;            /*!< [7..0] COUNT */
            uint32_t            : 24;
    } COUNT_b;
  } ;
} XOSC_Type;                                    /*!< Size = 32 (0x20) */



/* =========================================================================================================================== */
/* ================                                          PLL_SYS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief PLL_SYS (PLL_SYS)
  */

typedef struct {                                /*!< (@ 0x40028000) PLL_SYS Structure */

  union {
    __IOM uint32_t CS;                          /*!< (@ 0x00000000) Control and Status GENERAL CONSTRAINTS: Reference clock frequency min=5MHz, max=800MHz Feedback divider min=16, max=320 VCO frequency min=400MHz, max=1600MHz */

    struct {
      __IOM uint32_t REFDIV     : 6;            /*!< [5..0] Divides the PLL input reference clock. Behaviour is undefined for div=0. PLL output will be unpredictable during refdiv changes, wait for lock=1 before using it. */
            uint32_t            : 2;
      __IOM uint32_t BYPASS     : 1;            /*!< [8..8] Passes the reference clock to the output instead of the divided VCO. The VCO continues to run so the user can switch between the reference clock and the divided VCO but the output will glitch when doing so. */
            uint32_t            : 22;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] PLL is locked */
    } CS_b;
  } ;

  union {
    __IOM uint32_t PWR;                         /*!< (@ 0x00000004) Controls the PLL power modes. */

    struct {
      __IOM uint32_t PD         : 1;            /*!< [0..0] PLL powerdown To save power set high when PLL output not required. */
            uint32_t            : 1;
      __IOM uint32_t DSMPD      : 1;            /*!< [2..2] PLL DSM powerdown Nothing is achieved by setting this low. */
      __IOM uint32_t POSTDIVPD  : 1;            /*!< [3..3] PLL post divider powerdown To save power set high when PLL output not required or bypass=1. */
            uint32_t            : 1;
      __IOM uint32_t VCOPD      : 1;            /*!< [5..5] PLL VCO powerdown To save power set high when PLL output not required or bypass=1. */
            uint32_t            : 26;
    } PWR_b;
  } ;

  union {
    __IOM uint32_t FBDIV_INT;                   /*!< (@ 0x00000008) Feedback divisor (note: this PLL does not support fractional division) */

    struct {
      __IOM uint32_t FBDIV_INT  : 12;           /*!< [11..0] see ctrl reg description for constraints */
            uint32_t            : 20;
    } FBDIV_INT_b;
  } ;

  union {
    __IOM uint32_t PRIM;                        /*!< (@ 0x0000000C) Controls the PLL post dividers for the primary output (note: this PLL does not have a secondary output) the primary output is driven from VCO divided by postdiv1*postdiv2 */

    struct {
            uint32_t            : 12;
      __IOM uint32_t POSTDIV2   : 3;            /*!< [14..12] divide by 1-7 */
            uint32_t            : 1;
      __IOM uint32_t POSTDIV1   : 3;            /*!< [18..16] divide by 1-7 */
            uint32_t            : 13;
    } PRIM_b;
  } ;
} PLL_SYS_Type;                                 /*!< Size = 16 (0x10) */



/* =========================================================================================================================== */
/* ================                                          BUSCTRL                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Register block for busfabric control signals and performance counters (BUSCTRL)
  */

typedef struct {                                /*!< (@ 0x40030000) BUSCTRL Structure */

  union {
    __IOM uint32_t BUS_PRIORITY;                /*!< (@ 0x00000000) Set the priority of each master for bus arbitration. */

    struct {
      __IOM uint32_t PROC0      : 1;            /*!< [0..0] 0 - low priority, 1 - high priority */
            uint32_t            : 3;
      __IOM uint32_t PROC1      : 1;            /*!< [4..4] 0 - low priority, 1 - high priority */
            uint32_t            : 3;
      __IOM uint32_t DMA_R      : 1;            /*!< [8..8] 0 - low priority, 1 - high priority */
            uint32_t            : 3;
      __IOM uint32_t DMA_W      : 1;            /*!< [12..12] 0 - low priority, 1 - high priority */
            uint32_t            : 19;
    } BUS_PRIORITY_b;
  } ;

  union {
    __IOM uint32_t BUS_PRIORITY_ACK;            /*!< (@ 0x00000004) Bus priority acknowledge */

    struct {
      __IM  uint32_t BUS_PRIORITY_ACK : 1;      /*!< [0..0] Goes to 1 once all arbiters have registered the new global priority levels. Arbiters update their local priority when servicing a new nonsequential access. In normal circumstances this will happen almost immediately. */
            uint32_t            : 31;
    } BUS_PRIORITY_ACK_b;
  } ;

  union {
    __IOM uint32_t PERFCTR0;                    /*!< (@ 0x00000008) Bus fabric performance counter 0 */

    struct {
      __IOM uint32_t PERFCTR0   : 24;           /*!< [23..0] Busfabric saturating performance counter 0 Count some event signal from the busfabric arbiters. Write any value to clear. Select an event to count using PERFSEL0 */
            uint32_t            : 8;
    } PERFCTR0_b;
  } ;

  union {
    __IOM uint32_t PERFSEL0;                    /*!< (@ 0x0000000C) Bus fabric performance event select for PERFCTR0 */

    struct {
      __IOM uint32_t PERFSEL0   : 5;            /*!< [4..0] Select an event for PERFCTR0. Count either contested accesses, or all accesses, on a downstream port of the main crossbar. */
            uint32_t            : 27;
    } PERFSEL0_b;
  } ;

  union {
    __IOM uint32_t PERFCTR1;                    /*!< (@ 0x00000010) Bus fabric performance counter 1 */

    struct {
      __IOM uint32_t PERFCTR1   : 24;           /*!< [23..0] Busfabric saturating performance counter 1 Count some event signal from the busfabric arbiters. Write any value to clear. Select an event to count using PERFSEL1 */
            uint32_t            : 8;
    } PERFCTR1_b;
  } ;

  union {
    __IOM uint32_t PERFSEL1;                    /*!< (@ 0x00000014) Bus fabric performance event select for PERFCTR1 */

    struct {
      __IOM uint32_t PERFSEL1   : 5;            /*!< [4..0] Select an event for PERFCTR1. Count either contested accesses, or all accesses, on a downstream port of the main crossbar. */
            uint32_t            : 27;
    } PERFSEL1_b;
  } ;

  union {
    __IOM uint32_t PERFCTR2;                    /*!< (@ 0x00000018) Bus fabric performance counter 2 */

    struct {
      __IOM uint32_t PERFCTR2   : 24;           /*!< [23..0] Busfabric saturating performance counter 2 Count some event signal from the busfabric arbiters. Write any value to clear. Select an event to count using PERFSEL2 */
            uint32_t            : 8;
    } PERFCTR2_b;
  } ;

  union {
    __IOM uint32_t PERFSEL2;                    /*!< (@ 0x0000001C) Bus fabric performance event select for PERFCTR2 */

    struct {
      __IOM uint32_t PERFSEL2   : 5;            /*!< [4..0] Select an event for PERFCTR2. Count either contested accesses, or all accesses, on a downstream port of the main crossbar. */
            uint32_t            : 27;
    } PERFSEL2_b;
  } ;

  union {
    __IOM uint32_t PERFCTR3;                    /*!< (@ 0x00000020) Bus fabric performance counter 3 */

    struct {
      __IOM uint32_t PERFCTR3   : 24;           /*!< [23..0] Busfabric saturating performance counter 3 Count some event signal from the busfabric arbiters. Write any value to clear. Select an event to count using PERFSEL3 */
            uint32_t            : 8;
    } PERFCTR3_b;
  } ;

  union {
    __IOM uint32_t PERFSEL3;                    /*!< (@ 0x00000024) Bus fabric performance event select for PERFCTR3 */

    struct {
      __IOM uint32_t PERFSEL3   : 5;            /*!< [4..0] Select an event for PERFCTR3. Count either contested accesses, or all accesses, on a downstream port of the main crossbar. */
            uint32_t            : 27;
    } PERFSEL3_b;
  } ;
} BUSCTRL_Type;                                 /*!< Size = 40 (0x28) */



/* =========================================================================================================================== */
/* ================                                           UART0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief UART0 (UART0)
  */

typedef struct {                                /*!< (@ 0x40034000) UART0 Structure */

  union {
    __IOM uint32_t UARTDR;                      /*!< (@ 0x00000000) Data Register, UARTDR */

    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] Receive (read) data character. Transmit (write) data character. */
      __IM  uint32_t FE         : 1;            /*!< [8..8] Framing error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1). In FIFO mode, this error is associated with the character at the top of the FIFO. */
      __IM  uint32_t PE         : 1;            /*!< [9..9] Parity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H. In FIFO mode, this error is associated with the character at the top of the FIFO. */
      __IM  uint32_t BE         : 1;            /*!< [10..10] Break error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity and stop bits). In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state), and the next valid start bit is received. */
      __IM  uint32_t OE         : 1;            /*!< [11..11] Overrun error. This bit is set to 1 if data is received and the receive FIFO is already full. This is cleared to 0 once there is an empty space in the FIFO and a new character can be written to it. */
            uint32_t            : 20;
    } UARTDR_b;
  } ;

  union {
    __IOM uint32_t UARTRSR;                     /*!< (@ 0x00000004) Receive Status Register/Error Clear Register, UARTRSR/UARTECR */

    struct {
      __IOM uint32_t FE         : 1;            /*!< [0..0] Framing error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1). This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO. */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Parity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H. This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO. */
      __IOM uint32_t BE         : 1;            /*!< [2..2] Break error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity, and stop bits). This bit is cleared to 0 after a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state) */
      __IOM uint32_t OE         : 1;            /*!< [3..3] Overrun error. This bit is set to 1 if data is received and the FIFO is already full. This bit is cleared to 0 by a write to UARTECR. The FIFO contents remain valid because no more data is written when the FIFO is full, only the contents of the shift register are overwritten. The CPU must now read the data, to empty the FIFO. */
            uint32_t            : 28;
    } UARTRSR_b;
  } ;
  __IM  uint32_t  RESERVED[4];

  union {
    __IOM uint32_t UARTFR;                      /*!< (@ 0x00000018) Flag Register, UARTFR */

    struct {
      __IM  uint32_t CTS        : 1;            /*!< [0..0] Clear to send. This bit is the complement of the UART clear to send, nUARTCTS, modem status input. That is, the bit is 1 when nUARTCTS is LOW. */
      __IM  uint32_t DSR        : 1;            /*!< [1..1] Data set ready. This bit is the complement of the UART data set ready, nUARTDSR, modem status input. That is, the bit is 1 when nUARTDSR is LOW. */
      __IM  uint32_t DCD        : 1;            /*!< [2..2] Data carrier detect. This bit is the complement of the UART data carrier detect, nUARTDCD, modem status input. That is, the bit is 1 when nUARTDCD is LOW. */
      __IM  uint32_t BUSY       : 1;            /*!< [3..3] UART busy. If this bit is set to 1, the UART is busy transmitting data. This bit remains set until the complete byte, including all the stop bits, has been sent from the shift register. This bit is set as soon as the transmit FIFO becomes non-empty, regardless of whether the UART is enabled or not. */
      __IM  uint32_t RXFE       : 1;            /*!< [4..4] Receive FIFO empty. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the receive holding register is empty. If the FIFO is enabled, the RXFE bit is set when the receive FIFO is empty. */
      __IM  uint32_t TXFF       : 1;            /*!< [5..5] Transmit FIFO full. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the transmit holding register is full. If the FIFO is enabled, the TXFF bit is set when the transmit FIFO is full. */
      __IM  uint32_t RXFF       : 1;            /*!< [6..6] Receive FIFO full. The meaning of this bit depends on the state of the FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is set when the receive holding register is full. If the FIFO is enabled, the RXFF bit is set when the receive FIFO is full. */
      __IM  uint32_t TXFE       : 1;            /*!< [7..7] Transmit FIFO empty. The meaning of this bit depends on the state of the FEN bit in the Line Control Register, UARTLCR_H. If the FIFO is disabled, this bit is set when the transmit holding register is empty. If the FIFO is enabled, the TXFE bit is set when the transmit FIFO is empty. This bit does not indicate if there is data in the transmit shift register. */
      __IM  uint32_t RI         : 1;            /*!< [8..8] Ring indicator. This bit is the complement of the UART ring indicator, nUARTRI, modem status input. That is, the bit is 1 when nUARTRI is LOW. */
            uint32_t            : 23;
    } UARTFR_b;
  } ;
  __IM  uint32_t  RESERVED1;

  union {
    __IOM uint32_t UARTILPR;                    /*!< (@ 0x00000020) IrDA Low-Power Counter Register, UARTILPR */

    struct {
      __IOM uint32_t ILPDVSR    : 8;            /*!< [7..0] 8-bit low-power divisor value. These bits are cleared to 0 at reset. */
            uint32_t            : 24;
    } UARTILPR_b;
  } ;

  union {
    __IOM uint32_t UARTIBRD;                    /*!< (@ 0x00000024) Integer Baud Rate Register, UARTIBRD */

    struct {
      __IOM uint32_t BAUD_DIVINT : 16;          /*!< [15..0] The integer baud rate divisor. These bits are cleared to 0 on reset. */
            uint32_t            : 16;
    } UARTIBRD_b;
  } ;

  union {
    __IOM uint32_t UARTFBRD;                    /*!< (@ 0x00000028) Fractional Baud Rate Register, UARTFBRD */

    struct {
      __IOM uint32_t BAUD_DIVFRAC : 6;          /*!< [5..0] The fractional baud rate divisor. These bits are cleared to 0 on reset. */
            uint32_t            : 26;
    } UARTFBRD_b;
  } ;

  union {
    __IOM uint32_t UARTLCR_H;                   /*!< (@ 0x0000002C) Line Control Register, UARTLCR_H */

    struct {
      __IOM uint32_t BRK        : 1;            /*!< [0..0] Send break. If this bit is set to 1, a low-level is continually output on the UARTTXD output, after completing transmission of the current character. For the proper execution of the break command, the software must set this bit for at least two complete frames. For normal use, this bit must be cleared to 0. */
      __IOM uint32_t PEN        : 1;            /*!< [1..1] Parity enable: 0 = parity is disabled and no parity bit added to the data frame 1 = parity checking and generation is enabled. */
      __IOM uint32_t EPS        : 1;            /*!< [2..2] Even parity select. Controls the type of parity the UART uses during transmission and reception: 0 = odd parity. The UART generates or checks for an odd number of 1s in the data and parity bits. 1 = even parity. The UART generates or checks for an even number of 1s in the data and parity bits. This bit has no effect when the PEN bit disables parity checking and generation. */
      __IOM uint32_t STP2       : 1;            /*!< [3..3] Two stop bits select. If this bit is set to 1, two stop bits are transmitted at the end of the frame. The receive logic does not check for two stop bits being received. */
      __IOM uint32_t FEN        : 1;            /*!< [4..4] Enable FIFOs: 0 = FIFOs are disabled (character mode) that is, the FIFOs become 1-byte-deep holding registers 1 = transmit and receive FIFO buffers are enabled (FIFO mode). */
      __IOM uint32_t WLEN       : 2;            /*!< [6..5] Word length. These bits indicate the number of data bits transmitted or received in a frame as follows: b11 = 8 bits b10 = 7 bits b01 = 6 bits b00 = 5 bits. */
      __IOM uint32_t SPS        : 1;            /*!< [7..7] Stick parity select. 0 = stick parity is disabled 1 = either: * if the EPS bit is 0 then the parity bit is transmitted and checked as a 1 * if the EPS bit is 1 then the parity bit is transmitted and checked as a 0. This bit has no effect when the PEN bit disables parity checking and generation. */
            uint32_t            : 24;
    } UARTLCR_H_b;
  } ;

  union {
    __IOM uint32_t UARTCR;                      /*!< (@ 0x00000030) Control Register, UARTCR */

    struct {
      __IOM uint32_t UARTEN     : 1;            /*!< [0..0] UART enable: 0 = UART is disabled. If the UART is disabled in the middle of transmission or reception, it completes the current character before stopping. 1 = the UART is enabled. Data transmission and reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit. */
      __IOM uint32_t SIREN      : 1;            /*!< [1..1] SIR enable: 0 = IrDA SIR ENDEC is disabled. nSIROUT remains LOW (no light pulse generated), and signal transitions on SIRIN have no effect. 1 = IrDA SIR ENDEC is enabled. Data is transmitted and received on nSIROUT and SIRIN. UARTTXD remains HIGH, in the marking state. Signal transitions on UARTRXD or modem status inputs have no effect. This bit has no effect if the UARTEN bit disables the UART. */
      __IOM uint32_t SIRLP      : 1;            /*!< [2..2] SIR low-power IrDA mode. This bit selects the IrDA encoding mode. If this bit is cleared to 0, low-level bits are transmitted as an active high pulse with a width of 3 / 16th of the bit period. If this bit is set to 1, low-level bits are transmitted with a pulse width that is 3 times the period of the IrLPBaud16 input signal, regardless of the selected bit rate. Setting this bit uses less power, but might reduce transmission distances. */
            uint32_t            : 4;
      __IOM uint32_t LBE        : 1;            /*!< [7..7] Loopback enable. If this bit is set to 1 and the SIREN bit is set to 1 and the SIRTEST bit in the Test Control Register, UARTTCR is set to 1, then the nSIROUT path is inverted, and fed through to the SIRIN path. The SIRTEST bit in the test register must be set to 1 to override the normal half-duplex SIR operation. This must be the requirement for accessing the test registers during normal operation, and SIRTEST must be cleared to 0 when loopback testing is finished. This feature reduces the amount of ext */
      __IOM uint32_t TXE        : 1;            /*!< [8..8] Transmit enable. If this bit is set to 1, the transmit section of the UART is enabled. Data transmission occurs for either UART signals, or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of transmission, it completes the current character before stopping. */
      __IOM uint32_t RXE        : 1;            /*!< [9..9] Receive enable. If this bit is set to 1, the receive section of the UART is enabled. Data reception occurs for either UART signals or SIR signals depending on the setting of the SIREN bit. When the UART is disabled in the middle of reception, it completes the current character before stopping. */
      __IOM uint32_t DTR        : 1;            /*!< [10..10] Data transmit ready. This bit is the complement of the UART data transmit ready, nUARTDTR, modem status output. That is, when the bit is programmed to a 1 then nUARTDTR is LOW. */
      __IOM uint32_t RTS        : 1;            /*!< [11..11] Request to send. This bit is the complement of the UART request to send, nUARTRTS, modem status output. That is, when the bit is programmed to a 1 then nUARTRTS is LOW. */
      __IOM uint32_t OUT1       : 1;            /*!< [12..12] This bit is the complement of the UART Out1 (nUARTOut1) modem status output. That is, when the bit is programmed to a 1 the output is 0. For DTE this can be used as Data Carrier Detect (DCD). */
      __IOM uint32_t OUT2       : 1;            /*!< [13..13] This bit is the complement of the UART Out2 (nUARTOut2) modem status output. That is, when the bit is programmed to a 1, the output is 0. For DTE this can be used as Ring Indicator (RI). */
      __IOM uint32_t RTSEN      : 1;            /*!< [14..14] RTS hardware flow control enable. If this bit is set to 1, RTS hardware flow control is enabled. Data is only requested when there is space in the receive FIFO for it to be received. */
      __IOM uint32_t CTSEN      : 1;            /*!< [15..15] CTS hardware flow control enable. If this bit is set to 1, CTS hardware flow control is enabled. Data is only transmitted when the nUARTCTS signal is asserted. */
            uint32_t            : 16;
    } UARTCR_b;
  } ;

  union {
    __IOM uint32_t UARTIFLS;                    /*!< (@ 0x00000034) Interrupt FIFO Level Select Register, UARTIFLS */

    struct {
      __IOM uint32_t TXIFLSEL   : 3;            /*!< [2..0] Transmit interrupt FIFO level select. The trigger points for the transmit interrupt are as follows: b000 = Transmit FIFO becomes <= 1 / 8 full b001 = Transmit FIFO becomes <= 1 / 4 full b010 = Transmit FIFO becomes <= 1 / 2 full b011 = Transmit FIFO becomes <= 3 / 4 full b100 = Transmit FIFO becomes <= 7 / 8 full b101-b111 = reserved. */
      __IOM uint32_t RXIFLSEL   : 3;            /*!< [5..3] Receive interrupt FIFO level select. The trigger points for the receive interrupt are as follows: b000 = Receive FIFO becomes >= 1 / 8 full b001 = Receive FIFO becomes >= 1 / 4 full b010 = Receive FIFO becomes >= 1 / 2 full b011 = Receive FIFO becomes >= 3 / 4 full b100 = Receive FIFO becomes >= 7 / 8 full b101-b111 = reserved. */
            uint32_t            : 26;
    } UARTIFLS_b;
  } ;

  union {
    __IOM uint32_t UARTIMSC;                    /*!< (@ 0x00000038) Interrupt Mask Set/Clear Register, UARTIMSC */

    struct {
      __IOM uint32_t RIMIM      : 1;            /*!< [0..0] nUARTRI modem interrupt mask. A read returns the current mask for the UARTRIINTR interrupt. On a write of 1, the mask of the UARTRIINTR interrupt is set. A write of 0 clears the mask. */
      __IOM uint32_t CTSMIM     : 1;            /*!< [1..1] nUARTCTS modem interrupt mask. A read returns the current mask for the UARTCTSINTR interrupt. On a write of 1, the mask of the UARTCTSINTR interrupt is set. A write of 0 clears the mask. */
      __IOM uint32_t DCDMIM     : 1;            /*!< [2..2] nUARTDCD modem interrupt mask. A read returns the current mask for the UARTDCDINTR interrupt. On a write of 1, the mask of the UARTDCDINTR interrupt is set. A write of 0 clears the mask. */
      __IOM uint32_t DSRMIM     : 1;            /*!< [3..3] nUARTDSR modem interrupt mask. A read returns the current mask for the UARTDSRINTR interrupt. On a write of 1, the mask of the UARTDSRINTR interrupt is set. A write of 0 clears the mask. */
      __IOM uint32_t RXIM       : 1;            /*!< [4..4] Receive interrupt mask. A read returns the current mask for the UARTRXINTR interrupt. On a write of 1, the mask of the UARTRXINTR interrupt is set. A write of 0 clears the mask. */
      __IOM uint32_t TXIM       : 1;            /*!< [5..5] Transmit interrupt mask. A read returns the current mask for the UARTTXINTR interrupt. On a write of 1, the mask of the UARTTXINTR interrupt is set. A write of 0 clears the mask. */
      __IOM uint32_t RTIM       : 1;            /*!< [6..6] Receive timeout interrupt mask. A read returns the current mask for the UARTRTINTR interrupt. On a write of 1, the mask of the UARTRTINTR interrupt is set. A write of 0 clears the mask. */
      __IOM uint32_t FEIM       : 1;            /*!< [7..7] Framing error interrupt mask. A read returns the current mask for the UARTFEINTR interrupt. On a write of 1, the mask of the UARTFEINTR interrupt is set. A write of 0 clears the mask. */
      __IOM uint32_t PEIM       : 1;            /*!< [8..8] Parity error interrupt mask. A read returns the current mask for the UARTPEINTR interrupt. On a write of 1, the mask of the UARTPEINTR interrupt is set. A write of 0 clears the mask. */
      __IOM uint32_t BEIM       : 1;            /*!< [9..9] Break error interrupt mask. A read returns the current mask for the UARTBEINTR interrupt. On a write of 1, the mask of the UARTBEINTR interrupt is set. A write of 0 clears the mask. */
      __IOM uint32_t OEIM       : 1;            /*!< [10..10] Overrun error interrupt mask. A read returns the current mask for the UARTOEINTR interrupt. On a write of 1, the mask of the UARTOEINTR interrupt is set. A write of 0 clears the mask. */
            uint32_t            : 21;
    } UARTIMSC_b;
  } ;

  union {
    __IOM uint32_t UARTRIS;                     /*!< (@ 0x0000003C) Raw Interrupt Status Register, UARTRIS */

    struct {
      __IM  uint32_t RIRMIS     : 1;            /*!< [0..0] nUARTRI modem interrupt status. Returns the raw interrupt state of the UARTRIINTR interrupt. */
      __IM  uint32_t CTSRMIS    : 1;            /*!< [1..1] nUARTCTS modem interrupt status. Returns the raw interrupt state of the UARTCTSINTR interrupt. */
      __IM  uint32_t DCDRMIS    : 1;            /*!< [2..2] nUARTDCD modem interrupt status. Returns the raw interrupt state of the UARTDCDINTR interrupt. */
      __IM  uint32_t DSRRMIS    : 1;            /*!< [3..3] nUARTDSR modem interrupt status. Returns the raw interrupt state of the UARTDSRINTR interrupt. */
      __IM  uint32_t RXRIS      : 1;            /*!< [4..4] Receive interrupt status. Returns the raw interrupt state of the UARTRXINTR interrupt. */
      __IM  uint32_t TXRIS      : 1;            /*!< [5..5] Transmit interrupt status. Returns the raw interrupt state of the UARTTXINTR interrupt. */
      __IM  uint32_t RTRIS      : 1;            /*!< [6..6] Receive timeout interrupt status. Returns the raw interrupt state of the UARTRTINTR interrupt. a */
      __IM  uint32_t FERIS      : 1;            /*!< [7..7] Framing error interrupt status. Returns the raw interrupt state of the UARTFEINTR interrupt. */
      __IM  uint32_t PERIS      : 1;            /*!< [8..8] Parity error interrupt status. Returns the raw interrupt state of the UARTPEINTR interrupt. */
      __IM  uint32_t BERIS      : 1;            /*!< [9..9] Break error interrupt status. Returns the raw interrupt state of the UARTBEINTR interrupt. */
      __IM  uint32_t OERIS      : 1;            /*!< [10..10] Overrun error interrupt status. Returns the raw interrupt state of the UARTOEINTR interrupt. */
            uint32_t            : 21;
    } UARTRIS_b;
  } ;

  union {
    __IOM uint32_t UARTMIS;                     /*!< (@ 0x00000040) Masked Interrupt Status Register, UARTMIS */

    struct {
      __IM  uint32_t RIMMIS     : 1;            /*!< [0..0] nUARTRI modem masked interrupt status. Returns the masked interrupt state of the UARTRIINTR interrupt. */
      __IM  uint32_t CTSMMIS    : 1;            /*!< [1..1] nUARTCTS modem masked interrupt status. Returns the masked interrupt state of the UARTCTSINTR interrupt. */
      __IM  uint32_t DCDMMIS    : 1;            /*!< [2..2] nUARTDCD modem masked interrupt status. Returns the masked interrupt state of the UARTDCDINTR interrupt. */
      __IM  uint32_t DSRMMIS    : 1;            /*!< [3..3] nUARTDSR modem masked interrupt status. Returns the masked interrupt state of the UARTDSRINTR interrupt. */
      __IM  uint32_t RXMIS      : 1;            /*!< [4..4] Receive masked interrupt status. Returns the masked interrupt state of the UARTRXINTR interrupt. */
      __IM  uint32_t TXMIS      : 1;            /*!< [5..5] Transmit masked interrupt status. Returns the masked interrupt state of the UARTTXINTR interrupt. */
      __IM  uint32_t RTMIS      : 1;            /*!< [6..6] Receive timeout masked interrupt status. Returns the masked interrupt state of the UARTRTINTR interrupt. */
      __IM  uint32_t FEMIS      : 1;            /*!< [7..7] Framing error masked interrupt status. Returns the masked interrupt state of the UARTFEINTR interrupt. */
      __IM  uint32_t PEMIS      : 1;            /*!< [8..8] Parity error masked interrupt status. Returns the masked interrupt state of the UARTPEINTR interrupt. */
      __IM  uint32_t BEMIS      : 1;            /*!< [9..9] Break error masked interrupt status. Returns the masked interrupt state of the UARTBEINTR interrupt. */
      __IM  uint32_t OEMIS      : 1;            /*!< [10..10] Overrun error masked interrupt status. Returns the masked interrupt state of the UARTOEINTR interrupt. */
            uint32_t            : 21;
    } UARTMIS_b;
  } ;

  union {
    __IOM uint32_t UARTICR;                     /*!< (@ 0x00000044) Interrupt Clear Register, UARTICR */

    struct {
      __IOM uint32_t RIMIC      : 1;            /*!< [0..0] nUARTRI modem interrupt clear. Clears the UARTRIINTR interrupt. */
      __IOM uint32_t CTSMIC     : 1;            /*!< [1..1] nUARTCTS modem interrupt clear. Clears the UARTCTSINTR interrupt. */
      __IOM uint32_t DCDMIC     : 1;            /*!< [2..2] nUARTDCD modem interrupt clear. Clears the UARTDCDINTR interrupt. */
      __IOM uint32_t DSRMIC     : 1;            /*!< [3..3] nUARTDSR modem interrupt clear. Clears the UARTDSRINTR interrupt. */
      __IOM uint32_t RXIC       : 1;            /*!< [4..4] Receive interrupt clear. Clears the UARTRXINTR interrupt. */
      __IOM uint32_t TXIC       : 1;            /*!< [5..5] Transmit interrupt clear. Clears the UARTTXINTR interrupt. */
      __IOM uint32_t RTIC       : 1;            /*!< [6..6] Receive timeout interrupt clear. Clears the UARTRTINTR interrupt. */
      __IOM uint32_t FEIC       : 1;            /*!< [7..7] Framing error interrupt clear. Clears the UARTFEINTR interrupt. */
      __IOM uint32_t PEIC       : 1;            /*!< [8..8] Parity error interrupt clear. Clears the UARTPEINTR interrupt. */
      __IOM uint32_t BEIC       : 1;            /*!< [9..9] Break error interrupt clear. Clears the UARTBEINTR interrupt. */
      __IOM uint32_t OEIC       : 1;            /*!< [10..10] Overrun error interrupt clear. Clears the UARTOEINTR interrupt. */
            uint32_t            : 21;
    } UARTICR_b;
  } ;

  union {
    __IOM uint32_t UARTDMACR;                   /*!< (@ 0x00000048) DMA Control Register, UARTDMACR */

    struct {
      __IOM uint32_t RXDMAE     : 1;            /*!< [0..0] Receive DMA enable. If this bit is set to 1, DMA for the receive FIFO is enabled. */
      __IOM uint32_t TXDMAE     : 1;            /*!< [1..1] Transmit DMA enable. If this bit is set to 1, DMA for the transmit FIFO is enabled. */
      __IOM uint32_t DMAONERR   : 1;            /*!< [2..2] DMA on error. If this bit is set to 1, the DMA receive request outputs, UARTRXDMASREQ or UARTRXDMABREQ, are disabled when the UART error interrupt is asserted. */
            uint32_t            : 29;
    } UARTDMACR_b;
  } ;
  __IM  uint32_t  RESERVED2[997];

  union {
    __IOM uint32_t UARTPERIPHID0;               /*!< (@ 0x00000FE0) UARTPeriphID0 Register */

    struct {
      __IM  uint32_t PARTNUMBER0 : 8;           /*!< [7..0] These bits read back as 0x11 */
            uint32_t            : 24;
    } UARTPERIPHID0_b;
  } ;

  union {
    __IOM uint32_t UARTPERIPHID1;               /*!< (@ 0x00000FE4) UARTPeriphID1 Register */

    struct {
      __IM  uint32_t PARTNUMBER1 : 4;           /*!< [3..0] These bits read back as 0x0 */
      __IM  uint32_t DESIGNER0  : 4;            /*!< [7..4] These bits read back as 0x1 */
            uint32_t            : 24;
    } UARTPERIPHID1_b;
  } ;

  union {
    __IOM uint32_t UARTPERIPHID2;               /*!< (@ 0x00000FE8) UARTPeriphID2 Register */

    struct {
      __IM  uint32_t DESIGNER1  : 4;            /*!< [3..0] These bits read back as 0x4 */
      __IM  uint32_t REVISION   : 4;            /*!< [7..4] This field depends on the revision of the UART: r1p0 0x0 r1p1 0x1 r1p3 0x2 r1p4 0x2 r1p5 0x3 */
            uint32_t            : 24;
    } UARTPERIPHID2_b;
  } ;

  union {
    __IOM uint32_t UARTPERIPHID3;               /*!< (@ 0x00000FEC) UARTPeriphID3 Register */

    struct {
      __IM  uint32_t CONFIGURATION : 8;         /*!< [7..0] These bits read back as 0x00 */
            uint32_t            : 24;
    } UARTPERIPHID3_b;
  } ;

  union {
    __IOM uint32_t UARTPCELLID0;                /*!< (@ 0x00000FF0) UARTPCellID0 Register */

    struct {
      __IM  uint32_t UARTPCELLID0 : 8;          /*!< [7..0] These bits read back as 0x0D */
            uint32_t            : 24;
    } UARTPCELLID0_b;
  } ;

  union {
    __IOM uint32_t UARTPCELLID1;                /*!< (@ 0x00000FF4) UARTPCellID1 Register */

    struct {
      __IM  uint32_t UARTPCELLID1 : 8;          /*!< [7..0] These bits read back as 0xF0 */
            uint32_t            : 24;
    } UARTPCELLID1_b;
  } ;

  union {
    __IOM uint32_t UARTPCELLID2;                /*!< (@ 0x00000FF8) UARTPCellID2 Register */

    struct {
      __IM  uint32_t UARTPCELLID2 : 8;          /*!< [7..0] These bits read back as 0x05 */
            uint32_t            : 24;
    } UARTPCELLID2_b;
  } ;

  union {
    __IOM uint32_t UARTPCELLID3;                /*!< (@ 0x00000FFC) UARTPCellID3 Register */

    struct {
      __IM  uint32_t UARTPCELLID3 : 8;          /*!< [7..0] These bits read back as 0xB1 */
            uint32_t            : 24;
    } UARTPCELLID3_b;
  } ;
} UART0_Type;                                   /*!< Size = 4096 (0x1000) */



/* =========================================================================================================================== */
/* ================                                           SPI0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief SPI0 (SPI0)
  */

typedef struct {                                /*!< (@ 0x4003C000) SPI0 Structure */

  union {
    __IOM uint32_t SSPCR0;                      /*!< (@ 0x00000000) Control register 0, SSPCR0 on page 3-4 */

    struct {
      __IOM uint32_t DSS        : 4;            /*!< [3..0] Data Size Select: 0000 Reserved, undefined operation. 0001 Reserved, undefined operation. 0010 Reserved, undefined operation. 0011 4-bit data. 0100 5-bit data. 0101 6-bit data. 0110 7-bit data. 0111 8-bit data. 1000 9-bit data. 1001 10-bit data. 1010 11-bit data. 1011 12-bit data. 1100 13-bit data. 1101 14-bit data. 1110 15-bit data. 1111 16-bit data. */
      __IOM uint32_t FRF        : 2;            /*!< [5..4] Frame format: 00 Motorola SPI frame format. 01 TI synchronous serial frame format. 10 National Microwire frame format. 11 Reserved, undefined operation. */
      __IOM uint32_t SPO        : 1;            /*!< [6..6] SSPCLKOUT polarity, applicable to Motorola SPI frame format only. See Motorola SPI frame format on page 2-10. */
      __IOM uint32_t SPH        : 1;            /*!< [7..7] SSPCLKOUT phase, applicable to Motorola SPI frame format only. See Motorola SPI frame format on page 2-10. */
      __IOM uint32_t SCR        : 8;            /*!< [15..8] Serial clock rate. The value SCR is used to generate the transmit and receive bit rate of the PrimeCell SSP. The bit rate is: F SSPCLK CPSDVSR x (1+SCR) where CPSDVSR is an even value from 2-254, programmed through the SSPCPSR register and SCR is a value from 0-255. */
            uint32_t            : 16;
    } SSPCR0_b;
  } ;

  union {
    __IOM uint32_t SSPCR1;                      /*!< (@ 0x00000004) Control register 1, SSPCR1 on page 3-5 */

    struct {
      __IOM uint32_t LBM        : 1;            /*!< [0..0] Loop back mode: 0 Normal serial port operation enabled. 1 Output of transmit serial shifter is connected to input of receive serial shifter internally. */
      __IOM uint32_t SSE        : 1;            /*!< [1..1] Synchronous serial port enable: 0 SSP operation disabled. 1 SSP operation enabled. */
      __IOM uint32_t MS         : 1;            /*!< [2..2] Master or slave mode select. This bit can be modified only when the PrimeCell SSP is disabled, SSE=0: 0 Device configured as master, default. 1 Device configured as slave. */
      __IOM uint32_t SOD        : 1;            /*!< [3..3] Slave-mode output disable. This bit is relevant only in the slave mode, MS=1. In multiple-slave systems, it is possible for an PrimeCell SSP master to broadcast a message to all slaves in the system while ensuring that only one slave drives data onto its serial output line. In such systems the RXD lines from multiple slaves could be tied together. To operate in such systems, the SOD bit can be set if the PrimeCell SSP slave is not supposed to drive the SSPTXD line: 0 SSP can drive the SSPTXD output in sl */
            uint32_t            : 28;
    } SSPCR1_b;
  } ;

  union {
    __IOM uint32_t SSPDR;                       /*!< (@ 0x00000008) Data register, SSPDR on page 3-6 */

    struct {
      __IOM uint32_t DATA       : 16;           /*!< [15..0] Transmit/Receive FIFO: Read Receive FIFO. Write Transmit FIFO. You must right-justify data when the PrimeCell SSP is programmed for a data size that is less than 16 bits. Unused bits at the top are ignored by transmit logic. The receive logic automatically right-justifies. */
            uint32_t            : 16;
    } SSPDR_b;
  } ;

  union {
    __IOM uint32_t SSPSR;                       /*!< (@ 0x0000000C) Status register, SSPSR on page 3-7 */

    struct {
      __IM  uint32_t TFE        : 1;            /*!< [0..0] Transmit FIFO empty, RO: 0 Transmit FIFO is not empty. 1 Transmit FIFO is empty. */
      __IM  uint32_t TNF        : 1;            /*!< [1..1] Transmit FIFO not full, RO: 0 Transmit FIFO is full. 1 Transmit FIFO is not full. */
      __IM  uint32_t RNE        : 1;            /*!< [2..2] Receive FIFO not empty, RO: 0 Receive FIFO is empty. 1 Receive FIFO is not empty. */
      __IM  uint32_t RFF        : 1;            /*!< [3..3] Receive FIFO full, RO: 0 Receive FIFO is not full. 1 Receive FIFO is full. */
      __IM  uint32_t BSY        : 1;            /*!< [4..4] PrimeCell SSP busy flag, RO: 0 SSP is idle. 1 SSP is currently transmitting and/or receiving a frame or the transmit FIFO is not empty. */
            uint32_t            : 27;
    } SSPSR_b;
  } ;

  union {
    __IOM uint32_t SSPCPSR;                     /*!< (@ 0x00000010) Clock prescale register, SSPCPSR on page 3-8 */

    struct {
      __IOM uint32_t CPSDVSR    : 8;            /*!< [7..0] Clock prescale divisor. Must be an even number from 2-254, depending on the frequency of SSPCLK. The least significant bit always returns zero on reads. */
            uint32_t            : 24;
    } SSPCPSR_b;
  } ;

  union {
    __IOM uint32_t SSPIMSC;                     /*!< (@ 0x00000014) Interrupt mask set or clear register, SSPIMSC on page 3-9 */

    struct {
      __IOM uint32_t RORIM      : 1;            /*!< [0..0] Receive overrun interrupt mask: 0 Receive FIFO written to while full condition interrupt is masked. 1 Receive FIFO written to while full condition interrupt is not masked. */
      __IOM uint32_t RTIM       : 1;            /*!< [1..1] Receive timeout interrupt mask: 0 Receive FIFO not empty and no read prior to timeout period interrupt is masked. 1 Receive FIFO not empty and no read prior to timeout period interrupt is not masked. */
      __IOM uint32_t RXIM       : 1;            /*!< [2..2] Receive FIFO interrupt mask: 0 Receive FIFO half full or less condition interrupt is masked. 1 Receive FIFO half full or less condition interrupt is not masked. */
      __IOM uint32_t TXIM       : 1;            /*!< [3..3] Transmit FIFO interrupt mask: 0 Transmit FIFO half empty or less condition interrupt is masked. 1 Transmit FIFO half empty or less condition interrupt is not masked. */
            uint32_t            : 28;
    } SSPIMSC_b;
  } ;

  union {
    __IOM uint32_t SSPRIS;                      /*!< (@ 0x00000018) Raw interrupt status register, SSPRIS on page 3-10 */

    struct {
      __IM  uint32_t RORRIS     : 1;            /*!< [0..0] Gives the raw interrupt state, prior to masking, of the SSPRORINTR interrupt */
      __IM  uint32_t RTRIS      : 1;            /*!< [1..1] Gives the raw interrupt state, prior to masking, of the SSPRTINTR interrupt */
      __IM  uint32_t RXRIS      : 1;            /*!< [2..2] Gives the raw interrupt state, prior to masking, of the SSPRXINTR interrupt */
      __IM  uint32_t TXRIS      : 1;            /*!< [3..3] Gives the raw interrupt state, prior to masking, of the SSPTXINTR interrupt */
            uint32_t            : 28;
    } SSPRIS_b;
  } ;

  union {
    __IOM uint32_t SSPMIS;                      /*!< (@ 0x0000001C) Masked interrupt status register, SSPMIS on page 3-11 */

    struct {
      __IM  uint32_t RORMIS     : 1;            /*!< [0..0] Gives the receive over run masked interrupt status, after masking, of the SSPRORINTR interrupt */
      __IM  uint32_t RTMIS      : 1;            /*!< [1..1] Gives the receive timeout masked interrupt state, after masking, of the SSPRTINTR interrupt */
      __IM  uint32_t RXMIS      : 1;            /*!< [2..2] Gives the receive FIFO masked interrupt state, after masking, of the SSPRXINTR interrupt */
      __IM  uint32_t TXMIS      : 1;            /*!< [3..3] Gives the transmit FIFO masked interrupt state, after masking, of the SSPTXINTR interrupt */
            uint32_t            : 28;
    } SSPMIS_b;
  } ;

  union {
    __IOM uint32_t SSPICR;                      /*!< (@ 0x00000020) Interrupt clear register, SSPICR on page 3-11 */

    struct {
      __IOM uint32_t RORIC      : 1;            /*!< [0..0] Clears the SSPRORINTR interrupt */
      __IOM uint32_t RTIC       : 1;            /*!< [1..1] Clears the SSPRTINTR interrupt */
            uint32_t            : 30;
    } SSPICR_b;
  } ;

  union {
    __IOM uint32_t SSPDMACR;                    /*!< (@ 0x00000024) DMA control register, SSPDMACR on page 3-12 */

    struct {
      __IOM uint32_t RXDMAE     : 1;            /*!< [0..0] Receive DMA Enable. If this bit is set to 1, DMA for the receive FIFO is enabled. */
      __IOM uint32_t TXDMAE     : 1;            /*!< [1..1] Transmit DMA Enable. If this bit is set to 1, DMA for the transmit FIFO is enabled. */
            uint32_t            : 30;
    } SSPDMACR_b;
  } ;
  __IM  uint32_t  RESERVED[1006];

  union {
    __IOM uint32_t SSPPERIPHID0;                /*!< (@ 0x00000FE0) Peripheral identification registers, SSPPeriphID0-3 on page 3-13 */

    struct {
      __IM  uint32_t PARTNUMBER0 : 8;           /*!< [7..0] These bits read back as 0x22 */
            uint32_t            : 24;
    } SSPPERIPHID0_b;
  } ;

  union {
    __IOM uint32_t SSPPERIPHID1;                /*!< (@ 0x00000FE4) Peripheral identification registers, SSPPeriphID0-3 on page 3-13 */

    struct {
      __IM  uint32_t PARTNUMBER1 : 4;           /*!< [3..0] These bits read back as 0x0 */
      __IM  uint32_t DESIGNER0  : 4;            /*!< [7..4] These bits read back as 0x1 */
            uint32_t            : 24;
    } SSPPERIPHID1_b;
  } ;

  union {
    __IOM uint32_t SSPPERIPHID2;                /*!< (@ 0x00000FE8) Peripheral identification registers, SSPPeriphID0-3 on page 3-13 */

    struct {
      __IM  uint32_t DESIGNER1  : 4;            /*!< [3..0] These bits read back as 0x4 */
      __IM  uint32_t REVISION   : 4;            /*!< [7..4] These bits return the peripheral revision */
            uint32_t            : 24;
    } SSPPERIPHID2_b;
  } ;

  union {
    __IOM uint32_t SSPPERIPHID3;                /*!< (@ 0x00000FEC) Peripheral identification registers, SSPPeriphID0-3 on page 3-13 */

    struct {
      __IM  uint32_t CONFIGURATION : 8;         /*!< [7..0] These bits read back as 0x00 */
            uint32_t            : 24;
    } SSPPERIPHID3_b;
  } ;

  union {
    __IOM uint32_t SSPPCELLID0;                 /*!< (@ 0x00000FF0) PrimeCell identification registers, SSPPCellID0-3 on page 3-16 */

    struct {
      __IM  uint32_t SSPPCELLID0 : 8;           /*!< [7..0] These bits read back as 0x0D */
            uint32_t            : 24;
    } SSPPCELLID0_b;
  } ;

  union {
    __IOM uint32_t SSPPCELLID1;                 /*!< (@ 0x00000FF4) PrimeCell identification registers, SSPPCellID0-3 on page 3-16 */

    struct {
      __IM  uint32_t SSPPCELLID1 : 8;           /*!< [7..0] These bits read back as 0xF0 */
            uint32_t            : 24;
    } SSPPCELLID1_b;
  } ;

  union {
    __IOM uint32_t SSPPCELLID2;                 /*!< (@ 0x00000FF8) PrimeCell identification registers, SSPPCellID0-3 on page 3-16 */

    struct {
      __IM  uint32_t SSPPCELLID2 : 8;           /*!< [7..0] These bits read back as 0x05 */
            uint32_t            : 24;
    } SSPPCELLID2_b;
  } ;

  union {
    __IOM uint32_t SSPPCELLID3;                 /*!< (@ 0x00000FFC) PrimeCell identification registers, SSPPCellID0-3 on page 3-16 */

    struct {
      __IM  uint32_t SSPPCELLID3 : 8;           /*!< [7..0] These bits read back as 0xB1 */
            uint32_t            : 24;
    } SSPPCELLID3_b;
  } ;
} SPI0_Type;                                    /*!< Size = 4096 (0x1000) */



/* =========================================================================================================================== */
/* ================                                           I2C0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief DW_apb_i2c address block\n\n
        List of configuration constants for the Synopsys I2C hardware (you may see references to these in I2C register header; these are *fixed* values, set at hardware design time):\n\n
        IC_ULTRA_FAST_MODE ................ 0x0\n
        IC_UFM_TBUF_CNT_DEFAULT ........... 0x8\n
        IC_UFM_SCL_LOW_COUNT .............. 0x0008\n
        IC_UFM_SCL_HIGH_COUNT ............. 0x0006\n
        IC_TX_TL .......................... 0x0\n
        IC_TX_CMD_BLOCK ................... 0x1\n
        IC_HAS_DMA ........................ 0x1\n
        IC_HAS_ASYNC_FIFO ................. 0x0\n
        IC_SMBUS_ARP ...................... 0x0\n
        IC_FIRST_DATA_BYTE_STATUS ......... 0x1\n
        IC_INTR_IO ........................ 0x1\n
        IC_MASTER_MODE .................... 0x1\n
        IC_DEFAULT_ACK_GENERAL_CALL ....... 0x1\n
        IC_INTR_POL ....................... 0x1\n
        IC_OPTIONAL_SAR ................... 0x0\n
        IC_DEFAULT_TAR_SLAVE_ADDR ......... 0x055\n
        IC_DEFAULT_SLAVE_ADDR ............. 0x055\n
        IC_DEFAULT_HS_SPKLEN .............. 0x1\n
        IC_FS_SCL_HIGH_COUNT .............. 0x0006\n
        IC_HS_SCL_LOW_COUNT ............... 0x0008\n
        IC_DEVICE_ID_VALUE ................ 0x0\n
        IC_10BITADDR_MASTER ............... 0x0\n
        IC_CLK_FREQ_OPTIMIZATION .......... 0x0\n
        IC_DEFAULT_FS_SPKLEN .............. 0x7\n
        IC_ADD_ENCODED_PARAMS ............. 0x0\n
        IC_DEFAULT_SDA_HOLD ............... 0x000001\n
        IC_DEFAULT_SDA_SETUP .............. 0x64\n
        IC_AVOID_RX_FIFO_FLUSH_ON_TX_ABRT . 0x0\n
        IC_CLOCK_PERIOD ................... 100\n
        IC_EMPTYFIFO_HOLD_MASTER_EN ....... 1\n
        IC_RESTART_EN ..................... 0x1\n
        IC_TX_CMD_BLOCK_DEFAULT ........... 0x0\n
        IC_BUS_CLEAR_FEATURE .............. 0x0\n
        IC_CAP_LOADING .................... 100\n
        IC_FS_SCL_LOW_COUNT ............... 0x000d\n
        APB_DATA_WIDTH .................... 32\n
        IC_SDA_STUCK_TIMEOUT_DEFAULT ...... 0xffffffff\n
        IC_SLV_DATA_NACK_ONLY ............. 0x1\n
        IC_10BITADDR_SLAVE ................ 0x0\n
        IC_CLK_TYPE ....................... 0x0\n
        IC_SMBUS_UDID_MSB ................. 0x0\n
        IC_SMBUS_SUSPEND_ALERT ............ 0x0\n
        IC_HS_SCL_HIGH_COUNT .............. 0x0006\n
        IC_SLV_RESTART_DET_EN ............. 0x1\n
        IC_SMBUS .......................... 0x0\n
        IC_OPTIONAL_SAR_DEFAULT ........... 0x0\n
        IC_PERSISTANT_SLV_ADDR_DEFAULT .... 0x0\n
        IC_USE_COUNTS ..................... 0x0\n
        IC_RX_BUFFER_DEPTH ................ 16\n
        IC_SCL_STUCK_TIMEOUT_DEFAULT ...... 0xffffffff\n
        IC_RX_FULL_HLD_BUS_EN ............. 0x1\n
        IC_SLAVE_DISABLE .................. 0x1\n
        IC_RX_TL .......................... 0x0\n
        IC_DEVICE_ID ...................... 0x0\n
        IC_HC_COUNT_VALUES ................ 0x0\n
        I2C_DYNAMIC_TAR_UPDATE ............ 0\n
        IC_SMBUS_CLK_LOW_MEXT_DEFAULT ..... 0xffffffff\n
        IC_SMBUS_CLK_LOW_SEXT_DEFAULT ..... 0xffffffff\n
        IC_HS_MASTER_CODE ................. 0x1\n
        IC_SMBUS_RST_IDLE_CNT_DEFAULT ..... 0xffff\n
        IC_SMBUS_UDID_LSB_DEFAULT ......... 0xffffffff\n
        IC_SS_SCL_HIGH_COUNT .............. 0x0028\n
        IC_SS_SCL_LOW_COUNT ............... 0x002f\n
        IC_MAX_SPEED_MODE ................. 0x2\n
        IC_STAT_FOR_CLK_STRETCH ........... 0x0\n
        IC_STOP_DET_IF_MASTER_ACTIVE ...... 0x0\n
        IC_DEFAULT_UFM_SPKLEN ............. 0x1\n
        IC_TX_BUFFER_DEPTH ................ 16 (I2C0)
  */

typedef struct {                                /*!< (@ 0x40044000) I2C0 Structure */

  union {
    __IOM uint32_t IC_CON;                      /*!< (@ 0x00000000) I2C Control Register. This register can be written only when the DW_apb_i2c is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect. Read/Write Access: - bit 10 is read only. - bit 11 is read only - bit 16 is read only - bit 17 is read only - bits 18 and 19 are read only. */

    struct {
      __IOM uint32_t MASTER_MODE : 1;           /*!< [0..0] This bit controls whether the DW_apb_i2c master is enabled. NOTE: Software should ensure that if this bit is written with '1' then bit 6 should also be written with a '1'. */
      __IOM uint32_t SPEED      : 2;            /*!< [2..1] These bits control at which speed the DW_apb_i2c operates; its setting is relevant only if one is operating the DW_apb_i2c in master mode. Hardware protects against illegal values being programmed by software. These bits must be programmed appropriately for slave mode also, as it is used to capture correct value of spike filter as per the speed mode. This register should be programmed only with a value in the range of 1 to IC_MAX_SPEED_MODE; otherwise, hardware updates this register */
      __IOM uint32_t IC_10BITADDR_SLAVE : 1;    /*!< [3..3] When acting as a slave, this bit controls whether the DW_apb_i2c responds to 7- or 10-bit addresses. - 0: 7-bit addressing. The DW_apb_i2c ignores transactions that involve 10-bit addressing; for 7-bit addressing, only the lower 7 bits of the IC_SAR register are compared. - 1: 10-bit addressing. The DW_apb_i2c responds to only 10-bit addressing transfers that match the full 10 bits of the IC_SAR register. */
      __IOM uint32_t IC_10BITADDR_MASTER : 1;   /*!< [4..4] Controls whether the DW_apb_i2c starts its transfers in 7- or 10-bit addressing mode when acting as a master. - 0: 7-bit addressing - 1: 10-bit addressing */
      __IOM uint32_t IC_RESTART_EN : 1;         /*!< [5..5] Determines whether RESTART conditions may be sent when acting as a master. Some older slaves do not support handling RESTART conditions; however, RESTART conditions are used in several DW_apb_i2c operations. When RESTART is disabled, the master is prohibited from performing the following functions: - Sending a START BYTE - Performing any high-speed mode operation - High-speed mode operation - Performing direction changes in combined format mode - Performing a read operation with a 10-bit address By repla */
      __IOM uint32_t IC_SLAVE_DISABLE : 1;      /*!< [6..6] This bit controls whether I2C has its slave disabled, which means once the presetn signal is applied, then this bit is set and the slave is disabled. If this bit is set (slave is disabled), DW_apb_i2c functions only as a master and does not perform any action that requires a slave. NOTE: Software should ensure that if this bit is written with 0, then bit 0 should also be written with a 0. */
      __IOM uint32_t STOP_DET_IFADDRESSED : 1;  /*!< [7..7] In slave mode: - 1'b1: issues the STOP_DET interrupt only when it is addressed. - 1'b0: issues the STOP_DET irrespective of whether it's addressed or not. Reset value: 0x0 NOTE: During a general call address, this slave does not issue the STOP_DET interrupt if STOP_DET_IF_ADDRESSED = 1'b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR). */
      __IOM uint32_t TX_EMPTY_CTRL : 1;         /*!< [8..8] This bit controls the generation of the TX_EMPTY interrupt, as described in the IC_RAW_INTR_STAT register. Reset value: 0x0. */
      __IOM uint32_t RX_FIFO_FULL_HLD_CTRL : 1; /*!< [9..9] This bit controls whether DW_apb_i2c should hold the bus when the Rx FIFO is physically full to its RX_BUFFER_DEPTH, as described in the IC_RX_FULL_HLD_BUS_EN parameter. Reset value: 0x0. */
      __IM  uint32_t STOP_DET_IF_MASTER_ACTIVE : 1;/*!< [10..10] Master issues the STOP_DET interrupt irrespective of whether master is active or not */
            uint32_t            : 21;
    } IC_CON_b;
  } ;

  union {
    __IOM uint32_t IC_TAR;                      /*!< (@ 0x00000004) I2C Target Address Register This register is 12 bits wide, and bits 31:12 are reserved. This register can be written to only when IC_ENABLE[0] is set to 0. Note: If the software or application is aware that the DW_apb_i2c is not using the TAR address for the pending commands in the Tx FIFO, then it is possible to update the TAR address even while the Tx FIFO has entries (IC_STATUS[2]= 0). - It is not necessary to perform any write to this register if DW_ap */

    struct {
      __IOM uint32_t IC_TAR     : 10;           /*!< [9..0] This is the target address for any master transaction. When transmitting a General Call, these bits are ignored. To generate a START BYTE, the CPU needs to write only once into these bits. If the IC_TAR and IC_SAR are the same, loopback exists but the FIFOs are shared between master and slave, so full loopback is not feasible. Only one direction loopback mode is supported (simplex), not duplex. A master cannot transmit to itself; it can transmit to only a slave. */
      __IOM uint32_t GC_OR_START : 1;           /*!< [10..10] If bit 11 (SPECIAL) is set to 1 and bit 13(Device-ID) is set to 0, then this bit indicates whether a General Call or START byte command is to be performed by the DW_apb_i2c. - 0: General Call Address - after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The DW_apb_i2c remains in General Call mode until the SPECIAL bit value (bit 11) is cleared. - 1: START BYTE Reset value: 0x0 */
      __IOM uint32_t SPECIAL    : 1;            /*!< [11..11] This bit indicates whether software performs a Device-ID or General Call or START BYTE command. - 0: ignore bit 10 GC_OR_START and use IC_TAR normally - 1: perform special I2C command as specified in Device_ID or GC_OR_START bit Reset value: 0x0 */
            uint32_t            : 20;
    } IC_TAR_b;
  } ;

  union {
    __IOM uint32_t IC_SAR;                      /*!< (@ 0x00000008) I2C Slave Address Register */

    struct {
      __IOM uint32_t IC_SAR     : 10;           /*!< [9..0] The IC_SAR holds the slave address when the I2C is operating as a slave. For 7-bit addressing, only IC_SAR[6:0] is used. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect. Note: The default values cannot be any of the reserved address locations: that is, 0x00 to 0x07, or 0x78 to 0x7f. The correct operation of the device is not guaranteed if you */
            uint32_t            : 22;
    } IC_SAR_b;
  } ;
  __IM  uint32_t  RESERVED;

  union {
    __IOM uint32_t IC_DATA_CMD;                 /*!< (@ 0x00000010) I2C Rx/Tx Data Buffer and Command Register; this is the register the CPU writes to when filling the TX FIFO and the CPU reads from when retrieving bytes from RX FIFO. The size of the register changes as follows: Write: - 11 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=1 - 9 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=0 Read: - 12 bits when IC_FIRST_DATA_BYTE_STATUS = 1 - 8 bits when IC_FIRST_DATA_BYTE_STATUS = 0 Note: In order for the DW_apb_i2c to continue acknowledgi */

    struct {
      __IOM uint32_t DAT        : 8;            /*!< [7..0] This register contains the data to be transmitted or received on the I2C bus. If you are writing to this register and want to perform a read, bits 7:0 (DAT) are ignored by the DW_apb_i2c. However, when you read this register, these bits return the value of data received on the DW_apb_i2c interface. Reset value: 0x0 */
      __IOM uint32_t CMD        : 1;            /*!< [8..8] This bit controls whether a read or a write is performed. This bit does not control the direction when the DW_apb_i2con acts as a slave. It controls only the direction when it acts as a master. When a command is entered in the TX FIFO, this bit distinguishes the write and read commands. In slave-receiver mode, this bit is a 'don't care' because writes to this register are not required. In slave-transmitter mode, a '0' indicates that the data in IC_DATA_CMD is to be transmitted. */
      __IOM uint32_t STOP       : 1;            /*!< [9..9] This bit controls whether a STOP is issued after the byte is sent or received. - 1 - STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus. - 0 - STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data */
      __IOM uint32_t RESTART    : 1;            /*!< [10..10] This bit controls whether a RESTART is issued before the byte is sent or received. 1 - If IC_RESTART_EN is 1, a RESTART is issued before the data is sent/received (according to the value of CMD), regardless of whether or not the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead. 0 - If IC_RESTART_EN is 1, a RESTART is issued only if the transfer direction is changing from the previous com */
      __IM  uint32_t FIRST_DATA_BYTE : 1;       /*!< [11..11] Indicates the first data byte received after the address phase for receive transfer in Master receiver or Slave receiver mode. Reset value : 0x0 NOTE: In case of APB_DATA_WIDTH=8, 1. The user has to perform two APB Reads to IC_DATA_CMD in order to get status on 11 bit. 2. In order to read the 11 bit, the user has to perform the first data byte read [7:0] (offset 0x10) and then perform the second read [15:8] (offset 0x11) */
            uint32_t            : 20;
    } IC_DATA_CMD_b;
  } ;

  union {
    __IOM uint32_t IC_SS_SCL_HCNT;              /*!< (@ 0x00000014) Standard Speed I2C Clock SCL High Count Register */

    struct {
      __IOM uint32_t IC_SS_SCL_HCNT : 16;       /*!< [15..0] This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for standard speed. For more information, refer to 'IC_CLK Frequency Configuration'. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect. The minimum valid value is 6; hardware prevents values less */
            uint32_t            : 16;
    } IC_SS_SCL_HCNT_b;
  } ;

  union {
    __IOM uint32_t IC_SS_SCL_LCNT;              /*!< (@ 0x00000018) Standard Speed I2C Clock SCL Low Count Register */

    struct {
      __IOM uint32_t IC_SS_SCL_LCNT : 16;       /*!< [15..0] This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for standard speed. For more information, refer to 'IC_CLK Frequency Configuration' This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect. The minimum valid value is 8; hardware prevents values less th */
            uint32_t            : 16;
    } IC_SS_SCL_LCNT_b;
  } ;

  union {
    __IOM uint32_t IC_FS_SCL_HCNT;              /*!< (@ 0x0000001C) Fast Mode or Fast Mode Plus I2C Clock SCL High Count Register */

    struct {
      __IOM uint32_t IC_FS_SCL_HCNT : 16;       /*!< [15..0] This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for fast mode or fast mode plus. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. For more information, refer to 'IC_CLK Frequency Configuration'. This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE = standard. This register can be written only when the I2C interface is */
            uint32_t            : 16;
    } IC_FS_SCL_HCNT_b;
  } ;

  union {
    __IOM uint32_t IC_FS_SCL_LCNT;              /*!< (@ 0x00000020) Fast Mode or Fast Mode Plus I2C Clock SCL Low Count Register */

    struct {
      __IOM uint32_t IC_FS_SCL_LCNT : 16;       /*!< [15..0] This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. For more information, refer to 'IC_CLK Frequency Configuration'. This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE = standard. This register can be written only when the I2C interface */
            uint32_t            : 16;
    } IC_FS_SCL_LCNT_b;
  } ;
  __IM  uint32_t  RESERVED1[2];

  union {
    __IOM uint32_t IC_INTR_STAT;                /*!< (@ 0x0000002C) I2C Interrupt Status Register Each bit in this register has a corresponding mask bit in the IC_INTR_MASK register. These bits are cleared by reading the matching interrupt clear register. The unmasked raw versions of these bits are available in the IC_RAW_INTR_STAT register. */

    struct {
      __IM  uint32_t R_RX_UNDER : 1;            /*!< [0..0] See IC_RAW_INTR_STAT for a detailed description of R_RX_UNDER bit. Reset value: 0x0 */
      __IM  uint32_t R_RX_OVER  : 1;            /*!< [1..1] See IC_RAW_INTR_STAT for a detailed description of R_RX_OVER bit. Reset value: 0x0 */
      __IM  uint32_t R_RX_FULL  : 1;            /*!< [2..2] See IC_RAW_INTR_STAT for a detailed description of R_RX_FULL bit. Reset value: 0x0 */
      __IM  uint32_t R_TX_OVER  : 1;            /*!< [3..3] See IC_RAW_INTR_STAT for a detailed description of R_TX_OVER bit. Reset value: 0x0 */
      __IM  uint32_t R_TX_EMPTY : 1;            /*!< [4..4] See IC_RAW_INTR_STAT for a detailed description of R_TX_EMPTY bit. Reset value: 0x0 */
      __IM  uint32_t R_RD_REQ   : 1;            /*!< [5..5] See IC_RAW_INTR_STAT for a detailed description of R_RD_REQ bit. Reset value: 0x0 */
      __IM  uint32_t R_TX_ABRT  : 1;            /*!< [6..6] See IC_RAW_INTR_STAT for a detailed description of R_TX_ABRT bit. Reset value: 0x0 */
      __IM  uint32_t R_RX_DONE  : 1;            /*!< [7..7] See IC_RAW_INTR_STAT for a detailed description of R_RX_DONE bit. Reset value: 0x0 */
      __IM  uint32_t R_ACTIVITY : 1;            /*!< [8..8] See IC_RAW_INTR_STAT for a detailed description of R_ACTIVITY bit. Reset value: 0x0 */
      __IM  uint32_t R_STOP_DET : 1;            /*!< [9..9] See IC_RAW_INTR_STAT for a detailed description of R_STOP_DET bit. Reset value: 0x0 */
      __IM  uint32_t R_START_DET : 1;           /*!< [10..10] See IC_RAW_INTR_STAT for a detailed description of R_START_DET bit. Reset value: 0x0 */
      __IM  uint32_t R_GEN_CALL : 1;            /*!< [11..11] See IC_RAW_INTR_STAT for a detailed description of R_GEN_CALL bit. Reset value: 0x0 */
      __IM  uint32_t R_RESTART_DET : 1;         /*!< [12..12] See IC_RAW_INTR_STAT for a detailed description of R_RESTART_DET bit. Reset value: 0x0 */
            uint32_t            : 19;
    } IC_INTR_STAT_b;
  } ;

  union {
    __IOM uint32_t IC_INTR_MASK;                /*!< (@ 0x00000030) I2C Interrupt Mask Register. These bits mask their corresponding interrupt status bits. This register is active low; a value of 0 masks the interrupt, whereas a value of 1 unmasks the interrupt. */

    struct {
      __IOM uint32_t M_RX_UNDER : 1;            /*!< [0..0] This bit masks the R_RX_UNDER interrupt in IC_INTR_STAT register. Reset value: 0x1 */
      __IOM uint32_t M_RX_OVER  : 1;            /*!< [1..1] This bit masks the R_RX_OVER interrupt in IC_INTR_STAT register. Reset value: 0x1 */
      __IOM uint32_t M_RX_FULL  : 1;            /*!< [2..2] This bit masks the R_RX_FULL interrupt in IC_INTR_STAT register. Reset value: 0x1 */
      __IOM uint32_t M_TX_OVER  : 1;            /*!< [3..3] This bit masks the R_TX_OVER interrupt in IC_INTR_STAT register. Reset value: 0x1 */
      __IOM uint32_t M_TX_EMPTY : 1;            /*!< [4..4] This bit masks the R_TX_EMPTY interrupt in IC_INTR_STAT register. Reset value: 0x1 */
      __IOM uint32_t M_RD_REQ   : 1;            /*!< [5..5] This bit masks the R_RD_REQ interrupt in IC_INTR_STAT register. Reset value: 0x1 */
      __IOM uint32_t M_TX_ABRT  : 1;            /*!< [6..6] This bit masks the R_TX_ABRT interrupt in IC_INTR_STAT register. Reset value: 0x1 */
      __IOM uint32_t M_RX_DONE  : 1;            /*!< [7..7] This bit masks the R_RX_DONE interrupt in IC_INTR_STAT register. Reset value: 0x1 */
      __IOM uint32_t M_ACTIVITY : 1;            /*!< [8..8] This bit masks the R_ACTIVITY interrupt in IC_INTR_STAT register. Reset value: 0x0 */
      __IOM uint32_t M_STOP_DET : 1;            /*!< [9..9] This bit masks the R_STOP_DET interrupt in IC_INTR_STAT register. Reset value: 0x0 */
      __IOM uint32_t M_START_DET : 1;           /*!< [10..10] This bit masks the R_START_DET interrupt in IC_INTR_STAT register. Reset value: 0x0 */
      __IOM uint32_t M_GEN_CALL : 1;            /*!< [11..11] This bit masks the R_GEN_CALL interrupt in IC_INTR_STAT register. Reset value: 0x1 */
      __IOM uint32_t M_RESTART_DET : 1;         /*!< [12..12] This bit masks the R_RESTART_DET interrupt in IC_INTR_STAT register. Reset value: 0x0 */
            uint32_t            : 19;
    } IC_INTR_MASK_b;
  } ;

  union {
    __IOM uint32_t IC_RAW_INTR_STAT;            /*!< (@ 0x00000034) I2C Raw Interrupt Status Register Unlike the IC_INTR_STAT register, these bits are not masked so they always show the true status of the DW_apb_i2c. */

    struct {
      __IM  uint32_t RX_UNDER   : 1;            /*!< [0..0] Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. Reset value: 0x0 */
      __IM  uint32_t RX_OVER    : 1;            /*!< [1..1] Set if the receive buffer is completely filled to IC_RX_BUFFER_DEPTH and an additional byte is received from an external I2C device. The DW_apb_i2c acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. Note: If bit 9 of the IC_CON register (RX_FIFO_FULL_HLD_CTRL) is programmed to HIG */
      __IM  uint32_t RX_FULL    : 1;            /*!< [2..2] Set when the receive buffer reaches or goes above the RX_TL threshold in the IC_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (IC_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the IC_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues. Reset value: 0x0 */
      __IM  uint32_t TX_OVER    : 1;            /*!< [3..3] Set during transmit if the transmit buffer is filled to IC_TX_BUFFER_DEPTH and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. Reset value: 0x0 */
      __IM  uint32_t TX_EMPTY   : 1;            /*!< [4..4] The behavior of the TX_EMPTY interrupt status differs based on the TX_EMPTY_CTRL selection in the IC_CON register. - When TX_EMPTY_CTRL = 0: This bit is set to 1 when the transmit buffer is at or below the threshold value set in the IC_TX_TL register. - When TX_EMPTY_CTRL = 1: This bit is set to 1 when the transmit buffer is at or below the threshold value set in the IC_TX_TL register and the transmission of the address/data from the internal shift register for the most recently popped command is complet */
      __IM  uint32_t RD_REQ     : 1;            /*!< [5..5] This bit is set to 1 when DW_apb_i2c is acting as a slave and another I2C master is attempting to read data from DW_apb_i2c. The DW_apb_i2c holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the IC_DATA_CMD register. This bit is set to 0 just after the processor reads the IC_CLR_RD_REQ registe */
      __IM  uint32_t TX_ABRT    : 1;            /*!< [6..6] This bit indicates if DW_apb_i2c, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a 'transmit abort'. When this bit is set to 1, the IC_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places. Note: The DW_apb_i2c flushes/resets/empties the TX_FIFO and RX_FIFO whenever there is a transmit abort caused by any of the eve */
      __IM  uint32_t RX_DONE    : 1;            /*!< [7..7] When the DW_apb_i2c is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done. Reset value: 0x0 */
      __IM  uint32_t ACTIVITY   : 1;            /*!< [8..8] This bit captures DW_apb_i2c activity and stays set until it is cleared. There are four ways to clear it: - Disabling the DW_apb_i2c - Reading the IC_CLR_ACTIVITY register - Reading the IC_CLR_INTR register - System reset Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the DW_apb_i2c module is idle, this bit remains set until cleared, indicating that there was activity on the bus. Reset value: 0x0 */
      __IM  uint32_t STOP_DET   : 1;            /*!< [9..9] Indicates whether a STOP condition has occurred on the I2C interface regardless of whether DW_apb_i2c is operating in slave or master mode. In Slave Mode: - If IC_CON[7]=1'b1 (STOP_DET_IFADDRESSED), the STOP_DET interrupt will be issued only if slave is addressed. Note: During a general call address, this slave does not issue a STOP_DET interrupt if STOP_DET_IF_ADDRESSED=1'b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generat */
      __IM  uint32_t START_DET  : 1;            /*!< [10..10] Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether DW_apb_i2c is operating in slave or master mode. Reset value: 0x0 */
      __IM  uint32_t GEN_CALL   : 1;            /*!< [11..11] Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling DW_apb_i2c or when the CPU reads bit 0 of the IC_CLR_GEN_CALL register. DW_apb_i2c stores the received data in the Rx buffer. Reset value: 0x0 */
      __IM  uint32_t RESTART_DET : 1;           /*!< [12..12] Indicates whether a RESTART condition has occurred on the I2C interface when DW_apb_i2c is operating in Slave mode and the slave is being addressed. Enabled only when IC_SLV_RESTART_DET_EN=1. Note: However, in high-speed mode or during a START BYTE transfer, the RESTART comes before the address field as per the I2C protocol. In this case, the slave is not the addressed slave when the RESTART is issued, therefore DW_apb_i2c does not generate the RESTART_DET interrupt. */
            uint32_t            : 19;
    } IC_RAW_INTR_STAT_b;
  } ;

  union {
    __IOM uint32_t IC_RX_TL;                    /*!< (@ 0x00000038) I2C Receive FIFO Threshold Register */

    struct {
      __IOM uint32_t RX_TL      : 8;            /*!< [7..0] Receive FIFO Threshold Level. Controls the level of entries (or above) that triggers the RX_FULL interrupt (bit 2 in IC_RAW_INTR_STAT register). The valid range is 0-255, with the additional restriction that hardware does not allow this value to be set to a value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 1 entry, and a value of 255 sets the threshold for 256 */
            uint32_t            : 24;
    } IC_RX_TL_b;
  } ;

  union {
    __IOM uint32_t IC_TX_TL;                    /*!< (@ 0x0000003C) I2C Transmit FIFO Threshold Register */

    struct {
      __IOM uint32_t TX_TL      : 8;            /*!< [7..0] Transmit FIFO Threshold Level. Controls the level of entries (or below) that trigger the TX_EMPTY interrupt (bit 4 in IC_RAW_INTR_STAT register). The valid range is 0-255, with the additional restriction that it may not be set to value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 0 entries, and a value of 255 sets the threshold for 255 entries. */
            uint32_t            : 24;
    } IC_TX_TL_b;
  } ;

  union {
    __IOM uint32_t IC_CLR_INTR;                 /*!< (@ 0x00000040) Clear Combined and Individual Interrupt Register */

    struct {
      __IM  uint32_t CLR_INTR   : 1;            /*!< [0..0] Read this register to clear the combined interrupt, all individual interrupts, and the IC_TX_ABRT_SOURCE register. This bit does not clear hardware clearable interrupts but software clearable interrupts. Refer to Bit 9 of the IC_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE. Reset value: 0x0 */
            uint32_t            : 31;
    } IC_CLR_INTR_b;
  } ;

  union {
    __IOM uint32_t IC_CLR_RX_UNDER;             /*!< (@ 0x00000044) Clear RX_UNDER Interrupt Register */

    struct {
      __IM  uint32_t CLR_RX_UNDER : 1;          /*!< [0..0] Read this register to clear the RX_UNDER interrupt (bit 0) of the IC_RAW_INTR_STAT register. Reset value: 0x0 */
            uint32_t            : 31;
    } IC_CLR_RX_UNDER_b;
  } ;

  union {
    __IOM uint32_t IC_CLR_RX_OVER;              /*!< (@ 0x00000048) Clear RX_OVER Interrupt Register */

    struct {
      __IM  uint32_t CLR_RX_OVER : 1;           /*!< [0..0] Read this register to clear the RX_OVER interrupt (bit 1) of the IC_RAW_INTR_STAT register. Reset value: 0x0 */
            uint32_t            : 31;
    } IC_CLR_RX_OVER_b;
  } ;

  union {
    __IOM uint32_t IC_CLR_TX_OVER;              /*!< (@ 0x0000004C) Clear TX_OVER Interrupt Register */

    struct {
      __IM  uint32_t CLR_TX_OVER : 1;           /*!< [0..0] Read this register to clear the TX_OVER interrupt (bit 3) of the IC_RAW_INTR_STAT register. Reset value: 0x0 */
            uint32_t            : 31;
    } IC_CLR_TX_OVER_b;
  } ;

  union {
    __IOM uint32_t IC_CLR_RD_REQ;               /*!< (@ 0x00000050) Clear RD_REQ Interrupt Register */

    struct {
      __IM  uint32_t CLR_RD_REQ : 1;            /*!< [0..0] Read this register to clear the RD_REQ interrupt (bit 5) of the IC_RAW_INTR_STAT register. Reset value: 0x0 */
            uint32_t            : 31;
    } IC_CLR_RD_REQ_b;
  } ;

  union {
    __IOM uint32_t IC_CLR_TX_ABRT;              /*!< (@ 0x00000054) Clear TX_ABRT Interrupt Register */

    struct {
      __IM  uint32_t CLR_TX_ABRT : 1;           /*!< [0..0] Read this register to clear the TX_ABRT interrupt (bit 6) of the IC_RAW_INTR_STAT register, and the IC_TX_ABRT_SOURCE register. This also releases the TX FIFO from the flushed/reset state, allowing more writes to the TX FIFO. Refer to Bit 9 of the IC_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE. Reset value: 0x0 */
            uint32_t            : 31;
    } IC_CLR_TX_ABRT_b;
  } ;

  union {
    __IOM uint32_t IC_CLR_RX_DONE;              /*!< (@ 0x00000058) Clear RX_DONE Interrupt Register */

    struct {
      __IM  uint32_t CLR_RX_DONE : 1;           /*!< [0..0] Read this register to clear the RX_DONE interrupt (bit 7) of the IC_RAW_INTR_STAT register. Reset value: 0x0 */
            uint32_t            : 31;
    } IC_CLR_RX_DONE_b;
  } ;

  union {
    __IOM uint32_t IC_CLR_ACTIVITY;             /*!< (@ 0x0000005C) Clear ACTIVITY Interrupt Register */

    struct {
      __IM  uint32_t CLR_ACTIVITY : 1;          /*!< [0..0] Reading this register clears the ACTIVITY interrupt if the I2C is not active anymore. If the I2C module is still active on the bus, the ACTIVITY interrupt bit continues to be set. It is automatically cleared by hardware if the module is disabled and if there is no further activity on the bus. The value read from this register to get status of the ACTIVITY interrupt (bit 8) of the IC_RAW_INTR_STAT register. Reset value: 0x0 */
            uint32_t            : 31;
    } IC_CLR_ACTIVITY_b;
  } ;

  union {
    __IOM uint32_t IC_CLR_STOP_DET;             /*!< (@ 0x00000060) Clear STOP_DET Interrupt Register */

    struct {
      __IM  uint32_t CLR_STOP_DET : 1;          /*!< [0..0] Read this register to clear the STOP_DET interrupt (bit 9) of the IC_RAW_INTR_STAT register. Reset value: 0x0 */
            uint32_t            : 31;
    } IC_CLR_STOP_DET_b;
  } ;

  union {
    __IOM uint32_t IC_CLR_START_DET;            /*!< (@ 0x00000064) Clear START_DET Interrupt Register */

    struct {
      __IM  uint32_t CLR_START_DET : 1;         /*!< [0..0] Read this register to clear the START_DET interrupt (bit 10) of the IC_RAW_INTR_STAT register. Reset value: 0x0 */
            uint32_t            : 31;
    } IC_CLR_START_DET_b;
  } ;

  union {
    __IOM uint32_t IC_CLR_GEN_CALL;             /*!< (@ 0x00000068) Clear GEN_CALL Interrupt Register */

    struct {
      __IM  uint32_t CLR_GEN_CALL : 1;          /*!< [0..0] Read this register to clear the GEN_CALL interrupt (bit 11) of IC_RAW_INTR_STAT register. Reset value: 0x0 */
            uint32_t            : 31;
    } IC_CLR_GEN_CALL_b;
  } ;

  union {
    __IOM uint32_t IC_ENABLE;                   /*!< (@ 0x0000006C) I2C Enable Register */

    struct {
      __IOM uint32_t ENABLE     : 1;            /*!< [0..0] Controls whether the DW_apb_i2c is enabled. - 0: Disables DW_apb_i2c (TX and RX FIFOs are held in an erased state) - 1: Enables DW_apb_i2c Software can disable DW_apb_i2c while it is active. However, it is important that care be taken to ensure that DW_apb_i2c is disabled properly. A recommended procedure is described in 'Disabling DW_apb_i2c'. When DW_apb_i2c is disabled, the following occurs: - The TX FIFO and RX FIFO get flushed. - Status bits in the IC_INTR_STAT register are stil */
      __IOM uint32_t ABORT      : 1;            /*!< [1..1] When set, the controller initiates the transfer abort. - 0: ABORT not initiated or ABORT done - 1: ABORT operation in progress The software can abort the I2C transfer in master mode by setting this bit. The software can set this bit only when ENABLE is already set; otherwise, the controller ignores any write to ABORT bit. The software cannot clear the ABORT bit once set. In response to an ABORT, the controller issues a STOP and flushes the Tx FIFO after completing the current transfer, then sets the TX_A */
      __IOM uint32_t TX_CMD_BLOCK : 1;          /*!< [2..2] In Master mode: - 1'b1: Blocks the transmission of data on I2C bus even if Tx FIFO has data to transmit. - 1'b0: The transmission of data starts on I2C bus automatically, as soon as the first data is available in the Tx FIFO. Note: To block the execution of Master commands, set the TX_CMD_BLOCK bit only when Tx FIFO is empty (IC_STATUS[2]==1) and Master is in Idle state (IC_STATUS[5] == 0). Any further commands put in the Tx FIFO are not executed until TX_CMD_BLOCK bit is unset. Reset value: IC_TX_CMD_B */
            uint32_t            : 29;
    } IC_ENABLE_b;
  } ;

  union {
    __IOM uint32_t IC_STATUS;                   /*!< (@ 0x00000070) I2C Status Register This is a read-only register used to indicate the current transfer status and FIFO status. The status register may be read at any time. None of the bits in this register request an interrupt. When the I2C is disabled by writing 0 in bit 0 of the IC_ENABLE register: - Bits 1 and 2 are set to 1 - Bits 3 and 10 are set to 0 When the master or slave state machines goes to idle and ic_en=0: - Bits 5 and 6 are set to 0 */

    struct {
      __IM  uint32_t ACTIVITY   : 1;            /*!< [0..0] I2C Activity Status. Reset value: 0x0 */
      __IM  uint32_t TFNF       : 1;            /*!< [1..1] Transmit FIFO Not Full. Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full. - 0: Transmit FIFO is full - 1: Transmit FIFO is not full Reset value: 0x1 */
      __IM  uint32_t TFE        : 1;            /*!< [2..2] Transmit FIFO Completely Empty. When the transmit FIFO is completely empty, this bit is set. When it contains one or more valid entries, this bit is cleared. This bit field does not request an interrupt. - 0: Transmit FIFO is not empty - 1: Transmit FIFO is empty Reset value: 0x1 */
      __IM  uint32_t RFNE       : 1;            /*!< [3..3] Receive FIFO Not Empty. This bit is set when the receive FIFO contains one or more entries; it is cleared when the receive FIFO is empty. - 0: Receive FIFO is empty - 1: Receive FIFO is not empty Reset value: 0x0 */
      __IM  uint32_t RFF        : 1;            /*!< [4..4] Receive FIFO Completely Full. When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared. - 0: Receive FIFO is not full - 1: Receive FIFO is full Reset value: 0x0 */
      __IM  uint32_t MST_ACTIVITY : 1;          /*!< [5..5] Master FSM Activity Status. When the Master Finite State Machine (FSM) is not in the IDLE state, this bit is set. - 0: Master FSM is in IDLE state so the Master part of DW_apb_i2c is not Active - 1: Master FSM is not in IDLE state so the Master part of DW_apb_i2c is Active Note: IC_STATUS[0]-that is, ACTIVITY bit-is the OR of SLV_ACTIVITY and MST_ACTIVITY bits. Reset value: 0x0 */
      __IM  uint32_t SLV_ACTIVITY : 1;          /*!< [6..6] Slave FSM Activity Status. When the Slave Finite State Machine (FSM) is not in the IDLE state, this bit is set. - 0: Slave FSM is in IDLE state so the Slave part of DW_apb_i2c is not Active - 1: Slave FSM is not in IDLE state so the Slave part of DW_apb_i2c is Active Reset value: 0x0 */
            uint32_t            : 25;
    } IC_STATUS_b;
  } ;

  union {
    __IOM uint32_t IC_TXFLR;                    /*!< (@ 0x00000074) I2C Transmit FIFO Level Register This register contains the number of valid data entries in the transmit FIFO buffer. It is cleared whenever: - The I2C is disabled - There is a transmit abort - that is, TX_ABRT bit is set in the IC_RAW_INTR_STAT register - The slave bulk transmit mode is aborted The register increments whenever data is placed into the transmit FIFO and decrements when data is taken from the transmit FIFO. */

    struct {
      __IM  uint32_t TXFLR      : 5;            /*!< [4..0] Transmit FIFO Level. Contains the number of valid data entries in the transmit FIFO. Reset value: 0x0 */
            uint32_t            : 27;
    } IC_TXFLR_b;
  } ;

  union {
    __IOM uint32_t IC_RXFLR;                    /*!< (@ 0x00000078) I2C Receive FIFO Level Register This register contains the number of valid data entries in the receive FIFO buffer. It is cleared whenever: - The I2C is disabled - Whenever there is a transmit abort caused by any of the events tracked in IC_TX_ABRT_SOURCE The register increments whenever data is placed into the receive FIFO and decrements when data is taken from the receive FIFO. */

    struct {
      __IM  uint32_t RXFLR      : 5;            /*!< [4..0] Receive FIFO Level. Contains the number of valid data entries in the receive FIFO. Reset value: 0x0 */
            uint32_t            : 27;
    } IC_RXFLR_b;
  } ;

  union {
    __IOM uint32_t IC_SDA_HOLD;                 /*!< (@ 0x0000007C) I2C SDA Hold Time Length Register The bits [15:0] of this register are used to control the hold time of SDA during transmit in both slave and master mode (after SCL goes from HIGH to LOW). The bits [23:16] of this register are used to extend the SDA transition (if any) whenever SCL is HIGH in the receiver in either master or slave mode. Writes to this register succeed only when IC_ENABLE[0]=0. The values in this register a */

    struct {
      __IOM uint32_t IC_SDA_TX_HOLD : 16;       /*!< [15..0] Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts as a transmitter. Reset value: IC_DEFAULT_SDA_HOLD[15:0]. */
      __IOM uint32_t IC_SDA_RX_HOLD : 8;        /*!< [23..16] Sets the required SDA hold time in units of ic_clk period, when DW_apb_i2c acts as a receiver. Reset value: IC_DEFAULT_SDA_HOLD[23:16]. */
            uint32_t            : 8;
    } IC_SDA_HOLD_b;
  } ;

  union {
    __IOM uint32_t IC_TX_ABRT_SOURCE;           /*!< (@ 0x00000080) I2C Transmit Abort Source Register This register has 32 bits that indicate the source of the TX_ABRT bit. Except for Bit 9, this register is cleared whenever the IC_CLR_TX_ABRT register or the IC_CLR_INTR register is read. To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; RESTART must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]). Once the source of the AB */

    struct {
      __IM  uint32_t ABRT_7B_ADDR_NOACK : 1;    /*!< [0..0] This field indicates that the Master is in 7-bit addressing mode and the address sent was not acknowledged by any slave. Reset value: 0x0 Role of DW_apb_i2c: Master-Transmitter or Master-Receiver */
      __IM  uint32_t ABRT_10ADDR1_NOACK : 1;    /*!< [1..1] This field indicates that the Master is in 10-bit address mode and the first 10-bit address byte was not acknowledged by any slave. Reset value: 0x0 Role of DW_apb_i2c: Master-Transmitter or Master-Receiver */
      __IM  uint32_t ABRT_10ADDR2_NOACK : 1;    /*!< [2..2] This field indicates that the Master is in 10-bit address mode and that the second address byte of the 10-bit address was not acknowledged by any slave. Reset value: 0x0 Role of DW_apb_i2c: Master-Transmitter or Master-Receiver */
      __IM  uint32_t ABRT_TXDATA_NOACK : 1;     /*!< [3..3] This field indicates the master-mode only bit. When the master receives an acknowledgement for the address, but when it sends data byte(s) following the address, it did not receive an acknowledge from the remote slave(s). Reset value: 0x0 Role of DW_apb_i2c: Master-Transmitter */
      __IM  uint32_t ABRT_GCALL_NOACK : 1;      /*!< [4..4] This field indicates that DW_apb_i2c in master mode has sent a General Call and no slave on the bus acknowledged the General Call. Reset value: 0x0 Role of DW_apb_i2c: Master-Transmitter */
      __IM  uint32_t ABRT_GCALL_READ : 1;       /*!< [5..5] This field indicates that DW_apb_i2c in the master mode has sent a General Call but the user programmed the byte following the General Call to be a read from the bus (IC_DATA_CMD[9] is set to 1). Reset value: 0x0 Role of DW_apb_i2c: Master-Transmitter */
      __IM  uint32_t ABRT_HS_ACKDET : 1;        /*!< [6..6] This field indicates that the Master is in High Speed mode and the High Speed Master code was acknowledged (wrong behavior). Reset value: 0x0 Role of DW_apb_i2c: Master */
      __IM  uint32_t ABRT_SBYTE_ACKDET : 1;     /*!< [7..7] This field indicates that the Master has sent a START Byte and the START Byte was acknowledged (wrong behavior). Reset value: 0x0 Role of DW_apb_i2c: Master */
      __IM  uint32_t ABRT_HS_NORSTRT : 1;       /*!< [8..8] This field indicates that the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the user is trying to use the master to transfer data in High Speed mode. Reset value: 0x0 Role of DW_apb_i2c: Master-Transmitter or Master-Receiver */
      __IM  uint32_t ABRT_SBYTE_NORSTRT : 1;    /*!< [9..9] To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; restart must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, bit 9 clears for one cycle and then gets reasserted. When this field is set */
      __IM  uint32_t ABRT_10B_RD_NORSTRT : 1;   /*!< [10..10] This field indicates that the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) =0) and the master sends a read command in 10-bit addressing mode. Reset value: 0x0 Role of DW_apb_i2c: Master-Receiver */
      __IM  uint32_t ABRT_MASTER_DIS : 1;       /*!< [11..11] This field indicates that the User tries to initiate a Master operation with the Master mode disabled. Reset value: 0x0 Role of DW_apb_i2c: Master-Transmitter or Master-Receiver */
      __IM  uint32_t ARB_LOST   : 1;            /*!< [12..12] This field specifies that the Master has lost arbitration, or if IC_TX_ABRT_SOURCE[14] is also set, then the slave transmitter has lost arbitration. Reset value: 0x0 Role of DW_apb_i2c: Master-Transmitter or Slave-Transmitter */
      __IM  uint32_t ABRT_SLVFLUSH_TXFIFO : 1;  /*!< [13..13] This field specifies that the Slave has received a read command and some data exists in the TX FIFO, so the slave issues a TX_ABRT interrupt to flush old data in TX FIFO. Reset value: 0x0 Role of DW_apb_i2c: Slave-Transmitter */
      __IM  uint32_t ABRT_SLV_ARBLOST : 1;      /*!< [14..14] This field indicates that a Slave has lost the bus while transmitting data to a remote master. IC_TX_ABRT_SOURCE[12] is set at the same time. Note: Even though the slave never 'owns' the bus, something could go wrong on the bus. This is a fail safe check. For instance, during a data transmission at the low-to-high transition of SCL, if what is on the data bus is not what is supposed to be transmitted, then DW_apb_i2c no longer own the bus. Reset value: 0x0 Role */
      __IM  uint32_t ABRT_SLVRD_INTX : 1;       /*!< [15..15] 1: When the processor side responds to a slave mode request for data to be transmitted to a remote master and user writes a 1 in CMD (bit 8) of IC_DATA_CMD register. Reset value: 0x0 Role of DW_apb_i2c: Slave-Transmitter */
      __IM  uint32_t ABRT_USER_ABRT : 1;        /*!< [16..16] This is a master-mode-only bit. Master has detected the transfer abort (IC_ENABLE[1]) Reset value: 0x0 Role of DW_apb_i2c: Master-Transmitter */
            uint32_t            : 6;
      __IM  uint32_t TX_FLUSH_CNT : 9;          /*!< [31..23] This field indicates the number of Tx FIFO Data Commands which are flushed due to TX_ABRT interrupt. It is cleared whenever I2C is disabled. Reset value: 0x0 Role of DW_apb_i2c: Master-Transmitter or Slave-Transmitter */
    } IC_TX_ABRT_SOURCE_b;
  } ;

  union {
    __IOM uint32_t IC_SLV_DATA_NACK_ONLY;       /*!< (@ 0x00000084) Generate Slave Data NACK Register The register is used to generate a NACK for the data part of a transfer when DW_apb_i2c is acting as a slave-receiver. This register only exists when the IC_SLV_DATA_NACK_ONLY parameter is set to 1. When this parameter disabled, this register does not exist and writing to the register's address has no effect. A write can occur on this register if both of the following conditions are met: - DW_apb_i2c is disabled (IC_ENABLE */

    struct {
      __IOM uint32_t NACK       : 1;            /*!< [0..0] Generate NACK. This NACK generation only occurs when DW_apb_i2c is a slave-receiver. If this register is set to a value of 1, it can only generate a NACK after a data byte is received; hence, the data transfer is aborted and the data received is not pushed to the receive buffer. When the register is set to a value of 0, it generates NACK/ACK, depending on normal criteria. - 1: generate NACK after data byte received - 0: generate NACK/ACK normally Reset value: 0x0 */
            uint32_t            : 31;
    } IC_SLV_DATA_NACK_ONLY_b;
  } ;

  union {
    __IOM uint32_t IC_DMA_CR;                   /*!< (@ 0x00000088) DMA Control Register The register is used to enable the DMA Controller interface operation. There is a separate bit for transmit and receive. This can be programmed regardless of the state of IC_ENABLE. */

    struct {
      __IOM uint32_t RDMAE      : 1;            /*!< [0..0] Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel. Reset value: 0x0 */
      __IOM uint32_t TDMAE      : 1;            /*!< [1..1] Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA channel. Reset value: 0x0 */
            uint32_t            : 30;
    } IC_DMA_CR_b;
  } ;

  union {
    __IOM uint32_t IC_DMA_TDLR;                 /*!< (@ 0x0000008C) DMA Transmit Data Level Register */

    struct {
      __IOM uint32_t DMATDL     : 4;            /*!< [3..0] Transmit Data Level. This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the watermark level; that is, the dma_tx_req signal is generated when the number of valid data entries in the transmit FIFO is equal to or below this field value, and TDMAE = 1. Reset value: 0x0 */
            uint32_t            : 28;
    } IC_DMA_TDLR_b;
  } ;

  union {
    __IOM uint32_t IC_DMA_RDLR;                 /*!< (@ 0x00000090) I2C Receive Data Level Register */

    struct {
      __IOM uint32_t DMARDL     : 4;            /*!< [3..0] Receive Data Level. This bit field controls the level at which a DMA request is made by the receive logic. The watermark level = DMARDL+1; that is, dma_rx_req is generated when the number of valid data entries in the receive FIFO is equal to or more than this field value + 1, and RDMAE =1. For instance, when DMARDL is 0, then dma_rx_req is asserted when 1 or more data entries are present in the receive FIFO. Reset value: 0x0 */
            uint32_t            : 28;
    } IC_DMA_RDLR_b;
  } ;

  union {
    __IOM uint32_t IC_SDA_SETUP;                /*!< (@ 0x00000094) I2C SDA Setup Register This register controls the amount of time delay (in terms of number of ic_clk clock periods) introduced in the rising edge of SCL - relative to SDA changing - when DW_apb_i2c services a read request in a slave-transmitter operation. The relevant I2C requirement is tSU:DAT (note 4) as detailed in the I2C Bus Specification. This register must be programmed with a value equal to or greater than 2. Writes to this register succeed only wh */

    struct {
      __IOM uint32_t SDA_SETUP  : 8;            /*!< [7..0] SDA Setup. It is recommended that if the required delay is 1000ns, then for an ic_clk frequency of 10 MHz, IC_SDA_SETUP should be programmed to a value of 11. IC_SDA_SETUP must be programmed with a minimum value of 2. */
            uint32_t            : 24;
    } IC_SDA_SETUP_b;
  } ;

  union {
    __IOM uint32_t IC_ACK_GENERAL_CALL;         /*!< (@ 0x00000098) I2C ACK General Call Register The register controls whether DW_apb_i2c responds with a ACK or NACK when it receives an I2C General Call address. This register is applicable only when the DW_apb_i2c is in slave mode. */

    struct {
      __IOM uint32_t ACK_GEN_CALL : 1;          /*!< [0..0] ACK General Call. When set to 1, DW_apb_i2c responds with a ACK (by asserting ic_data_oe) when it receives a General Call. Otherwise, DW_apb_i2c responds with a NACK (by negating ic_data_oe). */
            uint32_t            : 31;
    } IC_ACK_GENERAL_CALL_b;
  } ;

  union {
    __IOM uint32_t IC_ENABLE_STATUS;            /*!< (@ 0x0000009C) I2C Enable Status Register The register is used to report the DW_apb_i2c hardware status when the IC_ENABLE[0] register is set from 1 to 0; that is, when DW_apb_i2c is disabled. If IC_ENABLE[0] has been set to 1, bits 2:1 are forced to 0, and bit 0 is forced to 1. If IC_ENABLE[0] has been set to 0, bits 2:1 is only be valid as soon as bit 0 is read as '0'. Note: When IC_ENABLE[0] has been set to 0, a delay occurs for bit 0 */

    struct {
      __IM  uint32_t IC_EN      : 1;            /*!< [0..0] ic_en Status. This bit always reflects the value driven on the output port ic_en. - When read as 1, DW_apb_i2c is deemed to be in an enabled state. - When read as 0, DW_apb_i2c is deemed completely inactive. Note: The CPU can safely read this bit anytime. When this bit is read as 0, the CPU can safely read SLV_RX_DATA_LOST (bit 2) and SLV_DISABLED_WHILE_BUSY (bit 1). Reset value: 0x0 */
      __IM  uint32_t SLV_DISABLED_WHILE_BUSY : 1;/*!< [1..1] Slave Disabled While Busy (Transmit, Receive). This bit indicates if a potential or active Slave operation has been aborted due to the setting bit 0 of the IC_ENABLE register from 1 to 0. This bit is set when the CPU writes a 0 to the IC_ENABLE register while: (a) DW_apb_i2c is receiving the address byte of the Slave-Transmitter operation from a remote master; OR, (b) address and data bytes of the Slave-Receiver operation from a remote master */
      __IM  uint32_t SLV_RX_DATA_LOST : 1;      /*!< [2..2] Slave Received Data Lost. This bit indicates if a Slave-Receiver operation has been aborted with at least one data byte received from an I2C transfer due to the setting bit 0 of IC_ENABLE from 1 to 0. When read as 1, DW_apb_i2c is deemed to have been actively engaged in an aborted I2C transfer (with matching address) and the data phase of the I2C transfer has been entered, even though a data byte has been responded with a NACK. Note: If the remote I2C master terminates the transfer */
            uint32_t            : 29;
    } IC_ENABLE_STATUS_b;
  } ;

  union {
    __IOM uint32_t IC_FS_SPKLEN;                /*!< (@ 0x000000A0) I2C SS, FS or FM+ spike suppression limit This register is used to store the duration, measured in ic_clk cycles, of the longest spike that is filtered out by the spike suppression logic when the component is operating in SS, FS or FM+ modes. The relevant I2C requirement is tSP (table 4) as detailed in the I2C Bus Specification. This register must be programmed with a minimum value of 1. */

    struct {
      __IOM uint32_t IC_FS_SPKLEN : 8;          /*!< [7..0] This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect. The minimum valid value is 1; hardware prevents values less than this being */
            uint32_t            : 24;
    } IC_FS_SPKLEN_b;
  } ;
  __IM  uint32_t  RESERVED2;

  union {
    __IOM uint32_t IC_CLR_RESTART_DET;          /*!< (@ 0x000000A8) Clear RESTART_DET Interrupt Register */

    struct {
      __IM  uint32_t CLR_RESTART_DET : 1;       /*!< [0..0] Read this register to clear the RESTART_DET interrupt (bit 12) of IC_RAW_INTR_STAT register. Reset value: 0x0 */
            uint32_t            : 31;
    } IC_CLR_RESTART_DET_b;
  } ;
  __IM  uint32_t  RESERVED3[18];

  union {
    __IOM uint32_t IC_COMP_PARAM_1;             /*!< (@ 0x000000F4) Component Parameter Register 1 Note This register is not implemented and therefore reads as 0. If it was implemented it would be a constant read-only register that contains encoded information about the component's parameter settings. Fields shown below are the settings for those parameters */

    struct {
      __IM  uint32_t APB_DATA_WIDTH : 2;        /*!< [1..0] APB data bus width is 32 bits */
      __IM  uint32_t MAX_SPEED_MODE : 2;        /*!< [3..2] MAX SPEED MODE = FAST MODE */
      __IM  uint32_t HC_COUNT_VALUES : 1;       /*!< [4..4] Programmable count values for each mode. */
      __IM  uint32_t INTR_IO    : 1;            /*!< [5..5] COMBINED Interrupt outputs */
      __IM  uint32_t HAS_DMA    : 1;            /*!< [6..6] DMA handshaking signals are enabled */
      __IM  uint32_t ADD_ENCODED_PARAMS : 1;    /*!< [7..7] Encoded parameters not visible */
      __IM  uint32_t RX_BUFFER_DEPTH : 8;       /*!< [15..8] RX Buffer Depth = 16 */
      __IM  uint32_t TX_BUFFER_DEPTH : 8;       /*!< [23..16] TX Buffer Depth = 16 */
            uint32_t            : 8;
    } IC_COMP_PARAM_1_b;
  } ;

  union {
    __IOM uint32_t IC_COMP_VERSION;             /*!< (@ 0x000000F8) I2C Component Version Register */

    struct {
      __IM  uint32_t IC_COMP_VERSION : 32;      /*!< [31..0] IC_COMP_VERSION */
    } IC_COMP_VERSION_b;
  } ;

  union {
    __IOM uint32_t IC_COMP_TYPE;                /*!< (@ 0x000000FC) I2C Component Type Register */

    struct {
      __IM  uint32_t IC_COMP_TYPE : 32;         /*!< [31..0] Designware Component Type number = 0x44_57_01_40. This assigned unique hex value is constant and is derived from the two ASCII letters 'DW' followed by a 16-bit unsigned number. */
    } IC_COMP_TYPE_b;
  } ;
} I2C0_Type;                                    /*!< Size = 256 (0x100) */



/* =========================================================================================================================== */
/* ================                                            ADC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Control and data interface to SAR ADC (ADC)
  */

typedef struct {                                /*!< (@ 0x4004C000) ADC Structure */

  union {
    __IOM uint32_t CS;                          /*!< (@ 0x00000000) ADC Control and Status */

    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Power on ADC and enable its clock. 1 - enabled. 0 - disabled. */
      __IOM uint32_t TS_EN      : 1;            /*!< [1..1] Power on temperature sensor. 1 - enabled. 0 - disabled. */
      __IOM uint32_t START_ONCE : 1;            /*!< [2..2] Start a single conversion. Self-clearing. Ignored if start_many is asserted. */
      __IOM uint32_t START_MANY : 1;            /*!< [3..3] Continuously perform conversions whilst this bit is 1. A new conversion will start immediately after the previous finishes. */
            uint32_t            : 4;
      __IM  uint32_t READY      : 1;            /*!< [8..8] 1 if the ADC is ready to start a new conversion. Implies any previous conversion has completed. 0 whilst conversion in progress. */
      __IM  uint32_t ERR        : 1;            /*!< [9..9] The most recent ADC conversion encountered an error; result is undefined or noisy. */
      __IOM uint32_t ERR_STICKY : 1;            /*!< [10..10] Some past ADC conversion encountered an error. Write 1 to clear. */
            uint32_t            : 1;
      __IOM uint32_t AINSEL     : 3;            /*!< [14..12] Select analog mux input. Updated automatically in round-robin mode. */
            uint32_t            : 1;
      __IOM uint32_t RROBIN     : 5;            /*!< [20..16] Round-robin sampling. 1 bit per channel. Set all bits to 0 to disable. Otherwise, the ADC will cycle through each enabled channel in a round-robin fashion. The first channel to be sampled will be the one currently indicated by AINSEL. AINSEL will be updated after each conversion with the newly-selected channel. */
            uint32_t            : 11;
    } CS_b;
  } ;

  union {
    __IOM uint32_t RESULT;                      /*!< (@ 0x00000004) Result of most recent ADC conversion */

    struct {
      __IM  uint32_t RESULT     : 12;           /*!< [11..0] RESULT */
            uint32_t            : 20;
    } RESULT_b;
  } ;

  union {
    __IOM uint32_t FCS;                         /*!< (@ 0x00000008) FIFO control and status */

    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] If 1: write result to the FIFO after each conversion. */
      __IOM uint32_t SHIFT      : 1;            /*!< [1..1] If 1: FIFO results are right-shifted to be one byte in size. Enables DMA to byte buffers. */
      __IOM uint32_t ERR        : 1;            /*!< [2..2] If 1: conversion error bit appears in the FIFO alongside the result */
      __IOM uint32_t DREQ_EN    : 1;            /*!< [3..3] If 1: assert DMA requests when FIFO contains data */
            uint32_t            : 4;
      __IM  uint32_t EMPTY      : 1;            /*!< [8..8] EMPTY */
      __IM  uint32_t FULL       : 1;            /*!< [9..9] FULL */
      __IOM uint32_t UNDER      : 1;            /*!< [10..10] 1 if the FIFO has been underflowed. Write 1 to clear. */
      __IOM uint32_t OVER       : 1;            /*!< [11..11] 1 if the FIFO has been overflowed. Write 1 to clear. */
            uint32_t            : 4;
      __IM  uint32_t LEVEL      : 4;            /*!< [19..16] The number of conversion results currently waiting in the FIFO */
            uint32_t            : 4;
      __IOM uint32_t THRESH     : 4;            /*!< [27..24] DREQ/IRQ asserted when level >= threshold */
            uint32_t            : 4;
    } FCS_b;
  } ;

  union {
    __IOM uint32_t FIFO;                        /*!< (@ 0x0000000C) Conversion result FIFO */

    struct {
      __IM  uint32_t VAL        : 12;           /*!< [11..0] VAL */
            uint32_t            : 3;
      __IM  uint32_t ERR        : 1;            /*!< [15..15] 1 if this particular sample experienced a conversion error. Remains in the same location if the sample is shifted. */
            uint32_t            : 16;
    } FIFO_b;
  } ;

  union {
    __IOM uint32_t DIV;                         /*!< (@ 0x00000010) Clock divider. If non-zero, CS_START_MANY will start conversions at regular intervals rather than back-to-back. The divider is reset when either of these fields are written. Total period is 1 + INT + FRAC / 256 */

    struct {
      __IOM uint32_t FRAC       : 8;            /*!< [7..0] Fractional part of clock divisor. First-order delta-sigma. */
      __IOM uint32_t INT        : 16;           /*!< [23..8] Integer part of clock divisor. */
            uint32_t            : 8;
    } DIV_b;
  } ;

  union {
    __IOM uint32_t INTR;                        /*!< (@ 0x00000014) Raw Interrupts */

    struct {
      __IM  uint32_t FIFO       : 1;            /*!< [0..0] Triggered when the sample FIFO reaches a certain level. This level can be programmed via the FCS_THRESH field. */
            uint32_t            : 31;
    } INTR_b;
  } ;

  union {
    __IOM uint32_t INTE;                        /*!< (@ 0x00000018) Interrupt Enable */

    struct {
      __IOM uint32_t FIFO       : 1;            /*!< [0..0] Triggered when the sample FIFO reaches a certain level. This level can be programmed via the FCS_THRESH field. */
            uint32_t            : 31;
    } INTE_b;
  } ;

  union {
    __IOM uint32_t INTF;                        /*!< (@ 0x0000001C) Interrupt Force */

    struct {
      __IOM uint32_t FIFO       : 1;            /*!< [0..0] Triggered when the sample FIFO reaches a certain level. This level can be programmed via the FCS_THRESH field. */
            uint32_t            : 31;
    } INTF_b;
  } ;

  union {
    __IOM uint32_t INTS;                        /*!< (@ 0x00000020) Interrupt status after masking & forcing */

    struct {
      __IM  uint32_t FIFO       : 1;            /*!< [0..0] Triggered when the sample FIFO reaches a certain level. This level can be programmed via the FCS_THRESH field. */
            uint32_t            : 31;
    } INTS_b;
  } ;
} ADC_Type;                                     /*!< Size = 36 (0x24) */



/* =========================================================================================================================== */
/* ================                                            PWM                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Simple PWM (PWM)
  */

typedef struct {                                /*!< (@ 0x40050000) PWM Structure */

  union {
    __IOM uint32_t CH0_CSR;                     /*!< (@ 0x00000000) Control and status register */

    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Enable the PWM channel. */
      __IOM uint32_t PH_CORRECT : 1;            /*!< [1..1] 1: Enable phase-correct modulation. 0: Trailing-edge */
      __IOM uint32_t A_INV      : 1;            /*!< [2..2] Invert output A */
      __IOM uint32_t B_INV      : 1;            /*!< [3..3] Invert output B */
      __IOM uint32_t DIVMODE    : 2;            /*!< [5..4] DIVMODE */
      __IOM uint32_t PH_RET     : 1;            /*!< [6..6] Retard the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running. */
      __IOM uint32_t PH_ADV     : 1;            /*!< [7..7] Advance the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running at less than full speed (div_int + div_frac / 16 > 1) */
            uint32_t            : 24;
    } CH0_CSR_b;
  } ;

  union {
    __IOM uint32_t CH0_DIV;                     /*!< (@ 0x00000004) INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta. */

    struct {
      __IOM uint32_t FRAC       : 4;            /*!< [3..0] FRAC */
      __IOM uint32_t INT        : 8;            /*!< [11..4] INT */
            uint32_t            : 20;
    } CH0_DIV_b;
  } ;

  union {
    __IOM uint32_t CH0_CTR;                     /*!< (@ 0x00000008) Direct access to the PWM counter */

    struct {
      __IOM uint32_t CH0_CTR    : 16;           /*!< [15..0] CH0_CTR */
            uint32_t            : 16;
    } CH0_CTR_b;
  } ;

  union {
    __IOM uint32_t CH0_CC;                      /*!< (@ 0x0000000C) Counter compare values */

    struct {
      __IOM uint32_t A          : 16;           /*!< [15..0] A */
      __IOM uint32_t B          : 16;           /*!< [31..16] B */
    } CH0_CC_b;
  } ;

  union {
    __IOM uint32_t CH0_TOP;                     /*!< (@ 0x00000010) Counter wrap value */

    struct {
      __IOM uint32_t CH0_TOP    : 16;           /*!< [15..0] CH0_TOP */
            uint32_t            : 16;
    } CH0_TOP_b;
  } ;

  union {
    __IOM uint32_t CH1_CSR;                     /*!< (@ 0x00000014) Control and status register */

    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Enable the PWM channel. */
      __IOM uint32_t PH_CORRECT : 1;            /*!< [1..1] 1: Enable phase-correct modulation. 0: Trailing-edge */
      __IOM uint32_t A_INV      : 1;            /*!< [2..2] Invert output A */
      __IOM uint32_t B_INV      : 1;            /*!< [3..3] Invert output B */
      __IOM uint32_t DIVMODE    : 2;            /*!< [5..4] DIVMODE */
      __IOM uint32_t PH_RET     : 1;            /*!< [6..6] Retard the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running. */
      __IOM uint32_t PH_ADV     : 1;            /*!< [7..7] Advance the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running at less than full speed (div_int + div_frac / 16 > 1) */
            uint32_t            : 24;
    } CH1_CSR_b;
  } ;

  union {
    __IOM uint32_t CH1_DIV;                     /*!< (@ 0x00000018) INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta. */

    struct {
      __IOM uint32_t FRAC       : 4;            /*!< [3..0] FRAC */
      __IOM uint32_t INT        : 8;            /*!< [11..4] INT */
            uint32_t            : 20;
    } CH1_DIV_b;
  } ;

  union {
    __IOM uint32_t CH1_CTR;                     /*!< (@ 0x0000001C) Direct access to the PWM counter */

    struct {
      __IOM uint32_t CH1_CTR    : 16;           /*!< [15..0] CH1_CTR */
            uint32_t            : 16;
    } CH1_CTR_b;
  } ;

  union {
    __IOM uint32_t CH1_CC;                      /*!< (@ 0x00000020) Counter compare values */

    struct {
      __IOM uint32_t A          : 16;           /*!< [15..0] A */
      __IOM uint32_t B          : 16;           /*!< [31..16] B */
    } CH1_CC_b;
  } ;

  union {
    __IOM uint32_t CH1_TOP;                     /*!< (@ 0x00000024) Counter wrap value */

    struct {
      __IOM uint32_t CH1_TOP    : 16;           /*!< [15..0] CH1_TOP */
            uint32_t            : 16;
    } CH1_TOP_b;
  } ;

  union {
    __IOM uint32_t CH2_CSR;                     /*!< (@ 0x00000028) Control and status register */

    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Enable the PWM channel. */
      __IOM uint32_t PH_CORRECT : 1;            /*!< [1..1] 1: Enable phase-correct modulation. 0: Trailing-edge */
      __IOM uint32_t A_INV      : 1;            /*!< [2..2] Invert output A */
      __IOM uint32_t B_INV      : 1;            /*!< [3..3] Invert output B */
      __IOM uint32_t DIVMODE    : 2;            /*!< [5..4] DIVMODE */
      __IOM uint32_t PH_RET     : 1;            /*!< [6..6] Retard the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running. */
      __IOM uint32_t PH_ADV     : 1;            /*!< [7..7] Advance the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running at less than full speed (div_int + div_frac / 16 > 1) */
            uint32_t            : 24;
    } CH2_CSR_b;
  } ;

  union {
    __IOM uint32_t CH2_DIV;                     /*!< (@ 0x0000002C) INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta. */

    struct {
      __IOM uint32_t FRAC       : 4;            /*!< [3..0] FRAC */
      __IOM uint32_t INT        : 8;            /*!< [11..4] INT */
            uint32_t            : 20;
    } CH2_DIV_b;
  } ;

  union {
    __IOM uint32_t CH2_CTR;                     /*!< (@ 0x00000030) Direct access to the PWM counter */

    struct {
      __IOM uint32_t CH2_CTR    : 16;           /*!< [15..0] CH2_CTR */
            uint32_t            : 16;
    } CH2_CTR_b;
  } ;

  union {
    __IOM uint32_t CH2_CC;                      /*!< (@ 0x00000034) Counter compare values */

    struct {
      __IOM uint32_t A          : 16;           /*!< [15..0] A */
      __IOM uint32_t B          : 16;           /*!< [31..16] B */
    } CH2_CC_b;
  } ;

  union {
    __IOM uint32_t CH2_TOP;                     /*!< (@ 0x00000038) Counter wrap value */

    struct {
      __IOM uint32_t CH2_TOP    : 16;           /*!< [15..0] CH2_TOP */
            uint32_t            : 16;
    } CH2_TOP_b;
  } ;

  union {
    __IOM uint32_t CH3_CSR;                     /*!< (@ 0x0000003C) Control and status register */

    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Enable the PWM channel. */
      __IOM uint32_t PH_CORRECT : 1;            /*!< [1..1] 1: Enable phase-correct modulation. 0: Trailing-edge */
      __IOM uint32_t A_INV      : 1;            /*!< [2..2] Invert output A */
      __IOM uint32_t B_INV      : 1;            /*!< [3..3] Invert output B */
      __IOM uint32_t DIVMODE    : 2;            /*!< [5..4] DIVMODE */
      __IOM uint32_t PH_RET     : 1;            /*!< [6..6] Retard the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running. */
      __IOM uint32_t PH_ADV     : 1;            /*!< [7..7] Advance the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running at less than full speed (div_int + div_frac / 16 > 1) */
            uint32_t            : 24;
    } CH3_CSR_b;
  } ;

  union {
    __IOM uint32_t CH3_DIV;                     /*!< (@ 0x00000040) INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta. */

    struct {
      __IOM uint32_t FRAC       : 4;            /*!< [3..0] FRAC */
      __IOM uint32_t INT        : 8;            /*!< [11..4] INT */
            uint32_t            : 20;
    } CH3_DIV_b;
  } ;

  union {
    __IOM uint32_t CH3_CTR;                     /*!< (@ 0x00000044) Direct access to the PWM counter */

    struct {
      __IOM uint32_t CH3_CTR    : 16;           /*!< [15..0] CH3_CTR */
            uint32_t            : 16;
    } CH3_CTR_b;
  } ;

  union {
    __IOM uint32_t CH3_CC;                      /*!< (@ 0x00000048) Counter compare values */

    struct {
      __IOM uint32_t A          : 16;           /*!< [15..0] A */
      __IOM uint32_t B          : 16;           /*!< [31..16] B */
    } CH3_CC_b;
  } ;

  union {
    __IOM uint32_t CH3_TOP;                     /*!< (@ 0x0000004C) Counter wrap value */

    struct {
      __IOM uint32_t CH3_TOP    : 16;           /*!< [15..0] CH3_TOP */
            uint32_t            : 16;
    } CH3_TOP_b;
  } ;

  union {
    __IOM uint32_t CH4_CSR;                     /*!< (@ 0x00000050) Control and status register */

    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Enable the PWM channel. */
      __IOM uint32_t PH_CORRECT : 1;            /*!< [1..1] 1: Enable phase-correct modulation. 0: Trailing-edge */
      __IOM uint32_t A_INV      : 1;            /*!< [2..2] Invert output A */
      __IOM uint32_t B_INV      : 1;            /*!< [3..3] Invert output B */
      __IOM uint32_t DIVMODE    : 2;            /*!< [5..4] DIVMODE */
      __IOM uint32_t PH_RET     : 1;            /*!< [6..6] Retard the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running. */
      __IOM uint32_t PH_ADV     : 1;            /*!< [7..7] Advance the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running at less than full speed (div_int + div_frac / 16 > 1) */
            uint32_t            : 24;
    } CH4_CSR_b;
  } ;

  union {
    __IOM uint32_t CH4_DIV;                     /*!< (@ 0x00000054) INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta. */

    struct {
      __IOM uint32_t FRAC       : 4;            /*!< [3..0] FRAC */
      __IOM uint32_t INT        : 8;            /*!< [11..4] INT */
            uint32_t            : 20;
    } CH4_DIV_b;
  } ;

  union {
    __IOM uint32_t CH4_CTR;                     /*!< (@ 0x00000058) Direct access to the PWM counter */

    struct {
      __IOM uint32_t CH4_CTR    : 16;           /*!< [15..0] CH4_CTR */
            uint32_t            : 16;
    } CH4_CTR_b;
  } ;

  union {
    __IOM uint32_t CH4_CC;                      /*!< (@ 0x0000005C) Counter compare values */

    struct {
      __IOM uint32_t A          : 16;           /*!< [15..0] A */
      __IOM uint32_t B          : 16;           /*!< [31..16] B */
    } CH4_CC_b;
  } ;

  union {
    __IOM uint32_t CH4_TOP;                     /*!< (@ 0x00000060) Counter wrap value */

    struct {
      __IOM uint32_t CH4_TOP    : 16;           /*!< [15..0] CH4_TOP */
            uint32_t            : 16;
    } CH4_TOP_b;
  } ;

  union {
    __IOM uint32_t CH5_CSR;                     /*!< (@ 0x00000064) Control and status register */

    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Enable the PWM channel. */
      __IOM uint32_t PH_CORRECT : 1;            /*!< [1..1] 1: Enable phase-correct modulation. 0: Trailing-edge */
      __IOM uint32_t A_INV      : 1;            /*!< [2..2] Invert output A */
      __IOM uint32_t B_INV      : 1;            /*!< [3..3] Invert output B */
      __IOM uint32_t DIVMODE    : 2;            /*!< [5..4] DIVMODE */
      __IOM uint32_t PH_RET     : 1;            /*!< [6..6] Retard the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running. */
      __IOM uint32_t PH_ADV     : 1;            /*!< [7..7] Advance the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running at less than full speed (div_int + div_frac / 16 > 1) */
            uint32_t            : 24;
    } CH5_CSR_b;
  } ;

  union {
    __IOM uint32_t CH5_DIV;                     /*!< (@ 0x00000068) INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta. */

    struct {
      __IOM uint32_t FRAC       : 4;            /*!< [3..0] FRAC */
      __IOM uint32_t INT        : 8;            /*!< [11..4] INT */
            uint32_t            : 20;
    } CH5_DIV_b;
  } ;

  union {
    __IOM uint32_t CH5_CTR;                     /*!< (@ 0x0000006C) Direct access to the PWM counter */

    struct {
      __IOM uint32_t CH5_CTR    : 16;           /*!< [15..0] CH5_CTR */
            uint32_t            : 16;
    } CH5_CTR_b;
  } ;

  union {
    __IOM uint32_t CH5_CC;                      /*!< (@ 0x00000070) Counter compare values */

    struct {
      __IOM uint32_t A          : 16;           /*!< [15..0] A */
      __IOM uint32_t B          : 16;           /*!< [31..16] B */
    } CH5_CC_b;
  } ;

  union {
    __IOM uint32_t CH5_TOP;                     /*!< (@ 0x00000074) Counter wrap value */

    struct {
      __IOM uint32_t CH5_TOP    : 16;           /*!< [15..0] CH5_TOP */
            uint32_t            : 16;
    } CH5_TOP_b;
  } ;

  union {
    __IOM uint32_t CH6_CSR;                     /*!< (@ 0x00000078) Control and status register */

    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Enable the PWM channel. */
      __IOM uint32_t PH_CORRECT : 1;            /*!< [1..1] 1: Enable phase-correct modulation. 0: Trailing-edge */
      __IOM uint32_t A_INV      : 1;            /*!< [2..2] Invert output A */
      __IOM uint32_t B_INV      : 1;            /*!< [3..3] Invert output B */
      __IOM uint32_t DIVMODE    : 2;            /*!< [5..4] DIVMODE */
      __IOM uint32_t PH_RET     : 1;            /*!< [6..6] Retard the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running. */
      __IOM uint32_t PH_ADV     : 1;            /*!< [7..7] Advance the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running at less than full speed (div_int + div_frac / 16 > 1) */
            uint32_t            : 24;
    } CH6_CSR_b;
  } ;

  union {
    __IOM uint32_t CH6_DIV;                     /*!< (@ 0x0000007C) INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta. */

    struct {
      __IOM uint32_t FRAC       : 4;            /*!< [3..0] FRAC */
      __IOM uint32_t INT        : 8;            /*!< [11..4] INT */
            uint32_t            : 20;
    } CH6_DIV_b;
  } ;

  union {
    __IOM uint32_t CH6_CTR;                     /*!< (@ 0x00000080) Direct access to the PWM counter */

    struct {
      __IOM uint32_t CH6_CTR    : 16;           /*!< [15..0] CH6_CTR */
            uint32_t            : 16;
    } CH6_CTR_b;
  } ;

  union {
    __IOM uint32_t CH6_CC;                      /*!< (@ 0x00000084) Counter compare values */

    struct {
      __IOM uint32_t A          : 16;           /*!< [15..0] A */
      __IOM uint32_t B          : 16;           /*!< [31..16] B */
    } CH6_CC_b;
  } ;

  union {
    __IOM uint32_t CH6_TOP;                     /*!< (@ 0x00000088) Counter wrap value */

    struct {
      __IOM uint32_t CH6_TOP    : 16;           /*!< [15..0] CH6_TOP */
            uint32_t            : 16;
    } CH6_TOP_b;
  } ;

  union {
    __IOM uint32_t CH7_CSR;                     /*!< (@ 0x0000008C) Control and status register */

    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Enable the PWM channel. */
      __IOM uint32_t PH_CORRECT : 1;            /*!< [1..1] 1: Enable phase-correct modulation. 0: Trailing-edge */
      __IOM uint32_t A_INV      : 1;            /*!< [2..2] Invert output A */
      __IOM uint32_t B_INV      : 1;            /*!< [3..3] Invert output B */
      __IOM uint32_t DIVMODE    : 2;            /*!< [5..4] DIVMODE */
      __IOM uint32_t PH_RET     : 1;            /*!< [6..6] Retard the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running. */
      __IOM uint32_t PH_ADV     : 1;            /*!< [7..7] Advance the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running at less than full speed (div_int + div_frac / 16 > 1) */
            uint32_t            : 24;
    } CH7_CSR_b;
  } ;

  union {
    __IOM uint32_t CH7_DIV;                     /*!< (@ 0x00000090) INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta. */

    struct {
      __IOM uint32_t FRAC       : 4;            /*!< [3..0] FRAC */
      __IOM uint32_t INT        : 8;            /*!< [11..4] INT */
            uint32_t            : 20;
    } CH7_DIV_b;
  } ;

  union {
    __IOM uint32_t CH7_CTR;                     /*!< (@ 0x00000094) Direct access to the PWM counter */

    struct {
      __IOM uint32_t CH7_CTR    : 16;           /*!< [15..0] CH7_CTR */
            uint32_t            : 16;
    } CH7_CTR_b;
  } ;

  union {
    __IOM uint32_t CH7_CC;                      /*!< (@ 0x00000098) Counter compare values */

    struct {
      __IOM uint32_t A          : 16;           /*!< [15..0] A */
      __IOM uint32_t B          : 16;           /*!< [31..16] B */
    } CH7_CC_b;
  } ;

  union {
    __IOM uint32_t CH7_TOP;                     /*!< (@ 0x0000009C) Counter wrap value */

    struct {
      __IOM uint32_t CH7_TOP    : 16;           /*!< [15..0] CH7_TOP */
            uint32_t            : 16;
    } CH7_TOP_b;
  } ;

  union {
    __IOM uint32_t EN;                          /*!< (@ 0x000000A0) This register aliases the CSR_EN bits for all channels. Writing to this register allows multiple channels to be enabled or disabled simultaneously, so they can run in perfect sync. For each channel, there is only one physical EN register bit, which can be accessed through here or CHx_CSR. */

    struct {
      __IOM uint32_t CH0        : 1;            /*!< [0..0] CH0 */
      __IOM uint32_t CH1        : 1;            /*!< [1..1] CH1 */
      __IOM uint32_t CH2        : 1;            /*!< [2..2] CH2 */
      __IOM uint32_t CH3        : 1;            /*!< [3..3] CH3 */
      __IOM uint32_t CH4        : 1;            /*!< [4..4] CH4 */
      __IOM uint32_t CH5        : 1;            /*!< [5..5] CH5 */
      __IOM uint32_t CH6        : 1;            /*!< [6..6] CH6 */
      __IOM uint32_t CH7        : 1;            /*!< [7..7] CH7 */
            uint32_t            : 24;
    } EN_b;
  } ;

  union {
    __IOM uint32_t INTR;                        /*!< (@ 0x000000A4) Raw Interrupts */

    struct {
      __IOM uint32_t CH0        : 1;            /*!< [0..0] CH0 */
      __IOM uint32_t CH1        : 1;            /*!< [1..1] CH1 */
      __IOM uint32_t CH2        : 1;            /*!< [2..2] CH2 */
      __IOM uint32_t CH3        : 1;            /*!< [3..3] CH3 */
      __IOM uint32_t CH4        : 1;            /*!< [4..4] CH4 */
      __IOM uint32_t CH5        : 1;            /*!< [5..5] CH5 */
      __IOM uint32_t CH6        : 1;            /*!< [6..6] CH6 */
      __IOM uint32_t CH7        : 1;            /*!< [7..7] CH7 */
            uint32_t            : 24;
    } INTR_b;
  } ;

  union {
    __IOM uint32_t INTE;                        /*!< (@ 0x000000A8) Interrupt Enable */

    struct {
      __IOM uint32_t CH0        : 1;            /*!< [0..0] CH0 */
      __IOM uint32_t CH1        : 1;            /*!< [1..1] CH1 */
      __IOM uint32_t CH2        : 1;            /*!< [2..2] CH2 */
      __IOM uint32_t CH3        : 1;            /*!< [3..3] CH3 */
      __IOM uint32_t CH4        : 1;            /*!< [4..4] CH4 */
      __IOM uint32_t CH5        : 1;            /*!< [5..5] CH5 */
      __IOM uint32_t CH6        : 1;            /*!< [6..6] CH6 */
      __IOM uint32_t CH7        : 1;            /*!< [7..7] CH7 */
            uint32_t            : 24;
    } INTE_b;
  } ;

  union {
    __IOM uint32_t INTF;                        /*!< (@ 0x000000AC) Interrupt Force */

    struct {
      __IOM uint32_t CH0        : 1;            /*!< [0..0] CH0 */
      __IOM uint32_t CH1        : 1;            /*!< [1..1] CH1 */
      __IOM uint32_t CH2        : 1;            /*!< [2..2] CH2 */
      __IOM uint32_t CH3        : 1;            /*!< [3..3] CH3 */
      __IOM uint32_t CH4        : 1;            /*!< [4..4] CH4 */
      __IOM uint32_t CH5        : 1;            /*!< [5..5] CH5 */
      __IOM uint32_t CH6        : 1;            /*!< [6..6] CH6 */
      __IOM uint32_t CH7        : 1;            /*!< [7..7] CH7 */
            uint32_t            : 24;
    } INTF_b;
  } ;

  union {
    __IOM uint32_t INTS;                        /*!< (@ 0x000000B0) Interrupt status after masking & forcing */

    struct {
      __IM  uint32_t CH0        : 1;            /*!< [0..0] CH0 */
      __IM  uint32_t CH1        : 1;            /*!< [1..1] CH1 */
      __IM  uint32_t CH2        : 1;            /*!< [2..2] CH2 */
      __IM  uint32_t CH3        : 1;            /*!< [3..3] CH3 */
      __IM  uint32_t CH4        : 1;            /*!< [4..4] CH4 */
      __IM  uint32_t CH5        : 1;            /*!< [5..5] CH5 */
      __IM  uint32_t CH6        : 1;            /*!< [6..6] CH6 */
      __IM  uint32_t CH7        : 1;            /*!< [7..7] CH7 */
            uint32_t            : 24;
    } INTS_b;
  } ;
} PWM_Type;                                     /*!< Size = 180 (0xb4) */



/* =========================================================================================================================== */
/* ================                                           TIMER                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Controls time and alarms\n
        time is a 64 bit value indicating the time in usec since power-on\n
        timeh is the top 32 bits of time & timel is the bottom 32 bits\n
        to change time write to timelw before timehw\n
        to read time read from timelr before timehr\n
        An alarm is set by setting alarm_enable and writing to the corresponding alarm register\n
        When an alarm is pending, the corresponding alarm_running signal will be high\n
        An alarm can be cancelled before it has finished by clearing the alarm_enable\n
        When an alarm fires, the corresponding alarm_irq is set and alarm_running is cleared\n
        To clear the interrupt write a 1 to the corresponding alarm_irq (TIMER)
  */

typedef struct {                                /*!< (@ 0x40054000) TIMER Structure */
  __OM  uint32_t  TIMEHW;                       /*!< (@ 0x00000000) Write to bits 63:32 of time always write timelw before timehw */
  __OM  uint32_t  TIMELW;                       /*!< (@ 0x00000004) Write to bits 31:0 of time writes do not get copied to time until timehw is written */
  __IM  uint32_t  TIMEHR;                       /*!< (@ 0x00000008) Read from bits 63:32 of time always read timelr before timehr */
  __IM  uint32_t  TIMELR;                       /*!< (@ 0x0000000C) Read from bits 31:0 of time */
  __IOM uint32_t  ALARM0;                       /*!< (@ 0x00000010) Arm alarm 0, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM0 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register. */
  __IOM uint32_t  ALARM1;                       /*!< (@ 0x00000014) Arm alarm 1, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM1 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register. */
  __IOM uint32_t  ALARM2;                       /*!< (@ 0x00000018) Arm alarm 2, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM2 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register. */
  __IOM uint32_t  ALARM3;                       /*!< (@ 0x0000001C) Arm alarm 3, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM3 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register. */

  union {
    __IOM uint32_t ARMED;                       /*!< (@ 0x00000020) Indicates the armed/disarmed status of each alarm. A write to the corresponding ALARMx register arms the alarm. Alarms automatically disarm upon firing, but writing ones here will disarm immediately without waiting to fire. */

    struct {
      __IOM uint32_t ARMED      : 4;            /*!< [3..0] ARMED */
            uint32_t            : 28;
    } ARMED_b;
  } ;
  __IM  uint32_t  TIMERAWH;                     /*!< (@ 0x00000024) Raw read from bits 63:32 of time (no side effects) */
  __IM  uint32_t  TIMERAWL;                     /*!< (@ 0x00000028) Raw read from bits 31:0 of time (no side effects) */

  union {
    __IOM uint32_t DBGPAUSE;                    /*!< (@ 0x0000002C) Set bits high to enable pause when the corresponding debug ports are active */

    struct {
            uint32_t            : 1;
      __IOM uint32_t DBG0       : 1;            /*!< [1..1] Pause when processor 0 is in debug mode */
      __IOM uint32_t DBG1       : 1;            /*!< [2..2] Pause when processor 1 is in debug mode */
            uint32_t            : 29;
    } DBGPAUSE_b;
  } ;

  union {
    __IOM uint32_t PAUSE;                       /*!< (@ 0x00000030) Set high to pause the timer */

    struct {
      __IOM uint32_t PAUSE      : 1;            /*!< [0..0] PAUSE */
            uint32_t            : 31;
    } PAUSE_b;
  } ;

  union {
    __IOM uint32_t INTR;                        /*!< (@ 0x00000034) Raw Interrupts */

    struct {
      __IOM uint32_t ALARM_0    : 1;            /*!< [0..0] ALARM_0 */
      __IOM uint32_t ALARM_1    : 1;            /*!< [1..1] ALARM_1 */
      __IOM uint32_t ALARM_2    : 1;            /*!< [2..2] ALARM_2 */
      __IOM uint32_t ALARM_3    : 1;            /*!< [3..3] ALARM_3 */
            uint32_t            : 28;
    } INTR_b;
  } ;

  union {
    __IOM uint32_t INTE;                        /*!< (@ 0x00000038) Interrupt Enable */

    struct {
      __IOM uint32_t ALARM_0    : 1;            /*!< [0..0] ALARM_0 */
      __IOM uint32_t ALARM_1    : 1;            /*!< [1..1] ALARM_1 */
      __IOM uint32_t ALARM_2    : 1;            /*!< [2..2] ALARM_2 */
      __IOM uint32_t ALARM_3    : 1;            /*!< [3..3] ALARM_3 */
            uint32_t            : 28;
    } INTE_b;
  } ;

  union {
    __IOM uint32_t INTF;                        /*!< (@ 0x0000003C) Interrupt Force */

    struct {
      __IOM uint32_t ALARM_0    : 1;            /*!< [0..0] ALARM_0 */
      __IOM uint32_t ALARM_1    : 1;            /*!< [1..1] ALARM_1 */
      __IOM uint32_t ALARM_2    : 1;            /*!< [2..2] ALARM_2 */
      __IOM uint32_t ALARM_3    : 1;            /*!< [3..3] ALARM_3 */
            uint32_t            : 28;
    } INTF_b;
  } ;

  union {
    __IOM uint32_t INTS;                        /*!< (@ 0x00000040) Interrupt status after masking & forcing */

    struct {
      __IM  uint32_t ALARM_0    : 1;            /*!< [0..0] ALARM_0 */
      __IM  uint32_t ALARM_1    : 1;            /*!< [1..1] ALARM_1 */
      __IM  uint32_t ALARM_2    : 1;            /*!< [2..2] ALARM_2 */
      __IM  uint32_t ALARM_3    : 1;            /*!< [3..3] ALARM_3 */
            uint32_t            : 28;
    } INTS_b;
  } ;
} TIMER_Type;                                   /*!< Size = 68 (0x44) */



/* =========================================================================================================================== */
/* ================                                         WATCHDOG                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief WATCHDOG (WATCHDOG)
  */

typedef struct {                                /*!< (@ 0x40058000) WATCHDOG Structure */

  union {
    __IOM uint32_t CTRL;                        /*!< (@ 0x00000000) Watchdog control The rst_wdsel register determines which subsystems are reset when the watchdog is triggered. The watchdog can be triggered in software. */

    struct {
      __IM  uint32_t TIME       : 24;           /*!< [23..0] Indicates the number of ticks / 2 (see errata RP2040-E1) before a watchdog reset will be triggered */
      __IOM uint32_t PAUSE_JTAG : 1;            /*!< [24..24] Pause the watchdog timer when JTAG is accessing the bus fabric */
      __IOM uint32_t PAUSE_DBG0 : 1;            /*!< [25..25] Pause the watchdog timer when processor 0 is in debug mode */
      __IOM uint32_t PAUSE_DBG1 : 1;            /*!< [26..26] Pause the watchdog timer when processor 1 is in debug mode */
            uint32_t            : 3;
      __IOM uint32_t ENABLE     : 1;            /*!< [30..30] When not enabled the watchdog timer is paused */
      __IOM uint32_t TRIGGER    : 1;            /*!< [31..31] Trigger a watchdog reset */
    } CTRL_b;
  } ;

  union {
    __IOM uint32_t LOAD;                        /*!< (@ 0x00000004) Load the watchdog timer. The maximum setting is 0xffffff which corresponds to 0xffffff / 2 ticks before triggering a watchdog reset (see errata RP2040-E1). */

    struct {
      __OM  uint32_t LOAD       : 24;           /*!< [23..0] LOAD */
            uint32_t            : 8;
    } LOAD_b;
  } ;

  union {
    __IOM uint32_t REASON;                      /*!< (@ 0x00000008) Logs the reason for the last reset. Both bits are zero for the case of a hardware reset. */

    struct {
      __IM  uint32_t TIMER      : 1;            /*!< [0..0] TIMER */
      __IM  uint32_t FORCE      : 1;            /*!< [1..1] FORCE */
            uint32_t            : 30;
    } REASON_b;
  } ;
  __IOM uint32_t  SCRATCH0;                     /*!< (@ 0x0000000C) Scratch register. Information persists through soft reset of the chip. */
  __IOM uint32_t  SCRATCH1;                     /*!< (@ 0x00000010) Scratch register. Information persists through soft reset of the chip. */
  __IOM uint32_t  SCRATCH2;                     /*!< (@ 0x00000014) Scratch register. Information persists through soft reset of the chip. */
  __IOM uint32_t  SCRATCH3;                     /*!< (@ 0x00000018) Scratch register. Information persists through soft reset of the chip. */
  __IOM uint32_t  SCRATCH4;                     /*!< (@ 0x0000001C) Scratch register. Information persists through soft reset of the chip. */
  __IOM uint32_t  SCRATCH5;                     /*!< (@ 0x00000020) Scratch register. Information persists through soft reset of the chip. */
  __IOM uint32_t  SCRATCH6;                     /*!< (@ 0x00000024) Scratch register. Information persists through soft reset of the chip. */
  __IOM uint32_t  SCRATCH7;                     /*!< (@ 0x00000028) Scratch register. Information persists through soft reset of the chip. */

  union {
    __IOM uint32_t TICK;                        /*!< (@ 0x0000002C) Controls the tick generator */

    struct {
      __IOM uint32_t CYCLES     : 9;            /*!< [8..0] Total number of clk_tick cycles before the next tick. */
      __IOM uint32_t ENABLE     : 1;            /*!< [9..9] start / stop tick generation */
      __IM  uint32_t RUNNING    : 1;            /*!< [10..10] Is the tick generator running? */
      __IM  uint32_t COUNT      : 9;            /*!< [19..11] Count down timer: the remaining number clk_tick cycles before the next tick is generated. */
            uint32_t            : 12;
    } TICK_b;
  } ;
} WATCHDOG_Type;                                /*!< Size = 48 (0x30) */



/* =========================================================================================================================== */
/* ================                                            RTC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Register block to control RTC (RTC)
  */

typedef struct {                                /*!< (@ 0x4005C000) RTC Structure */

  union {
    __IOM uint32_t CLKDIV_M1;                   /*!< (@ 0x00000000) Divider minus 1 for the 1 second counter. Safe to change the value when RTC is not enabled. */

    struct {
      __IOM uint32_t CLKDIV_M1  : 16;           /*!< [15..0] CLKDIV_M1 */
            uint32_t            : 16;
    } CLKDIV_M1_b;
  } ;

  union {
    __IOM uint32_t SETUP_0;                     /*!< (@ 0x00000004) RTC setup register 0 */

    struct {
      __IOM uint32_t DAY        : 5;            /*!< [4..0] Day of the month (1..31) */
            uint32_t            : 3;
      __IOM uint32_t MONTH      : 4;            /*!< [11..8] Month (1..12) */
      __IOM uint32_t YEAR       : 12;           /*!< [23..12] Year */
            uint32_t            : 8;
    } SETUP_0_b;
  } ;

  union {
    __IOM uint32_t SETUP_1;                     /*!< (@ 0x00000008) RTC setup register 1 */

    struct {
      __IOM uint32_t SEC        : 6;            /*!< [5..0] Seconds */
            uint32_t            : 2;
      __IOM uint32_t MIN        : 6;            /*!< [13..8] Minutes */
            uint32_t            : 2;
      __IOM uint32_t HOUR       : 5;            /*!< [20..16] Hours */
            uint32_t            : 3;
      __IOM uint32_t DOTW       : 3;            /*!< [26..24] Day of the week: 1-Monday...0-Sunday ISO 8601 mod 7 */
            uint32_t            : 5;
    } SETUP_1_b;
  } ;

  union {
    __IOM uint32_t CTRL;                        /*!< (@ 0x0000000C) RTC Control and status */

    struct {
      __IOM uint32_t RTC_ENABLE : 1;            /*!< [0..0] Enable RTC */
      __IM  uint32_t RTC_ACTIVE : 1;            /*!< [1..1] RTC enabled (running) */
            uint32_t            : 2;
      __IOM uint32_t LOAD       : 1;            /*!< [4..4] Load RTC */
            uint32_t            : 3;
      __IOM uint32_t FORCE_NOTLEAPYEAR : 1;     /*!< [8..8] If set, leapyear is forced off. Useful for years divisible by 100 but not by 400 */
            uint32_t            : 23;
    } CTRL_b;
  } ;

  union {
    __IOM uint32_t IRQ_SETUP_0;                 /*!< (@ 0x00000010) Interrupt setup register 0 */

    struct {
      __IOM uint32_t DAY        : 5;            /*!< [4..0] Day of the month (1..31) */
            uint32_t            : 3;
      __IOM uint32_t MONTH      : 4;            /*!< [11..8] Month (1..12) */
      __IOM uint32_t YEAR       : 12;           /*!< [23..12] Year */
      __IOM uint32_t DAY_ENA    : 1;            /*!< [24..24] Enable day matching */
      __IOM uint32_t MONTH_ENA  : 1;            /*!< [25..25] Enable month matching */
      __IOM uint32_t YEAR_ENA   : 1;            /*!< [26..26] Enable year matching */
            uint32_t            : 1;
      __IOM uint32_t MATCH_ENA  : 1;            /*!< [28..28] Global match enable. Don't change any other value while this one is enabled */
      __IM  uint32_t MATCH_ACTIVE : 1;          /*!< [29..29] MATCH_ACTIVE */
            uint32_t            : 2;
    } IRQ_SETUP_0_b;
  } ;

  union {
    __IOM uint32_t IRQ_SETUP_1;                 /*!< (@ 0x00000014) Interrupt setup register 1 */

    struct {
      __IOM uint32_t SEC        : 6;            /*!< [5..0] Seconds */
            uint32_t            : 2;
      __IOM uint32_t MIN        : 6;            /*!< [13..8] Minutes */
            uint32_t            : 2;
      __IOM uint32_t HOUR       : 5;            /*!< [20..16] Hours */
            uint32_t            : 3;
      __IOM uint32_t DOTW       : 3;            /*!< [26..24] Day of the week */
            uint32_t            : 1;
      __IOM uint32_t SEC_ENA    : 1;            /*!< [28..28] Enable second matching */
      __IOM uint32_t MIN_ENA    : 1;            /*!< [29..29] Enable minute matching */
      __IOM uint32_t HOUR_ENA   : 1;            /*!< [30..30] Enable hour matching */
      __IOM uint32_t DOTW_ENA   : 1;            /*!< [31..31] Enable day of the week matching */
    } IRQ_SETUP_1_b;
  } ;

  union {
    __IOM uint32_t RTC_1;                       /*!< (@ 0x00000018) RTC register 1. */

    struct {
      __IM  uint32_t DAY        : 5;            /*!< [4..0] Day of the month (1..31) */
            uint32_t            : 3;
      __IM  uint32_t MONTH      : 4;            /*!< [11..8] Month (1..12) */
      __IM  uint32_t YEAR       : 12;           /*!< [23..12] Year */
            uint32_t            : 8;
    } RTC_1_b;
  } ;

  union {
    __IOM uint32_t RTC_0;                       /*!< (@ 0x0000001C) RTC register 0 Read this before RTC 1! */

    struct {
      __IM  uint32_t SEC        : 6;            /*!< [5..0] Seconds */
            uint32_t            : 2;
      __IM  uint32_t MIN        : 6;            /*!< [13..8] Minutes */
            uint32_t            : 2;
      __IM  uint32_t HOUR       : 5;            /*!< [20..16] Hours */
            uint32_t            : 3;
      __IM  uint32_t DOTW       : 3;            /*!< [26..24] Day of the week */
            uint32_t            : 5;
    } RTC_0_b;
  } ;

  union {
    __IOM uint32_t INTR;                        /*!< (@ 0x00000020) Raw Interrupts */

    struct {
      __IM  uint32_t RTC        : 1;            /*!< [0..0] RTC */
            uint32_t            : 31;
    } INTR_b;
  } ;

  union {
    __IOM uint32_t INTE;                        /*!< (@ 0x00000024) Interrupt Enable */

    struct {
      __IOM uint32_t RTC        : 1;            /*!< [0..0] RTC */
            uint32_t            : 31;
    } INTE_b;
  } ;

  union {
    __IOM uint32_t INTF;                        /*!< (@ 0x00000028) Interrupt Force */

    struct {
      __IOM uint32_t RTC        : 1;            /*!< [0..0] RTC */
            uint32_t            : 31;
    } INTF_b;
  } ;

  union {
    __IOM uint32_t INTS;                        /*!< (@ 0x0000002C) Interrupt status after masking & forcing */

    struct {
      __IM  uint32_t RTC        : 1;            /*!< [0..0] RTC */
            uint32_t            : 31;
    } INTS_b;
  } ;
} RTC_Type;                                     /*!< Size = 48 (0x30) */



/* =========================================================================================================================== */
/* ================                                           ROSC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief ROSC (ROSC)
  */

typedef struct {                                /*!< (@ 0x40060000) ROSC Structure */

  union {
    __IOM uint32_t CTRL;                        /*!< (@ 0x00000000) Ring Oscillator control */

    struct {
      __IOM uint32_t FREQ_RANGE : 12;           /*!< [11..0] Controls the number of delay stages in the ROSC ring LOW uses stages 0 to 7 MEDIUM uses stages 0 to 5 HIGH uses stages 0 to 3 TOOHIGH uses stages 0 to 1 and should not be used because its frequency exceeds design specifications The clock output will not glitch when changing the range up one step at a time The clock output will glitch when changing the range down Note: the v */
      __IOM uint32_t ENABLE     : 12;           /*!< [23..12] On power-up this field is initialised to ENABLE The system clock must be switched to another source before setting this field to DISABLE otherwise the chip will lock up The 12-bit code is intended to give some protection against accidental writes. An invalid setting will enable the oscillator. */
            uint32_t            : 8;
    } CTRL_b;
  } ;

  union {
    __IOM uint32_t FREQA;                       /*!< (@ 0x00000004) The FREQA & FREQB registers control the frequency by controlling the drive strength of each stage The drive strength has 4 levels determined by the number of bits set Increasing the number of bits set increases the drive strength and increases the oscillation frequency 0 bits set is the default drive strength 1 bit set doubles the drive strength 2 bits set triples drive strength 3 bits set quadruples */

    struct {
      __IOM uint32_t DS0        : 3;            /*!< [2..0] Stage 0 drive strength */
            uint32_t            : 1;
      __IOM uint32_t DS1        : 3;            /*!< [6..4] Stage 1 drive strength */
            uint32_t            : 1;
      __IOM uint32_t DS2        : 3;            /*!< [10..8] Stage 2 drive strength */
            uint32_t            : 1;
      __IOM uint32_t DS3        : 3;            /*!< [14..12] Stage 3 drive strength */
            uint32_t            : 1;
      __IOM uint32_t PASSWD     : 16;           /*!< [31..16] Set to 0x9696 to apply the settings Any other value in this field will set all drive strengths to 0 */
    } FREQA_b;
  } ;

  union {
    __IOM uint32_t FREQB;                       /*!< (@ 0x00000008) For a detailed description see freqa register */

    struct {
      __IOM uint32_t DS4        : 3;            /*!< [2..0] Stage 4 drive strength */
            uint32_t            : 1;
      __IOM uint32_t DS5        : 3;            /*!< [6..4] Stage 5 drive strength */
            uint32_t            : 1;
      __IOM uint32_t DS6        : 3;            /*!< [10..8] Stage 6 drive strength */
            uint32_t            : 1;
      __IOM uint32_t DS7        : 3;            /*!< [14..12] Stage 7 drive strength */
            uint32_t            : 1;
      __IOM uint32_t PASSWD     : 16;           /*!< [31..16] Set to 0x9696 to apply the settings Any other value in this field will set all drive strengths to 0 */
    } FREQB_b;
  } ;
  __IOM uint32_t  DORMANT;                      /*!< (@ 0x0000000C) Ring Oscillator pause control This is used to save power by pausing the ROSC On power-up this field is initialised to WAKE An invalid write will also select WAKE Warning: setup the irq before selecting dormant mode */

  union {
    __IOM uint32_t DIV;                         /*!< (@ 0x00000010) Controls the output divider */

    struct {
      __IOM uint32_t DIV        : 12;           /*!< [11..0] set to 0xaa0 + div where div = 0 divides by 32 div = 1-31 divides by div any other value sets div=31 this register resets to div=16 */
            uint32_t            : 20;
    } DIV_b;
  } ;

  union {
    __IOM uint32_t PHASE;                       /*!< (@ 0x00000014) Controls the phase shifted output */

    struct {
      __IOM uint32_t SHIFT      : 2;            /*!< [1..0] phase shift the phase-shifted output by SHIFT input clocks this can be changed on-the-fly must be set to 0 before setting div=1 */
      __IOM uint32_t FLIP       : 1;            /*!< [2..2] invert the phase-shifted output this is ignored when div=1 */
      __IOM uint32_t ENABLE     : 1;            /*!< [3..3] enable the phase-shifted output this can be changed on-the-fly */
      __IOM uint32_t PASSWD     : 8;            /*!< [11..4] set to 0xaa any other value enables the output with shift=0 */
            uint32_t            : 20;
    } PHASE_b;
  } ;

  union {
    __IOM uint32_t STATUS;                      /*!< (@ 0x00000018) Ring Oscillator Status */

    struct {
            uint32_t            : 12;
      __IM  uint32_t ENABLED    : 1;            /*!< [12..12] Oscillator is enabled but not necessarily running and stable this resets to 0 but transitions to 1 during chip startup */
            uint32_t            : 3;
      __IM  uint32_t DIV_RUNNING : 1;           /*!< [16..16] post-divider is running this resets to 0 but transitions to 1 during chip startup */
            uint32_t            : 7;
      __IOM uint32_t BADWRITE   : 1;            /*!< [24..24] An invalid value has been written to CTRL_ENABLE or CTRL_FREQ_RANGE or FREQA or FREQB or DIV or PHASE or DORMANT */
            uint32_t            : 6;
      __IM  uint32_t STABLE     : 1;            /*!< [31..31] Oscillator is running and stable */
    } STATUS_b;
  } ;

  union {
    __IOM uint32_t RANDOMBIT;                   /*!< (@ 0x0000001C) This just reads the state of the oscillator output so randomness is compromised if the ring oscillator is stopped or run at a harmonic of the bus frequency */

    struct {
      __IM  uint32_t RANDOMBIT  : 1;            /*!< [0..0] RANDOMBIT */
            uint32_t            : 31;
    } RANDOMBIT_b;
  } ;

  union {
    __IOM uint32_t COUNT;                       /*!< (@ 0x00000020) A down counter running at the ROSC frequency which counts to zero and stops. To start the counter write a non-zero value. Can be used for short software pauses when setting up time sensitive hardware. */

    struct {
      __IOM uint32_t COUNT      : 8;            /*!< [7..0] COUNT */
            uint32_t            : 24;
    } COUNT_b;
  } ;
} ROSC_Type;                                    /*!< Size = 36 (0x24) */



/* =========================================================================================================================== */
/* ================                                    VREG_AND_CHIP_RESET                                    ================ */
/* =========================================================================================================================== */


/**
  * @brief control and status for on-chip voltage regulator and chip level reset subsystem (VREG_AND_CHIP_RESET)
  */

typedef struct {                                /*!< (@ 0x40064000) VREG_AND_CHIP_RESET Structure */

  union {
    __IOM uint32_t VREG;                        /*!< (@ 0x00000000) Voltage regulator control and status */

    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] enable 0=not enabled, 1=enabled */
      __IOM uint32_t HIZ        : 1;            /*!< [1..1] high impedance mode select 0=not in high impedance mode, 1=in high impedance mode */
            uint32_t            : 2;
      __IOM uint32_t VSEL       : 4;            /*!< [7..4] output voltage select 0000 to 0101 - 0.80V 0110 - 0.85V 0111 - 0.90V 1000 - 0.95V 1001 - 1.00V 1010 - 1.05V 1011 - 1.10V (default) 1100 - 1.15V 1101 - 1.20V 1110 - 1.25V 1111 - 1.30V */
            uint32_t            : 4;
      __IM  uint32_t ROK        : 1;            /*!< [12..12] regulation status 0=not in regulation, 1=in regulation */
            uint32_t            : 19;
    } VREG_b;
  } ;

  union {
    __IOM uint32_t BOD;                         /*!< (@ 0x00000004) brown-out detection control */

    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] enable 0=not enabled, 1=enabled */
            uint32_t            : 3;
      __IOM uint32_t VSEL       : 4;            /*!< [7..4] threshold select 0000 - 0.473V 0001 - 0.516V 0010 - 0.559V 0011 - 0.602V 0100 - 0.645V 0101 - 0.688V 0110 - 0.731V 0111 - 0.774V 1000 - 0.817V 1001 - 0.860V (default) 1010 - 0.903V 1011 - 0.946V 1100 - 0.989V 1101 - 1.032V 1 */
            uint32_t            : 24;
    } BOD_b;
  } ;

  union {
    __IOM uint32_t CHIP_RESET;                  /*!< (@ 0x00000008) Chip reset control and status */

    struct {
            uint32_t            : 8;
      __IM  uint32_t HAD_POR    : 1;            /*!< [8..8] Last reset was from the power-on reset or brown-out detection blocks */
            uint32_t            : 7;
      __IM  uint32_t HAD_RUN    : 1;            /*!< [16..16] Last reset was from the RUN pin */
            uint32_t            : 3;
      __IM  uint32_t HAD_PSM_RESTART : 1;       /*!< [20..20] Last reset was from the debug port */
            uint32_t            : 3;
      __IOM uint32_t PSM_RESTART_FLAG : 1;      /*!< [24..24] This is set by psm_restart from the debugger. Its purpose is to branch bootcode to a safe mode when the debugger has issued a psm_restart in order to recover from a boot lock-up. In the safe mode the debugger can repair the boot code, clear this flag then reboot the processor. */
            uint32_t            : 7;
    } CHIP_RESET_b;
  } ;
} VREG_AND_CHIP_RESET_Type;                     /*!< Size = 12 (0xc) */



/* =========================================================================================================================== */
/* ================                                           TBMAN                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Testbench manager. Allows the programmer to know what platform their software is running on. (TBMAN)
  */

typedef struct {                                /*!< (@ 0x4006C000) TBMAN Structure */

  union {
    __IOM uint32_t PLATFORM;                    /*!< (@ 0x00000000) Indicates the type of platform in use */

    struct {
      __IM  uint32_t ASIC       : 1;            /*!< [0..0] Indicates the platform is an ASIC */
      __IM  uint32_t FPGA       : 1;            /*!< [1..1] Indicates the platform is an FPGA */
            uint32_t            : 30;
    } PLATFORM_b;
  } ;
} TBMAN_Type;                                   /*!< Size = 4 (0x4) */



/* =========================================================================================================================== */
/* ================                                            DMA                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief DMA with separate read and write masters (DMA)
  */

typedef struct {                                /*!< (@ 0x50000000) DMA Structure */
  __IOM uint32_t  CH0_READ_ADDR;                /*!< (@ 0x00000000) DMA Channel 0 Read Address pointer This register updates automatically each time a read completes. The current value is the next address to be read by this channel. */
  __IOM uint32_t  CH0_WRITE_ADDR;               /*!< (@ 0x00000004) DMA Channel 0 Write Address pointer This register updates automatically each time a write completes. The current value is the next address to be written by this channel. */
  __IOM uint32_t  CH0_TRANS_COUNT;              /*!< (@ 0x00000008) DMA Channel 0 Transfer Count Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the tran */

  union {
    __IOM uint32_t CH0_CTRL_TRIG;               /*!< (@ 0x0000000C) DMA Channel 0 Control and Status */

    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high) */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< [1..1] HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput. */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< [3..2] Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer. */
      __IOM uint32_t INCR_READ  : 1;            /*!< [4..4] If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers. */
      __IOM uint32_t INCR_WRITE : 1;            /*!< [5..5] If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers. */
      __IOM uint32_t RING_SIZE  : 4;            /*!< [9..6] Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL. */
      __IOM uint32_t RING_SEL   : 1;            /*!< [10..10] Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped. */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< [14..11] When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. Reset value is equal to channel number (0). */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< [20..15] Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< [21..21] In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks. */
      __IOM uint32_t BSWAP      : 1;            /*!< [22..22] Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order. */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< [23..23] If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis. */
      __IM  uint32_t BUSY       : 1;            /*!< [24..24] This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT. */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< [29..29] If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later) */
      __IOM uint32_t READ_ERROR : 1;            /*!< [30..30] If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later) */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< [31..31] Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag. */
    } CH0_CTRL_TRIG_b;
  } ;
  __IOM uint32_t  CH0_AL1_CTRL;                 /*!< (@ 0x00000010) Alias for channel 0 CTRL register */
  __IOM uint32_t  CH0_AL1_READ_ADDR;            /*!< (@ 0x00000014) Alias for channel 0 READ_ADDR register */
  __IOM uint32_t  CH0_AL1_WRITE_ADDR;           /*!< (@ 0x00000018) Alias for channel 0 WRITE_ADDR register */
  __IOM uint32_t  CH0_AL1_TRANS_COUNT_TRIG;     /*!< (@ 0x0000001C) Alias for channel 0 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH0_AL2_CTRL;                 /*!< (@ 0x00000020) Alias for channel 0 CTRL register */
  __IOM uint32_t  CH0_AL2_TRANS_COUNT;          /*!< (@ 0x00000024) Alias for channel 0 TRANS_COUNT register */
  __IOM uint32_t  CH0_AL2_READ_ADDR;            /*!< (@ 0x00000028) Alias for channel 0 READ_ADDR register */
  __IOM uint32_t  CH0_AL2_WRITE_ADDR_TRIG;      /*!< (@ 0x0000002C) Alias for channel 0 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH0_AL3_CTRL;                 /*!< (@ 0x00000030) Alias for channel 0 CTRL register */
  __IOM uint32_t  CH0_AL3_WRITE_ADDR;           /*!< (@ 0x00000034) Alias for channel 0 WRITE_ADDR register */
  __IOM uint32_t  CH0_AL3_TRANS_COUNT;          /*!< (@ 0x00000038) Alias for channel 0 TRANS_COUNT register */
  __IOM uint32_t  CH0_AL3_READ_ADDR_TRIG;       /*!< (@ 0x0000003C) Alias for channel 0 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH1_READ_ADDR;                /*!< (@ 0x00000040) DMA Channel 1 Read Address pointer This register updates automatically each time a read completes. The current value is the next address to be read by this channel. */
  __IOM uint32_t  CH1_WRITE_ADDR;               /*!< (@ 0x00000044) DMA Channel 1 Write Address pointer This register updates automatically each time a write completes. The current value is the next address to be written by this channel. */
  __IOM uint32_t  CH1_TRANS_COUNT;              /*!< (@ 0x00000048) DMA Channel 1 Transfer Count Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the tran */

  union {
    __IOM uint32_t CH1_CTRL_TRIG;               /*!< (@ 0x0000004C) DMA Channel 1 Control and Status */

    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high) */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< [1..1] HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput. */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< [3..2] Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer. */
      __IOM uint32_t INCR_READ  : 1;            /*!< [4..4] If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers. */
      __IOM uint32_t INCR_WRITE : 1;            /*!< [5..5] If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers. */
      __IOM uint32_t RING_SIZE  : 4;            /*!< [9..6] Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL. */
      __IOM uint32_t RING_SEL   : 1;            /*!< [10..10] Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped. */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< [14..11] When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. Reset value is equal to channel number (1). */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< [20..15] Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< [21..21] In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks. */
      __IOM uint32_t BSWAP      : 1;            /*!< [22..22] Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order. */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< [23..23] If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis. */
      __IM  uint32_t BUSY       : 1;            /*!< [24..24] This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT. */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< [29..29] If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later) */
      __IOM uint32_t READ_ERROR : 1;            /*!< [30..30] If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later) */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< [31..31] Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag. */
    } CH1_CTRL_TRIG_b;
  } ;
  __IOM uint32_t  CH1_AL1_CTRL;                 /*!< (@ 0x00000050) Alias for channel 1 CTRL register */
  __IOM uint32_t  CH1_AL1_READ_ADDR;            /*!< (@ 0x00000054) Alias for channel 1 READ_ADDR register */
  __IOM uint32_t  CH1_AL1_WRITE_ADDR;           /*!< (@ 0x00000058) Alias for channel 1 WRITE_ADDR register */
  __IOM uint32_t  CH1_AL1_TRANS_COUNT_TRIG;     /*!< (@ 0x0000005C) Alias for channel 1 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH1_AL2_CTRL;                 /*!< (@ 0x00000060) Alias for channel 1 CTRL register */
  __IOM uint32_t  CH1_AL2_TRANS_COUNT;          /*!< (@ 0x00000064) Alias for channel 1 TRANS_COUNT register */
  __IOM uint32_t  CH1_AL2_READ_ADDR;            /*!< (@ 0x00000068) Alias for channel 1 READ_ADDR register */
  __IOM uint32_t  CH1_AL2_WRITE_ADDR_TRIG;      /*!< (@ 0x0000006C) Alias for channel 1 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH1_AL3_CTRL;                 /*!< (@ 0x00000070) Alias for channel 1 CTRL register */
  __IOM uint32_t  CH1_AL3_WRITE_ADDR;           /*!< (@ 0x00000074) Alias for channel 1 WRITE_ADDR register */
  __IOM uint32_t  CH1_AL3_TRANS_COUNT;          /*!< (@ 0x00000078) Alias for channel 1 TRANS_COUNT register */
  __IOM uint32_t  CH1_AL3_READ_ADDR_TRIG;       /*!< (@ 0x0000007C) Alias for channel 1 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH2_READ_ADDR;                /*!< (@ 0x00000080) DMA Channel 2 Read Address pointer This register updates automatically each time a read completes. The current value is the next address to be read by this channel. */
  __IOM uint32_t  CH2_WRITE_ADDR;               /*!< (@ 0x00000084) DMA Channel 2 Write Address pointer This register updates automatically each time a write completes. The current value is the next address to be written by this channel. */
  __IOM uint32_t  CH2_TRANS_COUNT;              /*!< (@ 0x00000088) DMA Channel 2 Transfer Count Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the tran */

  union {
    __IOM uint32_t CH2_CTRL_TRIG;               /*!< (@ 0x0000008C) DMA Channel 2 Control and Status */

    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high) */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< [1..1] HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput. */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< [3..2] Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer. */
      __IOM uint32_t INCR_READ  : 1;            /*!< [4..4] If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers. */
      __IOM uint32_t INCR_WRITE : 1;            /*!< [5..5] If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers. */
      __IOM uint32_t RING_SIZE  : 4;            /*!< [9..6] Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL. */
      __IOM uint32_t RING_SEL   : 1;            /*!< [10..10] Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped. */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< [14..11] When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. Reset value is equal to channel number (2). */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< [20..15] Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< [21..21] In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks. */
      __IOM uint32_t BSWAP      : 1;            /*!< [22..22] Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order. */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< [23..23] If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis. */
      __IM  uint32_t BUSY       : 1;            /*!< [24..24] This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT. */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< [29..29] If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later) */
      __IOM uint32_t READ_ERROR : 1;            /*!< [30..30] If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later) */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< [31..31] Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag. */
    } CH2_CTRL_TRIG_b;
  } ;
  __IOM uint32_t  CH2_AL1_CTRL;                 /*!< (@ 0x00000090) Alias for channel 2 CTRL register */
  __IOM uint32_t  CH2_AL1_READ_ADDR;            /*!< (@ 0x00000094) Alias for channel 2 READ_ADDR register */
  __IOM uint32_t  CH2_AL1_WRITE_ADDR;           /*!< (@ 0x00000098) Alias for channel 2 WRITE_ADDR register */
  __IOM uint32_t  CH2_AL1_TRANS_COUNT_TRIG;     /*!< (@ 0x0000009C) Alias for channel 2 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH2_AL2_CTRL;                 /*!< (@ 0x000000A0) Alias for channel 2 CTRL register */
  __IOM uint32_t  CH2_AL2_TRANS_COUNT;          /*!< (@ 0x000000A4) Alias for channel 2 TRANS_COUNT register */
  __IOM uint32_t  CH2_AL2_READ_ADDR;            /*!< (@ 0x000000A8) Alias for channel 2 READ_ADDR register */
  __IOM uint32_t  CH2_AL2_WRITE_ADDR_TRIG;      /*!< (@ 0x000000AC) Alias for channel 2 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH2_AL3_CTRL;                 /*!< (@ 0x000000B0) Alias for channel 2 CTRL register */
  __IOM uint32_t  CH2_AL3_WRITE_ADDR;           /*!< (@ 0x000000B4) Alias for channel 2 WRITE_ADDR register */
  __IOM uint32_t  CH2_AL3_TRANS_COUNT;          /*!< (@ 0x000000B8) Alias for channel 2 TRANS_COUNT register */
  __IOM uint32_t  CH2_AL3_READ_ADDR_TRIG;       /*!< (@ 0x000000BC) Alias for channel 2 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH3_READ_ADDR;                /*!< (@ 0x000000C0) DMA Channel 3 Read Address pointer This register updates automatically each time a read completes. The current value is the next address to be read by this channel. */
  __IOM uint32_t  CH3_WRITE_ADDR;               /*!< (@ 0x000000C4) DMA Channel 3 Write Address pointer This register updates automatically each time a write completes. The current value is the next address to be written by this channel. */
  __IOM uint32_t  CH3_TRANS_COUNT;              /*!< (@ 0x000000C8) DMA Channel 3 Transfer Count Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the tran */

  union {
    __IOM uint32_t CH3_CTRL_TRIG;               /*!< (@ 0x000000CC) DMA Channel 3 Control and Status */

    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high) */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< [1..1] HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput. */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< [3..2] Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer. */
      __IOM uint32_t INCR_READ  : 1;            /*!< [4..4] If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers. */
      __IOM uint32_t INCR_WRITE : 1;            /*!< [5..5] If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers. */
      __IOM uint32_t RING_SIZE  : 4;            /*!< [9..6] Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL. */
      __IOM uint32_t RING_SEL   : 1;            /*!< [10..10] Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped. */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< [14..11] When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. Reset value is equal to channel number (3). */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< [20..15] Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< [21..21] In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks. */
      __IOM uint32_t BSWAP      : 1;            /*!< [22..22] Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order. */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< [23..23] If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis. */
      __IM  uint32_t BUSY       : 1;            /*!< [24..24] This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT. */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< [29..29] If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later) */
      __IOM uint32_t READ_ERROR : 1;            /*!< [30..30] If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later) */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< [31..31] Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag. */
    } CH3_CTRL_TRIG_b;
  } ;
  __IOM uint32_t  CH3_AL1_CTRL;                 /*!< (@ 0x000000D0) Alias for channel 3 CTRL register */
  __IOM uint32_t  CH3_AL1_READ_ADDR;            /*!< (@ 0x000000D4) Alias for channel 3 READ_ADDR register */
  __IOM uint32_t  CH3_AL1_WRITE_ADDR;           /*!< (@ 0x000000D8) Alias for channel 3 WRITE_ADDR register */
  __IOM uint32_t  CH3_AL1_TRANS_COUNT_TRIG;     /*!< (@ 0x000000DC) Alias for channel 3 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH3_AL2_CTRL;                 /*!< (@ 0x000000E0) Alias for channel 3 CTRL register */
  __IOM uint32_t  CH3_AL2_TRANS_COUNT;          /*!< (@ 0x000000E4) Alias for channel 3 TRANS_COUNT register */
  __IOM uint32_t  CH3_AL2_READ_ADDR;            /*!< (@ 0x000000E8) Alias for channel 3 READ_ADDR register */
  __IOM uint32_t  CH3_AL2_WRITE_ADDR_TRIG;      /*!< (@ 0x000000EC) Alias for channel 3 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH3_AL3_CTRL;                 /*!< (@ 0x000000F0) Alias for channel 3 CTRL register */
  __IOM uint32_t  CH3_AL3_WRITE_ADDR;           /*!< (@ 0x000000F4) Alias for channel 3 WRITE_ADDR register */
  __IOM uint32_t  CH3_AL3_TRANS_COUNT;          /*!< (@ 0x000000F8) Alias for channel 3 TRANS_COUNT register */
  __IOM uint32_t  CH3_AL3_READ_ADDR_TRIG;       /*!< (@ 0x000000FC) Alias for channel 3 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH4_READ_ADDR;                /*!< (@ 0x00000100) DMA Channel 4 Read Address pointer This register updates automatically each time a read completes. The current value is the next address to be read by this channel. */
  __IOM uint32_t  CH4_WRITE_ADDR;               /*!< (@ 0x00000104) DMA Channel 4 Write Address pointer This register updates automatically each time a write completes. The current value is the next address to be written by this channel. */
  __IOM uint32_t  CH4_TRANS_COUNT;              /*!< (@ 0x00000108) DMA Channel 4 Transfer Count Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the tran */

  union {
    __IOM uint32_t CH4_CTRL_TRIG;               /*!< (@ 0x0000010C) DMA Channel 4 Control and Status */

    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high) */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< [1..1] HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput. */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< [3..2] Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer. */
      __IOM uint32_t INCR_READ  : 1;            /*!< [4..4] If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers. */
      __IOM uint32_t INCR_WRITE : 1;            /*!< [5..5] If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers. */
      __IOM uint32_t RING_SIZE  : 4;            /*!< [9..6] Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL. */
      __IOM uint32_t RING_SEL   : 1;            /*!< [10..10] Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped. */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< [14..11] When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. Reset value is equal to channel number (4). */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< [20..15] Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< [21..21] In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks. */
      __IOM uint32_t BSWAP      : 1;            /*!< [22..22] Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order. */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< [23..23] If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis. */
      __IM  uint32_t BUSY       : 1;            /*!< [24..24] This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT. */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< [29..29] If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later) */
      __IOM uint32_t READ_ERROR : 1;            /*!< [30..30] If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later) */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< [31..31] Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag. */
    } CH4_CTRL_TRIG_b;
  } ;
  __IOM uint32_t  CH4_AL1_CTRL;                 /*!< (@ 0x00000110) Alias for channel 4 CTRL register */
  __IOM uint32_t  CH4_AL1_READ_ADDR;            /*!< (@ 0x00000114) Alias for channel 4 READ_ADDR register */
  __IOM uint32_t  CH4_AL1_WRITE_ADDR;           /*!< (@ 0x00000118) Alias for channel 4 WRITE_ADDR register */
  __IOM uint32_t  CH4_AL1_TRANS_COUNT_TRIG;     /*!< (@ 0x0000011C) Alias for channel 4 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH4_AL2_CTRL;                 /*!< (@ 0x00000120) Alias for channel 4 CTRL register */
  __IOM uint32_t  CH4_AL2_TRANS_COUNT;          /*!< (@ 0x00000124) Alias for channel 4 TRANS_COUNT register */
  __IOM uint32_t  CH4_AL2_READ_ADDR;            /*!< (@ 0x00000128) Alias for channel 4 READ_ADDR register */
  __IOM uint32_t  CH4_AL2_WRITE_ADDR_TRIG;      /*!< (@ 0x0000012C) Alias for channel 4 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH4_AL3_CTRL;                 /*!< (@ 0x00000130) Alias for channel 4 CTRL register */
  __IOM uint32_t  CH4_AL3_WRITE_ADDR;           /*!< (@ 0x00000134) Alias for channel 4 WRITE_ADDR register */
  __IOM uint32_t  CH4_AL3_TRANS_COUNT;          /*!< (@ 0x00000138) Alias for channel 4 TRANS_COUNT register */
  __IOM uint32_t  CH4_AL3_READ_ADDR_TRIG;       /*!< (@ 0x0000013C) Alias for channel 4 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH5_READ_ADDR;                /*!< (@ 0x00000140) DMA Channel 5 Read Address pointer This register updates automatically each time a read completes. The current value is the next address to be read by this channel. */
  __IOM uint32_t  CH5_WRITE_ADDR;               /*!< (@ 0x00000144) DMA Channel 5 Write Address pointer This register updates automatically each time a write completes. The current value is the next address to be written by this channel. */
  __IOM uint32_t  CH5_TRANS_COUNT;              /*!< (@ 0x00000148) DMA Channel 5 Transfer Count Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the tran */

  union {
    __IOM uint32_t CH5_CTRL_TRIG;               /*!< (@ 0x0000014C) DMA Channel 5 Control and Status */

    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high) */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< [1..1] HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput. */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< [3..2] Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer. */
      __IOM uint32_t INCR_READ  : 1;            /*!< [4..4] If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers. */
      __IOM uint32_t INCR_WRITE : 1;            /*!< [5..5] If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers. */
      __IOM uint32_t RING_SIZE  : 4;            /*!< [9..6] Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL. */
      __IOM uint32_t RING_SEL   : 1;            /*!< [10..10] Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped. */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< [14..11] When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. Reset value is equal to channel number (5). */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< [20..15] Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< [21..21] In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks. */
      __IOM uint32_t BSWAP      : 1;            /*!< [22..22] Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order. */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< [23..23] If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis. */
      __IM  uint32_t BUSY       : 1;            /*!< [24..24] This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT. */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< [29..29] If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later) */
      __IOM uint32_t READ_ERROR : 1;            /*!< [30..30] If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later) */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< [31..31] Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag. */
    } CH5_CTRL_TRIG_b;
  } ;
  __IOM uint32_t  CH5_AL1_CTRL;                 /*!< (@ 0x00000150) Alias for channel 5 CTRL register */
  __IOM uint32_t  CH5_AL1_READ_ADDR;            /*!< (@ 0x00000154) Alias for channel 5 READ_ADDR register */
  __IOM uint32_t  CH5_AL1_WRITE_ADDR;           /*!< (@ 0x00000158) Alias for channel 5 WRITE_ADDR register */
  __IOM uint32_t  CH5_AL1_TRANS_COUNT_TRIG;     /*!< (@ 0x0000015C) Alias for channel 5 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH5_AL2_CTRL;                 /*!< (@ 0x00000160) Alias for channel 5 CTRL register */
  __IOM uint32_t  CH5_AL2_TRANS_COUNT;          /*!< (@ 0x00000164) Alias for channel 5 TRANS_COUNT register */
  __IOM uint32_t  CH5_AL2_READ_ADDR;            /*!< (@ 0x00000168) Alias for channel 5 READ_ADDR register */
  __IOM uint32_t  CH5_AL2_WRITE_ADDR_TRIG;      /*!< (@ 0x0000016C) Alias for channel 5 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH5_AL3_CTRL;                 /*!< (@ 0x00000170) Alias for channel 5 CTRL register */
  __IOM uint32_t  CH5_AL3_WRITE_ADDR;           /*!< (@ 0x00000174) Alias for channel 5 WRITE_ADDR register */
  __IOM uint32_t  CH5_AL3_TRANS_COUNT;          /*!< (@ 0x00000178) Alias for channel 5 TRANS_COUNT register */
  __IOM uint32_t  CH5_AL3_READ_ADDR_TRIG;       /*!< (@ 0x0000017C) Alias for channel 5 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH6_READ_ADDR;                /*!< (@ 0x00000180) DMA Channel 6 Read Address pointer This register updates automatically each time a read completes. The current value is the next address to be read by this channel. */
  __IOM uint32_t  CH6_WRITE_ADDR;               /*!< (@ 0x00000184) DMA Channel 6 Write Address pointer This register updates automatically each time a write completes. The current value is the next address to be written by this channel. */
  __IOM uint32_t  CH6_TRANS_COUNT;              /*!< (@ 0x00000188) DMA Channel 6 Transfer Count Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the tran */

  union {
    __IOM uint32_t CH6_CTRL_TRIG;               /*!< (@ 0x0000018C) DMA Channel 6 Control and Status */

    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high) */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< [1..1] HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput. */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< [3..2] Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer. */
      __IOM uint32_t INCR_READ  : 1;            /*!< [4..4] If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers. */
      __IOM uint32_t INCR_WRITE : 1;            /*!< [5..5] If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers. */
      __IOM uint32_t RING_SIZE  : 4;            /*!< [9..6] Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL. */
      __IOM uint32_t RING_SEL   : 1;            /*!< [10..10] Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped. */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< [14..11] When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. Reset value is equal to channel number (6). */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< [20..15] Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< [21..21] In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks. */
      __IOM uint32_t BSWAP      : 1;            /*!< [22..22] Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order. */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< [23..23] If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis. */
      __IM  uint32_t BUSY       : 1;            /*!< [24..24] This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT. */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< [29..29] If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later) */
      __IOM uint32_t READ_ERROR : 1;            /*!< [30..30] If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later) */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< [31..31] Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag. */
    } CH6_CTRL_TRIG_b;
  } ;
  __IOM uint32_t  CH6_AL1_CTRL;                 /*!< (@ 0x00000190) Alias for channel 6 CTRL register */
  __IOM uint32_t  CH6_AL1_READ_ADDR;            /*!< (@ 0x00000194) Alias for channel 6 READ_ADDR register */
  __IOM uint32_t  CH6_AL1_WRITE_ADDR;           /*!< (@ 0x00000198) Alias for channel 6 WRITE_ADDR register */
  __IOM uint32_t  CH6_AL1_TRANS_COUNT_TRIG;     /*!< (@ 0x0000019C) Alias for channel 6 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH6_AL2_CTRL;                 /*!< (@ 0x000001A0) Alias for channel 6 CTRL register */
  __IOM uint32_t  CH6_AL2_TRANS_COUNT;          /*!< (@ 0x000001A4) Alias for channel 6 TRANS_COUNT register */
  __IOM uint32_t  CH6_AL2_READ_ADDR;            /*!< (@ 0x000001A8) Alias for channel 6 READ_ADDR register */
  __IOM uint32_t  CH6_AL2_WRITE_ADDR_TRIG;      /*!< (@ 0x000001AC) Alias for channel 6 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH6_AL3_CTRL;                 /*!< (@ 0x000001B0) Alias for channel 6 CTRL register */
  __IOM uint32_t  CH6_AL3_WRITE_ADDR;           /*!< (@ 0x000001B4) Alias for channel 6 WRITE_ADDR register */
  __IOM uint32_t  CH6_AL3_TRANS_COUNT;          /*!< (@ 0x000001B8) Alias for channel 6 TRANS_COUNT register */
  __IOM uint32_t  CH6_AL3_READ_ADDR_TRIG;       /*!< (@ 0x000001BC) Alias for channel 6 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH7_READ_ADDR;                /*!< (@ 0x000001C0) DMA Channel 7 Read Address pointer This register updates automatically each time a read completes. The current value is the next address to be read by this channel. */
  __IOM uint32_t  CH7_WRITE_ADDR;               /*!< (@ 0x000001C4) DMA Channel 7 Write Address pointer This register updates automatically each time a write completes. The current value is the next address to be written by this channel. */
  __IOM uint32_t  CH7_TRANS_COUNT;              /*!< (@ 0x000001C8) DMA Channel 7 Transfer Count Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the tran */

  union {
    __IOM uint32_t CH7_CTRL_TRIG;               /*!< (@ 0x000001CC) DMA Channel 7 Control and Status */

    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high) */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< [1..1] HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput. */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< [3..2] Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer. */
      __IOM uint32_t INCR_READ  : 1;            /*!< [4..4] If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers. */
      __IOM uint32_t INCR_WRITE : 1;            /*!< [5..5] If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers. */
      __IOM uint32_t RING_SIZE  : 4;            /*!< [9..6] Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL. */
      __IOM uint32_t RING_SEL   : 1;            /*!< [10..10] Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped. */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< [14..11] When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. Reset value is equal to channel number (7). */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< [20..15] Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< [21..21] In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks. */
      __IOM uint32_t BSWAP      : 1;            /*!< [22..22] Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order. */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< [23..23] If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis. */
      __IM  uint32_t BUSY       : 1;            /*!< [24..24] This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT. */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< [29..29] If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later) */
      __IOM uint32_t READ_ERROR : 1;            /*!< [30..30] If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later) */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< [31..31] Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag. */
    } CH7_CTRL_TRIG_b;
  } ;
  __IOM uint32_t  CH7_AL1_CTRL;                 /*!< (@ 0x000001D0) Alias for channel 7 CTRL register */
  __IOM uint32_t  CH7_AL1_READ_ADDR;            /*!< (@ 0x000001D4) Alias for channel 7 READ_ADDR register */
  __IOM uint32_t  CH7_AL1_WRITE_ADDR;           /*!< (@ 0x000001D8) Alias for channel 7 WRITE_ADDR register */
  __IOM uint32_t  CH7_AL1_TRANS_COUNT_TRIG;     /*!< (@ 0x000001DC) Alias for channel 7 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH7_AL2_CTRL;                 /*!< (@ 0x000001E0) Alias for channel 7 CTRL register */
  __IOM uint32_t  CH7_AL2_TRANS_COUNT;          /*!< (@ 0x000001E4) Alias for channel 7 TRANS_COUNT register */
  __IOM uint32_t  CH7_AL2_READ_ADDR;            /*!< (@ 0x000001E8) Alias for channel 7 READ_ADDR register */
  __IOM uint32_t  CH7_AL2_WRITE_ADDR_TRIG;      /*!< (@ 0x000001EC) Alias for channel 7 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH7_AL3_CTRL;                 /*!< (@ 0x000001F0) Alias for channel 7 CTRL register */
  __IOM uint32_t  CH7_AL3_WRITE_ADDR;           /*!< (@ 0x000001F4) Alias for channel 7 WRITE_ADDR register */
  __IOM uint32_t  CH7_AL3_TRANS_COUNT;          /*!< (@ 0x000001F8) Alias for channel 7 TRANS_COUNT register */
  __IOM uint32_t  CH7_AL3_READ_ADDR_TRIG;       /*!< (@ 0x000001FC) Alias for channel 7 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH8_READ_ADDR;                /*!< (@ 0x00000200) DMA Channel 8 Read Address pointer This register updates automatically each time a read completes. The current value is the next address to be read by this channel. */
  __IOM uint32_t  CH8_WRITE_ADDR;               /*!< (@ 0x00000204) DMA Channel 8 Write Address pointer This register updates automatically each time a write completes. The current value is the next address to be written by this channel. */
  __IOM uint32_t  CH8_TRANS_COUNT;              /*!< (@ 0x00000208) DMA Channel 8 Transfer Count Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the tran */

  union {
    __IOM uint32_t CH8_CTRL_TRIG;               /*!< (@ 0x0000020C) DMA Channel 8 Control and Status */

    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high) */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< [1..1] HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput. */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< [3..2] Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer. */
      __IOM uint32_t INCR_READ  : 1;            /*!< [4..4] If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers. */
      __IOM uint32_t INCR_WRITE : 1;            /*!< [5..5] If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers. */
      __IOM uint32_t RING_SIZE  : 4;            /*!< [9..6] Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL. */
      __IOM uint32_t RING_SEL   : 1;            /*!< [10..10] Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped. */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< [14..11] When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. Reset value is equal to channel number (8). */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< [20..15] Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< [21..21] In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks. */
      __IOM uint32_t BSWAP      : 1;            /*!< [22..22] Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order. */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< [23..23] If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis. */
      __IM  uint32_t BUSY       : 1;            /*!< [24..24] This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT. */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< [29..29] If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later) */
      __IOM uint32_t READ_ERROR : 1;            /*!< [30..30] If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later) */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< [31..31] Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag. */
    } CH8_CTRL_TRIG_b;
  } ;
  __IOM uint32_t  CH8_AL1_CTRL;                 /*!< (@ 0x00000210) Alias for channel 8 CTRL register */
  __IOM uint32_t  CH8_AL1_READ_ADDR;            /*!< (@ 0x00000214) Alias for channel 8 READ_ADDR register */
  __IOM uint32_t  CH8_AL1_WRITE_ADDR;           /*!< (@ 0x00000218) Alias for channel 8 WRITE_ADDR register */
  __IOM uint32_t  CH8_AL1_TRANS_COUNT_TRIG;     /*!< (@ 0x0000021C) Alias for channel 8 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH8_AL2_CTRL;                 /*!< (@ 0x00000220) Alias for channel 8 CTRL register */
  __IOM uint32_t  CH8_AL2_TRANS_COUNT;          /*!< (@ 0x00000224) Alias for channel 8 TRANS_COUNT register */
  __IOM uint32_t  CH8_AL2_READ_ADDR;            /*!< (@ 0x00000228) Alias for channel 8 READ_ADDR register */
  __IOM uint32_t  CH8_AL2_WRITE_ADDR_TRIG;      /*!< (@ 0x0000022C) Alias for channel 8 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH8_AL3_CTRL;                 /*!< (@ 0x00000230) Alias for channel 8 CTRL register */
  __IOM uint32_t  CH8_AL3_WRITE_ADDR;           /*!< (@ 0x00000234) Alias for channel 8 WRITE_ADDR register */
  __IOM uint32_t  CH8_AL3_TRANS_COUNT;          /*!< (@ 0x00000238) Alias for channel 8 TRANS_COUNT register */
  __IOM uint32_t  CH8_AL3_READ_ADDR_TRIG;       /*!< (@ 0x0000023C) Alias for channel 8 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH9_READ_ADDR;                /*!< (@ 0x00000240) DMA Channel 9 Read Address pointer This register updates automatically each time a read completes. The current value is the next address to be read by this channel. */
  __IOM uint32_t  CH9_WRITE_ADDR;               /*!< (@ 0x00000244) DMA Channel 9 Write Address pointer This register updates automatically each time a write completes. The current value is the next address to be written by this channel. */
  __IOM uint32_t  CH9_TRANS_COUNT;              /*!< (@ 0x00000248) DMA Channel 9 Transfer Count Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the tran */

  union {
    __IOM uint32_t CH9_CTRL_TRIG;               /*!< (@ 0x0000024C) DMA Channel 9 Control and Status */

    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high) */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< [1..1] HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput. */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< [3..2] Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer. */
      __IOM uint32_t INCR_READ  : 1;            /*!< [4..4] If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers. */
      __IOM uint32_t INCR_WRITE : 1;            /*!< [5..5] If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers. */
      __IOM uint32_t RING_SIZE  : 4;            /*!< [9..6] Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL. */
      __IOM uint32_t RING_SEL   : 1;            /*!< [10..10] Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped. */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< [14..11] When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. Reset value is equal to channel number (9). */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< [20..15] Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< [21..21] In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks. */
      __IOM uint32_t BSWAP      : 1;            /*!< [22..22] Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order. */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< [23..23] If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis. */
      __IM  uint32_t BUSY       : 1;            /*!< [24..24] This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT. */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< [29..29] If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later) */
      __IOM uint32_t READ_ERROR : 1;            /*!< [30..30] If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later) */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< [31..31] Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag. */
    } CH9_CTRL_TRIG_b;
  } ;
  __IOM uint32_t  CH9_AL1_CTRL;                 /*!< (@ 0x00000250) Alias for channel 9 CTRL register */
  __IOM uint32_t  CH9_AL1_READ_ADDR;            /*!< (@ 0x00000254) Alias for channel 9 READ_ADDR register */
  __IOM uint32_t  CH9_AL1_WRITE_ADDR;           /*!< (@ 0x00000258) Alias for channel 9 WRITE_ADDR register */
  __IOM uint32_t  CH9_AL1_TRANS_COUNT_TRIG;     /*!< (@ 0x0000025C) Alias for channel 9 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH9_AL2_CTRL;                 /*!< (@ 0x00000260) Alias for channel 9 CTRL register */
  __IOM uint32_t  CH9_AL2_TRANS_COUNT;          /*!< (@ 0x00000264) Alias for channel 9 TRANS_COUNT register */
  __IOM uint32_t  CH9_AL2_READ_ADDR;            /*!< (@ 0x00000268) Alias for channel 9 READ_ADDR register */
  __IOM uint32_t  CH9_AL2_WRITE_ADDR_TRIG;      /*!< (@ 0x0000026C) Alias for channel 9 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH9_AL3_CTRL;                 /*!< (@ 0x00000270) Alias for channel 9 CTRL register */
  __IOM uint32_t  CH9_AL3_WRITE_ADDR;           /*!< (@ 0x00000274) Alias for channel 9 WRITE_ADDR register */
  __IOM uint32_t  CH9_AL3_TRANS_COUNT;          /*!< (@ 0x00000278) Alias for channel 9 TRANS_COUNT register */
  __IOM uint32_t  CH9_AL3_READ_ADDR_TRIG;       /*!< (@ 0x0000027C) Alias for channel 9 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH10_READ_ADDR;               /*!< (@ 0x00000280) DMA Channel 10 Read Address pointer This register updates automatically each time a read completes. The current value is the next address to be read by this channel. */
  __IOM uint32_t  CH10_WRITE_ADDR;              /*!< (@ 0x00000284) DMA Channel 10 Write Address pointer This register updates automatically each time a write completes. The current value is the next address to be written by this channel. */
  __IOM uint32_t  CH10_TRANS_COUNT;             /*!< (@ 0x00000288) DMA Channel 10 Transfer Count Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the tra */

  union {
    __IOM uint32_t CH10_CTRL_TRIG;              /*!< (@ 0x0000028C) DMA Channel 10 Control and Status */

    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high) */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< [1..1] HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput. */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< [3..2] Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer. */
      __IOM uint32_t INCR_READ  : 1;            /*!< [4..4] If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers. */
      __IOM uint32_t INCR_WRITE : 1;            /*!< [5..5] If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers. */
      __IOM uint32_t RING_SIZE  : 4;            /*!< [9..6] Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL. */
      __IOM uint32_t RING_SEL   : 1;            /*!< [10..10] Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped. */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< [14..11] When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. Reset value is equal to channel number (10). */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< [20..15] Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< [21..21] In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks. */
      __IOM uint32_t BSWAP      : 1;            /*!< [22..22] Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order. */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< [23..23] If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis. */
      __IM  uint32_t BUSY       : 1;            /*!< [24..24] This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT. */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< [29..29] If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later) */
      __IOM uint32_t READ_ERROR : 1;            /*!< [30..30] If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later) */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< [31..31] Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag. */
    } CH10_CTRL_TRIG_b;
  } ;
  __IOM uint32_t  CH10_AL1_CTRL;                /*!< (@ 0x00000290) Alias for channel 10 CTRL register */
  __IOM uint32_t  CH10_AL1_READ_ADDR;           /*!< (@ 0x00000294) Alias for channel 10 READ_ADDR register */
  __IOM uint32_t  CH10_AL1_WRITE_ADDR;          /*!< (@ 0x00000298) Alias for channel 10 WRITE_ADDR register */
  __IOM uint32_t  CH10_AL1_TRANS_COUNT_TRIG;    /*!< (@ 0x0000029C) Alias for channel 10 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH10_AL2_CTRL;                /*!< (@ 0x000002A0) Alias for channel 10 CTRL register */
  __IOM uint32_t  CH10_AL2_TRANS_COUNT;         /*!< (@ 0x000002A4) Alias for channel 10 TRANS_COUNT register */
  __IOM uint32_t  CH10_AL2_READ_ADDR;           /*!< (@ 0x000002A8) Alias for channel 10 READ_ADDR register */
  __IOM uint32_t  CH10_AL2_WRITE_ADDR_TRIG;     /*!< (@ 0x000002AC) Alias for channel 10 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH10_AL3_CTRL;                /*!< (@ 0x000002B0) Alias for channel 10 CTRL register */
  __IOM uint32_t  CH10_AL3_WRITE_ADDR;          /*!< (@ 0x000002B4) Alias for channel 10 WRITE_ADDR register */
  __IOM uint32_t  CH10_AL3_TRANS_COUNT;         /*!< (@ 0x000002B8) Alias for channel 10 TRANS_COUNT register */
  __IOM uint32_t  CH10_AL3_READ_ADDR_TRIG;      /*!< (@ 0x000002BC) Alias for channel 10 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH11_READ_ADDR;               /*!< (@ 0x000002C0) DMA Channel 11 Read Address pointer This register updates automatically each time a read completes. The current value is the next address to be read by this channel. */
  __IOM uint32_t  CH11_WRITE_ADDR;              /*!< (@ 0x000002C4) DMA Channel 11 Write Address pointer This register updates automatically each time a write completes. The current value is the next address to be written by this channel. */
  __IOM uint32_t  CH11_TRANS_COUNT;             /*!< (@ 0x000002C8) DMA Channel 11 Transfer Count Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the tra */

  union {
    __IOM uint32_t CH11_CTRL_TRIG;              /*!< (@ 0x000002CC) DMA Channel 11 Control and Status */

    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high) */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< [1..1] HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput. */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< [3..2] Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer. */
      __IOM uint32_t INCR_READ  : 1;            /*!< [4..4] If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers. */
      __IOM uint32_t INCR_WRITE : 1;            /*!< [5..5] If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers. */
      __IOM uint32_t RING_SIZE  : 4;            /*!< [9..6] Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL. */
      __IOM uint32_t RING_SEL   : 1;            /*!< [10..10] Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped. */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< [14..11] When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. Reset value is equal to channel number (11). */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< [20..15] Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< [21..21] In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks. */
      __IOM uint32_t BSWAP      : 1;            /*!< [22..22] Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order. */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< [23..23] If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis. */
      __IM  uint32_t BUSY       : 1;            /*!< [24..24] This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT. */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< [29..29] If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 5 transfers later) */
      __IOM uint32_t READ_ERROR : 1;            /*!< [30..30] If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not to be earlier, or more than 3 transfers later) */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< [31..31] Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag. */
    } CH11_CTRL_TRIG_b;
  } ;
  __IOM uint32_t  CH11_AL1_CTRL;                /*!< (@ 0x000002D0) Alias for channel 11 CTRL register */
  __IOM uint32_t  CH11_AL1_READ_ADDR;           /*!< (@ 0x000002D4) Alias for channel 11 READ_ADDR register */
  __IOM uint32_t  CH11_AL1_WRITE_ADDR;          /*!< (@ 0x000002D8) Alias for channel 11 WRITE_ADDR register */
  __IOM uint32_t  CH11_AL1_TRANS_COUNT_TRIG;    /*!< (@ 0x000002DC) Alias for channel 11 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH11_AL2_CTRL;                /*!< (@ 0x000002E0) Alias for channel 11 CTRL register */
  __IOM uint32_t  CH11_AL2_TRANS_COUNT;         /*!< (@ 0x000002E4) Alias for channel 11 TRANS_COUNT register */
  __IOM uint32_t  CH11_AL2_READ_ADDR;           /*!< (@ 0x000002E8) Alias for channel 11 READ_ADDR register */
  __IOM uint32_t  CH11_AL2_WRITE_ADDR_TRIG;     /*!< (@ 0x000002EC) Alias for channel 11 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IOM uint32_t  CH11_AL3_CTRL;                /*!< (@ 0x000002F0) Alias for channel 11 CTRL register */
  __IOM uint32_t  CH11_AL3_WRITE_ADDR;          /*!< (@ 0x000002F4) Alias for channel 11 WRITE_ADDR register */
  __IOM uint32_t  CH11_AL3_TRANS_COUNT;         /*!< (@ 0x000002F8) Alias for channel 11 TRANS_COUNT register */
  __IOM uint32_t  CH11_AL3_READ_ADDR_TRIG;      /*!< (@ 0x000002FC) Alias for channel 11 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel. */
  __IM  uint32_t  RESERVED[64];

  union {
    __IOM uint32_t INTR;                        /*!< (@ 0x00000400) Interrupt Status (raw) */

    struct {
      __IM  uint32_t INTR       : 16;           /*!< [15..0] Raw interrupt status for DMA Channels 0..15. Bit n corresponds to channel n. Ignores any masking or forcing. Channel interrupts can be cleared by writing a bit mask to INTR, INTS0 or INTS1. Channel interrupts can be routed to either of two system-level IRQs based on INTE0 and INTE1. This can be used vector different channel interrupts to different ISRs: this might be done to allow NVIC IRQ preemption for more time-critical channels, or to spread IRQ load across d */
            uint32_t            : 16;
    } INTR_b;
  } ;

  union {
    __IOM uint32_t INTE0;                       /*!< (@ 0x00000404) Interrupt Enables for IRQ 0 */

    struct {
      __IOM uint32_t INTE0      : 16;           /*!< [15..0] Set bit n to pass interrupts from channel n to DMA IRQ 0. */
            uint32_t            : 16;
    } INTE0_b;
  } ;

  union {
    __IOM uint32_t INTF0;                       /*!< (@ 0x00000408) Force Interrupts */

    struct {
      __IOM uint32_t INTF0      : 16;           /*!< [15..0] Write 1s to force the corresponding bits in INTE0. The interrupt remains asserted until INTF0 is cleared. */
            uint32_t            : 16;
    } INTF0_b;
  } ;

  union {
    __IOM uint32_t INTS0;                       /*!< (@ 0x0000040C) Interrupt Status for IRQ 0 */

    struct {
      __IOM uint32_t INTS0      : 16;           /*!< [15..0] Indicates active channel interrupt requests which are currently causing IRQ 0 to be asserted. Channel interrupts can be cleared by writing a bit mask here. */
            uint32_t            : 16;
    } INTS0_b;
  } ;
  __IM  uint32_t  RESERVED1;

  union {
    __IOM uint32_t INTE1;                       /*!< (@ 0x00000414) Interrupt Enables for IRQ 1 */

    struct {
      __IOM uint32_t INTE1      : 16;           /*!< [15..0] Set bit n to pass interrupts from channel n to DMA IRQ 1. */
            uint32_t            : 16;
    } INTE1_b;
  } ;

  union {
    __IOM uint32_t INTF1;                       /*!< (@ 0x00000418) Force Interrupts for IRQ 1 */

    struct {
      __IOM uint32_t INTF1      : 16;           /*!< [15..0] Write 1s to force the corresponding bits in INTE0. The interrupt remains asserted until INTF0 is cleared. */
            uint32_t            : 16;
    } INTF1_b;
  } ;

  union {
    __IOM uint32_t INTS1;                       /*!< (@ 0x0000041C) Interrupt Status (masked) for IRQ 1 */

    struct {
      __IOM uint32_t INTS1      : 16;           /*!< [15..0] Indicates active channel interrupt requests which are currently causing IRQ 1 to be asserted. Channel interrupts can be cleared by writing a bit mask here. */
            uint32_t            : 16;
    } INTS1_b;
  } ;

  union {
    __IOM uint32_t TIMER0;                      /*!< (@ 0x00000420) Pacing (X/Y) Fractional Timer The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less. */

    struct {
      __IOM uint32_t Y          : 16;           /*!< [15..0] Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer. */
      __IOM uint32_t X          : 16;           /*!< [31..16] Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer. */
    } TIMER0_b;
  } ;

  union {
    __IOM uint32_t TIMER1;                      /*!< (@ 0x00000424) Pacing (X/Y) Fractional Timer The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less. */

    struct {
      __IOM uint32_t Y          : 16;           /*!< [15..0] Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer. */
      __IOM uint32_t X          : 16;           /*!< [31..16] Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer. */
    } TIMER1_b;
  } ;

  union {
    __IOM uint32_t TIMER2;                      /*!< (@ 0x00000428) Pacing (X/Y) Fractional Timer The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less. */

    struct {
      __IOM uint32_t Y          : 16;           /*!< [15..0] Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer. */
      __IOM uint32_t X          : 16;           /*!< [31..16] Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer. */
    } TIMER2_b;
  } ;

  union {
    __IOM uint32_t TIMER3;                      /*!< (@ 0x0000042C) Pacing (X/Y) Fractional Timer The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less. */

    struct {
      __IOM uint32_t Y          : 16;           /*!< [15..0] Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer. */
      __IOM uint32_t X          : 16;           /*!< [31..16] Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer. */
    } TIMER3_b;
  } ;

  union {
    __IOM uint32_t MULTI_CHAN_TRIGGER;          /*!< (@ 0x00000430) Trigger one or more channels simultaneously */

    struct {
      __IOM uint32_t MULTI_CHAN_TRIGGER : 16;   /*!< [15..0] Each bit in this register corresponds to a DMA channel. Writing a 1 to the relevant bit is the same as writing to that channel's trigger register; the channel will start if it is currently enabled and not already busy. */
            uint32_t            : 16;
    } MULTI_CHAN_TRIGGER_b;
  } ;

  union {
    __IOM uint32_t SNIFF_CTRL;                  /*!< (@ 0x00000434) Sniffer Control */

    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Enable sniffer */
      __IOM uint32_t DMACH      : 4;            /*!< [4..1] DMA channel for Sniffer to observe */
      __IOM uint32_t CALC       : 4;            /*!< [8..5] CALC */
      __IOM uint32_t BSWAP      : 1;            /*!< [9..9] Locally perform a byte reverse on the sniffed data, before feeding into checksum. Note that the sniff hardware is downstream of the DMA channel byteswap performed in the read master: if channel CTRL_BSWAP and SNIFF_CTRL_BSWAP are both enabled, their effects cancel from the sniffer's point of view. */
      __IOM uint32_t OUT_REV    : 1;            /*!< [10..10] If set, the result appears bit-reversed when read. This does not affect the way the checksum is calculated; the result is transformed on-the-fly between the result register and the bus. */
      __IOM uint32_t OUT_INV    : 1;            /*!< [11..11] If set, the result appears inverted (bitwise complement) when read. This does not affect the way the checksum is calculated; the result is transformed on-the-fly between the result register and the bus. */
            uint32_t            : 20;
    } SNIFF_CTRL_b;
  } ;
  __IOM uint32_t  SNIFF_DATA;                   /*!< (@ 0x00000438) Data accumulator for sniff hardware Write an initial seed value here before starting a DMA transfer on the channel indicated by SNIFF_CTRL_DMACH. The hardware will update this register each time it observes a read from the indicated channel. Once the channel completes, the final result can be read from this register. */
  __IM  uint32_t  RESERVED2;

  union {
    __IOM uint32_t FIFO_LEVELS;                 /*!< (@ 0x00000440) Debug RAF, WAF, TDF levels */

    struct {
      __IM  uint32_t TDF_LVL    : 8;            /*!< [7..0] Current Transfer-Data-FIFO fill level */
      __IM  uint32_t WAF_LVL    : 8;            /*!< [15..8] Current Write-Address-FIFO fill level */
      __IM  uint32_t RAF_LVL    : 8;            /*!< [23..16] Current Read-Address-FIFO fill level */
            uint32_t            : 8;
    } FIFO_LEVELS_b;
  } ;

  union {
    __IOM uint32_t CHAN_ABORT;                  /*!< (@ 0x00000444) Abort an in-progress transfer sequence on one or more channels */

    struct {
      __IOM uint32_t CHAN_ABORT : 16;           /*!< [15..0] Each bit corresponds to a channel. Writing a 1 aborts whatever transfer sequence is in progress on that channel. The bit will remain high until any in-flight transfers have been flushed through the address and data FIFOs. After writing, this register must be polled until it returns all-zero. Until this point, it is unsafe to restart the channel. */
            uint32_t            : 16;
    } CHAN_ABORT_b;
  } ;

  union {
    __IOM uint32_t N_CHANNELS;                  /*!< (@ 0x00000448) The number of channels this DMA instance is equipped with. This DMA supports up to 16 hardware channels, but can be configured with as few as one, to minimise silicon area. */

    struct {
      __IM  uint32_t N_CHANNELS : 5;            /*!< [4..0] N_CHANNELS */
            uint32_t            : 27;
    } N_CHANNELS_b;
  } ;
  __IM  uint32_t  RESERVED3[237];

  union {
    __IOM uint32_t CH0_DBG_CTDREQ;              /*!< (@ 0x00000800) Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake. */

    struct {
      __IOM uint32_t CH0_DBG_CTDREQ : 6;        /*!< [5..0] CH0_DBG_CTDREQ */
            uint32_t            : 26;
    } CH0_DBG_CTDREQ_b;
  } ;
  __IM  uint32_t  CH0_DBG_TCR;                  /*!< (@ 0x00000804) Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer */
  __IM  uint32_t  RESERVED4[14];

  union {
    __IOM uint32_t CH1_DBG_CTDREQ;              /*!< (@ 0x00000840) Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake. */

    struct {
      __IOM uint32_t CH1_DBG_CTDREQ : 6;        /*!< [5..0] CH1_DBG_CTDREQ */
            uint32_t            : 26;
    } CH1_DBG_CTDREQ_b;
  } ;
  __IM  uint32_t  CH1_DBG_TCR;                  /*!< (@ 0x00000844) Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer */
  __IM  uint32_t  RESERVED5[14];

  union {
    __IOM uint32_t CH2_DBG_CTDREQ;              /*!< (@ 0x00000880) Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake. */

    struct {
      __IOM uint32_t CH2_DBG_CTDREQ : 6;        /*!< [5..0] CH2_DBG_CTDREQ */
            uint32_t            : 26;
    } CH2_DBG_CTDREQ_b;
  } ;
  __IM  uint32_t  CH2_DBG_TCR;                  /*!< (@ 0x00000884) Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer */
  __IM  uint32_t  RESERVED6[14];

  union {
    __IOM uint32_t CH3_DBG_CTDREQ;              /*!< (@ 0x000008C0) Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake. */

    struct {
      __IOM uint32_t CH3_DBG_CTDREQ : 6;        /*!< [5..0] CH3_DBG_CTDREQ */
            uint32_t            : 26;
    } CH3_DBG_CTDREQ_b;
  } ;
  __IM  uint32_t  CH3_DBG_TCR;                  /*!< (@ 0x000008C4) Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer */
  __IM  uint32_t  RESERVED7[14];

  union {
    __IOM uint32_t CH4_DBG_CTDREQ;              /*!< (@ 0x00000900) Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake. */

    struct {
      __IOM uint32_t CH4_DBG_CTDREQ : 6;        /*!< [5..0] CH4_DBG_CTDREQ */
            uint32_t            : 26;
    } CH4_DBG_CTDREQ_b;
  } ;
  __IM  uint32_t  CH4_DBG_TCR;                  /*!< (@ 0x00000904) Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer */
  __IM  uint32_t  RESERVED8[14];

  union {
    __IOM uint32_t CH5_DBG_CTDREQ;              /*!< (@ 0x00000940) Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake. */

    struct {
      __IOM uint32_t CH5_DBG_CTDREQ : 6;        /*!< [5..0] CH5_DBG_CTDREQ */
            uint32_t            : 26;
    } CH5_DBG_CTDREQ_b;
  } ;
  __IM  uint32_t  CH5_DBG_TCR;                  /*!< (@ 0x00000944) Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer */
  __IM  uint32_t  RESERVED9[14];

  union {
    __IOM uint32_t CH6_DBG_CTDREQ;              /*!< (@ 0x00000980) Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake. */

    struct {
      __IOM uint32_t CH6_DBG_CTDREQ : 6;        /*!< [5..0] CH6_DBG_CTDREQ */
            uint32_t            : 26;
    } CH6_DBG_CTDREQ_b;
  } ;
  __IM  uint32_t  CH6_DBG_TCR;                  /*!< (@ 0x00000984) Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer */
  __IM  uint32_t  RESERVED10[14];

  union {
    __IOM uint32_t CH7_DBG_CTDREQ;              /*!< (@ 0x000009C0) Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake. */

    struct {
      __IOM uint32_t CH7_DBG_CTDREQ : 6;        /*!< [5..0] CH7_DBG_CTDREQ */
            uint32_t            : 26;
    } CH7_DBG_CTDREQ_b;
  } ;
  __IM  uint32_t  CH7_DBG_TCR;                  /*!< (@ 0x000009C4) Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer */
  __IM  uint32_t  RESERVED11[14];

  union {
    __IOM uint32_t CH8_DBG_CTDREQ;              /*!< (@ 0x00000A00) Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake. */

    struct {
      __IOM uint32_t CH8_DBG_CTDREQ : 6;        /*!< [5..0] CH8_DBG_CTDREQ */
            uint32_t            : 26;
    } CH8_DBG_CTDREQ_b;
  } ;
  __IM  uint32_t  CH8_DBG_TCR;                  /*!< (@ 0x00000A04) Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer */
  __IM  uint32_t  RESERVED12[14];

  union {
    __IOM uint32_t CH9_DBG_CTDREQ;              /*!< (@ 0x00000A40) Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake. */

    struct {
      __IOM uint32_t CH9_DBG_CTDREQ : 6;        /*!< [5..0] CH9_DBG_CTDREQ */
            uint32_t            : 26;
    } CH9_DBG_CTDREQ_b;
  } ;
  __IM  uint32_t  CH9_DBG_TCR;                  /*!< (@ 0x00000A44) Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer */
  __IM  uint32_t  RESERVED13[14];

  union {
    __IOM uint32_t CH10_DBG_CTDREQ;             /*!< (@ 0x00000A80) Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake. */

    struct {
      __IOM uint32_t CH10_DBG_CTDREQ : 6;       /*!< [5..0] CH10_DBG_CTDREQ */
            uint32_t            : 26;
    } CH10_DBG_CTDREQ_b;
  } ;
  __IM  uint32_t  CH10_DBG_TCR;                 /*!< (@ 0x00000A84) Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer */
  __IM  uint32_t  RESERVED14[14];

  union {
    __IOM uint32_t CH11_DBG_CTDREQ;             /*!< (@ 0x00000AC0) Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake. */

    struct {
      __IOM uint32_t CH11_DBG_CTDREQ : 6;       /*!< [5..0] CH11_DBG_CTDREQ */
            uint32_t            : 26;
    } CH11_DBG_CTDREQ_b;
  } ;
  __IM  uint32_t  CH11_DBG_TCR;                 /*!< (@ 0x00000AC4) Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer */
} DMA_Type;                                     /*!< Size = 2760 (0xac8) */



/* =========================================================================================================================== */
/* ================                                       USBCTRL_DPRAM                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief DPRAM layout for USB device. (USBCTRL_DPRAM)
  */

typedef struct {                                /*!< (@ 0x50100000) USBCTRL_DPRAM Structure */

  union {
    __IOM uint32_t SETUP_PACKET_LOW;            /*!< (@ 0x00000000) Bytes 0-3 of the SETUP packet from the host. */

    struct {
      __IOM uint32_t BMREQUESTTYPE : 8;         /*!< [7..0] BMREQUESTTYPE */
      __IOM uint32_t BREQUEST   : 8;            /*!< [15..8] BREQUEST */
      __IOM uint32_t WVALUE     : 16;           /*!< [31..16] WVALUE */
    } SETUP_PACKET_LOW_b;
  } ;

  union {
    __IOM uint32_t SETUP_PACKET_HIGH;           /*!< (@ 0x00000004) Bytes 4-7 of the setup packet from the host. */

    struct {
      __IOM uint32_t WINDEX     : 16;           /*!< [15..0] WINDEX */
      __IOM uint32_t WLENGTH    : 16;           /*!< [31..16] WLENGTH */
    } SETUP_PACKET_HIGH_b;
  } ;

  union {
    __IOM uint32_t EP1_IN_CONTROL;              /*!< (@ 0x00000008) EP1_IN_CONTROL */

    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< [15..0] 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM. */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< [16..16] Trigger an interrupt if a NAK is sent. Intended for debug only. */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< [17..17] Trigger an interrupt if a STALL is sent. Intended for debug only. */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< [27..26] ENDPOINT_TYPE */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< [28..28] Trigger an interrupt each time both buffers are done. Only valid in double buffered mode. */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< [29..29] Trigger an interrupt each time a buffer is done. */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< [30..30] This endpoint is double buffered. */
      __IOM uint32_t ENABLE     : 1;            /*!< [31..31] Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set. */
    } EP1_IN_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP1_OUT_CONTROL;             /*!< (@ 0x0000000C) EP1_OUT_CONTROL */

    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< [15..0] 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM. */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< [16..16] Trigger an interrupt if a NAK is sent. Intended for debug only. */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< [17..17] Trigger an interrupt if a STALL is sent. Intended for debug only. */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< [27..26] ENDPOINT_TYPE */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< [28..28] Trigger an interrupt each time both buffers are done. Only valid in double buffered mode. */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< [29..29] Trigger an interrupt each time a buffer is done. */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< [30..30] This endpoint is double buffered. */
      __IOM uint32_t ENABLE     : 1;            /*!< [31..31] Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set. */
    } EP1_OUT_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP2_IN_CONTROL;              /*!< (@ 0x00000010) EP2_IN_CONTROL */

    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< [15..0] 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM. */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< [16..16] Trigger an interrupt if a NAK is sent. Intended for debug only. */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< [17..17] Trigger an interrupt if a STALL is sent. Intended for debug only. */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< [27..26] ENDPOINT_TYPE */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< [28..28] Trigger an interrupt each time both buffers are done. Only valid in double buffered mode. */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< [29..29] Trigger an interrupt each time a buffer is done. */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< [30..30] This endpoint is double buffered. */
      __IOM uint32_t ENABLE     : 1;            /*!< [31..31] Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set. */
    } EP2_IN_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP2_OUT_CONTROL;             /*!< (@ 0x00000014) EP2_OUT_CONTROL */

    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< [15..0] 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM. */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< [16..16] Trigger an interrupt if a NAK is sent. Intended for debug only. */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< [17..17] Trigger an interrupt if a STALL is sent. Intended for debug only. */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< [27..26] ENDPOINT_TYPE */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< [28..28] Trigger an interrupt each time both buffers are done. Only valid in double buffered mode. */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< [29..29] Trigger an interrupt each time a buffer is done. */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< [30..30] This endpoint is double buffered. */
      __IOM uint32_t ENABLE     : 1;            /*!< [31..31] Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set. */
    } EP2_OUT_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP3_IN_CONTROL;              /*!< (@ 0x00000018) EP3_IN_CONTROL */

    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< [15..0] 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM. */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< [16..16] Trigger an interrupt if a NAK is sent. Intended for debug only. */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< [17..17] Trigger an interrupt if a STALL is sent. Intended for debug only. */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< [27..26] ENDPOINT_TYPE */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< [28..28] Trigger an interrupt each time both buffers are done. Only valid in double buffered mode. */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< [29..29] Trigger an interrupt each time a buffer is done. */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< [30..30] This endpoint is double buffered. */
      __IOM uint32_t ENABLE     : 1;            /*!< [31..31] Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set. */
    } EP3_IN_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP3_OUT_CONTROL;             /*!< (@ 0x0000001C) EP3_OUT_CONTROL */

    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< [15..0] 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM. */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< [16..16] Trigger an interrupt if a NAK is sent. Intended for debug only. */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< [17..17] Trigger an interrupt if a STALL is sent. Intended for debug only. */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< [27..26] ENDPOINT_TYPE */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< [28..28] Trigger an interrupt each time both buffers are done. Only valid in double buffered mode. */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< [29..29] Trigger an interrupt each time a buffer is done. */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< [30..30] This endpoint is double buffered. */
      __IOM uint32_t ENABLE     : 1;            /*!< [31..31] Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set. */
    } EP3_OUT_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP4_IN_CONTROL;              /*!< (@ 0x00000020) EP4_IN_CONTROL */

    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< [15..0] 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM. */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< [16..16] Trigger an interrupt if a NAK is sent. Intended for debug only. */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< [17..17] Trigger an interrupt if a STALL is sent. Intended for debug only. */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< [27..26] ENDPOINT_TYPE */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< [28..28] Trigger an interrupt each time both buffers are done. Only valid in double buffered mode. */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< [29..29] Trigger an interrupt each time a buffer is done. */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< [30..30] This endpoint is double buffered. */
      __IOM uint32_t ENABLE     : 1;            /*!< [31..31] Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set. */
    } EP4_IN_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP4_OUT_CONTROL;             /*!< (@ 0x00000024) EP4_OUT_CONTROL */

    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< [15..0] 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM. */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< [16..16] Trigger an interrupt if a NAK is sent. Intended for debug only. */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< [17..17] Trigger an interrupt if a STALL is sent. Intended for debug only. */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< [27..26] ENDPOINT_TYPE */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< [28..28] Trigger an interrupt each time both buffers are done. Only valid in double buffered mode. */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< [29..29] Trigger an interrupt each time a buffer is done. */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< [30..30] This endpoint is double buffered. */
      __IOM uint32_t ENABLE     : 1;            /*!< [31..31] Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set. */
    } EP4_OUT_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP5_IN_CONTROL;              /*!< (@ 0x00000028) EP5_IN_CONTROL */

    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< [15..0] 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM. */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< [16..16] Trigger an interrupt if a NAK is sent. Intended for debug only. */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< [17..17] Trigger an interrupt if a STALL is sent. Intended for debug only. */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< [27..26] ENDPOINT_TYPE */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< [28..28] Trigger an interrupt each time both buffers are done. Only valid in double buffered mode. */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< [29..29] Trigger an interrupt each time a buffer is done. */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< [30..30] This endpoint is double buffered. */
      __IOM uint32_t ENABLE     : 1;            /*!< [31..31] Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set. */
    } EP5_IN_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP5_OUT_CONTROL;             /*!< (@ 0x0000002C) EP5_OUT_CONTROL */

    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< [15..0] 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM. */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< [16..16] Trigger an interrupt if a NAK is sent. Intended for debug only. */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< [17..17] Trigger an interrupt if a STALL is sent. Intended for debug only. */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< [27..26] ENDPOINT_TYPE */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< [28..28] Trigger an interrupt each time both buffers are done. Only valid in double buffered mode. */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< [29..29] Trigger an interrupt each time a buffer is done. */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< [30..30] This endpoint is double buffered. */
      __IOM uint32_t ENABLE     : 1;            /*!< [31..31] Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set. */
    } EP5_OUT_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP6_IN_CONTROL;              /*!< (@ 0x00000030) EP6_IN_CONTROL */

    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< [15..0] 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM. */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< [16..16] Trigger an interrupt if a NAK is sent. Intended for debug only. */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< [17..17] Trigger an interrupt if a STALL is sent. Intended for debug only. */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< [27..26] ENDPOINT_TYPE */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< [28..28] Trigger an interrupt each time both buffers are done. Only valid in double buffered mode. */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< [29..29] Trigger an interrupt each time a buffer is done. */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< [30..30] This endpoint is double buffered. */
      __IOM uint32_t ENABLE     : 1;            /*!< [31..31] Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set. */
    } EP6_IN_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP6_OUT_CONTROL;             /*!< (@ 0x00000034) EP6_OUT_CONTROL */

    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< [15..0] 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM. */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< [16..16] Trigger an interrupt if a NAK is sent. Intended for debug only. */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< [17..17] Trigger an interrupt if a STALL is sent. Intended for debug only. */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< [27..26] ENDPOINT_TYPE */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< [28..28] Trigger an interrupt each time both buffers are done. Only valid in double buffered mode. */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< [29..29] Trigger an interrupt each time a buffer is done. */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< [30..30] This endpoint is double buffered. */
      __IOM uint32_t ENABLE     : 1;            /*!< [31..31] Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set. */
    } EP6_OUT_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP7_IN_CONTROL;              /*!< (@ 0x00000038) EP7_IN_CONTROL */

    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< [15..0] 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM. */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< [16..16] Trigger an interrupt if a NAK is sent. Intended for debug only. */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< [17..17] Trigger an interrupt if a STALL is sent. Intended for debug only. */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< [27..26] ENDPOINT_TYPE */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< [28..28] Trigger an interrupt each time both buffers are done. Only valid in double buffered mode. */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< [29..29] Trigger an interrupt each time a buffer is done. */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< [30..30] This endpoint is double buffered. */
      __IOM uint32_t ENABLE     : 1;            /*!< [31..31] Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set. */
    } EP7_IN_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP7_OUT_CONTROL;             /*!< (@ 0x0000003C) EP7_OUT_CONTROL */

    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< [15..0] 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM. */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< [16..16] Trigger an interrupt if a NAK is sent. Intended for debug only. */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< [17..17] Trigger an interrupt if a STALL is sent. Intended for debug only. */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< [27..26] ENDPOINT_TYPE */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< [28..28] Trigger an interrupt each time both buffers are done. Only valid in double buffered mode. */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< [29..29] Trigger an interrupt each time a buffer is done. */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< [30..30] This endpoint is double buffered. */
      __IOM uint32_t ENABLE     : 1;            /*!< [31..31] Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set. */
    } EP7_OUT_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP8_IN_CONTROL;              /*!< (@ 0x00000040) EP8_IN_CONTROL */

    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< [15..0] 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM. */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< [16..16] Trigger an interrupt if a NAK is sent. Intended for debug only. */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< [17..17] Trigger an interrupt if a STALL is sent. Intended for debug only. */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< [27..26] ENDPOINT_TYPE */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< [28..28] Trigger an interrupt each time both buffers are done. Only valid in double buffered mode. */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< [29..29] Trigger an interrupt each time a buffer is done. */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< [30..30] This endpoint is double buffered. */
      __IOM uint32_t ENABLE     : 1;            /*!< [31..31] Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set. */
    } EP8_IN_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP8_OUT_CONTROL;             /*!< (@ 0x00000044) EP8_OUT_CONTROL */

    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< [15..0] 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM. */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< [16..16] Trigger an interrupt if a NAK is sent. Intended for debug only. */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< [17..17] Trigger an interrupt if a STALL is sent. Intended for debug only. */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< [27..26] ENDPOINT_TYPE */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< [28..28] Trigger an interrupt each time both buffers are done. Only valid in double buffered mode. */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< [29..29] Trigger an interrupt each time a buffer is done. */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< [30..30] This endpoint is double buffered. */
      __IOM uint32_t ENABLE     : 1;            /*!< [31..31] Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set. */
    } EP8_OUT_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP9_IN_CONTROL;              /*!< (@ 0x00000048) EP9_IN_CONTROL */

    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< [15..0] 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM. */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< [16..16] Trigger an interrupt if a NAK is sent. Intended for debug only. */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< [17..17] Trigger an interrupt if a STALL is sent. Intended for debug only. */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< [27..26] ENDPOINT_TYPE */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< [28..28] Trigger an interrupt each time both buffers are done. Only valid in double buffered mode. */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< [29..29] Trigger an interrupt each time a buffer is done. */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< [30..30] This endpoint is double buffered. */
      __IOM uint32_t ENABLE     : 1;            /*!< [31..31] Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set. */
    } EP9_IN_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP9_OUT_CONTROL;             /*!< (@ 0x0000004C) EP9_OUT_CONTROL */

    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< [15..0] 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM. */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< [16..16] Trigger an interrupt if a NAK is sent. Intended for debug only. */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< [17..17] Trigger an interrupt if a STALL is sent. Intended for debug only. */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< [27..26] ENDPOINT_TYPE */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< [28..28] Trigger an interrupt each time both buffers are done. Only valid in double buffered mode. */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< [29..29] Trigger an interrupt each time a buffer is done. */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< [30..30] This endpoint is double buffered. */
      __IOM uint32_t ENABLE     : 1;            /*!< [31..31] Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set. */
    } EP9_OUT_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP10_IN_CONTROL;             /*!< (@ 0x00000050) EP10_IN_CONTROL */

    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< [15..0] 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM. */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< [16..16] Trigger an interrupt if a NAK is sent. Intended for debug only. */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< [17..17] Trigger an interrupt if a STALL is sent. Intended for debug only. */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< [27..26] ENDPOINT_TYPE */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< [28..28] Trigger an interrupt each time both buffers are done. Only valid in double buffered mode. */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< [29..29] Trigger an interrupt each time a buffer is done. */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< [30..30] This endpoint is double buffered. */
      __IOM uint32_t ENABLE     : 1;            /*!< [31..31] Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set. */
    } EP10_IN_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP10_OUT_CONTROL;            /*!< (@ 0x00000054) EP10_OUT_CONTROL */

    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< [15..0] 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM. */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< [16..16] Trigger an interrupt if a NAK is sent. Intended for debug only. */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< [17..17] Trigger an interrupt if a STALL is sent. Intended for debug only. */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< [27..26] ENDPOINT_TYPE */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< [28..28] Trigger an interrupt each time both buffers are done. Only valid in double buffered mode. */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< [29..29] Trigger an interrupt each time a buffer is done. */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< [30..30] This endpoint is double buffered. */
      __IOM uint32_t ENABLE     : 1;            /*!< [31..31] Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set. */
    } EP10_OUT_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP11_IN_CONTROL;             /*!< (@ 0x00000058) EP11_IN_CONTROL */

    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< [15..0] 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM. */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< [16..16] Trigger an interrupt if a NAK is sent. Intended for debug only. */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< [17..17] Trigger an interrupt if a STALL is sent. Intended for debug only. */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< [27..26] ENDPOINT_TYPE */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< [28..28] Trigger an interrupt each time both buffers are done. Only valid in double buffered mode. */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< [29..29] Trigger an interrupt each time a buffer is done. */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< [30..30] This endpoint is double buffered. */
      __IOM uint32_t ENABLE     : 1;            /*!< [31..31] Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set. */
    } EP11_IN_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP11_OUT_CONTROL;            /*!< (@ 0x0000005C) EP11_OUT_CONTROL */

    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< [15..0] 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM. */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< [16..16] Trigger an interrupt if a NAK is sent. Intended for debug only. */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< [17..17] Trigger an interrupt if a STALL is sent. Intended for debug only. */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< [27..26] ENDPOINT_TYPE */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< [28..28] Trigger an interrupt each time both buffers are done. Only valid in double buffered mode. */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< [29..29] Trigger an interrupt each time a buffer is done. */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< [30..30] This endpoint is double buffered. */
      __IOM uint32_t ENABLE     : 1;            /*!< [31..31] Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set. */
    } EP11_OUT_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP12_IN_CONTROL;             /*!< (@ 0x00000060) EP12_IN_CONTROL */

    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< [15..0] 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM. */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< [16..16] Trigger an interrupt if a NAK is sent. Intended for debug only. */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< [17..17] Trigger an interrupt if a STALL is sent. Intended for debug only. */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< [27..26] ENDPOINT_TYPE */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< [28..28] Trigger an interrupt each time both buffers are done. Only valid in double buffered mode. */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< [29..29] Trigger an interrupt each time a buffer is done. */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< [30..30] This endpoint is double buffered. */
      __IOM uint32_t ENABLE     : 1;            /*!< [31..31] Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set. */
    } EP12_IN_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP12_OUT_CONTROL;            /*!< (@ 0x00000064) EP12_OUT_CONTROL */

    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< [15..0] 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM. */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< [16..16] Trigger an interrupt if a NAK is sent. Intended for debug only. */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< [17..17] Trigger an interrupt if a STALL is sent. Intended for debug only. */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< [27..26] ENDPOINT_TYPE */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< [28..28] Trigger an interrupt each time both buffers are done. Only valid in double buffered mode. */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< [29..29] Trigger an interrupt each time a buffer is done. */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< [30..30] This endpoint is double buffered. */
      __IOM uint32_t ENABLE     : 1;            /*!< [31..31] Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set. */
    } EP12_OUT_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP13_IN_CONTROL;             /*!< (@ 0x00000068) EP13_IN_CONTROL */

    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< [15..0] 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM. */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< [16..16] Trigger an interrupt if a NAK is sent. Intended for debug only. */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< [17..17] Trigger an interrupt if a STALL is sent. Intended for debug only. */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< [27..26] ENDPOINT_TYPE */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< [28..28] Trigger an interrupt each time both buffers are done. Only valid in double buffered mode. */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< [29..29] Trigger an interrupt each time a buffer is done. */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< [30..30] This endpoint is double buffered. */
      __IOM uint32_t ENABLE     : 1;            /*!< [31..31] Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set. */
    } EP13_IN_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP13_OUT_CONTROL;            /*!< (@ 0x0000006C) EP13_OUT_CONTROL */

    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< [15..0] 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM. */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< [16..16] Trigger an interrupt if a NAK is sent. Intended for debug only. */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< [17..17] Trigger an interrupt if a STALL is sent. Intended for debug only. */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< [27..26] ENDPOINT_TYPE */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< [28..28] Trigger an interrupt each time both buffers are done. Only valid in double buffered mode. */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< [29..29] Trigger an interrupt each time a buffer is done. */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< [30..30] This endpoint is double buffered. */
      __IOM uint32_t ENABLE     : 1;            /*!< [31..31] Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set. */
    } EP13_OUT_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP14_IN_CONTROL;             /*!< (@ 0x00000070) EP14_IN_CONTROL */

    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< [15..0] 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM. */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< [16..16] Trigger an interrupt if a NAK is sent. Intended for debug only. */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< [17..17] Trigger an interrupt if a STALL is sent. Intended for debug only. */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< [27..26] ENDPOINT_TYPE */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< [28..28] Trigger an interrupt each time both buffers are done. Only valid in double buffered mode. */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< [29..29] Trigger an interrupt each time a buffer is done. */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< [30..30] This endpoint is double buffered. */
      __IOM uint32_t ENABLE     : 1;            /*!< [31..31] Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set. */
    } EP14_IN_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP14_OUT_CONTROL;            /*!< (@ 0x00000074) EP14_OUT_CONTROL */

    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< [15..0] 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM. */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< [16..16] Trigger an interrupt if a NAK is sent. Intended for debug only. */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< [17..17] Trigger an interrupt if a STALL is sent. Intended for debug only. */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< [27..26] ENDPOINT_TYPE */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< [28..28] Trigger an interrupt each time both buffers are done. Only valid in double buffered mode. */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< [29..29] Trigger an interrupt each time a buffer is done. */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< [30..30] This endpoint is double buffered. */
      __IOM uint32_t ENABLE     : 1;            /*!< [31..31] Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set. */
    } EP14_OUT_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP15_IN_CONTROL;             /*!< (@ 0x00000078) EP15_IN_CONTROL */

    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< [15..0] 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM. */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< [16..16] Trigger an interrupt if a NAK is sent. Intended for debug only. */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< [17..17] Trigger an interrupt if a STALL is sent. Intended for debug only. */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< [27..26] ENDPOINT_TYPE */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< [28..28] Trigger an interrupt each time both buffers are done. Only valid in double buffered mode. */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< [29..29] Trigger an interrupt each time a buffer is done. */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< [30..30] This endpoint is double buffered. */
      __IOM uint32_t ENABLE     : 1;            /*!< [31..31] Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set. */
    } EP15_IN_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP15_OUT_CONTROL;            /*!< (@ 0x0000007C) EP15_OUT_CONTROL */

    struct {
      __IOM uint32_t BUFFER_ADDRESS : 16;       /*!< [15..0] 64 byte aligned buffer address for this EP (bits 0-5 are ignored). Relative to the start of the DPRAM. */
      __IOM uint32_t INTERRUPT_ON_NAK : 1;      /*!< [16..16] Trigger an interrupt if a NAK is sent. Intended for debug only. */
      __IOM uint32_t INTERRUPT_ON_STALL : 1;    /*!< [17..17] Trigger an interrupt if a STALL is sent. Intended for debug only. */
            uint32_t            : 8;
      __IOM uint32_t ENDPOINT_TYPE : 2;         /*!< [27..26] ENDPOINT_TYPE */
      __IOM uint32_t INTERRUPT_PER_DOUBLE_BUFF : 1;/*!< [28..28] Trigger an interrupt each time both buffers are done. Only valid in double buffered mode. */
      __IOM uint32_t INTERRUPT_PER_BUFF : 1;    /*!< [29..29] Trigger an interrupt each time a buffer is done. */
      __IOM uint32_t DOUBLE_BUFFERED : 1;       /*!< [30..30] This endpoint is double buffered. */
      __IOM uint32_t ENABLE     : 1;            /*!< [31..31] Enable this endpoint. The device will not reply to any packets for this endpoint if this bit is not set. */
    } EP15_OUT_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP0_IN_BUFFER_CONTROL;       /*!< (@ 0x00000080) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP0_IN_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP0_OUT_BUFFER_CONTROL;      /*!< (@ 0x00000084) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP0_OUT_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP1_IN_BUFFER_CONTROL;       /*!< (@ 0x00000088) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP1_IN_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP1_OUT_BUFFER_CONTROL;      /*!< (@ 0x0000008C) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP1_OUT_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP2_IN_BUFFER_CONTROL;       /*!< (@ 0x00000090) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP2_IN_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP2_OUT_BUFFER_CONTROL;      /*!< (@ 0x00000094) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP2_OUT_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP3_IN_BUFFER_CONTROL;       /*!< (@ 0x00000098) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP3_IN_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP3_OUT_BUFFER_CONTROL;      /*!< (@ 0x0000009C) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP3_OUT_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP4_IN_BUFFER_CONTROL;       /*!< (@ 0x000000A0) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP4_IN_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP4_OUT_BUFFER_CONTROL;      /*!< (@ 0x000000A4) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP4_OUT_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP5_IN_BUFFER_CONTROL;       /*!< (@ 0x000000A8) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP5_IN_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP5_OUT_BUFFER_CONTROL;      /*!< (@ 0x000000AC) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP5_OUT_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP6_IN_BUFFER_CONTROL;       /*!< (@ 0x000000B0) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP6_IN_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP6_OUT_BUFFER_CONTROL;      /*!< (@ 0x000000B4) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP6_OUT_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP7_IN_BUFFER_CONTROL;       /*!< (@ 0x000000B8) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP7_IN_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP7_OUT_BUFFER_CONTROL;      /*!< (@ 0x000000BC) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP7_OUT_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP8_IN_BUFFER_CONTROL;       /*!< (@ 0x000000C0) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP8_IN_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP8_OUT_BUFFER_CONTROL;      /*!< (@ 0x000000C4) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP8_OUT_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP9_IN_BUFFER_CONTROL;       /*!< (@ 0x000000C8) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP9_IN_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP9_OUT_BUFFER_CONTROL;      /*!< (@ 0x000000CC) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP9_OUT_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP10_IN_BUFFER_CONTROL;      /*!< (@ 0x000000D0) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP10_IN_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP10_OUT_BUFFER_CONTROL;     /*!< (@ 0x000000D4) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP10_OUT_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP11_IN_BUFFER_CONTROL;      /*!< (@ 0x000000D8) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP11_IN_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP11_OUT_BUFFER_CONTROL;     /*!< (@ 0x000000DC) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP11_OUT_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP12_IN_BUFFER_CONTROL;      /*!< (@ 0x000000E0) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP12_IN_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP12_OUT_BUFFER_CONTROL;     /*!< (@ 0x000000E4) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP12_OUT_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP13_IN_BUFFER_CONTROL;      /*!< (@ 0x000000E8) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP13_IN_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP13_OUT_BUFFER_CONTROL;     /*!< (@ 0x000000EC) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP13_OUT_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP14_IN_BUFFER_CONTROL;      /*!< (@ 0x000000F0) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP14_IN_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP14_OUT_BUFFER_CONTROL;     /*!< (@ 0x000000F4) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP14_OUT_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP15_IN_BUFFER_CONTROL;      /*!< (@ 0x000000F8) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP15_IN_BUFFER_CONTROL_b;
  } ;

  union {
    __IOM uint32_t EP15_OUT_BUFFER_CONTROL;     /*!< (@ 0x000000FC) Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode. */

    struct {
      __IOM uint32_t LENGTH_0   : 10;           /*!< [9..0] The length of the data in buffer 0. */
      __IOM uint32_t AVAILABLE_0 : 1;           /*!< [10..10] Buffer 0 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t STALL      : 1;            /*!< [11..11] Reply with a stall (valid for both buffers). */
      __IOM uint32_t RESET      : 1;            /*!< [12..12] Reset the buffer selector to buffer 0. */
      __IOM uint32_t PID_0      : 1;            /*!< [13..13] The data pid of buffer 0. */
      __IOM uint32_t LAST_0     : 1;            /*!< [14..14] Buffer 0 is the last buffer of the transfer. */
      __IOM uint32_t FULL_0     : 1;            /*!< [15..15] Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
      __IOM uint32_t LENGTH_1   : 10;           /*!< [25..16] The length of the data in buffer 1. */
      __IOM uint32_t AVAILABLE_1 : 1;           /*!< [26..26] Buffer 1 is available. This bit is set to indicate the buffer can be used by the controller. The controller clears the available bit when writing the status back. */
      __IOM uint32_t DOUBLE_BUFFER_ISO_OFFSET : 2;/*!< [28..27] The number of bytes buffer 1 is offset from buffer 0 in Isochronous mode. Only valid in double buffered mode for an Isochronous endpoint. For a non Isochronous endpoint the offset is always 64 bytes. */
      __IOM uint32_t PID_1      : 1;            /*!< [29..29] The data pid of buffer 1. */
      __IOM uint32_t LAST_1     : 1;            /*!< [30..30] Buffer 1 is the last buffer of the transfer. */
      __IOM uint32_t FULL_1     : 1;            /*!< [31..31] Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to indicate the data is valid. For an OUT transfer (RX from the host) this bit should be left as a 0. The host will set it when it has filled the buffer with data. */
    } EP15_OUT_BUFFER_CONTROL_b;
  } ;
} USBCTRL_DPRAM_Type;                           /*!< Size = 256 (0x100) */



/* =========================================================================================================================== */
/* ================                                       USBCTRL_REGS                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief USB FS/LS controller device registers (USBCTRL_REGS)
  */

typedef struct {                                /*!< (@ 0x50110000) USBCTRL_REGS Structure */

  union {
    __IOM uint32_t ADDR_ENDP;                   /*!< (@ 0x00000000) Device address and endpoint control */

    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] In device mode, the address that the device should respond to. Set in response to a SET_ADDR setup packet from the host. In host mode set to the address of the device to communicate with. */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Device endpoint to send data to. Only valid for HOST mode. */
            uint32_t            : 12;
    } ADDR_ENDP_b;
  } ;

  union {
    __IOM uint32_t ADDR_ENDP1;                  /*!< (@ 0x00000004) Interrupt endpoint 1. Only valid for HOST mode. */

    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] Device address */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Endpoint number of the interrupt endpoint */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< [25..25] Direction of the interrupt endpoint. In=0, Out=1 */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< [26..26] Interrupt EP requires preamble (is a low speed device on a full speed hub) */
            uint32_t            : 5;
    } ADDR_ENDP1_b;
  } ;

  union {
    __IOM uint32_t ADDR_ENDP2;                  /*!< (@ 0x00000008) Interrupt endpoint 2. Only valid for HOST mode. */

    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] Device address */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Endpoint number of the interrupt endpoint */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< [25..25] Direction of the interrupt endpoint. In=0, Out=1 */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< [26..26] Interrupt EP requires preamble (is a low speed device on a full speed hub) */
            uint32_t            : 5;
    } ADDR_ENDP2_b;
  } ;

  union {
    __IOM uint32_t ADDR_ENDP3;                  /*!< (@ 0x0000000C) Interrupt endpoint 3. Only valid for HOST mode. */

    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] Device address */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Endpoint number of the interrupt endpoint */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< [25..25] Direction of the interrupt endpoint. In=0, Out=1 */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< [26..26] Interrupt EP requires preamble (is a low speed device on a full speed hub) */
            uint32_t            : 5;
    } ADDR_ENDP3_b;
  } ;

  union {
    __IOM uint32_t ADDR_ENDP4;                  /*!< (@ 0x00000010) Interrupt endpoint 4. Only valid for HOST mode. */

    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] Device address */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Endpoint number of the interrupt endpoint */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< [25..25] Direction of the interrupt endpoint. In=0, Out=1 */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< [26..26] Interrupt EP requires preamble (is a low speed device on a full speed hub) */
            uint32_t            : 5;
    } ADDR_ENDP4_b;
  } ;

  union {
    __IOM uint32_t ADDR_ENDP5;                  /*!< (@ 0x00000014) Interrupt endpoint 5. Only valid for HOST mode. */

    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] Device address */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Endpoint number of the interrupt endpoint */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< [25..25] Direction of the interrupt endpoint. In=0, Out=1 */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< [26..26] Interrupt EP requires preamble (is a low speed device on a full speed hub) */
            uint32_t            : 5;
    } ADDR_ENDP5_b;
  } ;

  union {
    __IOM uint32_t ADDR_ENDP6;                  /*!< (@ 0x00000018) Interrupt endpoint 6. Only valid for HOST mode. */

    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] Device address */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Endpoint number of the interrupt endpoint */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< [25..25] Direction of the interrupt endpoint. In=0, Out=1 */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< [26..26] Interrupt EP requires preamble (is a low speed device on a full speed hub) */
            uint32_t            : 5;
    } ADDR_ENDP6_b;
  } ;

  union {
    __IOM uint32_t ADDR_ENDP7;                  /*!< (@ 0x0000001C) Interrupt endpoint 7. Only valid for HOST mode. */

    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] Device address */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Endpoint number of the interrupt endpoint */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< [25..25] Direction of the interrupt endpoint. In=0, Out=1 */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< [26..26] Interrupt EP requires preamble (is a low speed device on a full speed hub) */
            uint32_t            : 5;
    } ADDR_ENDP7_b;
  } ;

  union {
    __IOM uint32_t ADDR_ENDP8;                  /*!< (@ 0x00000020) Interrupt endpoint 8. Only valid for HOST mode. */

    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] Device address */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Endpoint number of the interrupt endpoint */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< [25..25] Direction of the interrupt endpoint. In=0, Out=1 */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< [26..26] Interrupt EP requires preamble (is a low speed device on a full speed hub) */
            uint32_t            : 5;
    } ADDR_ENDP8_b;
  } ;

  union {
    __IOM uint32_t ADDR_ENDP9;                  /*!< (@ 0x00000024) Interrupt endpoint 9. Only valid for HOST mode. */

    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] Device address */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Endpoint number of the interrupt endpoint */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< [25..25] Direction of the interrupt endpoint. In=0, Out=1 */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< [26..26] Interrupt EP requires preamble (is a low speed device on a full speed hub) */
            uint32_t            : 5;
    } ADDR_ENDP9_b;
  } ;

  union {
    __IOM uint32_t ADDR_ENDP10;                 /*!< (@ 0x00000028) Interrupt endpoint 10. Only valid for HOST mode. */

    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] Device address */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Endpoint number of the interrupt endpoint */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< [25..25] Direction of the interrupt endpoint. In=0, Out=1 */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< [26..26] Interrupt EP requires preamble (is a low speed device on a full speed hub) */
            uint32_t            : 5;
    } ADDR_ENDP10_b;
  } ;

  union {
    __IOM uint32_t ADDR_ENDP11;                 /*!< (@ 0x0000002C) Interrupt endpoint 11. Only valid for HOST mode. */

    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] Device address */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Endpoint number of the interrupt endpoint */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< [25..25] Direction of the interrupt endpoint. In=0, Out=1 */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< [26..26] Interrupt EP requires preamble (is a low speed device on a full speed hub) */
            uint32_t            : 5;
    } ADDR_ENDP11_b;
  } ;

  union {
    __IOM uint32_t ADDR_ENDP12;                 /*!< (@ 0x00000030) Interrupt endpoint 12. Only valid for HOST mode. */

    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] Device address */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Endpoint number of the interrupt endpoint */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< [25..25] Direction of the interrupt endpoint. In=0, Out=1 */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< [26..26] Interrupt EP requires preamble (is a low speed device on a full speed hub) */
            uint32_t            : 5;
    } ADDR_ENDP12_b;
  } ;

  union {
    __IOM uint32_t ADDR_ENDP13;                 /*!< (@ 0x00000034) Interrupt endpoint 13. Only valid for HOST mode. */

    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] Device address */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Endpoint number of the interrupt endpoint */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< [25..25] Direction of the interrupt endpoint. In=0, Out=1 */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< [26..26] Interrupt EP requires preamble (is a low speed device on a full speed hub) */
            uint32_t            : 5;
    } ADDR_ENDP13_b;
  } ;

  union {
    __IOM uint32_t ADDR_ENDP14;                 /*!< (@ 0x00000038) Interrupt endpoint 14. Only valid for HOST mode. */

    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] Device address */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Endpoint number of the interrupt endpoint */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< [25..25] Direction of the interrupt endpoint. In=0, Out=1 */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< [26..26] Interrupt EP requires preamble (is a low speed device on a full speed hub) */
            uint32_t            : 5;
    } ADDR_ENDP14_b;
  } ;

  union {
    __IOM uint32_t ADDR_ENDP15;                 /*!< (@ 0x0000003C) Interrupt endpoint 15. Only valid for HOST mode. */

    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] Device address */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Endpoint number of the interrupt endpoint */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< [25..25] Direction of the interrupt endpoint. In=0, Out=1 */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< [26..26] Interrupt EP requires preamble (is a low speed device on a full speed hub) */
            uint32_t            : 5;
    } ADDR_ENDP15_b;
  } ;

  union {
    __IOM uint32_t MAIN_CTRL;                   /*!< (@ 0x00000040) Main control register */

    struct {
      __IOM uint32_t CONTROLLER_EN : 1;         /*!< [0..0] Enable controller */
      __IOM uint32_t HOST_NDEVICE : 1;          /*!< [1..1] Device mode = 0, Host mode = 1 */
            uint32_t            : 29;
      __IOM uint32_t SIM_TIMING : 1;            /*!< [31..31] Reduced timings for simulation */
    } MAIN_CTRL_b;
  } ;

  union {
    __IOM uint32_t SOF_WR;                      /*!< (@ 0x00000044) Set the SOF (Start of Frame) frame number in the host controller. The SOF packet is sent every 1ms and the host will increment the frame number by 1 each time. */

    struct {
      __OM  uint32_t COUNT      : 11;           /*!< [10..0] COUNT */
            uint32_t            : 21;
    } SOF_WR_b;
  } ;

  union {
    __IOM uint32_t SOF_RD;                      /*!< (@ 0x00000048) Read the last SOF (Start of Frame) frame number seen. In device mode the last SOF received from the host. In host mode the last SOF sent by the host. */

    struct {
      __IM  uint32_t COUNT      : 11;           /*!< [10..0] COUNT */
            uint32_t            : 21;
    } SOF_RD_b;
  } ;

  union {
    __IOM uint32_t SIE_CTRL;                    /*!< (@ 0x0000004C) SIE control register */

    struct {
      __IOM uint32_t START_TRANS : 1;           /*!< [0..0] Host: Start transaction */
      __IOM uint32_t SEND_SETUP : 1;            /*!< [1..1] Host: Send Setup packet */
      __IOM uint32_t SEND_DATA  : 1;            /*!< [2..2] Host: Send transaction (OUT from host) */
      __IOM uint32_t RECEIVE_DATA : 1;          /*!< [3..3] Host: Receive transaction (IN to host) */
      __IOM uint32_t STOP_TRANS : 1;            /*!< [4..4] Host: Stop transaction */
            uint32_t            : 1;
      __IOM uint32_t PREAMBLE_EN : 1;           /*!< [6..6] Host: Preable enable for LS device on FS hub */
            uint32_t            : 1;
      __IOM uint32_t SOF_SYNC   : 1;            /*!< [8..8] Host: Delay packet(s) until after SOF */
      __IOM uint32_t SOF_EN     : 1;            /*!< [9..9] Host: Enable SOF generation (for full speed bus) */
      __IOM uint32_t KEEP_ALIVE_EN : 1;         /*!< [10..10] Host: Enable keep alive packet (for low speed bus) */
      __IOM uint32_t VBUS_EN    : 1;            /*!< [11..11] Host: Enable VBUS */
      __IOM uint32_t RESUME     : 1;            /*!< [12..12] Device: Remote wakeup. Device can initiate its own resume after suspend. */
      __IOM uint32_t RESET_BUS  : 1;            /*!< [13..13] Host: Reset bus */
            uint32_t            : 1;
      __IOM uint32_t PULLDOWN_EN : 1;           /*!< [15..15] Host: Enable pull down resistors */
      __IOM uint32_t PULLUP_EN  : 1;            /*!< [16..16] Device: Enable pull up resistor */
      __IOM uint32_t RPU_OPT    : 1;            /*!< [17..17] Device: Pull-up strength (0=1K2, 1=2k3) */
      __IOM uint32_t TRANSCEIVER_PD : 1;        /*!< [18..18] Power down bus transceiver */
            uint32_t            : 5;
      __IOM uint32_t DIRECT_DM  : 1;            /*!< [24..24] Direct control of DM */
      __IOM uint32_t DIRECT_DP  : 1;            /*!< [25..25] Direct control of DP */
      __IOM uint32_t DIRECT_EN  : 1;            /*!< [26..26] Direct bus drive enable */
      __IOM uint32_t EP0_INT_NAK : 1;           /*!< [27..27] Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends a NAK */
      __IOM uint32_t EP0_INT_2BUF : 1;          /*!< [28..28] Device: Set bit in BUFF_STATUS for every 2 buffers completed on EP0 */
      __IOM uint32_t EP0_INT_1BUF : 1;          /*!< [29..29] Device: Set bit in BUFF_STATUS for every buffer completed on EP0 */
      __IOM uint32_t EP0_DOUBLE_BUF : 1;        /*!< [30..30] Device: EP0 single buffered = 0, double buffered = 1 */
      __IOM uint32_t EP0_INT_STALL : 1;         /*!< [31..31] Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends a STALL */
    } SIE_CTRL_b;
  } ;

  union {
    __IOM uint32_t SIE_STATUS;                  /*!< (@ 0x00000050) SIE status register */

    struct {
      __IM  uint32_t VBUS_DETECTED : 1;         /*!< [0..0] Device: VBUS Detected */
            uint32_t            : 1;
      __IM  uint32_t LINE_STATE : 2;            /*!< [3..2] USB bus line state */
      __IOM uint32_t SUSPENDED  : 1;            /*!< [4..4] Bus in suspended state. Valid for device and host. Host and device will go into suspend if neither Keep Alive / SOF frames are enabled. */
            uint32_t            : 3;
      __IOM uint32_t SPEED      : 2;            /*!< [9..8] Host: device speed. Disconnected = 00, LS = 01, FS = 10 */
      __IM  uint32_t VBUS_OVER_CURR : 1;        /*!< [10..10] VBUS over current detected */
      __IOM uint32_t RESUME     : 1;            /*!< [11..11] Host: Device has initiated a remote resume. Device: host has initiated a resume. */
            uint32_t            : 4;
      __IOM uint32_t CONNECTED  : 1;            /*!< [16..16] Device: connected */
      __IOM uint32_t SETUP_REC  : 1;            /*!< [17..17] Device: Setup packet received */
      __IOM uint32_t TRANS_COMPLETE : 1;        /*!< [18..18] Transaction complete. Raised by device if: * An IN or OUT packet is sent with the `LAST_BUFF` bit set in the buffer control register Raised by host if: * A setup packet is sent when no data in or data out transaction follows * An IN packet is received and the `LAST_BUFF` bit is set in the buffer control register * An IN packet is received with zero length * An OUT packet is sent and the `LAST_BUFF` bit is set */
      __IOM uint32_t BUS_RESET  : 1;            /*!< [19..19] Device: bus reset received */
            uint32_t            : 4;
      __IOM uint32_t CRC_ERROR  : 1;            /*!< [24..24] CRC Error. Raised by the Serial RX engine. */
      __IOM uint32_t BIT_STUFF_ERROR : 1;       /*!< [25..25] Bit Stuff Error. Raised by the Serial RX engine. */
      __IOM uint32_t RX_OVERFLOW : 1;           /*!< [26..26] RX overflow is raised by the Serial RX engine if the incoming data is too fast. */
      __IOM uint32_t RX_TIMEOUT : 1;            /*!< [27..27] RX timeout is raised by both the host and device if an ACK is not received in the maximum time specified by the USB spec. */
      __IOM uint32_t NAK_REC    : 1;            /*!< [28..28] Host: NAK received */
      __IOM uint32_t STALL_REC  : 1;            /*!< [29..29] Host: STALL received */
      __IOM uint32_t ACK_REC    : 1;            /*!< [30..30] ACK received. Raised by both host and device. */
      __IOM uint32_t DATA_SEQ_ERROR : 1;        /*!< [31..31] Data Sequence Error. The device can raise a sequence error in the following conditions: * A SETUP packet is received followed by a DATA1 packet (data phase should always be DATA0) * An OUT packet is received from the host but doesn't match the data pid in the buffer control register read from DPSRAM The host can raise a data sequence error in the following conditions: * An IN packet from the device has the wrong data PID */
    } SIE_STATUS_b;
  } ;

  union {
    __IOM uint32_t INT_EP_CTRL;                 /*!< (@ 0x00000054) interrupt endpoint control register */

    struct {
            uint32_t            : 1;
      __IOM uint32_t INT_EP_ACTIVE : 15;        /*!< [15..1] Host: Enable interrupt endpoint 1 -> 15 */
            uint32_t            : 16;
    } INT_EP_CTRL_b;
  } ;

  union {
    __IOM uint32_t BUFF_STATUS;                 /*!< (@ 0x00000058) Buffer status register. A bit set here indicates that a buffer has completed on the endpoint (if the buffer interrupt is enabled). It is possible for 2 buffers to be completed, so clearing the buffer status bit may instantly re set it on the next clock cycle. */

    struct {
      __IOM uint32_t EP0_IN     : 1;            /*!< [0..0] EP0_IN */
      __IOM uint32_t EP0_OUT    : 1;            /*!< [1..1] EP0_OUT */
      __IOM uint32_t EP1_IN     : 1;            /*!< [2..2] EP1_IN */
      __IOM uint32_t EP1_OUT    : 1;            /*!< [3..3] EP1_OUT */
      __IOM uint32_t EP2_IN     : 1;            /*!< [4..4] EP2_IN */
      __IOM uint32_t EP2_OUT    : 1;            /*!< [5..5] EP2_OUT */
      __IOM uint32_t EP3_IN     : 1;            /*!< [6..6] EP3_IN */
      __IOM uint32_t EP3_OUT    : 1;            /*!< [7..7] EP3_OUT */
      __IOM uint32_t EP4_IN     : 1;            /*!< [8..8] EP4_IN */
      __IOM uint32_t EP4_OUT    : 1;            /*!< [9..9] EP4_OUT */
      __IOM uint32_t EP5_IN     : 1;            /*!< [10..10] EP5_IN */
      __IOM uint32_t EP5_OUT    : 1;            /*!< [11..11] EP5_OUT */
      __IOM uint32_t EP6_IN     : 1;            /*!< [12..12] EP6_IN */
      __IOM uint32_t EP6_OUT    : 1;            /*!< [13..13] EP6_OUT */
      __IOM uint32_t EP7_IN     : 1;            /*!< [14..14] EP7_IN */
      __IOM uint32_t EP7_OUT    : 1;            /*!< [15..15] EP7_OUT */
      __IOM uint32_t EP8_IN     : 1;            /*!< [16..16] EP8_IN */
      __IOM uint32_t EP8_OUT    : 1;            /*!< [17..17] EP8_OUT */
      __IOM uint32_t EP9_IN     : 1;            /*!< [18..18] EP9_IN */
      __IOM uint32_t EP9_OUT    : 1;            /*!< [19..19] EP9_OUT */
      __IOM uint32_t EP10_IN    : 1;            /*!< [20..20] EP10_IN */
      __IOM uint32_t EP10_OUT   : 1;            /*!< [21..21] EP10_OUT */
      __IOM uint32_t EP11_IN    : 1;            /*!< [22..22] EP11_IN */
      __IOM uint32_t EP11_OUT   : 1;            /*!< [23..23] EP11_OUT */
      __IOM uint32_t EP12_IN    : 1;            /*!< [24..24] EP12_IN */
      __IOM uint32_t EP12_OUT   : 1;            /*!< [25..25] EP12_OUT */
      __IOM uint32_t EP13_IN    : 1;            /*!< [26..26] EP13_IN */
      __IOM uint32_t EP13_OUT   : 1;            /*!< [27..27] EP13_OUT */
      __IOM uint32_t EP14_IN    : 1;            /*!< [28..28] EP14_IN */
      __IOM uint32_t EP14_OUT   : 1;            /*!< [29..29] EP14_OUT */
      __IOM uint32_t EP15_IN    : 1;            /*!< [30..30] EP15_IN */
      __IOM uint32_t EP15_OUT   : 1;            /*!< [31..31] EP15_OUT */
    } BUFF_STATUS_b;
  } ;

  union {
    __IOM uint32_t BUFF_CPU_SHOULD_HANDLE;      /*!< (@ 0x0000005C) Which of the double buffers should be handled. Only valid if using an interrupt per buffer (i.e. not per 2 buffers). Not valid for host interrupt endpoint polling because they are only single buffered. */

    struct {
      __IM  uint32_t EP0_IN     : 1;            /*!< [0..0] EP0_IN */
      __IM  uint32_t EP0_OUT    : 1;            /*!< [1..1] EP0_OUT */
      __IM  uint32_t EP1_IN     : 1;            /*!< [2..2] EP1_IN */
      __IM  uint32_t EP1_OUT    : 1;            /*!< [3..3] EP1_OUT */
      __IM  uint32_t EP2_IN     : 1;            /*!< [4..4] EP2_IN */
      __IM  uint32_t EP2_OUT    : 1;            /*!< [5..5] EP2_OUT */
      __IM  uint32_t EP3_IN     : 1;            /*!< [6..6] EP3_IN */
      __IM  uint32_t EP3_OUT    : 1;            /*!< [7..7] EP3_OUT */
      __IM  uint32_t EP4_IN     : 1;            /*!< [8..8] EP4_IN */
      __IM  uint32_t EP4_OUT    : 1;            /*!< [9..9] EP4_OUT */
      __IM  uint32_t EP5_IN     : 1;            /*!< [10..10] EP5_IN */
      __IM  uint32_t EP5_OUT    : 1;            /*!< [11..11] EP5_OUT */
      __IM  uint32_t EP6_IN     : 1;            /*!< [12..12] EP6_IN */
      __IM  uint32_t EP6_OUT    : 1;            /*!< [13..13] EP6_OUT */
      __IM  uint32_t EP7_IN     : 1;            /*!< [14..14] EP7_IN */
      __IM  uint32_t EP7_OUT    : 1;            /*!< [15..15] EP7_OUT */
      __IM  uint32_t EP8_IN     : 1;            /*!< [16..16] EP8_IN */
      __IM  uint32_t EP8_OUT    : 1;            /*!< [17..17] EP8_OUT */
      __IM  uint32_t EP9_IN     : 1;            /*!< [18..18] EP9_IN */
      __IM  uint32_t EP9_OUT    : 1;            /*!< [19..19] EP9_OUT */
      __IM  uint32_t EP10_IN    : 1;            /*!< [20..20] EP10_IN */
      __IM  uint32_t EP10_OUT   : 1;            /*!< [21..21] EP10_OUT */
      __IM  uint32_t EP11_IN    : 1;            /*!< [22..22] EP11_IN */
      __IM  uint32_t EP11_OUT   : 1;            /*!< [23..23] EP11_OUT */
      __IM  uint32_t EP12_IN    : 1;            /*!< [24..24] EP12_IN */
      __IM  uint32_t EP12_OUT   : 1;            /*!< [25..25] EP12_OUT */
      __IM  uint32_t EP13_IN    : 1;            /*!< [26..26] EP13_IN */
      __IM  uint32_t EP13_OUT   : 1;            /*!< [27..27] EP13_OUT */
      __IM  uint32_t EP14_IN    : 1;            /*!< [28..28] EP14_IN */
      __IM  uint32_t EP14_OUT   : 1;            /*!< [29..29] EP14_OUT */
      __IM  uint32_t EP15_IN    : 1;            /*!< [30..30] EP15_IN */
      __IM  uint32_t EP15_OUT   : 1;            /*!< [31..31] EP15_OUT */
    } BUFF_CPU_SHOULD_HANDLE_b;
  } ;

  union {
    __IOM uint32_t EP_ABORT;                    /*!< (@ 0x00000060) Device only: Can be set to ignore the buffer control register for this endpoint in case you would like to revoke a buffer. A NAK will be sent for every access to the endpoint until this bit is cleared. A corresponding bit in `EP_ABORT_DONE` is set when it is safe to modify the buffer control register. */

    struct {
      __IOM uint32_t EP0_IN     : 1;            /*!< [0..0] EP0_IN */
      __IOM uint32_t EP0_OUT    : 1;            /*!< [1..1] EP0_OUT */
      __IOM uint32_t EP1_IN     : 1;            /*!< [2..2] EP1_IN */
      __IOM uint32_t EP1_OUT    : 1;            /*!< [3..3] EP1_OUT */
      __IOM uint32_t EP2_IN     : 1;            /*!< [4..4] EP2_IN */
      __IOM uint32_t EP2_OUT    : 1;            /*!< [5..5] EP2_OUT */
      __IOM uint32_t EP3_IN     : 1;            /*!< [6..6] EP3_IN */
      __IOM uint32_t EP3_OUT    : 1;            /*!< [7..7] EP3_OUT */
      __IOM uint32_t EP4_IN     : 1;            /*!< [8..8] EP4_IN */
      __IOM uint32_t EP4_OUT    : 1;            /*!< [9..9] EP4_OUT */
      __IOM uint32_t EP5_IN     : 1;            /*!< [10..10] EP5_IN */
      __IOM uint32_t EP5_OUT    : 1;            /*!< [11..11] EP5_OUT */
      __IOM uint32_t EP6_IN     : 1;            /*!< [12..12] EP6_IN */
      __IOM uint32_t EP6_OUT    : 1;            /*!< [13..13] EP6_OUT */
      __IOM uint32_t EP7_IN     : 1;            /*!< [14..14] EP7_IN */
      __IOM uint32_t EP7_OUT    : 1;            /*!< [15..15] EP7_OUT */
      __IOM uint32_t EP8_IN     : 1;            /*!< [16..16] EP8_IN */
      __IOM uint32_t EP8_OUT    : 1;            /*!< [17..17] EP8_OUT */
      __IOM uint32_t EP9_IN     : 1;            /*!< [18..18] EP9_IN */
      __IOM uint32_t EP9_OUT    : 1;            /*!< [19..19] EP9_OUT */
      __IOM uint32_t EP10_IN    : 1;            /*!< [20..20] EP10_IN */
      __IOM uint32_t EP10_OUT   : 1;            /*!< [21..21] EP10_OUT */
      __IOM uint32_t EP11_IN    : 1;            /*!< [22..22] EP11_IN */
      __IOM uint32_t EP11_OUT   : 1;            /*!< [23..23] EP11_OUT */
      __IOM uint32_t EP12_IN    : 1;            /*!< [24..24] EP12_IN */
      __IOM uint32_t EP12_OUT   : 1;            /*!< [25..25] EP12_OUT */
      __IOM uint32_t EP13_IN    : 1;            /*!< [26..26] EP13_IN */
      __IOM uint32_t EP13_OUT   : 1;            /*!< [27..27] EP13_OUT */
      __IOM uint32_t EP14_IN    : 1;            /*!< [28..28] EP14_IN */
      __IOM uint32_t EP14_OUT   : 1;            /*!< [29..29] EP14_OUT */
      __IOM uint32_t EP15_IN    : 1;            /*!< [30..30] EP15_IN */
      __IOM uint32_t EP15_OUT   : 1;            /*!< [31..31] EP15_OUT */
    } EP_ABORT_b;
  } ;

  union {
    __IOM uint32_t EP_ABORT_DONE;               /*!< (@ 0x00000064) Device only: Used in conjunction with `EP_ABORT`. Set once an endpoint is idle so the programmer knows it is safe to modify the buffer control register. */

    struct {
      __IOM uint32_t EP0_IN     : 1;            /*!< [0..0] EP0_IN */
      __IOM uint32_t EP0_OUT    : 1;            /*!< [1..1] EP0_OUT */
      __IOM uint32_t EP1_IN     : 1;            /*!< [2..2] EP1_IN */
      __IOM uint32_t EP1_OUT    : 1;            /*!< [3..3] EP1_OUT */
      __IOM uint32_t EP2_IN     : 1;            /*!< [4..4] EP2_IN */
      __IOM uint32_t EP2_OUT    : 1;            /*!< [5..5] EP2_OUT */
      __IOM uint32_t EP3_IN     : 1;            /*!< [6..6] EP3_IN */
      __IOM uint32_t EP3_OUT    : 1;            /*!< [7..7] EP3_OUT */
      __IOM uint32_t EP4_IN     : 1;            /*!< [8..8] EP4_IN */
      __IOM uint32_t EP4_OUT    : 1;            /*!< [9..9] EP4_OUT */
      __IOM uint32_t EP5_IN     : 1;            /*!< [10..10] EP5_IN */
      __IOM uint32_t EP5_OUT    : 1;            /*!< [11..11] EP5_OUT */
      __IOM uint32_t EP6_IN     : 1;            /*!< [12..12] EP6_IN */
      __IOM uint32_t EP6_OUT    : 1;            /*!< [13..13] EP6_OUT */
      __IOM uint32_t EP7_IN     : 1;            /*!< [14..14] EP7_IN */
      __IOM uint32_t EP7_OUT    : 1;            /*!< [15..15] EP7_OUT */
      __IOM uint32_t EP8_IN     : 1;            /*!< [16..16] EP8_IN */
      __IOM uint32_t EP8_OUT    : 1;            /*!< [17..17] EP8_OUT */
      __IOM uint32_t EP9_IN     : 1;            /*!< [18..18] EP9_IN */
      __IOM uint32_t EP9_OUT    : 1;            /*!< [19..19] EP9_OUT */
      __IOM uint32_t EP10_IN    : 1;            /*!< [20..20] EP10_IN */
      __IOM uint32_t EP10_OUT   : 1;            /*!< [21..21] EP10_OUT */
      __IOM uint32_t EP11_IN    : 1;            /*!< [22..22] EP11_IN */
      __IOM uint32_t EP11_OUT   : 1;            /*!< [23..23] EP11_OUT */
      __IOM uint32_t EP12_IN    : 1;            /*!< [24..24] EP12_IN */
      __IOM uint32_t EP12_OUT   : 1;            /*!< [25..25] EP12_OUT */
      __IOM uint32_t EP13_IN    : 1;            /*!< [26..26] EP13_IN */
      __IOM uint32_t EP13_OUT   : 1;            /*!< [27..27] EP13_OUT */
      __IOM uint32_t EP14_IN    : 1;            /*!< [28..28] EP14_IN */
      __IOM uint32_t EP14_OUT   : 1;            /*!< [29..29] EP14_OUT */
      __IOM uint32_t EP15_IN    : 1;            /*!< [30..30] EP15_IN */
      __IOM uint32_t EP15_OUT   : 1;            /*!< [31..31] EP15_OUT */
    } EP_ABORT_DONE_b;
  } ;

  union {
    __IOM uint32_t EP_STALL_ARM;                /*!< (@ 0x00000068) Device: this bit must be set in conjunction with the `STALL` bit in the buffer control register to send a STALL on EP0. The device controller clears these bits when a SETUP packet is received because the USB spec requires that a STALL condition is cleared when a SETUP packet is received. */

    struct {
      __IOM uint32_t EP0_IN     : 1;            /*!< [0..0] EP0_IN */
      __IOM uint32_t EP0_OUT    : 1;            /*!< [1..1] EP0_OUT */
            uint32_t            : 30;
    } EP_STALL_ARM_b;
  } ;

  union {
    __IOM uint32_t NAK_POLL;                    /*!< (@ 0x0000006C) Used by the host controller. Sets the wait time in microseconds before trying again if the device replies with a NAK. */

    struct {
      __IOM uint32_t DELAY_LS   : 10;           /*!< [9..0] NAK polling interval for a low speed device */
            uint32_t            : 6;
      __IOM uint32_t DELAY_FS   : 10;           /*!< [25..16] NAK polling interval for a full speed device */
            uint32_t            : 6;
    } NAK_POLL_b;
  } ;

  union {
    __IOM uint32_t EP_STATUS_STALL_NAK;         /*!< (@ 0x00000070) Device: bits are set when the `IRQ_ON_NAK` or `IRQ_ON_STALL` bits are set. For EP0 this comes from `SIE_CTRL`. For all other endpoints it comes from the endpoint control register. */

    struct {
      __IOM uint32_t EP0_IN     : 1;            /*!< [0..0] EP0_IN */
      __IOM uint32_t EP0_OUT    : 1;            /*!< [1..1] EP0_OUT */
      __IOM uint32_t EP1_IN     : 1;            /*!< [2..2] EP1_IN */
      __IOM uint32_t EP1_OUT    : 1;            /*!< [3..3] EP1_OUT */
      __IOM uint32_t EP2_IN     : 1;            /*!< [4..4] EP2_IN */
      __IOM uint32_t EP2_OUT    : 1;            /*!< [5..5] EP2_OUT */
      __IOM uint32_t EP3_IN     : 1;            /*!< [6..6] EP3_IN */
      __IOM uint32_t EP3_OUT    : 1;            /*!< [7..7] EP3_OUT */
      __IOM uint32_t EP4_IN     : 1;            /*!< [8..8] EP4_IN */
      __IOM uint32_t EP4_OUT    : 1;            /*!< [9..9] EP4_OUT */
      __IOM uint32_t EP5_IN     : 1;            /*!< [10..10] EP5_IN */
      __IOM uint32_t EP5_OUT    : 1;            /*!< [11..11] EP5_OUT */
      __IOM uint32_t EP6_IN     : 1;            /*!< [12..12] EP6_IN */
      __IOM uint32_t EP6_OUT    : 1;            /*!< [13..13] EP6_OUT */
      __IOM uint32_t EP7_IN     : 1;            /*!< [14..14] EP7_IN */
      __IOM uint32_t EP7_OUT    : 1;            /*!< [15..15] EP7_OUT */
      __IOM uint32_t EP8_IN     : 1;            /*!< [16..16] EP8_IN */
      __IOM uint32_t EP8_OUT    : 1;            /*!< [17..17] EP8_OUT */
      __IOM uint32_t EP9_IN     : 1;            /*!< [18..18] EP9_IN */
      __IOM uint32_t EP9_OUT    : 1;            /*!< [19..19] EP9_OUT */
      __IOM uint32_t EP10_IN    : 1;            /*!< [20..20] EP10_IN */
      __IOM uint32_t EP10_OUT   : 1;            /*!< [21..21] EP10_OUT */
      __IOM uint32_t EP11_IN    : 1;            /*!< [22..22] EP11_IN */
      __IOM uint32_t EP11_OUT   : 1;            /*!< [23..23] EP11_OUT */
      __IOM uint32_t EP12_IN    : 1;            /*!< [24..24] EP12_IN */
      __IOM uint32_t EP12_OUT   : 1;            /*!< [25..25] EP12_OUT */
      __IOM uint32_t EP13_IN    : 1;            /*!< [26..26] EP13_IN */
      __IOM uint32_t EP13_OUT   : 1;            /*!< [27..27] EP13_OUT */
      __IOM uint32_t EP14_IN    : 1;            /*!< [28..28] EP14_IN */
      __IOM uint32_t EP14_OUT   : 1;            /*!< [29..29] EP14_OUT */
      __IOM uint32_t EP15_IN    : 1;            /*!< [30..30] EP15_IN */
      __IOM uint32_t EP15_OUT   : 1;            /*!< [31..31] EP15_OUT */
    } EP_STATUS_STALL_NAK_b;
  } ;

  union {
    __IOM uint32_t USB_MUXING;                  /*!< (@ 0x00000074) Where to connect the USB controller. Should be to_phy by default. */

    struct {
      __IOM uint32_t TO_PHY     : 1;            /*!< [0..0] TO_PHY */
      __IOM uint32_t TO_EXTPHY  : 1;            /*!< [1..1] TO_EXTPHY */
      __IOM uint32_t TO_DIGITAL_PAD : 1;        /*!< [2..2] TO_DIGITAL_PAD */
      __IOM uint32_t SOFTCON    : 1;            /*!< [3..3] SOFTCON */
            uint32_t            : 28;
    } USB_MUXING_b;
  } ;

  union {
    __IOM uint32_t USB_PWR;                     /*!< (@ 0x00000078) Overrides for the power signals in the event that the VBUS signals are not hooked up to GPIO. Set the value of the override and then the override enable to switch over to the override value. */

    struct {
      __IOM uint32_t VBUS_EN    : 1;            /*!< [0..0] VBUS_EN */
      __IOM uint32_t VBUS_EN_OVERRIDE_EN : 1;   /*!< [1..1] VBUS_EN_OVERRIDE_EN */
      __IOM uint32_t VBUS_DETECT : 1;           /*!< [2..2] VBUS_DETECT */
      __IOM uint32_t VBUS_DETECT_OVERRIDE_EN : 1;/*!< [3..3] VBUS_DETECT_OVERRIDE_EN */
      __IOM uint32_t OVERCURR_DETECT : 1;       /*!< [4..4] OVERCURR_DETECT */
      __IOM uint32_t OVERCURR_DETECT_EN : 1;    /*!< [5..5] OVERCURR_DETECT_EN */
            uint32_t            : 26;
    } USB_PWR_b;
  } ;

  union {
    __IOM uint32_t USBPHY_DIRECT;               /*!< (@ 0x0000007C) This register allows for direct control of the USB phy. Use in conjunction with usbphy_direct_override register to enable each override bit. */

    struct {
      __IOM uint32_t DP_PULLUP_HISEL : 1;       /*!< [0..0] Enable the second DP pull up resistor. 0 - Pull = Rpu2; 1 - Pull = Rpu1 + Rpu2 */
      __IOM uint32_t DP_PULLUP_EN : 1;          /*!< [1..1] DP pull up enable */
      __IOM uint32_t DP_PULLDN_EN : 1;          /*!< [2..2] DP pull down enable */
            uint32_t            : 1;
      __IOM uint32_t DM_PULLUP_HISEL : 1;       /*!< [4..4] Enable the second DM pull up resistor. 0 - Pull = Rpu2; 1 - Pull = Rpu1 + Rpu2 */
      __IOM uint32_t DM_PULLUP_EN : 1;          /*!< [5..5] DM pull up enable */
      __IOM uint32_t DM_PULLDN_EN : 1;          /*!< [6..6] DM pull down enable */
            uint32_t            : 1;
      __IOM uint32_t TX_DP_OE   : 1;            /*!< [8..8] Output enable. If TX_DIFFMODE=1, OE for DPP/DPM diff pair. 0 - DPP/DPM in Hi-Z state; 1 - DPP/DPM driving If TX_DIFFMODE=0, OE for DPP only. 0 - DPP in Hi-Z state; 1 - DPP driving */
      __IOM uint32_t TX_DM_OE   : 1;            /*!< [9..9] Output enable. If TX_DIFFMODE=1, Ignored. If TX_DIFFMODE=0, OE for DPM only. 0 - DPM in Hi-Z state; 1 - DPM driving */
      __IOM uint32_t TX_DP      : 1;            /*!< [10..10] Output data. If TX_DIFFMODE=1, Drives DPP/DPM diff pair. TX_DP_OE=1 to enable drive. DPP=TX_DP, DPM=~TX_DP If TX_DIFFMODE=0, Drives DPP only. TX_DP_OE=1 to enable drive. DPP=TX_DP */
      __IOM uint32_t TX_DM      : 1;            /*!< [11..11] Output data. TX_DIFFMODE=1, Ignored TX_DIFFMODE=0, Drives DPM only. TX_DM_OE=1 to enable drive. DPM=TX_DM */
      __IOM uint32_t RX_PD      : 1;            /*!< [12..12] RX power down override (if override enable is set). 1 = powered down. */
      __IOM uint32_t TX_PD      : 1;            /*!< [13..13] TX power down override (if override enable is set). 1 = powered down. */
      __IOM uint32_t TX_FSSLEW  : 1;            /*!< [14..14] TX_FSSLEW=0: Low speed slew rate TX_FSSLEW=1: Full speed slew rate */
      __IOM uint32_t TX_DIFFMODE : 1;           /*!< [15..15] TX_DIFFMODE=0: Single ended mode TX_DIFFMODE=1: Differential drive mode (TX_DM, TX_DM_OE ignored) */
      __IM  uint32_t RX_DD      : 1;            /*!< [16..16] Differential RX */
      __IM  uint32_t RX_DP      : 1;            /*!< [17..17] DPP pin state */
      __IM  uint32_t RX_DM      : 1;            /*!< [18..18] DPM pin state */
      __IM  uint32_t DP_OVCN    : 1;            /*!< [19..19] DP overcurrent */
      __IM  uint32_t DM_OVCN    : 1;            /*!< [20..20] DM overcurrent */
      __IM  uint32_t DP_OVV     : 1;            /*!< [21..21] DP over voltage */
      __IM  uint32_t DM_OVV     : 1;            /*!< [22..22] DM over voltage */
            uint32_t            : 9;
    } USBPHY_DIRECT_b;
  } ;

  union {
    __IOM uint32_t USBPHY_DIRECT_OVERRIDE;      /*!< (@ 0x00000080) Override enable for each control in usbphy_direct */

    struct {
      __IOM uint32_t DP_PULLUP_HISEL_OVERRIDE_EN : 1;/*!< [0..0] DP_PULLUP_HISEL_OVERRIDE_EN */
      __IOM uint32_t DM_PULLUP_HISEL_OVERRIDE_EN : 1;/*!< [1..1] DM_PULLUP_HISEL_OVERRIDE_EN */
      __IOM uint32_t DP_PULLUP_EN_OVERRIDE_EN : 1;/*!< [2..2] DP_PULLUP_EN_OVERRIDE_EN */
      __IOM uint32_t DP_PULLDN_EN_OVERRIDE_EN : 1;/*!< [3..3] DP_PULLDN_EN_OVERRIDE_EN */
      __IOM uint32_t DM_PULLDN_EN_OVERRIDE_EN : 1;/*!< [4..4] DM_PULLDN_EN_OVERRIDE_EN */
      __IOM uint32_t TX_DP_OE_OVERRIDE_EN : 1;  /*!< [5..5] TX_DP_OE_OVERRIDE_EN */
      __IOM uint32_t TX_DM_OE_OVERRIDE_EN : 1;  /*!< [6..6] TX_DM_OE_OVERRIDE_EN */
      __IOM uint32_t TX_DP_OVERRIDE_EN : 1;     /*!< [7..7] TX_DP_OVERRIDE_EN */
      __IOM uint32_t TX_DM_OVERRIDE_EN : 1;     /*!< [8..8] TX_DM_OVERRIDE_EN */
      __IOM uint32_t RX_PD_OVERRIDE_EN : 1;     /*!< [9..9] RX_PD_OVERRIDE_EN */
      __IOM uint32_t TX_PD_OVERRIDE_EN : 1;     /*!< [10..10] TX_PD_OVERRIDE_EN */
      __IOM uint32_t TX_FSSLEW_OVERRIDE_EN : 1; /*!< [11..11] TX_FSSLEW_OVERRIDE_EN */
      __IOM uint32_t DM_PULLUP_OVERRIDE_EN : 1; /*!< [12..12] DM_PULLUP_OVERRIDE_EN */
            uint32_t            : 2;
      __IOM uint32_t TX_DIFFMODE_OVERRIDE_EN : 1;/*!< [15..15] TX_DIFFMODE_OVERRIDE_EN */
            uint32_t            : 16;
    } USBPHY_DIRECT_OVERRIDE_b;
  } ;

  union {
    __IOM uint32_t USBPHY_TRIM;                 /*!< (@ 0x00000084) Used to adjust trim values of USB phy pull down resistors. */

    struct {
      __IOM uint32_t DP_PULLDN_TRIM : 5;        /*!< [4..0] Value to drive to USB PHY DP pulldown resistor trim control Experimental data suggests that the reset value will work, but this register allows adjustment if required */
            uint32_t            : 3;
      __IOM uint32_t DM_PULLDN_TRIM : 5;        /*!< [12..8] Value to drive to USB PHY DM pulldown resistor trim control Experimental data suggests that the reset value will work, but this register allows adjustment if required */
            uint32_t            : 19;
    } USBPHY_TRIM_b;
  } ;
  __IM  uint32_t  RESERVED;

  union {
    __IOM uint32_t INTR;                        /*!< (@ 0x0000008C) Raw Interrupts */

    struct {
      __IM  uint32_t HOST_CONN_DIS : 1;         /*!< [0..0] Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED */
      __IM  uint32_t HOST_RESUME : 1;           /*!< [1..1] Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME */
      __IM  uint32_t HOST_SOF   : 1;            /*!< [2..2] Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD */
      __IM  uint32_t TRANS_COMPLETE : 1;        /*!< [3..3] Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit. */
      __IM  uint32_t BUFF_STATUS : 1;           /*!< [4..4] Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS. */
      __IM  uint32_t ERROR_DATA_SEQ : 1;        /*!< [5..5] Source: SIE_STATUS.DATA_SEQ_ERROR */
      __IM  uint32_t ERROR_RX_TIMEOUT : 1;      /*!< [6..6] Source: SIE_STATUS.RX_TIMEOUT */
      __IM  uint32_t ERROR_RX_OVERFLOW : 1;     /*!< [7..7] Source: SIE_STATUS.RX_OVERFLOW */
      __IM  uint32_t ERROR_BIT_STUFF : 1;       /*!< [8..8] Source: SIE_STATUS.BIT_STUFF_ERROR */
      __IM  uint32_t ERROR_CRC  : 1;            /*!< [9..9] Source: SIE_STATUS.CRC_ERROR */
      __IM  uint32_t STALL      : 1;            /*!< [10..10] Source: SIE_STATUS.STALL_REC */
      __IM  uint32_t VBUS_DETECT : 1;           /*!< [11..11] Source: SIE_STATUS.VBUS_DETECTED */
      __IM  uint32_t BUS_RESET  : 1;            /*!< [12..12] Source: SIE_STATUS.BUS_RESET */
      __IM  uint32_t DEV_CONN_DIS : 1;          /*!< [13..13] Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED */
      __IM  uint32_t DEV_SUSPEND : 1;           /*!< [14..14] Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED */
      __IM  uint32_t DEV_RESUME_FROM_HOST : 1;  /*!< [15..15] Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME */
      __IM  uint32_t SETUP_REQ  : 1;            /*!< [16..16] Device. Source: SIE_STATUS.SETUP_REC */
      __IM  uint32_t DEV_SOF    : 1;            /*!< [17..17] Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD */
      __IM  uint32_t ABORT_DONE : 1;            /*!< [18..18] Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE. */
      __IM  uint32_t EP_STALL_NAK : 1;          /*!< [19..19] Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK. */
            uint32_t            : 12;
    } INTR_b;
  } ;

  union {
    __IOM uint32_t INTE;                        /*!< (@ 0x00000090) Interrupt Enable */

    struct {
      __IOM uint32_t HOST_CONN_DIS : 1;         /*!< [0..0] Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED */
      __IOM uint32_t HOST_RESUME : 1;           /*!< [1..1] Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME */
      __IOM uint32_t HOST_SOF   : 1;            /*!< [2..2] Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD */
      __IOM uint32_t TRANS_COMPLETE : 1;        /*!< [3..3] Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit. */
      __IOM uint32_t BUFF_STATUS : 1;           /*!< [4..4] Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS. */
      __IOM uint32_t ERROR_DATA_SEQ : 1;        /*!< [5..5] Source: SIE_STATUS.DATA_SEQ_ERROR */
      __IOM uint32_t ERROR_RX_TIMEOUT : 1;      /*!< [6..6] Source: SIE_STATUS.RX_TIMEOUT */
      __IOM uint32_t ERROR_RX_OVERFLOW : 1;     /*!< [7..7] Source: SIE_STATUS.RX_OVERFLOW */
      __IOM uint32_t ERROR_BIT_STUFF : 1;       /*!< [8..8] Source: SIE_STATUS.BIT_STUFF_ERROR */
      __IOM uint32_t ERROR_CRC  : 1;            /*!< [9..9] Source: SIE_STATUS.CRC_ERROR */
      __IOM uint32_t STALL      : 1;            /*!< [10..10] Source: SIE_STATUS.STALL_REC */
      __IOM uint32_t VBUS_DETECT : 1;           /*!< [11..11] Source: SIE_STATUS.VBUS_DETECTED */
      __IOM uint32_t BUS_RESET  : 1;            /*!< [12..12] Source: SIE_STATUS.BUS_RESET */
      __IOM uint32_t DEV_CONN_DIS : 1;          /*!< [13..13] Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED */
      __IOM uint32_t DEV_SUSPEND : 1;           /*!< [14..14] Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED */
      __IOM uint32_t DEV_RESUME_FROM_HOST : 1;  /*!< [15..15] Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME */
      __IOM uint32_t SETUP_REQ  : 1;            /*!< [16..16] Device. Source: SIE_STATUS.SETUP_REC */
      __IOM uint32_t DEV_SOF    : 1;            /*!< [17..17] Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD */
      __IOM uint32_t ABORT_DONE : 1;            /*!< [18..18] Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE. */
      __IOM uint32_t EP_STALL_NAK : 1;          /*!< [19..19] Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK. */
            uint32_t            : 12;
    } INTE_b;
  } ;

  union {
    __IOM uint32_t INTF;                        /*!< (@ 0x00000094) Interrupt Force */

    struct {
      __IOM uint32_t HOST_CONN_DIS : 1;         /*!< [0..0] Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED */
      __IOM uint32_t HOST_RESUME : 1;           /*!< [1..1] Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME */
      __IOM uint32_t HOST_SOF   : 1;            /*!< [2..2] Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD */
      __IOM uint32_t TRANS_COMPLETE : 1;        /*!< [3..3] Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit. */
      __IOM uint32_t BUFF_STATUS : 1;           /*!< [4..4] Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS. */
      __IOM uint32_t ERROR_DATA_SEQ : 1;        /*!< [5..5] Source: SIE_STATUS.DATA_SEQ_ERROR */
      __IOM uint32_t ERROR_RX_TIMEOUT : 1;      /*!< [6..6] Source: SIE_STATUS.RX_TIMEOUT */
      __IOM uint32_t ERROR_RX_OVERFLOW : 1;     /*!< [7..7] Source: SIE_STATUS.RX_OVERFLOW */
      __IOM uint32_t ERROR_BIT_STUFF : 1;       /*!< [8..8] Source: SIE_STATUS.BIT_STUFF_ERROR */
      __IOM uint32_t ERROR_CRC  : 1;            /*!< [9..9] Source: SIE_STATUS.CRC_ERROR */
      __IOM uint32_t STALL      : 1;            /*!< [10..10] Source: SIE_STATUS.STALL_REC */
      __IOM uint32_t VBUS_DETECT : 1;           /*!< [11..11] Source: SIE_STATUS.VBUS_DETECTED */
      __IOM uint32_t BUS_RESET  : 1;            /*!< [12..12] Source: SIE_STATUS.BUS_RESET */
      __IOM uint32_t DEV_CONN_DIS : 1;          /*!< [13..13] Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED */
      __IOM uint32_t DEV_SUSPEND : 1;           /*!< [14..14] Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED */
      __IOM uint32_t DEV_RESUME_FROM_HOST : 1;  /*!< [15..15] Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME */
      __IOM uint32_t SETUP_REQ  : 1;            /*!< [16..16] Device. Source: SIE_STATUS.SETUP_REC */
      __IOM uint32_t DEV_SOF    : 1;            /*!< [17..17] Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD */
      __IOM uint32_t ABORT_DONE : 1;            /*!< [18..18] Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE. */
      __IOM uint32_t EP_STALL_NAK : 1;          /*!< [19..19] Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK. */
            uint32_t            : 12;
    } INTF_b;
  } ;

  union {
    __IOM uint32_t INTS;                        /*!< (@ 0x00000098) Interrupt status after masking & forcing */

    struct {
      __IM  uint32_t HOST_CONN_DIS : 1;         /*!< [0..0] Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED */
      __IM  uint32_t HOST_RESUME : 1;           /*!< [1..1] Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME */
      __IM  uint32_t HOST_SOF   : 1;            /*!< [2..2] Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD */
      __IM  uint32_t TRANS_COMPLETE : 1;        /*!< [3..3] Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit. */
      __IM  uint32_t BUFF_STATUS : 1;           /*!< [4..4] Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS. */
      __IM  uint32_t ERROR_DATA_SEQ : 1;        /*!< [5..5] Source: SIE_STATUS.DATA_SEQ_ERROR */
      __IM  uint32_t ERROR_RX_TIMEOUT : 1;      /*!< [6..6] Source: SIE_STATUS.RX_TIMEOUT */
      __IM  uint32_t ERROR_RX_OVERFLOW : 1;     /*!< [7..7] Source: SIE_STATUS.RX_OVERFLOW */
      __IM  uint32_t ERROR_BIT_STUFF : 1;       /*!< [8..8] Source: SIE_STATUS.BIT_STUFF_ERROR */
      __IM  uint32_t ERROR_CRC  : 1;            /*!< [9..9] Source: SIE_STATUS.CRC_ERROR */
      __IM  uint32_t STALL      : 1;            /*!< [10..10] Source: SIE_STATUS.STALL_REC */
      __IM  uint32_t VBUS_DETECT : 1;           /*!< [11..11] Source: SIE_STATUS.VBUS_DETECTED */
      __IM  uint32_t BUS_RESET  : 1;            /*!< [12..12] Source: SIE_STATUS.BUS_RESET */
      __IM  uint32_t DEV_CONN_DIS : 1;          /*!< [13..13] Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED */
      __IM  uint32_t DEV_SUSPEND : 1;           /*!< [14..14] Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED */
      __IM  uint32_t DEV_RESUME_FROM_HOST : 1;  /*!< [15..15] Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME */
      __IM  uint32_t SETUP_REQ  : 1;            /*!< [16..16] Device. Source: SIE_STATUS.SETUP_REC */
      __IM  uint32_t DEV_SOF    : 1;            /*!< [17..17] Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD */
      __IM  uint32_t ABORT_DONE : 1;            /*!< [18..18] Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE. */
      __IM  uint32_t EP_STALL_NAK : 1;          /*!< [19..19] Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK. */
            uint32_t            : 12;
    } INTS_b;
  } ;
} USBCTRL_REGS_Type;                            /*!< Size = 156 (0x9c) */



/* =========================================================================================================================== */
/* ================                                           PIO0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Programmable IO block (PIO0)
  */

typedef struct {                                /*!< (@ 0x50200000) PIO0 Structure */

  union {
    __IOM uint32_t CTRL;                        /*!< (@ 0x00000000) PIO control register */

    struct {
      __IOM uint32_t SM_ENABLE  : 4;            /*!< [3..0] Enable/disable each of the four state machines by writing 1/0 to each of these four bits. When disabled, a state machine will cease executing instructions, except those written directly to SMx_INSTR by the system. Multiple bits can be set/cleared at once to run/halt multiple state machines simultaneously. */
      __IOM uint32_t SM_RESTART : 4;            /*!< [7..4] Write 1 to instantly clear internal SM state which may be otherwise difficult to access and will affect future execution. Specifically, the following are cleared: input and output shift counters; the contents of the input shift register; the delay counter; the waiting-on-IRQ state; any stalled instruction written to SMx_INSTR or run by OUT/MOV EXEC; any pin write left asserted due to OUT_STICKY. */
      __IOM uint32_t CLKDIV_RESTART : 4;        /*!< [11..8] Restart a state machine's clock divider from an initial phase of 0. Clock dividers are free-running, so once started, their output (including fractional jitter) is completely determined by the integer/fractional divisor configured in SMx_CLKDIV. This means that, if multiple clock dividers with the same divisor are restarted simultaneously, by writing multiple 1 bits to this field, the execution clocks of those state machines will run in precise lockstep. Note that setting/clearing SM */
            uint32_t            : 20;
    } CTRL_b;
  } ;

  union {
    __IOM uint32_t FSTAT;                       /*!< (@ 0x00000004) FIFO status register */

    struct {
      __IM  uint32_t RXFULL     : 4;            /*!< [3..0] State machine RX FIFO is full */
            uint32_t            : 4;
      __IM  uint32_t RXEMPTY    : 4;            /*!< [11..8] State machine RX FIFO is empty */
            uint32_t            : 4;
      __IM  uint32_t TXFULL     : 4;            /*!< [19..16] State machine TX FIFO is full */
            uint32_t            : 4;
      __IM  uint32_t TXEMPTY    : 4;            /*!< [27..24] State machine TX FIFO is empty */
            uint32_t            : 4;
    } FSTAT_b;
  } ;

  union {
    __IOM uint32_t FDEBUG;                      /*!< (@ 0x00000008) FIFO debug register */

    struct {
      __IOM uint32_t RXSTALL    : 4;            /*!< [3..0] State machine has stalled on full RX FIFO during a blocking PUSH, or an IN with autopush enabled. This flag is also set when a nonblocking PUSH to a full FIFO took place, in which case the state machine has dropped data. Write 1 to clear. */
            uint32_t            : 4;
      __IOM uint32_t RXUNDER    : 4;            /*!< [11..8] RX FIFO underflow (i.e. read-on-empty by the system) has occurred. Write 1 to clear. Note that read-on-empty does not perturb the state of the FIFO in any way, but the data returned by reading from an empty FIFO is undefined, so this flag generally only becomes set due to some kind of software error. */
            uint32_t            : 4;
      __IOM uint32_t TXOVER     : 4;            /*!< [19..16] TX FIFO overflow (i.e. write-on-full by the system) has occurred. Write 1 to clear. Note that write-on-full does not alter the state or contents of the FIFO in any way, but the data that the system attempted to write is dropped, so if this flag is set, your software has quite likely dropped some data on the floor. */
            uint32_t            : 4;
      __IOM uint32_t TXSTALL    : 4;            /*!< [27..24] State machine has stalled on empty TX FIFO during a blocking PULL, or an OUT with autopull enabled. Write 1 to clear. */
            uint32_t            : 4;
    } FDEBUG_b;
  } ;

  union {
    __IOM uint32_t FLEVEL;                      /*!< (@ 0x0000000C) FIFO levels */

    struct {
      __IM  uint32_t TX0        : 4;            /*!< [3..0] TX0 */
      __IM  uint32_t RX0        : 4;            /*!< [7..4] RX0 */
      __IM  uint32_t TX1        : 4;            /*!< [11..8] TX1 */
      __IM  uint32_t RX1        : 4;            /*!< [15..12] RX1 */
      __IM  uint32_t TX2        : 4;            /*!< [19..16] TX2 */
      __IM  uint32_t RX2        : 4;            /*!< [23..20] RX2 */
      __IM  uint32_t TX3        : 4;            /*!< [27..24] TX3 */
      __IM  uint32_t RX3        : 4;            /*!< [31..28] RX3 */
    } FLEVEL_b;
  } ;
  __OM  uint32_t  TXF0;                         /*!< (@ 0x00000010) Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO. */
  __OM  uint32_t  TXF1;                         /*!< (@ 0x00000014) Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO. */
  __OM  uint32_t  TXF2;                         /*!< (@ 0x00000018) Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO. */
  __OM  uint32_t  TXF3;                         /*!< (@ 0x0000001C) Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO. */
  __IM  uint32_t  RXF0;                         /*!< (@ 0x00000020) Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined. */
  __IM  uint32_t  RXF1;                         /*!< (@ 0x00000024) Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined. */
  __IM  uint32_t  RXF2;                         /*!< (@ 0x00000028) Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined. */
  __IM  uint32_t  RXF3;                         /*!< (@ 0x0000002C) Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined. */

  union {
    __IOM uint32_t IRQ;                         /*!< (@ 0x00000030) State machine IRQ flags register. Write 1 to clear. There are 8 state machine IRQ flags, which can be set, cleared, and waited on by the state machines. There's no fixed association between flags and state machines -- any state machine can use any flag. Any of the 8 flags can be used for timing synchronisation between state machines, using IRQ and WAIT instructions. The lower four of these flags are also routed out to system-level interrupt requests, alongside FIFO status */

    struct {
      __IOM uint32_t IRQ        : 8;            /*!< [7..0] IRQ */
            uint32_t            : 24;
    } IRQ_b;
  } ;

  union {
    __IOM uint32_t IRQ_FORCE;                   /*!< (@ 0x00000034) Writing a 1 to each of these bits will forcibly assert the corresponding IRQ. Note this is different to the INTF register: writing here affects PIO internal state. INTF just asserts the processor-facing IRQ signal for testing ISRs, and is not visible to the state machines. */

    struct {
      __OM  uint32_t IRQ_FORCE  : 8;            /*!< [7..0] IRQ_FORCE */
            uint32_t            : 24;
    } IRQ_FORCE_b;
  } ;
  __IOM uint32_t  INPUT_SYNC_BYPASS;            /*!< (@ 0x00000038) There is a 2-flipflop synchronizer on each GPIO input, which protects PIO logic from metastabilities. This increases input delay, and for fast synchronous IO (e.g. SPI) these synchronizers may need to be bypassed. Each bit in this register corresponds to one GPIO. 0 -> input is synchronized (default) 1 -> synchronizer is bypassed If in doubt, leave this register as all zeroes. */
  __IM  uint32_t  DBG_PADOUT;                   /*!< (@ 0x0000003C) Read to sample the pad output values PIO is currently driving to the GPIOs. On RP2040 there are 30 GPIOs, so the two most significant bits are hardwired to 0. */
  __IM  uint32_t  DBG_PADOE;                    /*!< (@ 0x00000040) Read to sample the pad output enables (direction) PIO is currently driving to the GPIOs. On RP2040 there are 30 GPIOs, so the two most significant bits are hardwired to 0. */

  union {
    __IOM uint32_t DBG_CFGINFO;                 /*!< (@ 0x00000044) The PIO hardware has some free parameters that may vary between chip products. These should be provided in the chip datasheet, but are also exposed here. */

    struct {
      __IM  uint32_t FIFO_DEPTH : 6;            /*!< [5..0] The depth of the state machine TX/RX FIFOs, measured in words. Joining fifos via SHIFTCTRL_FJOIN gives one FIFO with double this depth. */
            uint32_t            : 2;
      __IM  uint32_t SM_COUNT   : 4;            /*!< [11..8] The number of state machines this PIO instance is equipped with. */
            uint32_t            : 4;
      __IM  uint32_t IMEM_SIZE  : 6;            /*!< [21..16] The size of the instruction memory, measured in units of one instruction */
            uint32_t            : 10;
    } DBG_CFGINFO_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM0;                  /*!< (@ 0x00000048) Write-only access to instruction memory location 0 */

    struct {
      __OM  uint32_t INSTR_MEM0 : 16;           /*!< [15..0] INSTR_MEM0 */
            uint32_t            : 16;
    } INSTR_MEM0_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM1;                  /*!< (@ 0x0000004C) Write-only access to instruction memory location 1 */

    struct {
      __OM  uint32_t INSTR_MEM1 : 16;           /*!< [15..0] INSTR_MEM1 */
            uint32_t            : 16;
    } INSTR_MEM1_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM2;                  /*!< (@ 0x00000050) Write-only access to instruction memory location 2 */

    struct {
      __OM  uint32_t INSTR_MEM2 : 16;           /*!< [15..0] INSTR_MEM2 */
            uint32_t            : 16;
    } INSTR_MEM2_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM3;                  /*!< (@ 0x00000054) Write-only access to instruction memory location 3 */

    struct {
      __OM  uint32_t INSTR_MEM3 : 16;           /*!< [15..0] INSTR_MEM3 */
            uint32_t            : 16;
    } INSTR_MEM3_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM4;                  /*!< (@ 0x00000058) Write-only access to instruction memory location 4 */

    struct {
      __OM  uint32_t INSTR_MEM4 : 16;           /*!< [15..0] INSTR_MEM4 */
            uint32_t            : 16;
    } INSTR_MEM4_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM5;                  /*!< (@ 0x0000005C) Write-only access to instruction memory location 5 */

    struct {
      __OM  uint32_t INSTR_MEM5 : 16;           /*!< [15..0] INSTR_MEM5 */
            uint32_t            : 16;
    } INSTR_MEM5_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM6;                  /*!< (@ 0x00000060) Write-only access to instruction memory location 6 */

    struct {
      __OM  uint32_t INSTR_MEM6 : 16;           /*!< [15..0] INSTR_MEM6 */
            uint32_t            : 16;
    } INSTR_MEM6_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM7;                  /*!< (@ 0x00000064) Write-only access to instruction memory location 7 */

    struct {
      __OM  uint32_t INSTR_MEM7 : 16;           /*!< [15..0] INSTR_MEM7 */
            uint32_t            : 16;
    } INSTR_MEM7_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM8;                  /*!< (@ 0x00000068) Write-only access to instruction memory location 8 */

    struct {
      __OM  uint32_t INSTR_MEM8 : 16;           /*!< [15..0] INSTR_MEM8 */
            uint32_t            : 16;
    } INSTR_MEM8_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM9;                  /*!< (@ 0x0000006C) Write-only access to instruction memory location 9 */

    struct {
      __OM  uint32_t INSTR_MEM9 : 16;           /*!< [15..0] INSTR_MEM9 */
            uint32_t            : 16;
    } INSTR_MEM9_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM10;                 /*!< (@ 0x00000070) Write-only access to instruction memory location 10 */

    struct {
      __OM  uint32_t INSTR_MEM10 : 16;          /*!< [15..0] INSTR_MEM10 */
            uint32_t            : 16;
    } INSTR_MEM10_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM11;                 /*!< (@ 0x00000074) Write-only access to instruction memory location 11 */

    struct {
      __OM  uint32_t INSTR_MEM11 : 16;          /*!< [15..0] INSTR_MEM11 */
            uint32_t            : 16;
    } INSTR_MEM11_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM12;                 /*!< (@ 0x00000078) Write-only access to instruction memory location 12 */

    struct {
      __OM  uint32_t INSTR_MEM12 : 16;          /*!< [15..0] INSTR_MEM12 */
            uint32_t            : 16;
    } INSTR_MEM12_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM13;                 /*!< (@ 0x0000007C) Write-only access to instruction memory location 13 */

    struct {
      __OM  uint32_t INSTR_MEM13 : 16;          /*!< [15..0] INSTR_MEM13 */
            uint32_t            : 16;
    } INSTR_MEM13_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM14;                 /*!< (@ 0x00000080) Write-only access to instruction memory location 14 */

    struct {
      __OM  uint32_t INSTR_MEM14 : 16;          /*!< [15..0] INSTR_MEM14 */
            uint32_t            : 16;
    } INSTR_MEM14_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM15;                 /*!< (@ 0x00000084) Write-only access to instruction memory location 15 */

    struct {
      __OM  uint32_t INSTR_MEM15 : 16;          /*!< [15..0] INSTR_MEM15 */
            uint32_t            : 16;
    } INSTR_MEM15_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM16;                 /*!< (@ 0x00000088) Write-only access to instruction memory location 16 */

    struct {
      __OM  uint32_t INSTR_MEM16 : 16;          /*!< [15..0] INSTR_MEM16 */
            uint32_t            : 16;
    } INSTR_MEM16_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM17;                 /*!< (@ 0x0000008C) Write-only access to instruction memory location 17 */

    struct {
      __OM  uint32_t INSTR_MEM17 : 16;          /*!< [15..0] INSTR_MEM17 */
            uint32_t            : 16;
    } INSTR_MEM17_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM18;                 /*!< (@ 0x00000090) Write-only access to instruction memory location 18 */

    struct {
      __OM  uint32_t INSTR_MEM18 : 16;          /*!< [15..0] INSTR_MEM18 */
            uint32_t            : 16;
    } INSTR_MEM18_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM19;                 /*!< (@ 0x00000094) Write-only access to instruction memory location 19 */

    struct {
      __OM  uint32_t INSTR_MEM19 : 16;          /*!< [15..0] INSTR_MEM19 */
            uint32_t            : 16;
    } INSTR_MEM19_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM20;                 /*!< (@ 0x00000098) Write-only access to instruction memory location 20 */

    struct {
      __OM  uint32_t INSTR_MEM20 : 16;          /*!< [15..0] INSTR_MEM20 */
            uint32_t            : 16;
    } INSTR_MEM20_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM21;                 /*!< (@ 0x0000009C) Write-only access to instruction memory location 21 */

    struct {
      __OM  uint32_t INSTR_MEM21 : 16;          /*!< [15..0] INSTR_MEM21 */
            uint32_t            : 16;
    } INSTR_MEM21_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM22;                 /*!< (@ 0x000000A0) Write-only access to instruction memory location 22 */

    struct {
      __OM  uint32_t INSTR_MEM22 : 16;          /*!< [15..0] INSTR_MEM22 */
            uint32_t            : 16;
    } INSTR_MEM22_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM23;                 /*!< (@ 0x000000A4) Write-only access to instruction memory location 23 */

    struct {
      __OM  uint32_t INSTR_MEM23 : 16;          /*!< [15..0] INSTR_MEM23 */
            uint32_t            : 16;
    } INSTR_MEM23_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM24;                 /*!< (@ 0x000000A8) Write-only access to instruction memory location 24 */

    struct {
      __OM  uint32_t INSTR_MEM24 : 16;          /*!< [15..0] INSTR_MEM24 */
            uint32_t            : 16;
    } INSTR_MEM24_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM25;                 /*!< (@ 0x000000AC) Write-only access to instruction memory location 25 */

    struct {
      __OM  uint32_t INSTR_MEM25 : 16;          /*!< [15..0] INSTR_MEM25 */
            uint32_t            : 16;
    } INSTR_MEM25_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM26;                 /*!< (@ 0x000000B0) Write-only access to instruction memory location 26 */

    struct {
      __OM  uint32_t INSTR_MEM26 : 16;          /*!< [15..0] INSTR_MEM26 */
            uint32_t            : 16;
    } INSTR_MEM26_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM27;                 /*!< (@ 0x000000B4) Write-only access to instruction memory location 27 */

    struct {
      __OM  uint32_t INSTR_MEM27 : 16;          /*!< [15..0] INSTR_MEM27 */
            uint32_t            : 16;
    } INSTR_MEM27_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM28;                 /*!< (@ 0x000000B8) Write-only access to instruction memory location 28 */

    struct {
      __OM  uint32_t INSTR_MEM28 : 16;          /*!< [15..0] INSTR_MEM28 */
            uint32_t            : 16;
    } INSTR_MEM28_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM29;                 /*!< (@ 0x000000BC) Write-only access to instruction memory location 29 */

    struct {
      __OM  uint32_t INSTR_MEM29 : 16;          /*!< [15..0] INSTR_MEM29 */
            uint32_t            : 16;
    } INSTR_MEM29_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM30;                 /*!< (@ 0x000000C0) Write-only access to instruction memory location 30 */

    struct {
      __OM  uint32_t INSTR_MEM30 : 16;          /*!< [15..0] INSTR_MEM30 */
            uint32_t            : 16;
    } INSTR_MEM30_b;
  } ;

  union {
    __IOM uint32_t INSTR_MEM31;                 /*!< (@ 0x000000C4) Write-only access to instruction memory location 31 */

    struct {
      __OM  uint32_t INSTR_MEM31 : 16;          /*!< [15..0] INSTR_MEM31 */
            uint32_t            : 16;
    } INSTR_MEM31_b;
  } ;

  union {
    __IOM uint32_t SM0_CLKDIV;                  /*!< (@ 0x000000C8) Clock divisor register for state machine 0 Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256) */

    struct {
            uint32_t            : 8;
      __IOM uint32_t FRAC       : 8;            /*!< [15..8] Fractional part of clock divisor */
      __IOM uint32_t INT        : 16;           /*!< [31..16] Effective frequency is sysclk/(int + frac/256). Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0. */
    } SM0_CLKDIV_b;
  } ;

  union {
    __IOM uint32_t SM0_EXECCTRL;                /*!< (@ 0x000000CC) Execution/behavioural settings for state machine 0 */

    struct {
      __IOM uint32_t STATUS_N   : 4;            /*!< [3..0] Comparison level for the MOV x, STATUS instruction */
      __IOM uint32_t STATUS_SEL : 1;            /*!< [4..4] Comparison used for the MOV x, STATUS instruction. */
            uint32_t            : 2;
      __IOM uint32_t WRAP_BOTTOM : 5;           /*!< [11..7] After reaching wrap_top, execution is wrapped to this address. */
      __IOM uint32_t WRAP_TOP   : 5;            /*!< [16..12] After reaching this address, execution is wrapped to wrap_bottom. If the instruction is a jump, and the jump condition is true, the jump takes priority. */
      __IOM uint32_t OUT_STICKY : 1;            /*!< [17..17] Continuously assert the most recent OUT/SET to the pins */
      __IOM uint32_t INLINE_OUT_EN : 1;         /*!< [18..18] If 1, use a bit of OUT data as an auxiliary write enable When used in conjunction with OUT_STICKY, writes with an enable of 0 will deassert the latest pin write. This can create useful masking/override behaviour due to the priority ordering of state machine pin writes (SM0 < SM1 < ...) */
      __IOM uint32_t OUT_EN_SEL : 5;            /*!< [23..19] Which data bit to use for inline OUT enable */
      __IOM uint32_t JMP_PIN    : 5;            /*!< [28..24] The GPIO number to use as condition for JMP PIN. Unaffected by input mapping. */
      __IOM uint32_t SIDE_PINDIR : 1;           /*!< [29..29] If 1, side-set data is asserted to pin directions, instead of pin values */
      __IOM uint32_t SIDE_EN    : 1;            /*!< [30..30] If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit. */
      __IM  uint32_t EXEC_STALLED : 1;          /*!< [31..31] If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes. */
    } SM0_EXECCTRL_b;
  } ;

  union {
    __IOM uint32_t SM0_SHIFTCTRL;               /*!< (@ 0x000000D0) Control behaviour of the input/output shift registers for state machine 0 */

    struct {
            uint32_t            : 16;
      __IOM uint32_t AUTOPUSH   : 1;            /*!< [16..16] Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH. */
      __IOM uint32_t AUTOPULL   : 1;            /*!< [17..17] Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH. */
      __IOM uint32_t IN_SHIFTDIR : 1;           /*!< [18..18] 1 = shift input shift register to right (data enters from left). 0 = to left. */
      __IOM uint32_t OUT_SHIFTDIR : 1;          /*!< [19..19] 1 = shift out of output shift register to right. 0 = to left. */
      __IOM uint32_t PUSH_THRESH : 5;           /*!< [24..20] Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place. Write 0 for value of 32. */
      __IOM uint32_t PULL_THRESH : 5;           /*!< [29..25] Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place. Write 0 for value of 32. */
      __IOM uint32_t FJOIN_TX   : 1;            /*!< [30..30] When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep. RX FIFO is disabled as a result (always reads as both full and empty). FIFOs are flushed when this bit is changed. */
      __IOM uint32_t FJOIN_RX   : 1;            /*!< [31..31] When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep. TX FIFO is disabled as a result (always reads as both full and empty). FIFOs are flushed when this bit is changed. */
    } SM0_SHIFTCTRL_b;
  } ;

  union {
    __IOM uint32_t SM0_ADDR;                    /*!< (@ 0x000000D4) Current instruction address of state machine 0 */

    struct {
      __IM  uint32_t SM0_ADDR   : 5;            /*!< [4..0] SM0_ADDR */
            uint32_t            : 27;
    } SM0_ADDR_b;
  } ;

  union {
    __IOM uint32_t SM0_INSTR;                   /*!< (@ 0x000000D8) Read to see the instruction currently addressed by state machine 0's program counter Write to execute an instruction immediately (including jumps) and then resume execution. */

    struct {
      __IOM uint32_t SM0_INSTR  : 16;           /*!< [15..0] SM0_INSTR */
            uint32_t            : 16;
    } SM0_INSTR_b;
  } ;

  union {
    __IOM uint32_t SM0_PINCTRL;                 /*!< (@ 0x000000DC) State machine pin control */

    struct {
      __IOM uint32_t OUT_BASE   : 5;            /*!< [4..0] The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data. */
      __IOM uint32_t SET_BASE   : 5;            /*!< [9..5] The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data. */
      __IOM uint32_t SIDESET_BASE : 5;          /*!< [14..10] The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins. */
      __IOM uint32_t IN_BASE    : 5;            /*!< [19..15] The pin which is mapped to the least-significant bit of a state machine's IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number. */
      __IOM uint32_t OUT_COUNT  : 6;            /*!< [25..20] The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive. */
      __IOM uint32_t SET_COUNT  : 3;            /*!< [28..26] The number of pins asserted by a SET. In the range 0 to 5 inclusive. */
      __IOM uint32_t SIDESET_COUNT : 3;         /*!< [31..29] The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay). */
    } SM0_PINCTRL_b;
  } ;

  union {
    __IOM uint32_t SM1_CLKDIV;                  /*!< (@ 0x000000E0) Clock divisor register for state machine 1 Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256) */

    struct {
            uint32_t            : 8;
      __IOM uint32_t FRAC       : 8;            /*!< [15..8] Fractional part of clock divisor */
      __IOM uint32_t INT        : 16;           /*!< [31..16] Effective frequency is sysclk/(int + frac/256). Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0. */
    } SM1_CLKDIV_b;
  } ;

  union {
    __IOM uint32_t SM1_EXECCTRL;                /*!< (@ 0x000000E4) Execution/behavioural settings for state machine 1 */

    struct {
      __IOM uint32_t STATUS_N   : 4;            /*!< [3..0] Comparison level for the MOV x, STATUS instruction */
      __IOM uint32_t STATUS_SEL : 1;            /*!< [4..4] Comparison used for the MOV x, STATUS instruction. */
            uint32_t            : 2;
      __IOM uint32_t WRAP_BOTTOM : 5;           /*!< [11..7] After reaching wrap_top, execution is wrapped to this address. */
      __IOM uint32_t WRAP_TOP   : 5;            /*!< [16..12] After reaching this address, execution is wrapped to wrap_bottom. If the instruction is a jump, and the jump condition is true, the jump takes priority. */
      __IOM uint32_t OUT_STICKY : 1;            /*!< [17..17] Continuously assert the most recent OUT/SET to the pins */
      __IOM uint32_t INLINE_OUT_EN : 1;         /*!< [18..18] If 1, use a bit of OUT data as an auxiliary write enable When used in conjunction with OUT_STICKY, writes with an enable of 0 will deassert the latest pin write. This can create useful masking/override behaviour due to the priority ordering of state machine pin writes (SM0 < SM1 < ...) */
      __IOM uint32_t OUT_EN_SEL : 5;            /*!< [23..19] Which data bit to use for inline OUT enable */
      __IOM uint32_t JMP_PIN    : 5;            /*!< [28..24] The GPIO number to use as condition for JMP PIN. Unaffected by input mapping. */
      __IOM uint32_t SIDE_PINDIR : 1;           /*!< [29..29] If 1, side-set data is asserted to pin directions, instead of pin values */
      __IOM uint32_t SIDE_EN    : 1;            /*!< [30..30] If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit. */
      __IM  uint32_t EXEC_STALLED : 1;          /*!< [31..31] If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes. */
    } SM1_EXECCTRL_b;
  } ;

  union {
    __IOM uint32_t SM1_SHIFTCTRL;               /*!< (@ 0x000000E8) Control behaviour of the input/output shift registers for state machine 1 */

    struct {
            uint32_t            : 16;
      __IOM uint32_t AUTOPUSH   : 1;            /*!< [16..16] Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH. */
      __IOM uint32_t AUTOPULL   : 1;            /*!< [17..17] Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH. */
      __IOM uint32_t IN_SHIFTDIR : 1;           /*!< [18..18] 1 = shift input shift register to right (data enters from left). 0 = to left. */
      __IOM uint32_t OUT_SHIFTDIR : 1;          /*!< [19..19] 1 = shift out of output shift register to right. 0 = to left. */
      __IOM uint32_t PUSH_THRESH : 5;           /*!< [24..20] Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place. Write 0 for value of 32. */
      __IOM uint32_t PULL_THRESH : 5;           /*!< [29..25] Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place. Write 0 for value of 32. */
      __IOM uint32_t FJOIN_TX   : 1;            /*!< [30..30] When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep. RX FIFO is disabled as a result (always reads as both full and empty). FIFOs are flushed when this bit is changed. */
      __IOM uint32_t FJOIN_RX   : 1;            /*!< [31..31] When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep. TX FIFO is disabled as a result (always reads as both full and empty). FIFOs are flushed when this bit is changed. */
    } SM1_SHIFTCTRL_b;
  } ;

  union {
    __IOM uint32_t SM1_ADDR;                    /*!< (@ 0x000000EC) Current instruction address of state machine 1 */

    struct {
      __IM  uint32_t SM1_ADDR   : 5;            /*!< [4..0] SM1_ADDR */
            uint32_t            : 27;
    } SM1_ADDR_b;
  } ;

  union {
    __IOM uint32_t SM1_INSTR;                   /*!< (@ 0x000000F0) Read to see the instruction currently addressed by state machine 1's program counter Write to execute an instruction immediately (including jumps) and then resume execution. */

    struct {
      __IOM uint32_t SM1_INSTR  : 16;           /*!< [15..0] SM1_INSTR */
            uint32_t            : 16;
    } SM1_INSTR_b;
  } ;

  union {
    __IOM uint32_t SM1_PINCTRL;                 /*!< (@ 0x000000F4) State machine pin control */

    struct {
      __IOM uint32_t OUT_BASE   : 5;            /*!< [4..0] The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data. */
      __IOM uint32_t SET_BASE   : 5;            /*!< [9..5] The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data. */
      __IOM uint32_t SIDESET_BASE : 5;          /*!< [14..10] The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins. */
      __IOM uint32_t IN_BASE    : 5;            /*!< [19..15] The pin which is mapped to the least-significant bit of a state machine's IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number. */
      __IOM uint32_t OUT_COUNT  : 6;            /*!< [25..20] The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive. */
      __IOM uint32_t SET_COUNT  : 3;            /*!< [28..26] The number of pins asserted by a SET. In the range 0 to 5 inclusive. */
      __IOM uint32_t SIDESET_COUNT : 3;         /*!< [31..29] The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay). */
    } SM1_PINCTRL_b;
  } ;

  union {
    __IOM uint32_t SM2_CLKDIV;                  /*!< (@ 0x000000F8) Clock divisor register for state machine 2 Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256) */

    struct {
            uint32_t            : 8;
      __IOM uint32_t FRAC       : 8;            /*!< [15..8] Fractional part of clock divisor */
      __IOM uint32_t INT        : 16;           /*!< [31..16] Effective frequency is sysclk/(int + frac/256). Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0. */
    } SM2_CLKDIV_b;
  } ;

  union {
    __IOM uint32_t SM2_EXECCTRL;                /*!< (@ 0x000000FC) Execution/behavioural settings for state machine 2 */

    struct {
      __IOM uint32_t STATUS_N   : 4;            /*!< [3..0] Comparison level for the MOV x, STATUS instruction */
      __IOM uint32_t STATUS_SEL : 1;            /*!< [4..4] Comparison used for the MOV x, STATUS instruction. */
            uint32_t            : 2;
      __IOM uint32_t WRAP_BOTTOM : 5;           /*!< [11..7] After reaching wrap_top, execution is wrapped to this address. */
      __IOM uint32_t WRAP_TOP   : 5;            /*!< [16..12] After reaching this address, execution is wrapped to wrap_bottom. If the instruction is a jump, and the jump condition is true, the jump takes priority. */
      __IOM uint32_t OUT_STICKY : 1;            /*!< [17..17] Continuously assert the most recent OUT/SET to the pins */
      __IOM uint32_t INLINE_OUT_EN : 1;         /*!< [18..18] If 1, use a bit of OUT data as an auxiliary write enable When used in conjunction with OUT_STICKY, writes with an enable of 0 will deassert the latest pin write. This can create useful masking/override behaviour due to the priority ordering of state machine pin writes (SM0 < SM1 < ...) */
      __IOM uint32_t OUT_EN_SEL : 5;            /*!< [23..19] Which data bit to use for inline OUT enable */
      __IOM uint32_t JMP_PIN    : 5;            /*!< [28..24] The GPIO number to use as condition for JMP PIN. Unaffected by input mapping. */
      __IOM uint32_t SIDE_PINDIR : 1;           /*!< [29..29] If 1, side-set data is asserted to pin directions, instead of pin values */
      __IOM uint32_t SIDE_EN    : 1;            /*!< [30..30] If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit. */
      __IM  uint32_t EXEC_STALLED : 1;          /*!< [31..31] If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes. */
    } SM2_EXECCTRL_b;
  } ;

  union {
    __IOM uint32_t SM2_SHIFTCTRL;               /*!< (@ 0x00000100) Control behaviour of the input/output shift registers for state machine 2 */

    struct {
            uint32_t            : 16;
      __IOM uint32_t AUTOPUSH   : 1;            /*!< [16..16] Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH. */
      __IOM uint32_t AUTOPULL   : 1;            /*!< [17..17] Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH. */
      __IOM uint32_t IN_SHIFTDIR : 1;           /*!< [18..18] 1 = shift input shift register to right (data enters from left). 0 = to left. */
      __IOM uint32_t OUT_SHIFTDIR : 1;          /*!< [19..19] 1 = shift out of output shift register to right. 0 = to left. */
      __IOM uint32_t PUSH_THRESH : 5;           /*!< [24..20] Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place. Write 0 for value of 32. */
      __IOM uint32_t PULL_THRESH : 5;           /*!< [29..25] Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place. Write 0 for value of 32. */
      __IOM uint32_t FJOIN_TX   : 1;            /*!< [30..30] When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep. RX FIFO is disabled as a result (always reads as both full and empty). FIFOs are flushed when this bit is changed. */
      __IOM uint32_t FJOIN_RX   : 1;            /*!< [31..31] When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep. TX FIFO is disabled as a result (always reads as both full and empty). FIFOs are flushed when this bit is changed. */
    } SM2_SHIFTCTRL_b;
  } ;

  union {
    __IOM uint32_t SM2_ADDR;                    /*!< (@ 0x00000104) Current instruction address of state machine 2 */

    struct {
      __IM  uint32_t SM2_ADDR   : 5;            /*!< [4..0] SM2_ADDR */
            uint32_t            : 27;
    } SM2_ADDR_b;
  } ;

  union {
    __IOM uint32_t SM2_INSTR;                   /*!< (@ 0x00000108) Read to see the instruction currently addressed by state machine 2's program counter Write to execute an instruction immediately (including jumps) and then resume execution. */

    struct {
      __IOM uint32_t SM2_INSTR  : 16;           /*!< [15..0] SM2_INSTR */
            uint32_t            : 16;
    } SM2_INSTR_b;
  } ;

  union {
    __IOM uint32_t SM2_PINCTRL;                 /*!< (@ 0x0000010C) State machine pin control */

    struct {
      __IOM uint32_t OUT_BASE   : 5;            /*!< [4..0] The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data. */
      __IOM uint32_t SET_BASE   : 5;            /*!< [9..5] The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data. */
      __IOM uint32_t SIDESET_BASE : 5;          /*!< [14..10] The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins. */
      __IOM uint32_t IN_BASE    : 5;            /*!< [19..15] The pin which is mapped to the least-significant bit of a state machine's IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number. */
      __IOM uint32_t OUT_COUNT  : 6;            /*!< [25..20] The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive. */
      __IOM uint32_t SET_COUNT  : 3;            /*!< [28..26] The number of pins asserted by a SET. In the range 0 to 5 inclusive. */
      __IOM uint32_t SIDESET_COUNT : 3;         /*!< [31..29] The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay). */
    } SM2_PINCTRL_b;
  } ;

  union {
    __IOM uint32_t SM3_CLKDIV;                  /*!< (@ 0x00000110) Clock divisor register for state machine 3 Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256) */

    struct {
            uint32_t            : 8;
      __IOM uint32_t FRAC       : 8;            /*!< [15..8] Fractional part of clock divisor */
      __IOM uint32_t INT        : 16;           /*!< [31..16] Effective frequency is sysclk/(int + frac/256). Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0. */
    } SM3_CLKDIV_b;
  } ;

  union {
    __IOM uint32_t SM3_EXECCTRL;                /*!< (@ 0x00000114) Execution/behavioural settings for state machine 3 */

    struct {
      __IOM uint32_t STATUS_N   : 4;            /*!< [3..0] Comparison level for the MOV x, STATUS instruction */
      __IOM uint32_t STATUS_SEL : 1;            /*!< [4..4] Comparison used for the MOV x, STATUS instruction. */
            uint32_t            : 2;
      __IOM uint32_t WRAP_BOTTOM : 5;           /*!< [11..7] After reaching wrap_top, execution is wrapped to this address. */
      __IOM uint32_t WRAP_TOP   : 5;            /*!< [16..12] After reaching this address, execution is wrapped to wrap_bottom. If the instruction is a jump, and the jump condition is true, the jump takes priority. */
      __IOM uint32_t OUT_STICKY : 1;            /*!< [17..17] Continuously assert the most recent OUT/SET to the pins */
      __IOM uint32_t INLINE_OUT_EN : 1;         /*!< [18..18] If 1, use a bit of OUT data as an auxiliary write enable When used in conjunction with OUT_STICKY, writes with an enable of 0 will deassert the latest pin write. This can create useful masking/override behaviour due to the priority ordering of state machine pin writes (SM0 < SM1 < ...) */
      __IOM uint32_t OUT_EN_SEL : 5;            /*!< [23..19] Which data bit to use for inline OUT enable */
      __IOM uint32_t JMP_PIN    : 5;            /*!< [28..24] The GPIO number to use as condition for JMP PIN. Unaffected by input mapping. */
      __IOM uint32_t SIDE_PINDIR : 1;           /*!< [29..29] If 1, side-set data is asserted to pin directions, instead of pin values */
      __IOM uint32_t SIDE_EN    : 1;            /*!< [30..30] If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit. */
      __IM  uint32_t EXEC_STALLED : 1;          /*!< [31..31] If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes. */
    } SM3_EXECCTRL_b;
  } ;

  union {
    __IOM uint32_t SM3_SHIFTCTRL;               /*!< (@ 0x00000118) Control behaviour of the input/output shift registers for state machine 3 */

    struct {
            uint32_t            : 16;
      __IOM uint32_t AUTOPUSH   : 1;            /*!< [16..16] Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH. */
      __IOM uint32_t AUTOPULL   : 1;            /*!< [17..17] Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH. */
      __IOM uint32_t IN_SHIFTDIR : 1;           /*!< [18..18] 1 = shift input shift register to right (data enters from left). 0 = to left. */
      __IOM uint32_t OUT_SHIFTDIR : 1;          /*!< [19..19] 1 = shift out of output shift register to right. 0 = to left. */
      __IOM uint32_t PUSH_THRESH : 5;           /*!< [24..20] Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place. Write 0 for value of 32. */
      __IOM uint32_t PULL_THRESH : 5;           /*!< [29..25] Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place. Write 0 for value of 32. */
      __IOM uint32_t FJOIN_TX   : 1;            /*!< [30..30] When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep. RX FIFO is disabled as a result (always reads as both full and empty). FIFOs are flushed when this bit is changed. */
      __IOM uint32_t FJOIN_RX   : 1;            /*!< [31..31] When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep. TX FIFO is disabled as a result (always reads as both full and empty). FIFOs are flushed when this bit is changed. */
    } SM3_SHIFTCTRL_b;
  } ;

  union {
    __IOM uint32_t SM3_ADDR;                    /*!< (@ 0x0000011C) Current instruction address of state machine 3 */

    struct {
      __IM  uint32_t SM3_ADDR   : 5;            /*!< [4..0] SM3_ADDR */
            uint32_t            : 27;
    } SM3_ADDR_b;
  } ;

  union {
    __IOM uint32_t SM3_INSTR;                   /*!< (@ 0x00000120) Read to see the instruction currently addressed by state machine 3's program counter Write to execute an instruction immediately (including jumps) and then resume execution. */

    struct {
      __IOM uint32_t SM3_INSTR  : 16;           /*!< [15..0] SM3_INSTR */
            uint32_t            : 16;
    } SM3_INSTR_b;
  } ;

  union {
    __IOM uint32_t SM3_PINCTRL;                 /*!< (@ 0x00000124) State machine pin control */

    struct {
      __IOM uint32_t OUT_BASE   : 5;            /*!< [4..0] The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data. */
      __IOM uint32_t SET_BASE   : 5;            /*!< [9..5] The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data. */
      __IOM uint32_t SIDESET_BASE : 5;          /*!< [14..10] The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins. */
      __IOM uint32_t IN_BASE    : 5;            /*!< [19..15] The pin which is mapped to the least-significant bit of a state machine's IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number. */
      __IOM uint32_t OUT_COUNT  : 6;            /*!< [25..20] The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive. */
      __IOM uint32_t SET_COUNT  : 3;            /*!< [28..26] The number of pins asserted by a SET. In the range 0 to 5 inclusive. */
      __IOM uint32_t SIDESET_COUNT : 3;         /*!< [31..29] The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay). */
    } SM3_PINCTRL_b;
  } ;

  union {
    __IOM uint32_t INTR;                        /*!< (@ 0x00000128) Raw Interrupts */

    struct {
      __IM  uint32_t SM0_RXNEMPTY : 1;          /*!< [0..0] SM0_RXNEMPTY */
      __IM  uint32_t SM1_RXNEMPTY : 1;          /*!< [1..1] SM1_RXNEMPTY */
      __IM  uint32_t SM2_RXNEMPTY : 1;          /*!< [2..2] SM2_RXNEMPTY */
      __IM  uint32_t SM3_RXNEMPTY : 1;          /*!< [3..3] SM3_RXNEMPTY */
      __IM  uint32_t SM0_TXNFULL : 1;           /*!< [4..4] SM0_TXNFULL */
      __IM  uint32_t SM1_TXNFULL : 1;           /*!< [5..5] SM1_TXNFULL */
      __IM  uint32_t SM2_TXNFULL : 1;           /*!< [6..6] SM2_TXNFULL */
      __IM  uint32_t SM3_TXNFULL : 1;           /*!< [7..7] SM3_TXNFULL */
      __IM  uint32_t SM0        : 1;            /*!< [8..8] SM0 */
      __IM  uint32_t SM1        : 1;            /*!< [9..9] SM1 */
      __IM  uint32_t SM2        : 1;            /*!< [10..10] SM2 */
      __IM  uint32_t SM3        : 1;            /*!< [11..11] SM3 */
            uint32_t            : 20;
    } INTR_b;
  } ;

  union {
    __IOM uint32_t IRQ0_INTE;                   /*!< (@ 0x0000012C) Interrupt Enable for irq0 */

    struct {
      __IOM uint32_t SM0_RXNEMPTY : 1;          /*!< [0..0] SM0_RXNEMPTY */
      __IOM uint32_t SM1_RXNEMPTY : 1;          /*!< [1..1] SM1_RXNEMPTY */
      __IOM uint32_t SM2_RXNEMPTY : 1;          /*!< [2..2] SM2_RXNEMPTY */
      __IOM uint32_t SM3_RXNEMPTY : 1;          /*!< [3..3] SM3_RXNEMPTY */
      __IOM uint32_t SM0_TXNFULL : 1;           /*!< [4..4] SM0_TXNFULL */
      __IOM uint32_t SM1_TXNFULL : 1;           /*!< [5..5] SM1_TXNFULL */
      __IOM uint32_t SM2_TXNFULL : 1;           /*!< [6..6] SM2_TXNFULL */
      __IOM uint32_t SM3_TXNFULL : 1;           /*!< [7..7] SM3_TXNFULL */
      __IOM uint32_t SM0        : 1;            /*!< [8..8] SM0 */
      __IOM uint32_t SM1        : 1;            /*!< [9..9] SM1 */
      __IOM uint32_t SM2        : 1;            /*!< [10..10] SM2 */
      __IOM uint32_t SM3        : 1;            /*!< [11..11] SM3 */
            uint32_t            : 20;
    } IRQ0_INTE_b;
  } ;

  union {
    __IOM uint32_t IRQ0_INTF;                   /*!< (@ 0x00000130) Interrupt Force for irq0 */

    struct {
      __IOM uint32_t SM0_RXNEMPTY : 1;          /*!< [0..0] SM0_RXNEMPTY */
      __IOM uint32_t SM1_RXNEMPTY : 1;          /*!< [1..1] SM1_RXNEMPTY */
      __IOM uint32_t SM2_RXNEMPTY : 1;          /*!< [2..2] SM2_RXNEMPTY */
      __IOM uint32_t SM3_RXNEMPTY : 1;          /*!< [3..3] SM3_RXNEMPTY */
      __IOM uint32_t SM0_TXNFULL : 1;           /*!< [4..4] SM0_TXNFULL */
      __IOM uint32_t SM1_TXNFULL : 1;           /*!< [5..5] SM1_TXNFULL */
      __IOM uint32_t SM2_TXNFULL : 1;           /*!< [6..6] SM2_TXNFULL */
      __IOM uint32_t SM3_TXNFULL : 1;           /*!< [7..7] SM3_TXNFULL */
      __IOM uint32_t SM0        : 1;            /*!< [8..8] SM0 */
      __IOM uint32_t SM1        : 1;            /*!< [9..9] SM1 */
      __IOM uint32_t SM2        : 1;            /*!< [10..10] SM2 */
      __IOM uint32_t SM3        : 1;            /*!< [11..11] SM3 */
            uint32_t            : 20;
    } IRQ0_INTF_b;
  } ;

  union {
    __IOM uint32_t IRQ0_INTS;                   /*!< (@ 0x00000134) Interrupt status after masking & forcing for irq0 */

    struct {
      __IM  uint32_t SM0_RXNEMPTY : 1;          /*!< [0..0] SM0_RXNEMPTY */
      __IM  uint32_t SM1_RXNEMPTY : 1;          /*!< [1..1] SM1_RXNEMPTY */
      __IM  uint32_t SM2_RXNEMPTY : 1;          /*!< [2..2] SM2_RXNEMPTY */
      __IM  uint32_t SM3_RXNEMPTY : 1;          /*!< [3..3] SM3_RXNEMPTY */
      __IM  uint32_t SM0_TXNFULL : 1;           /*!< [4..4] SM0_TXNFULL */
      __IM  uint32_t SM1_TXNFULL : 1;           /*!< [5..5] SM1_TXNFULL */
      __IM  uint32_t SM2_TXNFULL : 1;           /*!< [6..6] SM2_TXNFULL */
      __IM  uint32_t SM3_TXNFULL : 1;           /*!< [7..7] SM3_TXNFULL */
      __IM  uint32_t SM0        : 1;            /*!< [8..8] SM0 */
      __IM  uint32_t SM1        : 1;            /*!< [9..9] SM1 */
      __IM  uint32_t SM2        : 1;            /*!< [10..10] SM2 */
      __IM  uint32_t SM3        : 1;            /*!< [11..11] SM3 */
            uint32_t            : 20;
    } IRQ0_INTS_b;
  } ;

  union {
    __IOM uint32_t IRQ1_INTE;                   /*!< (@ 0x00000138) Interrupt Enable for irq1 */

    struct {
      __IOM uint32_t SM0_RXNEMPTY : 1;          /*!< [0..0] SM0_RXNEMPTY */
      __IOM uint32_t SM1_RXNEMPTY : 1;          /*!< [1..1] SM1_RXNEMPTY */
      __IOM uint32_t SM2_RXNEMPTY : 1;          /*!< [2..2] SM2_RXNEMPTY */
      __IOM uint32_t SM3_RXNEMPTY : 1;          /*!< [3..3] SM3_RXNEMPTY */
      __IOM uint32_t SM0_TXNFULL : 1;           /*!< [4..4] SM0_TXNFULL */
      __IOM uint32_t SM1_TXNFULL : 1;           /*!< [5..5] SM1_TXNFULL */
      __IOM uint32_t SM2_TXNFULL : 1;           /*!< [6..6] SM2_TXNFULL */
      __IOM uint32_t SM3_TXNFULL : 1;           /*!< [7..7] SM3_TXNFULL */
      __IOM uint32_t SM0        : 1;            /*!< [8..8] SM0 */
      __IOM uint32_t SM1        : 1;            /*!< [9..9] SM1 */
      __IOM uint32_t SM2        : 1;            /*!< [10..10] SM2 */
      __IOM uint32_t SM3        : 1;            /*!< [11..11] SM3 */
            uint32_t            : 20;
    } IRQ1_INTE_b;
  } ;

  union {
    __IOM uint32_t IRQ1_INTF;                   /*!< (@ 0x0000013C) Interrupt Force for irq1 */

    struct {
      __IOM uint32_t SM0_RXNEMPTY : 1;          /*!< [0..0] SM0_RXNEMPTY */
      __IOM uint32_t SM1_RXNEMPTY : 1;          /*!< [1..1] SM1_RXNEMPTY */
      __IOM uint32_t SM2_RXNEMPTY : 1;          /*!< [2..2] SM2_RXNEMPTY */
      __IOM uint32_t SM3_RXNEMPTY : 1;          /*!< [3..3] SM3_RXNEMPTY */
      __IOM uint32_t SM0_TXNFULL : 1;           /*!< [4..4] SM0_TXNFULL */
      __IOM uint32_t SM1_TXNFULL : 1;           /*!< [5..5] SM1_TXNFULL */
      __IOM uint32_t SM2_TXNFULL : 1;           /*!< [6..6] SM2_TXNFULL */
      __IOM uint32_t SM3_TXNFULL : 1;           /*!< [7..7] SM3_TXNFULL */
      __IOM uint32_t SM0        : 1;            /*!< [8..8] SM0 */
      __IOM uint32_t SM1        : 1;            /*!< [9..9] SM1 */
      __IOM uint32_t SM2        : 1;            /*!< [10..10] SM2 */
      __IOM uint32_t SM3        : 1;            /*!< [11..11] SM3 */
            uint32_t            : 20;
    } IRQ1_INTF_b;
  } ;

  union {
    __IOM uint32_t IRQ1_INTS;                   /*!< (@ 0x00000140) Interrupt status after masking & forcing for irq1 */

    struct {
      __IM  uint32_t SM0_RXNEMPTY : 1;          /*!< [0..0] SM0_RXNEMPTY */
      __IM  uint32_t SM1_RXNEMPTY : 1;          /*!< [1..1] SM1_RXNEMPTY */
      __IM  uint32_t SM2_RXNEMPTY : 1;          /*!< [2..2] SM2_RXNEMPTY */
      __IM  uint32_t SM3_RXNEMPTY : 1;          /*!< [3..3] SM3_RXNEMPTY */
      __IM  uint32_t SM0_TXNFULL : 1;           /*!< [4..4] SM0_TXNFULL */
      __IM  uint32_t SM1_TXNFULL : 1;           /*!< [5..5] SM1_TXNFULL */
      __IM  uint32_t SM2_TXNFULL : 1;           /*!< [6..6] SM2_TXNFULL */
      __IM  uint32_t SM3_TXNFULL : 1;           /*!< [7..7] SM3_TXNFULL */
      __IM  uint32_t SM0        : 1;            /*!< [8..8] SM0 */
      __IM  uint32_t SM1        : 1;            /*!< [9..9] SM1 */
      __IM  uint32_t SM2        : 1;            /*!< [10..10] SM2 */
      __IM  uint32_t SM3        : 1;            /*!< [11..11] SM3 */
            uint32_t            : 20;
    } IRQ1_INTS_b;
  } ;
} PIO0_Type;                                    /*!< Size = 324 (0x144) */



/* =========================================================================================================================== */
/* ================                                            SIO                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Single-cycle IO block\n
        Provides core-local and inter-core hardware for the two processors, with single-cycle access. (SIO)
  */

typedef struct {                                /*!< (@ 0xD0000000) SIO Structure */
  __IM  uint32_t  CPUID;                        /*!< (@ 0x00000000) Processor core identifier Value is 0 when read from processor core 0, and 1 when read from processor core 1. */

  union {
    __IOM uint32_t GPIO_IN;                     /*!< (@ 0x00000004) Input value for GPIO pins */

    struct {
      __IM  uint32_t GPIO_IN    : 30;           /*!< [29..0] Input value for GPIO0...29 */
            uint32_t            : 2;
    } GPIO_IN_b;
  } ;

  union {
    __IOM uint32_t GPIO_HI_IN;                  /*!< (@ 0x00000008) Input value for QSPI pins */

    struct {
      __IM  uint32_t GPIO_HI_IN : 6;            /*!< [5..0] Input value on QSPI IO in order 0..5: SCLK, SSn, SD0, SD1, SD2, SD3 */
            uint32_t            : 26;
    } GPIO_HI_IN_b;
  } ;
  __IM  uint32_t  RESERVED;

  union {
    __IOM uint32_t GPIO_OUT;                    /*!< (@ 0x00000010) GPIO output value */

    struct {
      __IOM uint32_t GPIO_OUT   : 30;           /*!< [29..0] Set output level (1/0 -> high/low) for GPIO0...29. Reading back gives the last value written, NOT the input value from the pins. If core 0 and core 1 both write to GPIO_OUT simultaneously (or to a SET/CLR/XOR alias), the result is as though the write from core 0 took place first, and the write from core 1 was then applied to that intermediate result. */
            uint32_t            : 2;
    } GPIO_OUT_b;
  } ;

  union {
    __IOM uint32_t GPIO_OUT_SET;                /*!< (@ 0x00000014) GPIO output value set */

    struct {
      __OM  uint32_t GPIO_OUT_SET : 30;         /*!< [29..0] Perform an atomic bit-set on GPIO_OUT, i.e. `GPIO_OUT |= wdata` */
            uint32_t            : 2;
    } GPIO_OUT_SET_b;
  } ;

  union {
    __IOM uint32_t GPIO_OUT_CLR;                /*!< (@ 0x00000018) GPIO output value clear */

    struct {
      __OM  uint32_t GPIO_OUT_CLR : 30;         /*!< [29..0] Perform an atomic bit-clear on GPIO_OUT, i.e. `GPIO_OUT &= ~wdata` */
            uint32_t            : 2;
    } GPIO_OUT_CLR_b;
  } ;

  union {
    __IOM uint32_t GPIO_OUT_XOR;                /*!< (@ 0x0000001C) GPIO output value XOR */

    struct {
      __OM  uint32_t GPIO_OUT_XOR : 30;         /*!< [29..0] Perform an atomic bitwise XOR on GPIO_OUT, i.e. `GPIO_OUT ^= wdata` */
            uint32_t            : 2;
    } GPIO_OUT_XOR_b;
  } ;

  union {
    __IOM uint32_t GPIO_OE;                     /*!< (@ 0x00000020) GPIO output enable */

    struct {
      __IOM uint32_t GPIO_OE    : 30;           /*!< [29..0] Set output enable (1/0 -> output/input) for GPIO0...29. Reading back gives the last value written. If core 0 and core 1 both write to GPIO_OE simultaneously (or to a SET/CLR/XOR alias), the result is as though the write from core 0 took place first, and the write from core 1 was then applied to that intermediate result. */
            uint32_t            : 2;
    } GPIO_OE_b;
  } ;

  union {
    __IOM uint32_t GPIO_OE_SET;                 /*!< (@ 0x00000024) GPIO output enable set */

    struct {
      __OM  uint32_t GPIO_OE_SET : 30;          /*!< [29..0] Perform an atomic bit-set on GPIO_OE, i.e. `GPIO_OE |= wdata` */
            uint32_t            : 2;
    } GPIO_OE_SET_b;
  } ;

  union {
    __IOM uint32_t GPIO_OE_CLR;                 /*!< (@ 0x00000028) GPIO output enable clear */

    struct {
      __OM  uint32_t GPIO_OE_CLR : 30;          /*!< [29..0] Perform an atomic bit-clear on GPIO_OE, i.e. `GPIO_OE &= ~wdata` */
            uint32_t            : 2;
    } GPIO_OE_CLR_b;
  } ;

  union {
    __IOM uint32_t GPIO_OE_XOR;                 /*!< (@ 0x0000002C) GPIO output enable XOR */

    struct {
      __OM  uint32_t GPIO_OE_XOR : 30;          /*!< [29..0] Perform an atomic bitwise XOR on GPIO_OE, i.e. `GPIO_OE ^= wdata` */
            uint32_t            : 2;
    } GPIO_OE_XOR_b;
  } ;

  union {
    __IOM uint32_t GPIO_HI_OUT;                 /*!< (@ 0x00000030) QSPI output value */

    struct {
      __IOM uint32_t GPIO_HI_OUT : 6;           /*!< [5..0] Set output level (1/0 -> high/low) for QSPI IO0...5. Reading back gives the last value written, NOT the input value from the pins. If core 0 and core 1 both write to GPIO_HI_OUT simultaneously (or to a SET/CLR/XOR alias), the result is as though the write from core 0 took place first, and the write from core 1 was then applied to that intermediate result. */
            uint32_t            : 26;
    } GPIO_HI_OUT_b;
  } ;

  union {
    __IOM uint32_t GPIO_HI_OUT_SET;             /*!< (@ 0x00000034) QSPI output value set */

    struct {
      __OM  uint32_t GPIO_HI_OUT_SET : 6;       /*!< [5..0] Perform an atomic bit-set on GPIO_HI_OUT, i.e. `GPIO_HI_OUT |= wdata` */
            uint32_t            : 26;
    } GPIO_HI_OUT_SET_b;
  } ;

  union {
    __IOM uint32_t GPIO_HI_OUT_CLR;             /*!< (@ 0x00000038) QSPI output value clear */

    struct {
      __OM  uint32_t GPIO_HI_OUT_CLR : 6;       /*!< [5..0] Perform an atomic bit-clear on GPIO_HI_OUT, i.e. `GPIO_HI_OUT &= ~wdata` */
            uint32_t            : 26;
    } GPIO_HI_OUT_CLR_b;
  } ;

  union {
    __IOM uint32_t GPIO_HI_OUT_XOR;             /*!< (@ 0x0000003C) QSPI output value XOR */

    struct {
      __OM  uint32_t GPIO_HI_OUT_XOR : 6;       /*!< [5..0] Perform an atomic bitwise XOR on GPIO_HI_OUT, i.e. `GPIO_HI_OUT ^= wdata` */
            uint32_t            : 26;
    } GPIO_HI_OUT_XOR_b;
  } ;

  union {
    __IOM uint32_t GPIO_HI_OE;                  /*!< (@ 0x00000040) QSPI output enable */

    struct {
      __IOM uint32_t GPIO_HI_OE : 6;            /*!< [5..0] Set output enable (1/0 -> output/input) for QSPI IO0...5. Reading back gives the last value written. If core 0 and core 1 both write to GPIO_HI_OE simultaneously (or to a SET/CLR/XOR alias), the result is as though the write from core 0 took place first, and the write from core 1 was then applied to that intermediate result. */
            uint32_t            : 26;
    } GPIO_HI_OE_b;
  } ;

  union {
    __IOM uint32_t GPIO_HI_OE_SET;              /*!< (@ 0x00000044) QSPI output enable set */

    struct {
      __OM  uint32_t GPIO_HI_OE_SET : 6;        /*!< [5..0] Perform an atomic bit-set on GPIO_HI_OE, i.e. `GPIO_HI_OE |= wdata` */
            uint32_t            : 26;
    } GPIO_HI_OE_SET_b;
  } ;

  union {
    __IOM uint32_t GPIO_HI_OE_CLR;              /*!< (@ 0x00000048) QSPI output enable clear */

    struct {
      __OM  uint32_t GPIO_HI_OE_CLR : 6;        /*!< [5..0] Perform an atomic bit-clear on GPIO_HI_OE, i.e. `GPIO_HI_OE &= ~wdata` */
            uint32_t            : 26;
    } GPIO_HI_OE_CLR_b;
  } ;

  union {
    __IOM uint32_t GPIO_HI_OE_XOR;              /*!< (@ 0x0000004C) QSPI output enable XOR */

    struct {
      __OM  uint32_t GPIO_HI_OE_XOR : 6;        /*!< [5..0] Perform an atomic bitwise XOR on GPIO_HI_OE, i.e. `GPIO_HI_OE ^= wdata` */
            uint32_t            : 26;
    } GPIO_HI_OE_XOR_b;
  } ;

  union {
    __IOM uint32_t FIFO_ST;                     /*!< (@ 0x00000050) Status register for inter-core FIFOs (mailboxes). There is one FIFO in the core 0 -> core 1 direction, and one core 1 -> core 0. Both are 32 bits wide and 8 words deep. Core 0 can see the read side of the 1->0 FIFO (RX), and the write side of 0->1 FIFO (TX). Core 1 can see the read side of the 0->1 FIFO (RX), and the write side of 1->0 FIFO (TX). The SIO IRQ for each core is the logical OR of the VLD, WOF and ROE fields of its FIF */

    struct {
      __IM  uint32_t VLD        : 1;            /*!< [0..0] Value is 1 if this core's RX FIFO is not empty (i.e. if FIFO_RD is valid) */
      __IM  uint32_t RDY        : 1;            /*!< [1..1] Value is 1 if this core's TX FIFO is not full (i.e. if FIFO_WR is ready for more data) */
      __IOM uint32_t WOF        : 1;            /*!< [2..2] Sticky flag indicating the TX FIFO was written when full. This write was ignored by the FIFO. */
      __IOM uint32_t ROE        : 1;            /*!< [3..3] Sticky flag indicating the RX FIFO was read when empty. This read was ignored by the FIFO. */
            uint32_t            : 28;
    } FIFO_ST_b;
  } ;
  __OM  uint32_t  FIFO_WR;                      /*!< (@ 0x00000054) Write access to this core's TX FIFO */
  __IM  uint32_t  FIFO_RD;                      /*!< (@ 0x00000058) Read access to this core's RX FIFO */
  __IM  uint32_t  SPINLOCK_ST;                  /*!< (@ 0x0000005C) Spinlock state A bitmap containing the state of all 32 spinlocks (1=locked). Mainly intended for debugging. */
  __IOM uint32_t  DIV_UDIVIDEND;                /*!< (@ 0x00000060) Divider unsigned dividend Write to the DIVIDEND operand of the divider, i.e. the p in `p / q`. Any operand write starts a new calculation. The results appear in QUOTIENT, REMAINDER. UDIVIDEND/SDIVIDEND are aliases of the same internal register. The U alias starts an unsigned calculation, and the S alias starts a signed calculation. */
  __IOM uint32_t  DIV_UDIVISOR;                 /*!< (@ 0x00000064) Divider unsigned divisor Write to the DIVISOR operand of the divider, i.e. the q in `p / q`. Any operand write starts a new calculation. The results appear in QUOTIENT, REMAINDER. UDIVIDEND/SDIVIDEND are aliases of the same internal register. The U alias starts an unsigned calculation, and the S alias starts a signed calculation. */
  __IOM uint32_t  DIV_SDIVIDEND;                /*!< (@ 0x00000068) Divider signed dividend The same as UDIVIDEND, but starts a signed calculation, rather than unsigned. */
  __IOM uint32_t  DIV_SDIVISOR;                 /*!< (@ 0x0000006C) Divider signed divisor The same as UDIVISOR, but starts a signed calculation, rather than unsigned. */
  __IOM uint32_t  DIV_QUOTIENT;                 /*!< (@ 0x00000070) Divider result quotient The result of `DIVIDEND / DIVISOR` (division). Contents undefined while CSR_READY is low. For signed calculations, QUOTIENT is negative when the signs of DIVIDEND and DIVISOR differ. This register can be written to directly, for context save/restore purposes. This halts any in-progress calculation and sets the CSR_READY and CSR_DIRTY flags. Reading from QUOTIENT clears the CSR_DIRTY flag, so */
  __IOM uint32_t  DIV_REMAINDER;                /*!< (@ 0x00000074) Divider result remainder The result of `DIVIDEND % DIVISOR` (modulo). Contents undefined while CSR_READY is low. For signed calculations, REMAINDER is negative only when DIVIDEND is negative. This register can be written to directly, for context save/restore purposes. This halts any in-progress calculation and sets the CSR_READY and CSR_DIRTY flags. */

  union {
    __IOM uint32_t DIV_CSR;                     /*!< (@ 0x00000078) Control and status register for divider. */

    struct {
      __IM  uint32_t READY      : 1;            /*!< [0..0] Reads as 0 when a calculation is in progress, 1 otherwise. Writing an operand (xDIVIDEND, xDIVISOR) will immediately start a new calculation, no matter if one is already in progress. Writing to a result register will immediately terminate any in-progress calculation and set the READY and DIRTY flags. */
      __IM  uint32_t DIRTY      : 1;            /*!< [1..1] Changes to 1 when any register is written, and back to 0 when QUOTIENT is read. Software can use this flag to make save/restore more efficient (skip if not DIRTY). If the flag is used in this way, it's recommended to either read QUOTIENT only, or REMAINDER and then QUOTIENT, to prevent data loss on context switch. */
            uint32_t            : 30;
    } DIV_CSR_b;
  } ;
  __IM  uint32_t  RESERVED1;
  __IOM uint32_t  INTERP0_ACCUM0;               /*!< (@ 0x00000080) Read/write access to accumulator 0 */
  __IOM uint32_t  INTERP0_ACCUM1;               /*!< (@ 0x00000084) Read/write access to accumulator 1 */
  __IOM uint32_t  INTERP0_BASE0;                /*!< (@ 0x00000088) Read/write access to BASE0 register. */
  __IOM uint32_t  INTERP0_BASE1;                /*!< (@ 0x0000008C) Read/write access to BASE1 register. */
  __IOM uint32_t  INTERP0_BASE2;                /*!< (@ 0x00000090) Read/write access to BASE2 register. */
  __IM  uint32_t  INTERP0_POP_LANE0;            /*!< (@ 0x00000094) Read LANE0 result, and simultaneously write lane results to both accumulators (POP). */
  __IM  uint32_t  INTERP0_POP_LANE1;            /*!< (@ 0x00000098) Read LANE1 result, and simultaneously write lane results to both accumulators (POP). */
  __IM  uint32_t  INTERP0_POP_FULL;             /*!< (@ 0x0000009C) Read FULL result, and simultaneously write lane results to both accumulators (POP). */
  __IM  uint32_t  INTERP0_PEEK_LANE0;           /*!< (@ 0x000000A0) Read LANE0 result, without altering any internal state (PEEK). */
  __IM  uint32_t  INTERP0_PEEK_LANE1;           /*!< (@ 0x000000A4) Read LANE1 result, without altering any internal state (PEEK). */
  __IM  uint32_t  INTERP0_PEEK_FULL;            /*!< (@ 0x000000A8) Read FULL result, without altering any internal state (PEEK). */

  union {
    __IOM uint32_t INTERP0_CTRL_LANE0;          /*!< (@ 0x000000AC) Control register for lane 0 */

    struct {
      __IOM uint32_t SHIFT      : 5;            /*!< [4..0] Logical right-shift applied to accumulator before masking */
      __IOM uint32_t MASK_LSB   : 5;            /*!< [9..5] The least-significant bit allowed to pass by the mask (inclusive) */
      __IOM uint32_t MASK_MSB   : 5;            /*!< [14..10] The most-significant bit allowed to pass by the mask (inclusive) Setting MSB < LSB may cause chip to turn inside-out */
      __IOM uint32_t SIGNED     : 1;            /*!< [15..15] If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits before adding to BASE0, and LANE0 PEEK/POP appear extended to 32 bits when read by processor. */
      __IOM uint32_t CROSS_INPUT : 1;           /*!< [16..16] If 1, feed the opposite lane's accumulator into this lane's shift + mask hardware. Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass) */
      __IOM uint32_t CROSS_RESULT : 1;          /*!< [17..17] If 1, feed the opposite lane's result into this lane's accumulator on POP. */
      __IOM uint32_t ADD_RAW    : 1;            /*!< [18..18] If 1, mask + shift is bypassed for LANE0 result. This does not affect FULL result. */
      __IOM uint32_t FORCE_MSB  : 2;            /*!< [20..19] ORed into bits 29:28 of the lane result presented to the processor on the bus. No effect on the internal 32-bit datapath. Handy for using a lane to generate sequence of pointers into flash or SRAM. */
      __IOM uint32_t BLEND      : 1;            /*!< [21..21] Only present on INTERP0 on each core. If BLEND mode is enabled: - LANE1 result is a linear interpolation between BASE0 and BASE1, controlled by the 8 LSBs of lane 1 shift and mask value (a fractional number between 0 and 255/256ths) - LANE0 result does not have BASE0 added (yields only the 8 LSBs of lane 1 shift+mask value) - FULL result does not have lane 1 shift+mask value added (BASE2 + lane 0 shift+mask) */
            uint32_t            : 1;
      __IM  uint32_t OVERF0     : 1;            /*!< [23..23] Indicates if any masked-off MSBs in ACCUM0 are set. */
      __IM  uint32_t OVERF1     : 1;            /*!< [24..24] Indicates if any masked-off MSBs in ACCUM1 are set. */
      __IM  uint32_t OVERF      : 1;            /*!< [25..25] Set if either OVERF0 or OVERF1 is set. */
            uint32_t            : 6;
    } INTERP0_CTRL_LANE0_b;
  } ;

  union {
    __IOM uint32_t INTERP0_CTRL_LANE1;          /*!< (@ 0x000000B0) Control register for lane 1 */

    struct {
      __IOM uint32_t SHIFT      : 5;            /*!< [4..0] Logical right-shift applied to accumulator before masking */
      __IOM uint32_t MASK_LSB   : 5;            /*!< [9..5] The least-significant bit allowed to pass by the mask (inclusive) */
      __IOM uint32_t MASK_MSB   : 5;            /*!< [14..10] The most-significant bit allowed to pass by the mask (inclusive) Setting MSB < LSB may cause chip to turn inside-out */
      __IOM uint32_t SIGNED     : 1;            /*!< [15..15] If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits before adding to BASE1, and LANE1 PEEK/POP appear extended to 32 bits when read by processor. */
      __IOM uint32_t CROSS_INPUT : 1;           /*!< [16..16] If 1, feed the opposite lane's accumulator into this lane's shift + mask hardware. Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass) */
      __IOM uint32_t CROSS_RESULT : 1;          /*!< [17..17] If 1, feed the opposite lane's result into this lane's accumulator on POP. */
      __IOM uint32_t ADD_RAW    : 1;            /*!< [18..18] If 1, mask + shift is bypassed for LANE1 result. This does not affect FULL result. */
      __IOM uint32_t FORCE_MSB  : 2;            /*!< [20..19] ORed into bits 29:28 of the lane result presented to the processor on the bus. No effect on the internal 32-bit datapath. Handy for using a lane to generate sequence of pointers into flash or SRAM. */
            uint32_t            : 11;
    } INTERP0_CTRL_LANE1_b;
  } ;

  union {
    __IOM uint32_t INTERP0_ACCUM0_ADD;          /*!< (@ 0x000000B4) Values written here are atomically added to ACCUM0 Reading yields lane 0's raw shift and mask value (BASE0 not added). */

    struct {
      __IOM uint32_t INTERP0_ACCUM0_ADD : 24;   /*!< [23..0] INTERP0_ACCUM0_ADD */
            uint32_t            : 8;
    } INTERP0_ACCUM0_ADD_b;
  } ;

  union {
    __IOM uint32_t INTERP0_ACCUM1_ADD;          /*!< (@ 0x000000B8) Values written here are atomically added to ACCUM1 Reading yields lane 1's raw shift and mask value (BASE1 not added). */

    struct {
      __IOM uint32_t INTERP0_ACCUM1_ADD : 24;   /*!< [23..0] INTERP0_ACCUM1_ADD */
            uint32_t            : 8;
    } INTERP0_ACCUM1_ADD_b;
  } ;
  __OM  uint32_t  INTERP0_BASE_1AND0;           /*!< (@ 0x000000BC) On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously. Each half is sign-extended to 32 bits if that lane's SIGNED flag is set. */
  __IOM uint32_t  INTERP1_ACCUM0;               /*!< (@ 0x000000C0) Read/write access to accumulator 0 */
  __IOM uint32_t  INTERP1_ACCUM1;               /*!< (@ 0x000000C4) Read/write access to accumulator 1 */
  __IOM uint32_t  INTERP1_BASE0;                /*!< (@ 0x000000C8) Read/write access to BASE0 register. */
  __IOM uint32_t  INTERP1_BASE1;                /*!< (@ 0x000000CC) Read/write access to BASE1 register. */
  __IOM uint32_t  INTERP1_BASE2;                /*!< (@ 0x000000D0) Read/write access to BASE2 register. */
  __IM  uint32_t  INTERP1_POP_LANE0;            /*!< (@ 0x000000D4) Read LANE0 result, and simultaneously write lane results to both accumulators (POP). */
  __IM  uint32_t  INTERP1_POP_LANE1;            /*!< (@ 0x000000D8) Read LANE1 result, and simultaneously write lane results to both accumulators (POP). */
  __IM  uint32_t  INTERP1_POP_FULL;             /*!< (@ 0x000000DC) Read FULL result, and simultaneously write lane results to both accumulators (POP). */
  __IM  uint32_t  INTERP1_PEEK_LANE0;           /*!< (@ 0x000000E0) Read LANE0 result, without altering any internal state (PEEK). */
  __IM  uint32_t  INTERP1_PEEK_LANE1;           /*!< (@ 0x000000E4) Read LANE1 result, without altering any internal state (PEEK). */
  __IM  uint32_t  INTERP1_PEEK_FULL;            /*!< (@ 0x000000E8) Read FULL result, without altering any internal state (PEEK). */

  union {
    __IOM uint32_t INTERP1_CTRL_LANE0;          /*!< (@ 0x000000EC) Control register for lane 0 */

    struct {
      __IOM uint32_t SHIFT      : 5;            /*!< [4..0] Logical right-shift applied to accumulator before masking */
      __IOM uint32_t MASK_LSB   : 5;            /*!< [9..5] The least-significant bit allowed to pass by the mask (inclusive) */
      __IOM uint32_t MASK_MSB   : 5;            /*!< [14..10] The most-significant bit allowed to pass by the mask (inclusive) Setting MSB < LSB may cause chip to turn inside-out */
      __IOM uint32_t SIGNED     : 1;            /*!< [15..15] If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits before adding to BASE0, and LANE0 PEEK/POP appear extended to 32 bits when read by processor. */
      __IOM uint32_t CROSS_INPUT : 1;           /*!< [16..16] If 1, feed the opposite lane's accumulator into this lane's shift + mask hardware. Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass) */
      __IOM uint32_t CROSS_RESULT : 1;          /*!< [17..17] If 1, feed the opposite lane's result into this lane's accumulator on POP. */
      __IOM uint32_t ADD_RAW    : 1;            /*!< [18..18] If 1, mask + shift is bypassed for LANE0 result. This does not affect FULL result. */
      __IOM uint32_t FORCE_MSB  : 2;            /*!< [20..19] ORed into bits 29:28 of the lane result presented to the processor on the bus. No effect on the internal 32-bit datapath. Handy for using a lane to generate sequence of pointers into flash or SRAM. */
            uint32_t            : 1;
      __IOM uint32_t CLAMP      : 1;            /*!< [22..22] Only present on INTERP1 on each core. If CLAMP mode is enabled: - LANE0 result is shifted and masked ACCUM0, clamped by a lower bound of BASE0 and an upper bound of BASE1. - Signedness of these comparisons is determined by LANE0_CTRL_SIGNED */
      __IM  uint32_t OVERF0     : 1;            /*!< [23..23] Indicates if any masked-off MSBs in ACCUM0 are set. */
      __IM  uint32_t OVERF1     : 1;            /*!< [24..24] Indicates if any masked-off MSBs in ACCUM1 are set. */
      __IM  uint32_t OVERF      : 1;            /*!< [25..25] Set if either OVERF0 or OVERF1 is set. */
            uint32_t            : 6;
    } INTERP1_CTRL_LANE0_b;
  } ;

  union {
    __IOM uint32_t INTERP1_CTRL_LANE1;          /*!< (@ 0x000000F0) Control register for lane 1 */

    struct {
      __IOM uint32_t SHIFT      : 5;            /*!< [4..0] Logical right-shift applied to accumulator before masking */
      __IOM uint32_t MASK_LSB   : 5;            /*!< [9..5] The least-significant bit allowed to pass by the mask (inclusive) */
      __IOM uint32_t MASK_MSB   : 5;            /*!< [14..10] The most-significant bit allowed to pass by the mask (inclusive) Setting MSB < LSB may cause chip to turn inside-out */
      __IOM uint32_t SIGNED     : 1;            /*!< [15..15] If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits before adding to BASE1, and LANE1 PEEK/POP appear extended to 32 bits when read by processor. */
      __IOM uint32_t CROSS_INPUT : 1;           /*!< [16..16] If 1, feed the opposite lane's accumulator into this lane's shift + mask hardware. Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass) */
      __IOM uint32_t CROSS_RESULT : 1;          /*!< [17..17] If 1, feed the opposite lane's result into this lane's accumulator on POP. */
      __IOM uint32_t ADD_RAW    : 1;            /*!< [18..18] If 1, mask + shift is bypassed for LANE1 result. This does not affect FULL result. */
      __IOM uint32_t FORCE_MSB  : 2;            /*!< [20..19] ORed into bits 29:28 of the lane result presented to the processor on the bus. No effect on the internal 32-bit datapath. Handy for using a lane to generate sequence of pointers into flash or SRAM. */
            uint32_t            : 11;
    } INTERP1_CTRL_LANE1_b;
  } ;

  union {
    __IOM uint32_t INTERP1_ACCUM0_ADD;          /*!< (@ 0x000000F4) Values written here are atomically added to ACCUM0 Reading yields lane 0's raw shift and mask value (BASE0 not added). */

    struct {
      __IOM uint32_t INTERP1_ACCUM0_ADD : 24;   /*!< [23..0] INTERP1_ACCUM0_ADD */
            uint32_t            : 8;
    } INTERP1_ACCUM0_ADD_b;
  } ;

  union {
    __IOM uint32_t INTERP1_ACCUM1_ADD;          /*!< (@ 0x000000F8) Values written here are atomically added to ACCUM1 Reading yields lane 1's raw shift and mask value (BASE1 not added). */

    struct {
      __IOM uint32_t INTERP1_ACCUM1_ADD : 24;   /*!< [23..0] INTERP1_ACCUM1_ADD */
            uint32_t            : 8;
    } INTERP1_ACCUM1_ADD_b;
  } ;
  __OM  uint32_t  INTERP1_BASE_1AND0;           /*!< (@ 0x000000FC) On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously. Each half is sign-extended to 32 bits if that lane's SIGNED flag is set. */
  __IOM uint32_t  SPINLOCK0;                    /*!< (@ 0x00000100) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK1;                    /*!< (@ 0x00000104) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK2;                    /*!< (@ 0x00000108) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK3;                    /*!< (@ 0x0000010C) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK4;                    /*!< (@ 0x00000110) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK5;                    /*!< (@ 0x00000114) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK6;                    /*!< (@ 0x00000118) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK7;                    /*!< (@ 0x0000011C) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK8;                    /*!< (@ 0x00000120) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK9;                    /*!< (@ 0x00000124) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK10;                   /*!< (@ 0x00000128) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK11;                   /*!< (@ 0x0000012C) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK12;                   /*!< (@ 0x00000130) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK13;                   /*!< (@ 0x00000134) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK14;                   /*!< (@ 0x00000138) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK15;                   /*!< (@ 0x0000013C) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK16;                   /*!< (@ 0x00000140) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK17;                   /*!< (@ 0x00000144) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK18;                   /*!< (@ 0x00000148) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK19;                   /*!< (@ 0x0000014C) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK20;                   /*!< (@ 0x00000150) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK21;                   /*!< (@ 0x00000154) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK22;                   /*!< (@ 0x00000158) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK23;                   /*!< (@ 0x0000015C) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK24;                   /*!< (@ 0x00000160) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK25;                   /*!< (@ 0x00000164) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK26;                   /*!< (@ 0x00000168) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK27;                   /*!< (@ 0x0000016C) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK28;                   /*!< (@ 0x00000170) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK29;                   /*!< (@ 0x00000174) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK30;                   /*!< (@ 0x00000178) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
  __IOM uint32_t  SPINLOCK31;                   /*!< (@ 0x0000017C) Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number. */
} SIO_Type;                                     /*!< Size = 384 (0x180) */



/* =========================================================================================================================== */
/* ================                                            PPB                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief PPB (PPB)
  */

typedef struct {                                /*!< (@ 0xE0000000) PPB Structure */
  __IM  uint32_t  RESERVED[14340];

  union {
    __IOM uint32_t SYST_CSR;                    /*!< (@ 0x0000E010) Use the SysTick Control and Status Register to enable the SysTick features. */

    struct {
      __IOM uint32_t ENABLE     : 1;            /*!< [0..0] Enable SysTick counter: 0 = Counter disabled. 1 = Counter enabled. */
      __IOM uint32_t TICKINT    : 1;            /*!< [1..1] Enables SysTick exception request: 0 = Counting down to zero does not assert the SysTick exception request. 1 = Counting down to zero to asserts the SysTick exception request. */
      __IOM uint32_t CLKSOURCE  : 1;            /*!< [2..2] SysTick clock source. Always reads as one if SYST_CALIB reports NOREF. Selects the SysTick timer clock source: 0 = External reference clock. 1 = Processor clock. */
            uint32_t            : 13;
      __IM  uint32_t COUNTFLAG  : 1;            /*!< [16..16] Returns 1 if timer counted to 0 since last time this was read. Clears on read by application or debugger. */
            uint32_t            : 15;
    } SYST_CSR_b;
  } ;

  union {
    __IOM uint32_t SYST_RVR;                    /*!< (@ 0x0000E014) Use the SysTick Reload Value Register to specify the start value to load into the current value register when the counter reaches 0. It can be any value between 0 and 0x00FFFFFF. A start value of 0 is possible, but has no effect because the SysTick interrupt and COUNTFLAG are activated when counting from 1 to 0. The reset value of this register is UNKNOWN. To generate a multi-shot timer with a period of N processor clock cycles, use a RELOAD value of N-1. For example, if the */

    struct {
      __IOM uint32_t RELOAD     : 24;           /*!< [23..0] Value to load into the SysTick Current Value Register when the counter reaches 0. */
            uint32_t            : 8;
    } SYST_RVR_b;
  } ;

  union {
    __IOM uint32_t SYST_CVR;                    /*!< (@ 0x0000E018) Use the SysTick Current Value Register to find the current value in the register. The reset value of this register is UNKNOWN. */

    struct {
      __IOM uint32_t CURRENT    : 24;           /*!< [23..0] Reads return the current value of the SysTick counter. This register is write-clear. Writing to it with any value clears the register to 0. Clearing this register also clears the COUNTFLAG bit of the SysTick Control and Status Register. */
            uint32_t            : 8;
    } SYST_CVR_b;
  } ;

  union {
    __IOM uint32_t SYST_CALIB;                  /*!< (@ 0x0000E01C) Use the SysTick Calibration Value Register to enable software to scale to any required speed using divide and multiply. */

    struct {
      __IM  uint32_t TENMS      : 24;           /*!< [23..0] An optional Reload value to be used for 10ms (100Hz) timing, subject to system clock skew errors. If the value reads as 0, the calibration value is not known. */
            uint32_t            : 6;
      __IM  uint32_t SKEW       : 1;            /*!< [30..30] If reads as 1, the calibration value for 10ms is inexact (due to clock frequency). */
      __IM  uint32_t NOREF      : 1;            /*!< [31..31] If reads as 1, the Reference clock is not provided - the CLKSOURCE bit of the SysTick Control and Status register will be forced to 1 and cannot be cleared to 0. */
    } SYST_CALIB_b;
  } ;
  __IM  uint32_t  RESERVED1[56];

  union {
    __IOM uint32_t NVIC_ISER;                   /*!< (@ 0x0000E100) Use the Interrupt Set-Enable Register to enable interrupts and determine which interrupts are currently enabled. If a pending interrupt is enabled, the NVIC activates the interrupt based on its priority. If an interrupt is not enabled, asserting its interrupt signal changes the interrupt state to pending, but the NVIC never activates the interrupt, regardless of its priority. */

    struct {
      __IOM uint32_t SETENA     : 32;           /*!< [31..0] Interrupt set-enable bits. Write: 0 = No effect. 1 = Enable interrupt. Read: 0 = Interrupt disabled. 1 = Interrupt enabled. */
    } NVIC_ISER_b;
  } ;
  __IM  uint32_t  RESERVED2[31];

  union {
    __IOM uint32_t NVIC_ICER;                   /*!< (@ 0x0000E180) Use the Interrupt Clear-Enable Registers to disable interrupts and determine which interrupts are currently enabled. */

    struct {
      __IOM uint32_t CLRENA     : 32;           /*!< [31..0] Interrupt clear-enable bits. Write: 0 = No effect. 1 = Disable interrupt. Read: 0 = Interrupt disabled. 1 = Interrupt enabled. */
    } NVIC_ICER_b;
  } ;
  __IM  uint32_t  RESERVED3[31];

  union {
    __IOM uint32_t NVIC_ISPR;                   /*!< (@ 0x0000E200) The NVIC_ISPR forces interrupts into the pending state, and shows which interrupts are pending. */

    struct {
      __IOM uint32_t SETPEND    : 32;           /*!< [31..0] Interrupt set-pending bits. Write: 0 = No effect. 1 = Changes interrupt state to pending. Read: 0 = Interrupt is not pending. 1 = Interrupt is pending. Note: Writing 1 to the NVIC_ISPR bit corresponding to: An interrupt that is pending has no effect. A disabled interrupt sets the state of that interrupt to pending. */
    } NVIC_ISPR_b;
  } ;
  __IM  uint32_t  RESERVED4[31];

  union {
    __IOM uint32_t NVIC_ICPR;                   /*!< (@ 0x0000E280) Use the Interrupt Clear-Pending Register to clear pending interrupts and determine which interrupts are currently pending. */

    struct {
      __IOM uint32_t CLRPEND    : 32;           /*!< [31..0] Interrupt clear-pending bits. Write: 0 = No effect. 1 = Removes pending state and interrupt. Read: 0 = Interrupt is not pending. 1 = Interrupt is pending. */
    } NVIC_ICPR_b;
  } ;
  __IM  uint32_t  RESERVED5[95];

  union {
    __IOM uint32_t NVIC_IPR0;                   /*!< (@ 0x0000E400) Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest. Note: Writing 1 to an NVIC_ICPR bit does not affect the active state of the corresponding interrupt. These registers are only word-accessible */

    struct {
            uint32_t            : 6;
      __IOM uint32_t IP_0       : 2;            /*!< [7..6] Priority of interrupt 0 */
            uint32_t            : 6;
      __IOM uint32_t IP_1       : 2;            /*!< [15..14] Priority of interrupt 1 */
            uint32_t            : 6;
      __IOM uint32_t IP_2       : 2;            /*!< [23..22] Priority of interrupt 2 */
            uint32_t            : 6;
      __IOM uint32_t IP_3       : 2;            /*!< [31..30] Priority of interrupt 3 */
    } NVIC_IPR0_b;
  } ;

  union {
    __IOM uint32_t NVIC_IPR1;                   /*!< (@ 0x0000E404) Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest. */

    struct {
            uint32_t            : 6;
      __IOM uint32_t IP_4       : 2;            /*!< [7..6] Priority of interrupt 4 */
            uint32_t            : 6;
      __IOM uint32_t IP_5       : 2;            /*!< [15..14] Priority of interrupt 5 */
            uint32_t            : 6;
      __IOM uint32_t IP_6       : 2;            /*!< [23..22] Priority of interrupt 6 */
            uint32_t            : 6;
      __IOM uint32_t IP_7       : 2;            /*!< [31..30] Priority of interrupt 7 */
    } NVIC_IPR1_b;
  } ;

  union {
    __IOM uint32_t NVIC_IPR2;                   /*!< (@ 0x0000E408) Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest. */

    struct {
            uint32_t            : 6;
      __IOM uint32_t IP_8       : 2;            /*!< [7..6] Priority of interrupt 8 */
            uint32_t            : 6;
      __IOM uint32_t IP_9       : 2;            /*!< [15..14] Priority of interrupt 9 */
            uint32_t            : 6;
      __IOM uint32_t IP_10      : 2;            /*!< [23..22] Priority of interrupt 10 */
            uint32_t            : 6;
      __IOM uint32_t IP_11      : 2;            /*!< [31..30] Priority of interrupt 11 */
    } NVIC_IPR2_b;
  } ;

  union {
    __IOM uint32_t NVIC_IPR3;                   /*!< (@ 0x0000E40C) Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest. */

    struct {
            uint32_t            : 6;
      __IOM uint32_t IP_12      : 2;            /*!< [7..6] Priority of interrupt 12 */
            uint32_t            : 6;
      __IOM uint32_t IP_13      : 2;            /*!< [15..14] Priority of interrupt 13 */
            uint32_t            : 6;
      __IOM uint32_t IP_14      : 2;            /*!< [23..22] Priority of interrupt 14 */
            uint32_t            : 6;
      __IOM uint32_t IP_15      : 2;            /*!< [31..30] Priority of interrupt 15 */
    } NVIC_IPR3_b;
  } ;

  union {
    __IOM uint32_t NVIC_IPR4;                   /*!< (@ 0x0000E410) Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest. */

    struct {
            uint32_t            : 6;
      __IOM uint32_t IP_16      : 2;            /*!< [7..6] Priority of interrupt 16 */
            uint32_t            : 6;
      __IOM uint32_t IP_17      : 2;            /*!< [15..14] Priority of interrupt 17 */
            uint32_t            : 6;
      __IOM uint32_t IP_18      : 2;            /*!< [23..22] Priority of interrupt 18 */
            uint32_t            : 6;
      __IOM uint32_t IP_19      : 2;            /*!< [31..30] Priority of interrupt 19 */
    } NVIC_IPR4_b;
  } ;

  union {
    __IOM uint32_t NVIC_IPR5;                   /*!< (@ 0x0000E414) Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest. */

    struct {
            uint32_t            : 6;
      __IOM uint32_t IP_20      : 2;            /*!< [7..6] Priority of interrupt 20 */
            uint32_t            : 6;
      __IOM uint32_t IP_21      : 2;            /*!< [15..14] Priority of interrupt 21 */
            uint32_t            : 6;
      __IOM uint32_t IP_22      : 2;            /*!< [23..22] Priority of interrupt 22 */
            uint32_t            : 6;
      __IOM uint32_t IP_23      : 2;            /*!< [31..30] Priority of interrupt 23 */
    } NVIC_IPR5_b;
  } ;

  union {
    __IOM uint32_t NVIC_IPR6;                   /*!< (@ 0x0000E418) Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest. */

    struct {
            uint32_t            : 6;
      __IOM uint32_t IP_24      : 2;            /*!< [7..6] Priority of interrupt 24 */
            uint32_t            : 6;
      __IOM uint32_t IP_25      : 2;            /*!< [15..14] Priority of interrupt 25 */
            uint32_t            : 6;
      __IOM uint32_t IP_26      : 2;            /*!< [23..22] Priority of interrupt 26 */
            uint32_t            : 6;
      __IOM uint32_t IP_27      : 2;            /*!< [31..30] Priority of interrupt 27 */
    } NVIC_IPR6_b;
  } ;

  union {
    __IOM uint32_t NVIC_IPR7;                   /*!< (@ 0x0000E41C) Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest. */

    struct {
            uint32_t            : 6;
      __IOM uint32_t IP_28      : 2;            /*!< [7..6] Priority of interrupt 28 */
            uint32_t            : 6;
      __IOM uint32_t IP_29      : 2;            /*!< [15..14] Priority of interrupt 29 */
            uint32_t            : 6;
      __IOM uint32_t IP_30      : 2;            /*!< [23..22] Priority of interrupt 30 */
            uint32_t            : 6;
      __IOM uint32_t IP_31      : 2;            /*!< [31..30] Priority of interrupt 31 */
    } NVIC_IPR7_b;
  } ;
  __IM  uint32_t  RESERVED6[568];

  union {
    __IOM uint32_t CPUID;                       /*!< (@ 0x0000ED00) Read the CPU ID Base Register to determine: the ID number of the processor core, the version number of the processor core, the implementation details of the processor core. */

    struct {
      __IM  uint32_t REVISION   : 4;            /*!< [3..0] Minor revision number m in the rnpm revision status: 0x1 = Patch 1. */
      __IM  uint32_t PARTNO     : 12;           /*!< [15..4] Number of processor within family: 0xC60 = Cortex-M0+ */
      __IM  uint32_t ARCHITECTURE : 4;          /*!< [19..16] Constant that defines the architecture of the processor: 0xC = ARMv6-M architecture. */
      __IM  uint32_t VARIANT    : 4;            /*!< [23..20] Major revision number n in the rnpm revision status: 0x0 = Revision 0. */
      __IM  uint32_t IMPLEMENTER : 8;           /*!< [31..24] Implementor code: 0x41 = ARM */
    } CPUID_b;
  } ;

  union {
    __IOM uint32_t ICSR;                        /*!< (@ 0x0000ED04) Use the Interrupt Control State Register to set a pending Non-Maskable Interrupt (NMI), set or clear a pending PendSV, set or clear a pending SysTick, check for pending exceptions, check the vector number of the highest priority pended exception, check the vector number of the active exception. */

    struct {
      __IM  uint32_t VECTACTIVE : 9;            /*!< [8..0] Active exception number field. Reset clears the VECTACTIVE field. */
            uint32_t            : 3;
      __IM  uint32_t VECTPENDING : 9;           /*!< [20..12] Indicates the exception number for the highest priority pending exception: 0 = no pending exceptions. Non zero = The pending state includes the effect of memory-mapped enable and mask registers. It does not include the PRIMASK special-purpose register qualifier. */
            uint32_t            : 1;
      __IM  uint32_t ISRPENDING : 1;            /*!< [22..22] External interrupt pending flag */
      __IM  uint32_t ISRPREEMPT : 1;            /*!< [23..23] The system can only access this bit when the core is halted. It indicates that a pending interrupt is to be taken in the next running cycle. If C_MASKINTS is clear in the Debug Halting Control and Status Register, the interrupt is serviced. */
            uint32_t            : 1;
      __IOM uint32_t PENDSTCLR  : 1;            /*!< [25..25] SysTick exception clear-pending bit. Write: 0 = No effect. 1 = Removes the pending state from the SysTick exception. This bit is WO. On a register read its value is Unknown. */
      __IOM uint32_t PENDSTSET  : 1;            /*!< [26..26] SysTick exception set-pending bit. Write: 0 = No effect. 1 = Changes SysTick exception state to pending. Read: 0 = SysTick exception is not pending. 1 = SysTick exception is pending. */
      __IOM uint32_t PENDSVCLR  : 1;            /*!< [27..27] PendSV clear-pending bit. Write: 0 = No effect. 1 = Removes the pending state from the PendSV exception. */
      __IOM uint32_t PENDSVSET  : 1;            /*!< [28..28] PendSV set-pending bit. Write: 0 = No effect. 1 = Changes PendSV exception state to pending. Read: 0 = PendSV exception is not pending. 1 = PendSV exception is pending. Writing 1 to this bit is the only way to set the PendSV exception state to pending. */
            uint32_t            : 2;
      __IOM uint32_t NMIPENDSET : 1;            /*!< [31..31] Setting this bit will activate an NMI. Since NMI is the highest priority exception, it will activate as soon as it is registered. NMI set-pending bit. Write: 0 = No effect. 1 = Changes NMI exception state to pending. Read: 0 = NMI exception is not pending. 1 = NMI exception is pending. Because NMI is the highest-priority exception, normally the processor */
    } ICSR_b;
  } ;

  union {
    __IOM uint32_t VTOR;                        /*!< (@ 0x0000ED08) The VTOR holds the vector table offset address. */

    struct {
            uint32_t            : 8;
      __IOM uint32_t TBLOFF     : 24;           /*!< [31..8] Bits [31:8] of the indicate the vector table offset address. */
    } VTOR_b;
  } ;

  union {
    __IOM uint32_t AIRCR;                       /*!< (@ 0x0000ED0C) Use the Application Interrupt and Reset Control Register to: determine data endianness, clear all active state information from debug halt mode, request a system reset. */

    struct {
            uint32_t            : 1;
      __IOM uint32_t VECTCLRACTIVE : 1;         /*!< [1..1] Clears all active state information for fixed and configurable exceptions. This bit: is self-clearing, can only be set by the DAP when the core is halted. When set: clears all active exception status of the processor, forces a return to Thread mode, forces an IPSR of 0. A debugger must re-initialize the stack. */
      __IOM uint32_t SYSRESETREQ : 1;           /*!< [2..2] Writing 1 to this bit causes the SYSRESETREQ signal to the outer system to be asserted to request a reset. The intention is to force a large system reset of all major components except for debug. The C_HALT bit in the DHCSR is cleared as a result of the system reset requested. The debugger does not lose contact with the device. */
            uint32_t            : 12;
      __IM  uint32_t ENDIANESS  : 1;            /*!< [15..15] Data endianness implemented: 0 = Little-endian. */
      __IOM uint32_t VECTKEY    : 16;           /*!< [31..16] Register key: Reads as Unknown On writes, write 0x05FA to VECTKEY, otherwise the write is ignored. */
    } AIRCR_b;
  } ;

  union {
    __IOM uint32_t SCR;                         /*!< (@ 0x0000ED10) System Control Register. Use the System Control Register for power-management functions: signal to the system when the processor can enter a low power state, control how the processor enters and exits low power states. */

    struct {
            uint32_t            : 1;
      __IOM uint32_t SLEEPONEXIT : 1;           /*!< [1..1] Indicates sleep-on-exit when returning from Handler mode to Thread mode: 0 = Do not sleep when returning to Thread mode. 1 = Enter sleep, or deep sleep, on return from an ISR to Thread mode. Setting this bit to 1 enables an interrupt driven application to avoid returning to an empty main application. */
      __IOM uint32_t SLEEPDEEP  : 1;            /*!< [2..2] Controls whether the processor uses sleep or deep sleep as its low power mode: 0 = Sleep. 1 = Deep sleep. */
            uint32_t            : 1;
      __IOM uint32_t SEVONPEND  : 1;            /*!< [4..4] Send Event on Pending bit: 0 = Only enabled interrupts or events can wakeup the processor, disabled interrupts are excluded. 1 = Enabled events and all interrupts, including disabled interrupts, can wakeup the processor. When an event or interrupt becomes pending, the event signal wakes up the processor from WFE. If the processor is not waiting for an event, the event is registered and affects the next WFE. The */
            uint32_t            : 27;
    } SCR_b;
  } ;

  union {
    __IOM uint32_t CCR;                         /*!< (@ 0x0000ED14) The Configuration and Control Register permanently enables stack alignment and causes unaligned accesses to result in a Hard Fault. */

    struct {
            uint32_t            : 3;
      __IM  uint32_t UNALIGN_TRP : 1;           /*!< [3..3] Always reads as one, indicates that all unaligned accesses generate a HardFault. */
            uint32_t            : 5;
      __IM  uint32_t STKALIGN   : 1;            /*!< [9..9] Always reads as one, indicates 8-byte stack alignment on exception entry. On exception entry, the processor uses bit[9] of the stacked PSR to indicate the stack alignment. On return from the exception it uses this stacked bit to restore the correct stack alignment. */
            uint32_t            : 22;
    } CCR_b;
  } ;
  __IM  uint32_t  RESERVED7;

  union {
    __IOM uint32_t SHPR2;                       /*!< (@ 0x0000ED1C) System handlers are a special class of exception handler that can have their priority set to any of the priority levels. Use the System Handler Priority Register 2 to set the priority of SVCall. */

    struct {
            uint32_t            : 30;
      __IOM uint32_t PRI_11     : 2;            /*!< [31..30] Priority of system handler 11, SVCall */
    } SHPR2_b;
  } ;

  union {
    __IOM uint32_t SHPR3;                       /*!< (@ 0x0000ED20) System handlers are a special class of exception handler that can have their priority set to any of the priority levels. Use the System Handler Priority Register 3 to set the priority of PendSV and SysTick. */

    struct {
            uint32_t            : 22;
      __IOM uint32_t PRI_14     : 2;            /*!< [23..22] Priority of system handler 14, PendSV */
            uint32_t            : 6;
      __IOM uint32_t PRI_15     : 2;            /*!< [31..30] Priority of system handler 15, SysTick */
    } SHPR3_b;
  } ;

  union {
    __IOM uint32_t SHCSR;                       /*!< (@ 0x0000ED24) Use the System Handler Control and State Register to determine or clear the pending status of SVCall. */

    struct {
            uint32_t            : 15;
      __IOM uint32_t SVCALLPENDED : 1;          /*!< [15..15] Reads as 1 if SVCall is Pending. Write 1 to set pending SVCall, write 0 to clear pending SVCall. */
            uint32_t            : 16;
    } SHCSR_b;
  } ;
  __IM  uint32_t  RESERVED8[26];

  union {
    __IOM uint32_t MPU_TYPE;                    /*!< (@ 0x0000ED90) Read the MPU Type Register to determine if the processor implements an MPU, and how many regions the MPU supports. */

    struct {
      __IM  uint32_t SEPARATE   : 1;            /*!< [0..0] Indicates support for separate instruction and data address maps. Reads as 0 as ARMv6-M only supports a unified MPU. */
            uint32_t            : 7;
      __IM  uint32_t DREGION    : 8;            /*!< [15..8] Number of regions supported by the MPU. */
      __IM  uint32_t IREGION    : 8;            /*!< [23..16] Instruction region. Reads as zero as ARMv6-M only supports a unified MPU. */
            uint32_t            : 8;
    } MPU_TYPE_b;
  } ;

  union {
    __IOM uint32_t MPU_CTRL;                    /*!< (@ 0x0000ED94) Use the MPU Control Register to enable and disable the MPU, and to control whether the default memory map is enabled as a background region for privileged accesses, and whether the MPU is enabled for HardFaults and NMIs. */

    struct {
      __IOM uint32_t ENABLE     : 1;            /*!< [0..0] Enables the MPU. If the MPU is disabled, privileged and unprivileged accesses use the default memory map. 0 = MPU disabled. 1 = MPU enabled. */
      __IOM uint32_t HFNMIENA   : 1;            /*!< [1..1] Controls the use of the MPU for HardFaults and NMIs. Setting this bit when ENABLE is clear results in UNPREDICTABLE behaviour. When the MPU is enabled: 0 = MPU is disabled during HardFault and NMI handlers, regardless of the value of the ENABLE bit. 1 = the MPU is enabled during HardFault and NMI handlers. */
      __IOM uint32_t PRIVDEFENA : 1;            /*!< [2..2] Controls whether the default memory map is enabled as a background region for privileged accesses. This bit is ignored when ENABLE is clear. 0 = If the MPU is enabled, disables use of the default memory map. Any memory access to a location not covered by any enabled region causes a fault. 1 = If the MPU is enabled, enables use of the default memory map as a background region for privileged software accesses. When enabled, the bac */
            uint32_t            : 29;
    } MPU_CTRL_b;
  } ;

  union {
    __IOM uint32_t MPU_RNR;                     /*!< (@ 0x0000ED98) Use the MPU Region Number Register to select the region currently accessed by MPU_RBAR and MPU_RASR. */

    struct {
      __IOM uint32_t REGION     : 4;            /*!< [3..0] Indicates the MPU region referenced by the MPU_RBAR and MPU_RASR registers. The MPU supports 8 memory regions, so the permitted values of this field are 0-7. */
            uint32_t            : 28;
    } MPU_RNR_b;
  } ;

  union {
    __IOM uint32_t MPU_RBAR;                    /*!< (@ 0x0000ED9C) Read the MPU Region Base Address Register to determine the base address of the region identified by MPU_RNR. Write to update the base address of said region or that of a specified region, with whose number MPU_RNR will also be updated. */

    struct {
      __IOM uint32_t REGION     : 4;            /*!< [3..0] On writes, specifies the number of the region whose base address to update provided VALID is set written as 1. On reads, returns bits [3:0] of MPU_RNR. */
      __IOM uint32_t VALID      : 1;            /*!< [4..4] On writes, indicates whether the write must update the base address of the region identified by the REGION field, updating the MPU_RNR to indicate this new region. Write: 0 = MPU_RNR not changed, and the processor: Updates the base address for the region specified in the MPU_RNR. Ignores the value of the REGION field. 1 = The processor: Updates the value of the MPU_RNR to the value of the REG */
            uint32_t            : 3;
      __IOM uint32_t ADDR       : 24;           /*!< [31..8] Base address of the region. */
    } MPU_RBAR_b;
  } ;

  union {
    __IOM uint32_t MPU_RASR;                    /*!< (@ 0x0000EDA0) Use the MPU Region Attribute and Size Register to define the size, access behaviour and memory type of the region identified by MPU_RNR, and enable that region. */

    struct {
      __IOM uint32_t ENABLE     : 1;            /*!< [0..0] Enables the region. */
      __IOM uint32_t SIZE       : 5;            /*!< [5..1] Indicates the region size. Region size in bytes = 2^(SIZE+1). The minimum permitted value is 7 (b00111) = 256Bytes */
            uint32_t            : 2;
      __IOM uint32_t SRD        : 8;            /*!< [15..8] Subregion Disable. For regions of 256 bytes or larger, each bit of this field controls whether one of the eight equal subregions is enabled. */
      __IOM uint32_t ATTRS      : 16;           /*!< [31..16] The MPU Region Attribute field. Use to define the region attribute control. 28 = XN: Instruction access disable bit: 0 = Instruction fetches enabled. 1 = Instruction fetches disabled. 26:24 = AP: Access permission field 18 = S: Shareable bit 17 = C: Cacheable bit 16 = B: Bufferable bit */
    } MPU_RASR_b;
  } ;
} PPB_Type;                                     /*!< Size = 60836 (0xeda4) */


/** @} */ /* End of group Device_Peripheral_peripherals */


/* =========================================================================================================================== */
/* ================                          Device Specific Peripheral Address Map                           ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripheralAddr
  * @{
  */

#define XIP_CTRL_BASE               0x14000000UL
#define XIP_SSI_BASE                0x18000000UL
#define SYSINFO_BASE                0x40000000UL
#define SYSCFG_BASE                 0x40004000UL
#define CLOCKS_BASE                 0x40008000UL
#define RESETS_BASE                 0x4000C000UL
#define PSM_BASE                    0x40010000UL
#define IO_BANK0_BASE               0x40014000UL
#define IO_QSPI_BASE                0x40018000UL
#define PADS_BANK0_BASE             0x4001C000UL
#define PADS_QSPI_BASE              0x40020000UL
#define XOSC_BASE                   0x40024000UL
#define PLL_SYS_BASE                0x40028000UL
#define PLL_USB_BASE                0x4002C000UL
#define BUSCTRL_BASE                0x40030000UL
#define UART0_BASE                  0x40034000UL
#define UART1_BASE                  0x40038000UL
#define SPI0_BASE                   0x4003C000UL
#define SPI1_BASE                   0x40040000UL
#define I2C0_BASE                   0x40044000UL
#define I2C1_BASE                   0x40048000UL
#define ADC_BASE                    0x4004C000UL
#define PWM_BASE                    0x40050000UL
#define TIMER_BASE                  0x40054000UL
#define WATCHDOG_BASE               0x40058000UL
#define RTC_BASE                    0x4005C000UL
#define ROSC_BASE                   0x40060000UL
#define VREG_AND_CHIP_RESET_BASE    0x40064000UL
#define TBMAN_BASE                  0x4006C000UL
#define DMA_BASE                    0x50000000UL
#define USBCTRL_DPRAM_BASE          0x50100000UL
#define USBCTRL_REGS_BASE           0x50110000UL
#define PIO0_BASE                   0x50200000UL
#define PIO1_BASE                   0x50300000UL
#define SIO_BASE                    0xD0000000UL
#define PPB_BASE                    0xE0000000UL

/** @} */ /* End of group Device_Peripheral_peripheralAddr */


/* =========================================================================================================================== */
/* ================                                  Peripheral declaration                                   ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_declaration
  * @{
  */

#define XIP_CTRL                    ((XIP_CTRL_Type*)          XIP_CTRL_BASE)
#define XIP_SSI                     ((XIP_SSI_Type*)           XIP_SSI_BASE)
#define SYSINFO                     ((SYSINFO_Type*)           SYSINFO_BASE)
#define SYSCFG                      ((SYSCFG_Type*)            SYSCFG_BASE)
#define CLOCKS                      ((CLOCKS_Type*)            CLOCKS_BASE)
#define RESETS                      ((RESETS_Type*)            RESETS_BASE)
#define PSM                         ((PSM_Type*)               PSM_BASE)
#define IO_BANK0                    ((IO_BANK0_Type*)          IO_BANK0_BASE)
#define IO_QSPI                     ((IO_QSPI_Type*)           IO_QSPI_BASE)
#define PADS_BANK0                  ((PADS_BANK0_Type*)        PADS_BANK0_BASE)
#define PADS_QSPI                   ((PADS_QSPI_Type*)         PADS_QSPI_BASE)
#define XOSC                        ((XOSC_Type*)              XOSC_BASE)
#define PLL_SYS                     ((PLL_SYS_Type*)           PLL_SYS_BASE)
#define PLL_USB                     ((PLL_SYS_Type*)           PLL_USB_BASE)
#define BUSCTRL                     ((BUSCTRL_Type*)           BUSCTRL_BASE)
#define UART0                       ((UART0_Type*)             UART0_BASE)
#define UART1                       ((UART0_Type*)             UART1_BASE)
#define SPI0                        ((SPI0_Type*)              SPI0_BASE)
#define SPI1                        ((SPI0_Type*)              SPI1_BASE)
#define I2C0                        ((I2C0_Type*)              I2C0_BASE)
#define I2C1                        ((I2C0_Type*)              I2C1_BASE)
#define ADC                         ((ADC_Type*)               ADC_BASE)
#define PWM                         ((PWM_Type*)               PWM_BASE)
#define TIMER                       ((TIMER_Type*)             TIMER_BASE)
#define WATCHDOG                    ((WATCHDOG_Type*)          WATCHDOG_BASE)
#define RTC                         ((RTC_Type*)               RTC_BASE)
#define ROSC                        ((ROSC_Type*)              ROSC_BASE)
#define VREG_AND_CHIP_RESET         ((VREG_AND_CHIP_RESET_Type*)  VREG_AND_CHIP_RESET_BASE)
#define TBMAN                       ((TBMAN_Type*)             TBMAN_BASE)
#define DMA                         ((DMA_Type*)               DMA_BASE)
#define USBCTRL_DPRAM               ((USBCTRL_DPRAM_Type*)     USBCTRL_DPRAM_BASE)
#define USBCTRL_REGS                ((USBCTRL_REGS_Type*)      USBCTRL_REGS_BASE)
#define PIO0                        ((PIO0_Type*)              PIO0_BASE)
#define PIO1                        ((PIO0_Type*)              PIO1_BASE)
#define SIO                         ((SIO_Type*)               SIO_BASE)
#define PPB                         ((PPB_Type*)               PPB_BASE)

#define XIP_CTRL_XOR                ((XIP_CTRL_Type*)          (XIP_CTRL_BASE+0x1000))
#define XIP_SSI_XOR                 ((XIP_SSI_Type*)           (XIP_SSI_BASE+0x1000))
#define SYSINFO_XOR                 ((SYSINFO_Type*)           (SYSINFO_BASE+0x1000))
#define SYSCFG_XOR                  ((SYSCFG_Type*)            (SYSCFG_BASE+0x1000))
#define CLOCKS_XOR                  ((CLOCKS_Type*)            (CLOCKS_BASE+0x1000))
#define RESETS_XOR                  ((RESETS_Type*)            (RESETS_BASE+0x1000))
#define PSM_XOR                     ((PSM_Type*)               (PSM_BASE+0x1000))
#define IO_BANK0_XOR                ((IO_BANK0_Type*)          (IO_BANK0_BASE+0x1000))
#define IO_QSPI_XOR                 ((IO_QSPI_Type*)           (IO_QSPI_BASE+0x1000))
#define PADS_BANK0_XOR              ((PADS_BANK0_Type*)        (PADS_BANK0_BASE+0x1000))
#define PADS_QSPI_XOR               ((PADS_QSPI_Type*)         (PADS_QSPI_BASE+0x1000))
#define XOSC_XOR                    ((XOSC_Type*)              (XOSC_BASE+0x1000))
#define PLL_SYS_XOR                 ((PLL_SYS_Type*)           (PLL_SYS_BASE+0x1000))
#define PLL_USB_XOR                 ((PLL_SYS_Type*)           (PLL_USB_BASE+0x1000))
#define BUSCTRL_XOR                 ((BUSCTRL_Type*)           (BUSCTRL_BASE+0x1000))
#define UART0_XOR                   ((UART0_Type*)             (UART0_BASE+0x1000))
#define UART1_XOR                   ((UART0_Type*)             (UART1_BASE+0x1000))
#define SPI0_XOR                    ((SPI0_Type*)              (SPI0_BASE+0x1000))
#define SPI1_XOR                    ((SPI0_Type*)              (SPI1_BASE+0x1000))
#define I2C0_XOR                    ((I2C0_Type*)              (I2C0_BASE+0x1000))
#define I2C1_XOR                    ((I2C0_Type*)              (I2C1_BASE+0x1000))
#define ADC_XOR                     ((ADC_Type*)               (ADC_BASE+0x1000))
#define PWM_XOR                     ((PWM_Type*)               (PWM_BASE+0x1000))
#define TIMER_XOR                   ((TIMER_Type*)             (TIMER_BASE+0x1000))
#define WATCHDOG_XOR                ((WATCHDOG_Type*)          (WATCHDOG_BASE+0x1000))
#define RTC_XOR                     ((RTC_Type*)               (RTC_BASE+0x1000))
#define ROSC_XOR                    ((ROSC_Type*)              (ROSC_BASE+0x1000))
#define VREG_AND_CHIP_RESET_XOR     ((VREG_AND_CHIP_RESET_Type*)  (VREG_AND_CHIP_RESET_BASE+0x1000))
#define TBMAN_XOR                   ((TBMAN_Type*)             (TBMAN_BASE+0x1000))
#define DMA_XOR                     ((DMA_Type*)               (DMA_BASE+0x1000))
#define USBCTRL_DPRAM_XOR           ((USBCTRL_DPRAM_Type*)     (USBCTRL_DPRAM_BASE+0x1000))
#define USBCTRL_REGS_XOR            ((USBCTRL_REGS_Type*)      (USBCTRL_REGS_BASE+0x1000))
#define PIO0_XOR                    ((PIO0_Type*)              (PIO0_BASE+0x1000))
#define PIO1_XOR                    ((PIO0_Type*)              (PIO1_BASE+0x1000))
#define SIO_XOR                     ((SIO_Type*)               (SIO_BASE+0x1000))
#define PPB_XOR                     ((PPB_Type*)               (PPB_BASE+0x1000))

#define XIP_CTRL_SET                ((XIP_CTRL_Type*)          (XIP_CTRL_BASE+0x2000))
#define XIP_SSI_SET                 ((XIP_SSI_Type*)           (XIP_SSI_BASE+0x2000))
#define SYSINFO_SET                 ((SYSINFO_Type*)           (SYSINFO_BASE+0x2000))
#define SYSCFG_SET                  ((SYSCFG_Type*)            (SYSCFG_BASE+0x2000))
#define CLOCKS_SET                  ((CLOCKS_Type*)            (CLOCKS_BASE+0x2000))
#define RESETS_SET                  ((RESETS_Type*)            (RESETS_BASE+0x2000))
#define PSM_SET                     ((PSM_Type*)               (PSM_BASE+0x2000))
#define IO_BANK0_SET                ((IO_BANK0_Type*)          (IO_BANK0_BASE+0x2000))
#define IO_QSPI_SET                 ((IO_QSPI_Type*)           (IO_QSPI_BASE+0x2000))
#define PADS_BANK0_SET              ((PADS_BANK0_Type*)        (PADS_BANK0_BASE+0x2000))
#define PADS_QSPI_SET               ((PADS_QSPI_Type*)         (PADS_QSPI_BASE+0x2000))
#define XOSC_SET                    ((XOSC_Type*)              (XOSC_BASE+0x2000))
#define PLL_SYS_SET                 ((PLL_SYS_Type*)           (PLL_SYS_BASE+0x2000))
#define PLL_USB_SET                 ((PLL_SYS_Type*)           (PLL_USB_BASE+0x2000))
#define BUSCTRL_SET                 ((BUSCTRL_Type*)           (BUSCTRL_BASE+0x2000))
#define UART0_SET                   ((UART0_Type*)             (UART0_BASE+0x2000))
#define UART1_SET                   ((UART0_Type*)             (UART1_BASE+0x2000))
#define SPI0_SET                    ((SPI0_Type*)              (SPI0_BASE+0x2000))
#define SPI1_SET                    ((SPI0_Type*)              (SPI1_BASE+0x2000))
#define I2C0_SET                    ((I2C0_Type*)              (I2C0_BASE+0x2000))
#define I2C1_SET                    ((I2C0_Type*)              (I2C1_BASE+0x2000))
#define ADC_SET                     ((ADC_Type*)               (ADC_BASE+0x2000))
#define PWM_SET                     ((PWM_Type*)               (PWM_BASE+0x2000))
#define TIMER_SET                   ((TIMER_Type*)             (TIMER_BASE+0x2000))
#define WATCHDOG_SET                ((WATCHDOG_Type*)          (WATCHDOG_BASE+0x2000))
#define RTC_SET                     ((RTC_Type*)               (RTC_BASE+0x2000))
#define ROSC_SET                    ((ROSC_Type*)              (ROSC_BASE+0x2000))
#define VREG_AND_CHIP_RESET_SET     ((VREG_AND_CHIP_RESET_Type*)  (VREG_AND_CHIP_RESET_BASE+0x2000))
#define TBMAN_SET                   ((TBMAN_Type*)             (TBMAN_BASE+0x2000))
#define DMA_SET                     ((DMA_Type*)               (DMA_BASE+0x2000))
#define USBCTRL_DPRAM_SET           ((USBCTRL_DPRAM_Type*)     (USBCTRL_DPRAM_BASE+0x2000))
#define USBCTRL_REGS_SET            ((USBCTRL_REGS_Type*)      (USBCTRL_REGS_BASE+0x2000))
#define PIO0_SET                    ((PIO0_Type*)              (PIO0_BASE+0x2000))
#define PIO1_SET                    ((PIO0_Type*)              (PIO1_BASE+0x2000))
#define SIO_SET                     ((SIO_Type*)               (SIO_BASE+0x2000))
#define PPB_SET                     ((PPB_Type*)               (PPB_BASE+0x2000))

#define XIP_CTRL_CLR                ((XIP_CTRL_Type*)          (XIP_CTRL_BASE+0x3000))
#define XIP_SSI_CLR                 ((XIP_SSI_Type*)           (XIP_SSI_BASE+0x3000))
#define SYSINFO_CLR                 ((SYSINFO_Type*)           (SYSINFO_BASE+0x3000))
#define SYSCFG_CLR                  ((SYSCFG_Type*)            (SYSCFG_BASE+0x3000))
#define CLOCKS_CLR                  ((CLOCKS_Type*)            (CLOCKS_BASE+0x3000))
#define RESETS_CLR                  ((RESETS_Type*)            (RESETS_BASE+0x3000))
#define PSM_CLR                     ((PSM_Type*)               (PSM_BASE+0x3000))
#define IO_BANK0_CLR                ((IO_BANK0_Type*)          (IO_BANK0_BASE+0x3000))
#define IO_QSPI_CLR                 ((IO_QSPI_Type*)           (IO_QSPI_BASE+0x3000))
#define PADS_BANK0_CLR              ((PADS_BANK0_Type*)        (PADS_BANK0_BASE+0x3000))
#define PADS_QSPI_CLR               ((PADS_QSPI_Type*)         (PADS_QSPI_BASE+0x3000))
#define XOSC_CLR                    ((XOSC_Type*)              (XOSC_BASE+0x3000))
#define PLL_SYS_CLR                 ((PLL_SYS_Type*)           (PLL_SYS_BASE+0x3000))
#define PLL_USB_CLR                 ((PLL_SYS_Type*)           (PLL_USB_BASE+0x3000))
#define BUSCTRL_CLR                 ((BUSCTRL_Type*)           (BUSCTRL_BASE+0x3000))
#define UART0_CLR                   ((UART0_Type*)             (UART0_BASE+0x3000))
#define UART1_CLR                   ((UART0_Type*)             (UART1_BASE+0x3000))
#define SPI0_CLR                    ((SPI0_Type*)              (SPI0_BASE+0x3000))
#define SPI1_CLR                    ((SPI0_Type*)              (SPI1_BASE+0x3000))
#define I2C0_CLR                    ((I2C0_Type*)              (I2C0_BASE+0x3000))
#define I2C1_CLR                    ((I2C0_Type*)              (I2C1_BASE+0x3000))
#define ADC_CLR                     ((ADC_Type*)               (ADC_BASE+0x3000))
#define PWM_CLR                     ((PWM_Type*)               (PWM_BASE+0x3000))
#define TIMER_CLR                   ((TIMER_Type*)             (TIMER_BASE+0x3000))
#define WATCHDOG_CLR                ((WATCHDOG_Type*)          (WATCHDOG_BASE+0x3000))
#define RTC_CLR                     ((RTC_Type*)               (RTC_BASE+0x3000))
#define ROSC_CLR                    ((ROSC_Type*)              (ROSC_BASE+0x3000))
#define VREG_AND_CHIP_RESET_CLR     ((VREG_AND_CHIP_RESET_Type*)  (VREG_AND_CHIP_RESET_BASE+0x3000))
#define TBMAN_CLR                   ((TBMAN_Type*)             (TBMAN_BASE+0x3000))
#define DMA_CLR                     ((DMA_Type*)               (DMA_BASE+0x3000))
#define USBCTRL_DPRAM_CLR           ((USBCTRL_DPRAM_Type*)     (USBCTRL_DPRAM_BASE+0x3000))
#define USBCTRL_REGS_CLR            ((USBCTRL_REGS_Type*)      (USBCTRL_REGS_BASE+0x3000))
#define PIO0_CLR                    ((PIO0_Type*)              (PIO0_BASE+0x3000))
#define PIO1_CLR                    ((PIO0_Type*)              (PIO1_BASE+0x3000))
#define SIO_CLR                     ((SIO_Type*)               (SIO_BASE+0x3000))
#define PPB_CLR                     ((PPB_Type*)               (PPB_BASE+0x3000))

/** @} */ /* End of group Device_Peripheral_declaration */


/* =========================================  End of section using anonymous unions  ========================================= */
#if defined (__CC_ARM)
  #pragma pop
#elif defined (__ICCARM__)
  /* leave anonymous unions enabled */
#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  #pragma clang diagnostic pop
#elif defined (__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined (__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined (__TASKING__)
  #pragma warning restore
#elif defined (__CSMC__)
  /* anonymous unions are enabled by default */
#endif


/* =========================================================================================================================== */
/* ================                                Pos/Mask Peripheral Section                                ================ */
/* =========================================================================================================================== */


/** @addtogroup PosMask_peripherals
  * @{
  */



/* =========================================================================================================================== */
/* ================                                         XIP_CTRL                                          ================ */
/* =========================================================================================================================== */

/* =========================================================  CTRL  ========================================================== */
#define XIP_CTRL_CTRL_POWER_DOWN_Pos      (3UL)                     /*!< POWER_DOWN (Bit 3) */
#define XIP_CTRL_CTRL_POWER_DOWN_Msk      (0x8UL)                   /*!< POWER_DOWN (Bitfield-Mask: 0x01) */
#define XIP_CTRL_CTRL_ERR_BADWRITE_Pos    (1UL)                     /*!< ERR_BADWRITE (Bit 1) */
#define XIP_CTRL_CTRL_ERR_BADWRITE_Msk    (0x2UL)                   /*!< ERR_BADWRITE (Bitfield-Mask: 0x01) */
#define XIP_CTRL_CTRL_EN_Pos              (0UL)                     /*!< EN (Bit 0) */
#define XIP_CTRL_CTRL_EN_Msk              (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01) */
/* =========================================================  FLUSH  ========================================================= */
#define XIP_CTRL_FLUSH_FLUSH_Pos          (0UL)                     /*!< FLUSH (Bit 0) */
#define XIP_CTRL_FLUSH_FLUSH_Msk          (0x1UL)                   /*!< FLUSH (Bitfield-Mask: 0x01) */
/* =========================================================  STAT  ========================================================== */
#define XIP_CTRL_STAT_FIFO_FULL_Pos       (2UL)                     /*!< FIFO_FULL (Bit 2) */
#define XIP_CTRL_STAT_FIFO_FULL_Msk       (0x4UL)                   /*!< FIFO_FULL (Bitfield-Mask: 0x01) */
#define XIP_CTRL_STAT_FIFO_EMPTY_Pos      (1UL)                     /*!< FIFO_EMPTY (Bit 1) */
#define XIP_CTRL_STAT_FIFO_EMPTY_Msk      (0x2UL)                   /*!< FIFO_EMPTY (Bitfield-Mask: 0x01) */
#define XIP_CTRL_STAT_FLUSH_READY_Pos     (0UL)                     /*!< FLUSH_READY (Bit 0) */
#define XIP_CTRL_STAT_FLUSH_READY_Msk     (0x1UL)                   /*!< FLUSH_READY (Bitfield-Mask: 0x01) */
/* ========================================================  CTR_HIT  ======================================================== */
/* ========================================================  CTR_ACC  ======================================================== */
/* ======================================================  STREAM_ADDR  ====================================================== */
#define XIP_CTRL_STREAM_ADDR_STREAM_ADDR_Pos (2UL)                  /*!< STREAM_ADDR (Bit 2) */
#define XIP_CTRL_STREAM_ADDR_STREAM_ADDR_Msk (0xfffffffcUL)         /*!< STREAM_ADDR (Bitfield-Mask: 0x3fffffff) */
/* ======================================================  STREAM_CTR  ======================================================= */
#define XIP_CTRL_STREAM_CTR_STREAM_CTR_Pos (0UL)                    /*!< STREAM_CTR (Bit 0) */
#define XIP_CTRL_STREAM_CTR_STREAM_CTR_Msk (0x3fffffUL)             /*!< STREAM_CTR (Bitfield-Mask: 0x3fffff) */
/* ======================================================  STREAM_FIFO  ====================================================== */


/* =========================================================================================================================== */
/* ================                                          XIP_SSI                                          ================ */
/* =========================================================================================================================== */

/* ========================================================  CTRLR0  ========================================================= */
#define XIP_SSI_CTRLR0_SSTE_Pos           (24UL)                    /*!< SSTE (Bit 24) */
#define XIP_SSI_CTRLR0_SSTE_Msk           (0x1000000UL)             /*!< SSTE (Bitfield-Mask: 0x01) */
#define XIP_SSI_CTRLR0_SPI_FRF_Pos        (21UL)                    /*!< SPI_FRF (Bit 21) */
#define XIP_SSI_CTRLR0_SPI_FRF_Msk        (0x600000UL)              /*!< SPI_FRF (Bitfield-Mask: 0x03) */
#define XIP_SSI_CTRLR0_DFS_32_Pos         (16UL)                    /*!< DFS_32 (Bit 16) */
#define XIP_SSI_CTRLR0_DFS_32_Msk         (0x1f0000UL)              /*!< DFS_32 (Bitfield-Mask: 0x1f) */
#define XIP_SSI_CTRLR0_CFS_Pos            (12UL)                    /*!< CFS (Bit 12) */
#define XIP_SSI_CTRLR0_CFS_Msk            (0xf000UL)                /*!< CFS (Bitfield-Mask: 0x0f) */
#define XIP_SSI_CTRLR0_SRL_Pos            (11UL)                    /*!< SRL (Bit 11) */
#define XIP_SSI_CTRLR0_SRL_Msk            (0x800UL)                 /*!< SRL (Bitfield-Mask: 0x01) */
#define XIP_SSI_CTRLR0_SLV_OE_Pos         (10UL)                    /*!< SLV_OE (Bit 10) */
#define XIP_SSI_CTRLR0_SLV_OE_Msk         (0x400UL)                 /*!< SLV_OE (Bitfield-Mask: 0x01) */
#define XIP_SSI_CTRLR0_TMOD_Pos           (8UL)                     /*!< TMOD (Bit 8) */
#define XIP_SSI_CTRLR0_TMOD_Msk           (0x300UL)                 /*!< TMOD (Bitfield-Mask: 0x03) */
#define XIP_SSI_CTRLR0_SCPOL_Pos          (7UL)                     /*!< SCPOL (Bit 7) */
#define XIP_SSI_CTRLR0_SCPOL_Msk          (0x80UL)                  /*!< SCPOL (Bitfield-Mask: 0x01) */
#define XIP_SSI_CTRLR0_SCPH_Pos           (6UL)                     /*!< SCPH (Bit 6) */
#define XIP_SSI_CTRLR0_SCPH_Msk           (0x40UL)                  /*!< SCPH (Bitfield-Mask: 0x01) */
#define XIP_SSI_CTRLR0_FRF_Pos            (4UL)                     /*!< FRF (Bit 4) */
#define XIP_SSI_CTRLR0_FRF_Msk            (0x30UL)                  /*!< FRF (Bitfield-Mask: 0x03) */
#define XIP_SSI_CTRLR0_DFS_Pos            (0UL)                     /*!< DFS (Bit 0) */
#define XIP_SSI_CTRLR0_DFS_Msk            (0xfUL)                   /*!< DFS (Bitfield-Mask: 0x0f) */
/* ========================================================  CTRLR1  ========================================================= */
#define XIP_SSI_CTRLR1_NDF_Pos            (0UL)                     /*!< NDF (Bit 0) */
#define XIP_SSI_CTRLR1_NDF_Msk            (0xffffUL)                /*!< NDF (Bitfield-Mask: 0xffff) */
/* ========================================================  SSIENR  ========================================================= */
#define XIP_SSI_SSIENR_SSI_EN_Pos         (0UL)                     /*!< SSI_EN (Bit 0) */
#define XIP_SSI_SSIENR_SSI_EN_Msk         (0x1UL)                   /*!< SSI_EN (Bitfield-Mask: 0x01) */
/* =========================================================  MWCR  ========================================================== */
#define XIP_SSI_MWCR_MHS_Pos              (2UL)                     /*!< MHS (Bit 2) */
#define XIP_SSI_MWCR_MHS_Msk              (0x4UL)                   /*!< MHS (Bitfield-Mask: 0x01) */
#define XIP_SSI_MWCR_MDD_Pos              (1UL)                     /*!< MDD (Bit 1) */
#define XIP_SSI_MWCR_MDD_Msk              (0x2UL)                   /*!< MDD (Bitfield-Mask: 0x01) */
#define XIP_SSI_MWCR_MWMOD_Pos            (0UL)                     /*!< MWMOD (Bit 0) */
#define XIP_SSI_MWCR_MWMOD_Msk            (0x1UL)                   /*!< MWMOD (Bitfield-Mask: 0x01) */
/* ==========================================================  SER  ========================================================== */
#define XIP_SSI_SER_SER_Pos               (0UL)                     /*!< SER (Bit 0) */
#define XIP_SSI_SER_SER_Msk               (0x1UL)                   /*!< SER (Bitfield-Mask: 0x01) */
/* =========================================================  BAUDR  ========================================================= */
#define XIP_SSI_BAUDR_SCKDV_Pos           (0UL)                     /*!< SCKDV (Bit 0) */
#define XIP_SSI_BAUDR_SCKDV_Msk           (0xffffUL)                /*!< SCKDV (Bitfield-Mask: 0xffff) */
/* ========================================================  TXFTLR  ========================================================= */
#define XIP_SSI_TXFTLR_TFT_Pos            (0UL)                     /*!< TFT (Bit 0) */
#define XIP_SSI_TXFTLR_TFT_Msk            (0xffUL)                  /*!< TFT (Bitfield-Mask: 0xff) */
/* ========================================================  RXFTLR  ========================================================= */
#define XIP_SSI_RXFTLR_RFT_Pos            (0UL)                     /*!< RFT (Bit 0) */
#define XIP_SSI_RXFTLR_RFT_Msk            (0xffUL)                  /*!< RFT (Bitfield-Mask: 0xff) */
/* =========================================================  TXFLR  ========================================================= */
#define XIP_SSI_TXFLR_TFTFL_Pos           (0UL)                     /*!< TFTFL (Bit 0) */
#define XIP_SSI_TXFLR_TFTFL_Msk           (0xffUL)                  /*!< TFTFL (Bitfield-Mask: 0xff) */
/* =========================================================  RXFLR  ========================================================= */
#define XIP_SSI_RXFLR_RXTFL_Pos           (0UL)                     /*!< RXTFL (Bit 0) */
#define XIP_SSI_RXFLR_RXTFL_Msk           (0xffUL)                  /*!< RXTFL (Bitfield-Mask: 0xff) */
/* ==========================================================  SR  =========================================================== */
#define XIP_SSI_SR_DCOL_Pos               (6UL)                     /*!< DCOL (Bit 6) */
#define XIP_SSI_SR_DCOL_Msk               (0x40UL)                  /*!< DCOL (Bitfield-Mask: 0x01) */
#define XIP_SSI_SR_TXE_Pos                (5UL)                     /*!< TXE (Bit 5) */
#define XIP_SSI_SR_TXE_Msk                (0x20UL)                  /*!< TXE (Bitfield-Mask: 0x01) */
#define XIP_SSI_SR_RFF_Pos                (4UL)                     /*!< RFF (Bit 4) */
#define XIP_SSI_SR_RFF_Msk                (0x10UL)                  /*!< RFF (Bitfield-Mask: 0x01) */
#define XIP_SSI_SR_RFNE_Pos               (3UL)                     /*!< RFNE (Bit 3) */
#define XIP_SSI_SR_RFNE_Msk               (0x8UL)                   /*!< RFNE (Bitfield-Mask: 0x01) */
#define XIP_SSI_SR_TFE_Pos                (2UL)                     /*!< TFE (Bit 2) */
#define XIP_SSI_SR_TFE_Msk                (0x4UL)                   /*!< TFE (Bitfield-Mask: 0x01) */
#define XIP_SSI_SR_TFNF_Pos               (1UL)                     /*!< TFNF (Bit 1) */
#define XIP_SSI_SR_TFNF_Msk               (0x2UL)                   /*!< TFNF (Bitfield-Mask: 0x01) */
#define XIP_SSI_SR_BUSY_Pos               (0UL)                     /*!< BUSY (Bit 0) */
#define XIP_SSI_SR_BUSY_Msk               (0x1UL)                   /*!< BUSY (Bitfield-Mask: 0x01) */
/* ==========================================================  IMR  ========================================================== */
#define XIP_SSI_IMR_MSTIM_Pos             (5UL)                     /*!< MSTIM (Bit 5) */
#define XIP_SSI_IMR_MSTIM_Msk             (0x20UL)                  /*!< MSTIM (Bitfield-Mask: 0x01) */
#define XIP_SSI_IMR_RXFIM_Pos             (4UL)                     /*!< RXFIM (Bit 4) */
#define XIP_SSI_IMR_RXFIM_Msk             (0x10UL)                  /*!< RXFIM (Bitfield-Mask: 0x01) */
#define XIP_SSI_IMR_RXOIM_Pos             (3UL)                     /*!< RXOIM (Bit 3) */
#define XIP_SSI_IMR_RXOIM_Msk             (0x8UL)                   /*!< RXOIM (Bitfield-Mask: 0x01) */
#define XIP_SSI_IMR_RXUIM_Pos             (2UL)                     /*!< RXUIM (Bit 2) */
#define XIP_SSI_IMR_RXUIM_Msk             (0x4UL)                   /*!< RXUIM (Bitfield-Mask: 0x01) */
#define XIP_SSI_IMR_TXOIM_Pos             (1UL)                     /*!< TXOIM (Bit 1) */
#define XIP_SSI_IMR_TXOIM_Msk             (0x2UL)                   /*!< TXOIM (Bitfield-Mask: 0x01) */
#define XIP_SSI_IMR_TXEIM_Pos             (0UL)                     /*!< TXEIM (Bit 0) */
#define XIP_SSI_IMR_TXEIM_Msk             (0x1UL)                   /*!< TXEIM (Bitfield-Mask: 0x01) */
/* ==========================================================  ISR  ========================================================== */
#define XIP_SSI_ISR_MSTIS_Pos             (5UL)                     /*!< MSTIS (Bit 5) */
#define XIP_SSI_ISR_MSTIS_Msk             (0x20UL)                  /*!< MSTIS (Bitfield-Mask: 0x01) */
#define XIP_SSI_ISR_RXFIS_Pos             (4UL)                     /*!< RXFIS (Bit 4) */
#define XIP_SSI_ISR_RXFIS_Msk             (0x10UL)                  /*!< RXFIS (Bitfield-Mask: 0x01) */
#define XIP_SSI_ISR_RXOIS_Pos             (3UL)                     /*!< RXOIS (Bit 3) */
#define XIP_SSI_ISR_RXOIS_Msk             (0x8UL)                   /*!< RXOIS (Bitfield-Mask: 0x01) */
#define XIP_SSI_ISR_RXUIS_Pos             (2UL)                     /*!< RXUIS (Bit 2) */
#define XIP_SSI_ISR_RXUIS_Msk             (0x4UL)                   /*!< RXUIS (Bitfield-Mask: 0x01) */
#define XIP_SSI_ISR_TXOIS_Pos             (1UL)                     /*!< TXOIS (Bit 1) */
#define XIP_SSI_ISR_TXOIS_Msk             (0x2UL)                   /*!< TXOIS (Bitfield-Mask: 0x01) */
#define XIP_SSI_ISR_TXEIS_Pos             (0UL)                     /*!< TXEIS (Bit 0) */
#define XIP_SSI_ISR_TXEIS_Msk             (0x1UL)                   /*!< TXEIS (Bitfield-Mask: 0x01) */
/* =========================================================  RISR  ========================================================== */
#define XIP_SSI_RISR_MSTIR_Pos            (5UL)                     /*!< MSTIR (Bit 5) */
#define XIP_SSI_RISR_MSTIR_Msk            (0x20UL)                  /*!< MSTIR (Bitfield-Mask: 0x01) */
#define XIP_SSI_RISR_RXFIR_Pos            (4UL)                     /*!< RXFIR (Bit 4) */
#define XIP_SSI_RISR_RXFIR_Msk            (0x10UL)                  /*!< RXFIR (Bitfield-Mask: 0x01) */
#define XIP_SSI_RISR_RXOIR_Pos            (3UL)                     /*!< RXOIR (Bit 3) */
#define XIP_SSI_RISR_RXOIR_Msk            (0x8UL)                   /*!< RXOIR (Bitfield-Mask: 0x01) */
#define XIP_SSI_RISR_RXUIR_Pos            (2UL)                     /*!< RXUIR (Bit 2) */
#define XIP_SSI_RISR_RXUIR_Msk            (0x4UL)                   /*!< RXUIR (Bitfield-Mask: 0x01) */
#define XIP_SSI_RISR_TXOIR_Pos            (1UL)                     /*!< TXOIR (Bit 1) */
#define XIP_SSI_RISR_TXOIR_Msk            (0x2UL)                   /*!< TXOIR (Bitfield-Mask: 0x01) */
#define XIP_SSI_RISR_TXEIR_Pos            (0UL)                     /*!< TXEIR (Bit 0) */
#define XIP_SSI_RISR_TXEIR_Msk            (0x1UL)                   /*!< TXEIR (Bitfield-Mask: 0x01) */
/* ========================================================  TXOICR  ========================================================= */
#define XIP_SSI_TXOICR_TXOICR_Pos         (0UL)                     /*!< TXOICR (Bit 0) */
#define XIP_SSI_TXOICR_TXOICR_Msk         (0x1UL)                   /*!< TXOICR (Bitfield-Mask: 0x01) */
/* ========================================================  RXOICR  ========================================================= */
#define XIP_SSI_RXOICR_RXOICR_Pos         (0UL)                     /*!< RXOICR (Bit 0) */
#define XIP_SSI_RXOICR_RXOICR_Msk         (0x1UL)                   /*!< RXOICR (Bitfield-Mask: 0x01) */
/* ========================================================  RXUICR  ========================================================= */
#define XIP_SSI_RXUICR_RXUICR_Pos         (0UL)                     /*!< RXUICR (Bit 0) */
#define XIP_SSI_RXUICR_RXUICR_Msk         (0x1UL)                   /*!< RXUICR (Bitfield-Mask: 0x01) */
/* ========================================================  MSTICR  ========================================================= */
#define XIP_SSI_MSTICR_MSTICR_Pos         (0UL)                     /*!< MSTICR (Bit 0) */
#define XIP_SSI_MSTICR_MSTICR_Msk         (0x1UL)                   /*!< MSTICR (Bitfield-Mask: 0x01) */
/* ==========================================================  ICR  ========================================================== */
#define XIP_SSI_ICR_ICR_Pos               (0UL)                     /*!< ICR (Bit 0) */
#define XIP_SSI_ICR_ICR_Msk               (0x1UL)                   /*!< ICR (Bitfield-Mask: 0x01) */
/* =========================================================  DMACR  ========================================================= */
#define XIP_SSI_DMACR_TDMAE_Pos           (1UL)                     /*!< TDMAE (Bit 1) */
#define XIP_SSI_DMACR_TDMAE_Msk           (0x2UL)                   /*!< TDMAE (Bitfield-Mask: 0x01) */
#define XIP_SSI_DMACR_RDMAE_Pos           (0UL)                     /*!< RDMAE (Bit 0) */
#define XIP_SSI_DMACR_RDMAE_Msk           (0x1UL)                   /*!< RDMAE (Bitfield-Mask: 0x01) */
/* ========================================================  DMATDLR  ======================================================== */
#define XIP_SSI_DMATDLR_DMATDL_Pos        (0UL)                     /*!< DMATDL (Bit 0) */
#define XIP_SSI_DMATDLR_DMATDL_Msk        (0xffUL)                  /*!< DMATDL (Bitfield-Mask: 0xff) */
/* ========================================================  DMARDLR  ======================================================== */
#define XIP_SSI_DMARDLR_DMARDL_Pos        (0UL)                     /*!< DMARDL (Bit 0) */
#define XIP_SSI_DMARDLR_DMARDL_Msk        (0xffUL)                  /*!< DMARDL (Bitfield-Mask: 0xff) */
/* ==========================================================  IDR  ========================================================== */
#define XIP_SSI_IDR_IDCODE_Pos            (0UL)                     /*!< IDCODE (Bit 0) */
#define XIP_SSI_IDR_IDCODE_Msk            (0xffffffffUL)            /*!< IDCODE (Bitfield-Mask: 0xffffffff) */
/* ====================================================  SSI_VERSION_ID  ===================================================== */
#define XIP_SSI_SSI_VERSION_ID_SSI_COMP_VERSION_Pos (0UL)           /*!< SSI_COMP_VERSION (Bit 0) */
#define XIP_SSI_SSI_VERSION_ID_SSI_COMP_VERSION_Msk (0xffffffffUL)  /*!< SSI_COMP_VERSION (Bitfield-Mask: 0xffffffff) */
/* ==========================================================  DR0  ========================================================== */
#define XIP_SSI_DR0_DR_Pos                (0UL)                     /*!< DR (Bit 0) */
#define XIP_SSI_DR0_DR_Msk                (0xffffffffUL)            /*!< DR (Bitfield-Mask: 0xffffffff) */
/* =====================================================  RX_SAMPLE_DLY  ===================================================== */
#define XIP_SSI_RX_SAMPLE_DLY_RSD_Pos     (0UL)                     /*!< RSD (Bit 0) */
#define XIP_SSI_RX_SAMPLE_DLY_RSD_Msk     (0xffUL)                  /*!< RSD (Bitfield-Mask: 0xff) */
/* ======================================================  SPI_CTRLR0  ======================================================= */
#define XIP_SSI_SPI_CTRLR0_XIP_CMD_Pos    (24UL)                    /*!< XIP_CMD (Bit 24) */
#define XIP_SSI_SPI_CTRLR0_XIP_CMD_Msk    (0xff000000UL)            /*!< XIP_CMD (Bitfield-Mask: 0xff) */
#define XIP_SSI_SPI_CTRLR0_SPI_RXDS_EN_Pos (18UL)                   /*!< SPI_RXDS_EN (Bit 18) */
#define XIP_SSI_SPI_CTRLR0_SPI_RXDS_EN_Msk (0x40000UL)              /*!< SPI_RXDS_EN (Bitfield-Mask: 0x01) */
#define XIP_SSI_SPI_CTRLR0_INST_DDR_EN_Pos (17UL)                   /*!< INST_DDR_EN (Bit 17) */
#define XIP_SSI_SPI_CTRLR0_INST_DDR_EN_Msk (0x20000UL)              /*!< INST_DDR_EN (Bitfield-Mask: 0x01) */
#define XIP_SSI_SPI_CTRLR0_SPI_DDR_EN_Pos (16UL)                    /*!< SPI_DDR_EN (Bit 16) */
#define XIP_SSI_SPI_CTRLR0_SPI_DDR_EN_Msk (0x10000UL)               /*!< SPI_DDR_EN (Bitfield-Mask: 0x01) */
#define XIP_SSI_SPI_CTRLR0_WAIT_CYCLES_Pos (11UL)                   /*!< WAIT_CYCLES (Bit 11) */
#define XIP_SSI_SPI_CTRLR0_WAIT_CYCLES_Msk (0xf800UL)               /*!< WAIT_CYCLES (Bitfield-Mask: 0x1f) */
#define XIP_SSI_SPI_CTRLR0_INST_L_Pos     (8UL)                     /*!< INST_L (Bit 8) */
#define XIP_SSI_SPI_CTRLR0_INST_L_Msk     (0x300UL)                 /*!< INST_L (Bitfield-Mask: 0x03) */
#define XIP_SSI_SPI_CTRLR0_ADDR_L_Pos     (2UL)                     /*!< ADDR_L (Bit 2) */
#define XIP_SSI_SPI_CTRLR0_ADDR_L_Msk     (0x3cUL)                  /*!< ADDR_L (Bitfield-Mask: 0x0f) */
#define XIP_SSI_SPI_CTRLR0_TRANS_TYPE_Pos (0UL)                     /*!< TRANS_TYPE (Bit 0) */
#define XIP_SSI_SPI_CTRLR0_TRANS_TYPE_Msk (0x3UL)                   /*!< TRANS_TYPE (Bitfield-Mask: 0x03) */
/* ====================================================  TXD_DRIVE_EDGE  ===================================================== */
#define XIP_SSI_TXD_DRIVE_EDGE_TDE_Pos    (0UL)                     /*!< TDE (Bit 0) */
#define XIP_SSI_TXD_DRIVE_EDGE_TDE_Msk    (0xffUL)                  /*!< TDE (Bitfield-Mask: 0xff) */


/* =========================================================================================================================== */
/* ================                                          SYSINFO                                          ================ */
/* =========================================================================================================================== */

/* ========================================================  CHIP_ID  ======================================================== */
#define SYSINFO_CHIP_ID_REVISION_Pos      (28UL)                    /*!< REVISION (Bit 28) */
#define SYSINFO_CHIP_ID_REVISION_Msk      (0xf0000000UL)            /*!< REVISION (Bitfield-Mask: 0x0f) */
#define SYSINFO_CHIP_ID_PART_Pos          (12UL)                    /*!< PART (Bit 12) */
#define SYSINFO_CHIP_ID_PART_Msk          (0xffff000UL)             /*!< PART (Bitfield-Mask: 0xffff) */
#define SYSINFO_CHIP_ID_MANUFACTURER_Pos  (0UL)                     /*!< MANUFACTURER (Bit 0) */
#define SYSINFO_CHIP_ID_MANUFACTURER_Msk  (0xfffUL)                 /*!< MANUFACTURER (Bitfield-Mask: 0xfff) */
/* =======================================================  PLATFORM  ======================================================== */
#define SYSINFO_PLATFORM_ASIC_Pos         (1UL)                     /*!< ASIC (Bit 1) */
#define SYSINFO_PLATFORM_ASIC_Msk         (0x2UL)                   /*!< ASIC (Bitfield-Mask: 0x01) */
#define SYSINFO_PLATFORM_FPGA_Pos         (0UL)                     /*!< FPGA (Bit 0) */
#define SYSINFO_PLATFORM_FPGA_Msk         (0x1UL)                   /*!< FPGA (Bitfield-Mask: 0x01) */
/* =====================================================  GITREF_RP2040  ===================================================== */


/* =========================================================================================================================== */
/* ================                                          SYSCFG                                           ================ */
/* =========================================================================================================================== */

/* ====================================================  PROC0_NMI_MASK  ===================================================== */
/* ====================================================  PROC1_NMI_MASK  ===================================================== */
/* ======================================================  PROC_CONFIG  ====================================================== */
#define SYSCFG_PROC_CONFIG_PROC1_DAP_INSTID_Pos (28UL)              /*!< PROC1_DAP_INSTID (Bit 28) */
#define SYSCFG_PROC_CONFIG_PROC1_DAP_INSTID_Msk (0xf0000000UL)      /*!< PROC1_DAP_INSTID (Bitfield-Mask: 0x0f) */
#define SYSCFG_PROC_CONFIG_PROC0_DAP_INSTID_Pos (24UL)              /*!< PROC0_DAP_INSTID (Bit 24) */
#define SYSCFG_PROC_CONFIG_PROC0_DAP_INSTID_Msk (0xf000000UL)       /*!< PROC0_DAP_INSTID (Bitfield-Mask: 0x0f) */
#define SYSCFG_PROC_CONFIG_PROC1_HALTED_Pos (1UL)                   /*!< PROC1_HALTED (Bit 1) */
#define SYSCFG_PROC_CONFIG_PROC1_HALTED_Msk (0x2UL)                 /*!< PROC1_HALTED (Bitfield-Mask: 0x01) */
#define SYSCFG_PROC_CONFIG_PROC0_HALTED_Pos (0UL)                   /*!< PROC0_HALTED (Bit 0) */
#define SYSCFG_PROC_CONFIG_PROC0_HALTED_Msk (0x1UL)                 /*!< PROC0_HALTED (Bitfield-Mask: 0x01) */
/* ==================================================  PROC_IN_SYNC_BYPASS  ================================================== */
#define SYSCFG_PROC_IN_SYNC_BYPASS_PROC_IN_SYNC_BYPASS_Pos (0UL)    /*!< PROC_IN_SYNC_BYPASS (Bit 0) */
#define SYSCFG_PROC_IN_SYNC_BYPASS_PROC_IN_SYNC_BYPASS_Msk (0x3fffffffUL) /*!< PROC_IN_SYNC_BYPASS (Bitfield-Mask: 0x3fffffff) */
/* ================================================  PROC_IN_SYNC_BYPASS_HI  ================================================= */
#define SYSCFG_PROC_IN_SYNC_BYPASS_HI_PROC_IN_SYNC_BYPASS_HI_Pos (0UL) /*!< PROC_IN_SYNC_BYPASS_HI (Bit 0) */
#define SYSCFG_PROC_IN_SYNC_BYPASS_HI_PROC_IN_SYNC_BYPASS_HI_Msk (0x3fUL) /*!< PROC_IN_SYNC_BYPASS_HI (Bitfield-Mask: 0x3f) */
/* =======================================================  DBGFORCE  ======================================================== */
#define SYSCFG_DBGFORCE_PROC1_ATTACH_Pos  (7UL)                     /*!< PROC1_ATTACH (Bit 7) */
#define SYSCFG_DBGFORCE_PROC1_ATTACH_Msk  (0x80UL)                  /*!< PROC1_ATTACH (Bitfield-Mask: 0x01) */
#define SYSCFG_DBGFORCE_PROC1_SWCLK_Pos   (6UL)                     /*!< PROC1_SWCLK (Bit 6) */
#define SYSCFG_DBGFORCE_PROC1_SWCLK_Msk   (0x40UL)                  /*!< PROC1_SWCLK (Bitfield-Mask: 0x01) */
#define SYSCFG_DBGFORCE_PROC1_SWDI_Pos    (5UL)                     /*!< PROC1_SWDI (Bit 5) */
#define SYSCFG_DBGFORCE_PROC1_SWDI_Msk    (0x20UL)                  /*!< PROC1_SWDI (Bitfield-Mask: 0x01) */
#define SYSCFG_DBGFORCE_PROC1_SWDO_Pos    (4UL)                     /*!< PROC1_SWDO (Bit 4) */
#define SYSCFG_DBGFORCE_PROC1_SWDO_Msk    (0x10UL)                  /*!< PROC1_SWDO (Bitfield-Mask: 0x01) */
#define SYSCFG_DBGFORCE_PROC0_ATTACH_Pos  (3UL)                     /*!< PROC0_ATTACH (Bit 3) */
#define SYSCFG_DBGFORCE_PROC0_ATTACH_Msk  (0x8UL)                   /*!< PROC0_ATTACH (Bitfield-Mask: 0x01) */
#define SYSCFG_DBGFORCE_PROC0_SWCLK_Pos   (2UL)                     /*!< PROC0_SWCLK (Bit 2) */
#define SYSCFG_DBGFORCE_PROC0_SWCLK_Msk   (0x4UL)                   /*!< PROC0_SWCLK (Bitfield-Mask: 0x01) */
#define SYSCFG_DBGFORCE_PROC0_SWDI_Pos    (1UL)                     /*!< PROC0_SWDI (Bit 1) */
#define SYSCFG_DBGFORCE_PROC0_SWDI_Msk    (0x2UL)                   /*!< PROC0_SWDI (Bitfield-Mask: 0x01) */
#define SYSCFG_DBGFORCE_PROC0_SWDO_Pos    (0UL)                     /*!< PROC0_SWDO (Bit 0) */
#define SYSCFG_DBGFORCE_PROC0_SWDO_Msk    (0x1UL)                   /*!< PROC0_SWDO (Bitfield-Mask: 0x01) */
/* =====================================================  MEMPOWERDOWN  ====================================================== */
#define SYSCFG_MEMPOWERDOWN_ROM_Pos       (7UL)                     /*!< ROM (Bit 7) */
#define SYSCFG_MEMPOWERDOWN_ROM_Msk       (0x80UL)                  /*!< ROM (Bitfield-Mask: 0x01) */
#define SYSCFG_MEMPOWERDOWN_USB_Pos       (6UL)                     /*!< USB (Bit 6) */
#define SYSCFG_MEMPOWERDOWN_USB_Msk       (0x40UL)                  /*!< USB (Bitfield-Mask: 0x01) */
#define SYSCFG_MEMPOWERDOWN_SRAM5_Pos     (5UL)                     /*!< SRAM5 (Bit 5) */
#define SYSCFG_MEMPOWERDOWN_SRAM5_Msk     (0x20UL)                  /*!< SRAM5 (Bitfield-Mask: 0x01) */
#define SYSCFG_MEMPOWERDOWN_SRAM4_Pos     (4UL)                     /*!< SRAM4 (Bit 4) */
#define SYSCFG_MEMPOWERDOWN_SRAM4_Msk     (0x10UL)                  /*!< SRAM4 (Bitfield-Mask: 0x01) */
#define SYSCFG_MEMPOWERDOWN_SRAM3_Pos     (3UL)                     /*!< SRAM3 (Bit 3) */
#define SYSCFG_MEMPOWERDOWN_SRAM3_Msk     (0x8UL)                   /*!< SRAM3 (Bitfield-Mask: 0x01) */
#define SYSCFG_MEMPOWERDOWN_SRAM2_Pos     (2UL)                     /*!< SRAM2 (Bit 2) */
#define SYSCFG_MEMPOWERDOWN_SRAM2_Msk     (0x4UL)                   /*!< SRAM2 (Bitfield-Mask: 0x01) */
#define SYSCFG_MEMPOWERDOWN_SRAM1_Pos     (1UL)                     /*!< SRAM1 (Bit 1) */
#define SYSCFG_MEMPOWERDOWN_SRAM1_Msk     (0x2UL)                   /*!< SRAM1 (Bitfield-Mask: 0x01) */
#define SYSCFG_MEMPOWERDOWN_SRAM0_Pos     (0UL)                     /*!< SRAM0 (Bit 0) */
#define SYSCFG_MEMPOWERDOWN_SRAM0_Msk     (0x1UL)                   /*!< SRAM0 (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                          CLOCKS                                           ================ */
/* =========================================================================================================================== */

/* ====================================================  CLK_GPOUT0_CTRL  ==================================================== */
#define CLOCKS_CLK_GPOUT0_CTRL_NUDGE_Pos  (20UL)                    /*!< NUDGE (Bit 20) */
#define CLOCKS_CLK_GPOUT0_CTRL_NUDGE_Msk  (0x100000UL)              /*!< NUDGE (Bitfield-Mask: 0x01) */
#define CLOCKS_CLK_GPOUT0_CTRL_PHASE_Pos  (16UL)                    /*!< PHASE (Bit 16) */
#define CLOCKS_CLK_GPOUT0_CTRL_PHASE_Msk  (0x30000UL)               /*!< PHASE (Bitfield-Mask: 0x03) */
#define CLOCKS_CLK_GPOUT0_CTRL_DC50_Pos   (12UL)                    /*!< DC50 (Bit 12) */
#define CLOCKS_CLK_GPOUT0_CTRL_DC50_Msk   (0x1000UL)                /*!< DC50 (Bitfield-Mask: 0x01) */
#define CLOCKS_CLK_GPOUT0_CTRL_ENABLE_Pos (11UL)                    /*!< ENABLE (Bit 11) */
#define CLOCKS_CLK_GPOUT0_CTRL_ENABLE_Msk (0x800UL)                 /*!< ENABLE (Bitfield-Mask: 0x01) */
#define CLOCKS_CLK_GPOUT0_CTRL_KILL_Pos   (10UL)                    /*!< KILL (Bit 10) */
#define CLOCKS_CLK_GPOUT0_CTRL_KILL_Msk   (0x400UL)                 /*!< KILL (Bitfield-Mask: 0x01) */
#define CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_Pos (5UL)                     /*!< AUXSRC (Bit 5) */
#define CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_Msk (0x1e0UL)                 /*!< AUXSRC (Bitfield-Mask: 0x0f) */
/* ====================================================  CLK_GPOUT0_DIV  ===================================================== */
#define CLOCKS_CLK_GPOUT0_DIV_INT_Pos     (8UL)                     /*!< INT (Bit 8) */
#define CLOCKS_CLK_GPOUT0_DIV_INT_Msk     (0xffffff00UL)            /*!< INT (Bitfield-Mask: 0xffffff) */
#define CLOCKS_CLK_GPOUT0_DIV_FRAC_Pos    (0UL)                     /*!< FRAC (Bit 0) */
#define CLOCKS_CLK_GPOUT0_DIV_FRAC_Msk    (0xffUL)                  /*!< FRAC (Bitfield-Mask: 0xff) */
/* ==================================================  CLK_GPOUT0_SELECTED  ================================================== */
/* ====================================================  CLK_GPOUT1_CTRL  ==================================================== */
#define CLOCKS_CLK_GPOUT1_CTRL_NUDGE_Pos  (20UL)                    /*!< NUDGE (Bit 20) */
#define CLOCKS_CLK_GPOUT1_CTRL_NUDGE_Msk  (0x100000UL)              /*!< NUDGE (Bitfield-Mask: 0x01) */
#define CLOCKS_CLK_GPOUT1_CTRL_PHASE_Pos  (16UL)                    /*!< PHASE (Bit 16) */
#define CLOCKS_CLK_GPOUT1_CTRL_PHASE_Msk  (0x30000UL)               /*!< PHASE (Bitfield-Mask: 0x03) */
#define CLOCKS_CLK_GPOUT1_CTRL_DC50_Pos   (12UL)                    /*!< DC50 (Bit 12) */
#define CLOCKS_CLK_GPOUT1_CTRL_DC50_Msk   (0x1000UL)                /*!< DC50 (Bitfield-Mask: 0x01) */
#define CLOCKS_CLK_GPOUT1_CTRL_ENABLE_Pos (11UL)                    /*!< ENABLE (Bit 11) */
#define CLOCKS_CLK_GPOUT1_CTRL_ENABLE_Msk (0x800UL)                 /*!< ENABLE (Bitfield-Mask: 0x01) */
#define CLOCKS_CLK_GPOUT1_CTRL_KILL_Pos   (10UL)                    /*!< KILL (Bit 10) */
#define CLOCKS_CLK_GPOUT1_CTRL_KILL_Msk   (0x400UL)                 /*!< KILL (Bitfield-Mask: 0x01) */
#define CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_Pos (5UL)                     /*!< AUXSRC (Bit 5) */
#define CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_Msk (0x1e0UL)                 /*!< AUXSRC (Bitfield-Mask: 0x0f) */
/* ====================================================  CLK_GPOUT1_DIV  ===================================================== */
#define CLOCKS_CLK_GPOUT1_DIV_INT_Pos     (8UL)                     /*!< INT (Bit 8) */
#define CLOCKS_CLK_GPOUT1_DIV_INT_Msk     (0xffffff00UL)            /*!< INT (Bitfield-Mask: 0xffffff) */
#define CLOCKS_CLK_GPOUT1_DIV_FRAC_Pos    (0UL)                     /*!< FRAC (Bit 0) */
#define CLOCKS_CLK_GPOUT1_DIV_FRAC_Msk    (0xffUL)                  /*!< FRAC (Bitfield-Mask: 0xff) */
/* ==================================================  CLK_GPOUT1_SELECTED  ================================================== */
/* ====================================================  CLK_GPOUT2_CTRL  ==================================================== */
#define CLOCKS_CLK_GPOUT2_CTRL_NUDGE_Pos  (20UL)                    /*!< NUDGE (Bit 20) */
#define CLOCKS_CLK_GPOUT2_CTRL_NUDGE_Msk  (0x100000UL)              /*!< NUDGE (Bitfield-Mask: 0x01) */
#define CLOCKS_CLK_GPOUT2_CTRL_PHASE_Pos  (16UL)                    /*!< PHASE (Bit 16) */
#define CLOCKS_CLK_GPOUT2_CTRL_PHASE_Msk  (0x30000UL)               /*!< PHASE (Bitfield-Mask: 0x03) */
#define CLOCKS_CLK_GPOUT2_CTRL_DC50_Pos   (12UL)                    /*!< DC50 (Bit 12) */
#define CLOCKS_CLK_GPOUT2_CTRL_DC50_Msk   (0x1000UL)                /*!< DC50 (Bitfield-Mask: 0x01) */
#define CLOCKS_CLK_GPOUT2_CTRL_ENABLE_Pos (11UL)                    /*!< ENABLE (Bit 11) */
#define CLOCKS_CLK_GPOUT2_CTRL_ENABLE_Msk (0x800UL)                 /*!< ENABLE (Bitfield-Mask: 0x01) */
#define CLOCKS_CLK_GPOUT2_CTRL_KILL_Pos   (10UL)                    /*!< KILL (Bit 10) */
#define CLOCKS_CLK_GPOUT2_CTRL_KILL_Msk   (0x400UL)                 /*!< KILL (Bitfield-Mask: 0x01) */
#define CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_Pos (5UL)                     /*!< AUXSRC (Bit 5) */
#define CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_Msk (0x1e0UL)                 /*!< AUXSRC (Bitfield-Mask: 0x0f) */
/* ====================================================  CLK_GPOUT2_DIV  ===================================================== */
#define CLOCKS_CLK_GPOUT2_DIV_INT_Pos     (8UL)                     /*!< INT (Bit 8) */
#define CLOCKS_CLK_GPOUT2_DIV_INT_Msk     (0xffffff00UL)            /*!< INT (Bitfield-Mask: 0xffffff) */
#define CLOCKS_CLK_GPOUT2_DIV_FRAC_Pos    (0UL)                     /*!< FRAC (Bit 0) */
#define CLOCKS_CLK_GPOUT2_DIV_FRAC_Msk    (0xffUL)                  /*!< FRAC (Bitfield-Mask: 0xff) */
/* ==================================================  CLK_GPOUT2_SELECTED  ================================================== */
/* ====================================================  CLK_GPOUT3_CTRL  ==================================================== */
#define CLOCKS_CLK_GPOUT3_CTRL_NUDGE_Pos  (20UL)                    /*!< NUDGE (Bit 20) */
#define CLOCKS_CLK_GPOUT3_CTRL_NUDGE_Msk  (0x100000UL)              /*!< NUDGE (Bitfield-Mask: 0x01) */
#define CLOCKS_CLK_GPOUT3_CTRL_PHASE_Pos  (16UL)                    /*!< PHASE (Bit 16) */
#define CLOCKS_CLK_GPOUT3_CTRL_PHASE_Msk  (0x30000UL)               /*!< PHASE (Bitfield-Mask: 0x03) */
#define CLOCKS_CLK_GPOUT3_CTRL_DC50_Pos   (12UL)                    /*!< DC50 (Bit 12) */
#define CLOCKS_CLK_GPOUT3_CTRL_DC50_Msk   (0x1000UL)                /*!< DC50 (Bitfield-Mask: 0x01) */
#define CLOCKS_CLK_GPOUT3_CTRL_ENABLE_Pos (11UL)                    /*!< ENABLE (Bit 11) */
#define CLOCKS_CLK_GPOUT3_CTRL_ENABLE_Msk (0x800UL)                 /*!< ENABLE (Bitfield-Mask: 0x01) */
#define CLOCKS_CLK_GPOUT3_CTRL_KILL_Pos   (10UL)                    /*!< KILL (Bit 10) */
#define CLOCKS_CLK_GPOUT3_CTRL_KILL_Msk   (0x400UL)                 /*!< KILL (Bitfield-Mask: 0x01) */
#define CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_Pos (5UL)                     /*!< AUXSRC (Bit 5) */
#define CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_Msk (0x1e0UL)                 /*!< AUXSRC (Bitfield-Mask: 0x0f) */
/* ====================================================  CLK_GPOUT3_DIV  ===================================================== */
#define CLOCKS_CLK_GPOUT3_DIV_INT_Pos     (8UL)                     /*!< INT (Bit 8) */
#define CLOCKS_CLK_GPOUT3_DIV_INT_Msk     (0xffffff00UL)            /*!< INT (Bitfield-Mask: 0xffffff) */
#define CLOCKS_CLK_GPOUT3_DIV_FRAC_Pos    (0UL)                     /*!< FRAC (Bit 0) */
#define CLOCKS_CLK_GPOUT3_DIV_FRAC_Msk    (0xffUL)                  /*!< FRAC (Bitfield-Mask: 0xff) */
/* ==================================================  CLK_GPOUT3_SELECTED  ================================================== */
/* =====================================================  CLK_REF_CTRL  ====================================================== */
#define CLOCKS_CLK_REF_CTRL_AUXSRC_Pos    (5UL)                     /*!< AUXSRC (Bit 5) */
#define CLOCKS_CLK_REF_CTRL_AUXSRC_Msk    (0x60UL)                  /*!< AUXSRC (Bitfield-Mask: 0x03) */
#define CLOCKS_CLK_REF_CTRL_SRC_Pos       (0UL)                     /*!< SRC (Bit 0) */
#define CLOCKS_CLK_REF_CTRL_SRC_Msk       (0x3UL)                   /*!< SRC (Bitfield-Mask: 0x03) */
/* ======================================================  CLK_REF_DIV  ====================================================== */
#define CLOCKS_CLK_REF_DIV_INT_Pos        (8UL)                     /*!< INT (Bit 8) */
#define CLOCKS_CLK_REF_DIV_INT_Msk        (0x300UL)                 /*!< INT (Bitfield-Mask: 0x03) */
/* ===================================================  CLK_REF_SELECTED  ==================================================== */
/* =====================================================  CLK_SYS_CTRL  ====================================================== */
#define CLOCKS_CLK_SYS_CTRL_AUXSRC_Pos    (5UL)                     /*!< AUXSRC (Bit 5) */
#define CLOCKS_CLK_SYS_CTRL_AUXSRC_Msk    (0xe0UL)                  /*!< AUXSRC (Bitfield-Mask: 0x07) */
#define CLOCKS_CLK_SYS_CTRL_SRC_Pos       (0UL)                     /*!< SRC (Bit 0) */
#define CLOCKS_CLK_SYS_CTRL_SRC_Msk       (0x1UL)                   /*!< SRC (Bitfield-Mask: 0x01) */
/* ======================================================  CLK_SYS_DIV  ====================================================== */
#define CLOCKS_CLK_SYS_DIV_INT_Pos        (8UL)                     /*!< INT (Bit 8) */
#define CLOCKS_CLK_SYS_DIV_INT_Msk        (0xffffff00UL)            /*!< INT (Bitfield-Mask: 0xffffff) */
#define CLOCKS_CLK_SYS_DIV_FRAC_Pos       (0UL)                     /*!< FRAC (Bit 0) */
#define CLOCKS_CLK_SYS_DIV_FRAC_Msk       (0xffUL)                  /*!< FRAC (Bitfield-Mask: 0xff) */
/* ===================================================  CLK_SYS_SELECTED  ==================================================== */
/* =====================================================  CLK_PERI_CTRL  ===================================================== */
#define CLOCKS_CLK_PERI_CTRL_ENABLE_Pos   (11UL)                    /*!< ENABLE (Bit 11) */
#define CLOCKS_CLK_PERI_CTRL_ENABLE_Msk   (0x800UL)                 /*!< ENABLE (Bitfield-Mask: 0x01) */
#define CLOCKS_CLK_PERI_CTRL_KILL_Pos     (10UL)                    /*!< KILL (Bit 10) */
#define CLOCKS_CLK_PERI_CTRL_KILL_Msk     (0x400UL)                 /*!< KILL (Bitfield-Mask: 0x01) */
#define CLOCKS_CLK_PERI_CTRL_AUXSRC_Pos   (5UL)                     /*!< AUXSRC (Bit 5) */
#define CLOCKS_CLK_PERI_CTRL_AUXSRC_Msk   (0xe0UL)                  /*!< AUXSRC (Bitfield-Mask: 0x07) */
/* ===================================================  CLK_PERI_SELECTED  =================================================== */
/* =====================================================  CLK_USB_CTRL  ====================================================== */
#define CLOCKS_CLK_USB_CTRL_NUDGE_Pos     (20UL)                    /*!< NUDGE (Bit 20) */
#define CLOCKS_CLK_USB_CTRL_NUDGE_Msk     (0x100000UL)              /*!< NUDGE (Bitfield-Mask: 0x01) */
#define CLOCKS_CLK_USB_CTRL_PHASE_Pos     (16UL)                    /*!< PHASE (Bit 16) */
#define CLOCKS_CLK_USB_CTRL_PHASE_Msk     (0x30000UL)               /*!< PHASE (Bitfield-Mask: 0x03) */
#define CLOCKS_CLK_USB_CTRL_ENABLE_Pos    (11UL)                    /*!< ENABLE (Bit 11) */
#define CLOCKS_CLK_USB_CTRL_ENABLE_Msk    (0x800UL)                 /*!< ENABLE (Bitfield-Mask: 0x01) */
#define CLOCKS_CLK_USB_CTRL_KILL_Pos      (10UL)                    /*!< KILL (Bit 10) */
#define CLOCKS_CLK_USB_CTRL_KILL_Msk      (0x400UL)                 /*!< KILL (Bitfield-Mask: 0x01) */
#define CLOCKS_CLK_USB_CTRL_AUXSRC_Pos    (5UL)                     /*!< AUXSRC (Bit 5) */
#define CLOCKS_CLK_USB_CTRL_AUXSRC_Msk    (0xe0UL)                  /*!< AUXSRC (Bitfield-Mask: 0x07) */
/* ======================================================  CLK_USB_DIV  ====================================================== */
#define CLOCKS_CLK_USB_DIV_INT_Pos        (8UL)                     /*!< INT (Bit 8) */
#define CLOCKS_CLK_USB_DIV_INT_Msk        (0x300UL)                 /*!< INT (Bitfield-Mask: 0x03) */
/* ===================================================  CLK_USB_SELECTED  ==================================================== */
/* =====================================================  CLK_ADC_CTRL  ====================================================== */
#define CLOCKS_CLK_ADC_CTRL_NUDGE_Pos     (20UL)                    /*!< NUDGE (Bit 20) */
#define CLOCKS_CLK_ADC_CTRL_NUDGE_Msk     (0x100000UL)              /*!< NUDGE (Bitfield-Mask: 0x01) */
#define CLOCKS_CLK_ADC_CTRL_PHASE_Pos     (16UL)                    /*!< PHASE (Bit 16) */
#define CLOCKS_CLK_ADC_CTRL_PHASE_Msk     (0x30000UL)               /*!< PHASE (Bitfield-Mask: 0x03) */
#define CLOCKS_CLK_ADC_CTRL_ENABLE_Pos    (11UL)                    /*!< ENABLE (Bit 11) */
#define CLOCKS_CLK_ADC_CTRL_ENABLE_Msk    (0x800UL)                 /*!< ENABLE (Bitfield-Mask: 0x01) */
#define CLOCKS_CLK_ADC_CTRL_KILL_Pos      (10UL)                    /*!< KILL (Bit 10) */
#define CLOCKS_CLK_ADC_CTRL_KILL_Msk      (0x400UL)                 /*!< KILL (Bitfield-Mask: 0x01) */
#define CLOCKS_CLK_ADC_CTRL_AUXSRC_Pos    (5UL)                     /*!< AUXSRC (Bit 5) */
#define CLOCKS_CLK_ADC_CTRL_AUXSRC_Msk    (0xe0UL)                  /*!< AUXSRC (Bitfield-Mask: 0x07) */
/* ======================================================  CLK_ADC_DIV  ====================================================== */
#define CLOCKS_CLK_ADC_DIV_INT_Pos        (8UL)                     /*!< INT (Bit 8) */
#define CLOCKS_CLK_ADC_DIV_INT_Msk        (0x300UL)                 /*!< INT (Bitfield-Mask: 0x03) */
/* ===================================================  CLK_ADC_SELECTED  ==================================================== */
/* =====================================================  CLK_RTC_CTRL  ====================================================== */
#define CLOCKS_CLK_RTC_CTRL_NUDGE_Pos     (20UL)                    /*!< NUDGE (Bit 20) */
#define CLOCKS_CLK_RTC_CTRL_NUDGE_Msk     (0x100000UL)              /*!< NUDGE (Bitfield-Mask: 0x01) */
#define CLOCKS_CLK_RTC_CTRL_PHASE_Pos     (16UL)                    /*!< PHASE (Bit 16) */
#define CLOCKS_CLK_RTC_CTRL_PHASE_Msk     (0x30000UL)               /*!< PHASE (Bitfield-Mask: 0x03) */
#define CLOCKS_CLK_RTC_CTRL_ENABLE_Pos    (11UL)                    /*!< ENABLE (Bit 11) */
#define CLOCKS_CLK_RTC_CTRL_ENABLE_Msk    (0x800UL)                 /*!< ENABLE (Bitfield-Mask: 0x01) */
#define CLOCKS_CLK_RTC_CTRL_KILL_Pos      (10UL)                    /*!< KILL (Bit 10) */
#define CLOCKS_CLK_RTC_CTRL_KILL_Msk      (0x400UL)                 /*!< KILL (Bitfield-Mask: 0x01) */
#define CLOCKS_CLK_RTC_CTRL_AUXSRC_Pos    (5UL)                     /*!< AUXSRC (Bit 5) */
#define CLOCKS_CLK_RTC_CTRL_AUXSRC_Msk    (0xe0UL)                  /*!< AUXSRC (Bitfield-Mask: 0x07) */
/* ======================================================  CLK_RTC_DIV  ====================================================== */
#define CLOCKS_CLK_RTC_DIV_INT_Pos        (8UL)                     /*!< INT (Bit 8) */
#define CLOCKS_CLK_RTC_DIV_INT_Msk        (0xffffff00UL)            /*!< INT (Bitfield-Mask: 0xffffff) */
#define CLOCKS_CLK_RTC_DIV_FRAC_Pos       (0UL)                     /*!< FRAC (Bit 0) */
#define CLOCKS_CLK_RTC_DIV_FRAC_Msk       (0xffUL)                  /*!< FRAC (Bitfield-Mask: 0xff) */
/* ===================================================  CLK_RTC_SELECTED  ==================================================== */
/* ==================================================  CLK_SYS_RESUS_CTRL  =================================================== */
#define CLOCKS_CLK_SYS_RESUS_CTRL_CLEAR_Pos (16UL)                  /*!< CLEAR (Bit 16) */
#define CLOCKS_CLK_SYS_RESUS_CTRL_CLEAR_Msk (0x10000UL)             /*!< CLEAR (Bitfield-Mask: 0x01) */
#define CLOCKS_CLK_SYS_RESUS_CTRL_FRCE_Pos (12UL)                   /*!< FRCE (Bit 12) */
#define CLOCKS_CLK_SYS_RESUS_CTRL_FRCE_Msk (0x1000UL)               /*!< FRCE (Bitfield-Mask: 0x01) */
#define CLOCKS_CLK_SYS_RESUS_CTRL_ENABLE_Pos (8UL)                  /*!< ENABLE (Bit 8) */
#define CLOCKS_CLK_SYS_RESUS_CTRL_ENABLE_Msk (0x100UL)              /*!< ENABLE (Bitfield-Mask: 0x01) */
#define CLOCKS_CLK_SYS_RESUS_CTRL_TIMEOUT_Pos (0UL)                 /*!< TIMEOUT (Bit 0) */
#define CLOCKS_CLK_SYS_RESUS_CTRL_TIMEOUT_Msk (0xffUL)              /*!< TIMEOUT (Bitfield-Mask: 0xff) */
/* =================================================  CLK_SYS_RESUS_STATUS  ================================================== */
#define CLOCKS_CLK_SYS_RESUS_STATUS_RESUSSED_Pos (0UL)              /*!< RESUSSED (Bit 0) */
#define CLOCKS_CLK_SYS_RESUS_STATUS_RESUSSED_Msk (0x1UL)            /*!< RESUSSED (Bitfield-Mask: 0x01) */
/* ======================================================  FC0_REF_KHZ  ====================================================== */
#define CLOCKS_FC0_REF_KHZ_FC0_REF_KHZ_Pos (0UL)                    /*!< FC0_REF_KHZ (Bit 0) */
#define CLOCKS_FC0_REF_KHZ_FC0_REF_KHZ_Msk (0xfffffUL)              /*!< FC0_REF_KHZ (Bitfield-Mask: 0xfffff) */
/* ======================================================  FC0_MIN_KHZ  ====================================================== */
#define CLOCKS_FC0_MIN_KHZ_FC0_MIN_KHZ_Pos (0UL)                    /*!< FC0_MIN_KHZ (Bit 0) */
#define CLOCKS_FC0_MIN_KHZ_FC0_MIN_KHZ_Msk (0x1ffffffUL)            /*!< FC0_MIN_KHZ (Bitfield-Mask: 0x1ffffff) */
/* ======================================================  FC0_MAX_KHZ  ====================================================== */
#define CLOCKS_FC0_MAX_KHZ_FC0_MAX_KHZ_Pos (0UL)                    /*!< FC0_MAX_KHZ (Bit 0) */
#define CLOCKS_FC0_MAX_KHZ_FC0_MAX_KHZ_Msk (0x1ffffffUL)            /*!< FC0_MAX_KHZ (Bitfield-Mask: 0x1ffffff) */
/* =======================================================  FC0_DELAY  ======================================================= */
#define CLOCKS_FC0_DELAY_FC0_DELAY_Pos    (0UL)                     /*!< FC0_DELAY (Bit 0) */
#define CLOCKS_FC0_DELAY_FC0_DELAY_Msk    (0x7UL)                   /*!< FC0_DELAY (Bitfield-Mask: 0x07) */
/* =====================================================  FC0_INTERVAL  ====================================================== */
#define CLOCKS_FC0_INTERVAL_FC0_INTERVAL_Pos (0UL)                  /*!< FC0_INTERVAL (Bit 0) */
#define CLOCKS_FC0_INTERVAL_FC0_INTERVAL_Msk (0xfUL)                /*!< FC0_INTERVAL (Bitfield-Mask: 0x0f) */
/* ========================================================  FC0_SRC  ======================================================== */
#define CLOCKS_FC0_SRC_FC0_SRC_Pos        (0UL)                     /*!< FC0_SRC (Bit 0) */
#define CLOCKS_FC0_SRC_FC0_SRC_Msk        (0xffUL)                  /*!< FC0_SRC (Bitfield-Mask: 0xff) */
/* ======================================================  FC0_STATUS  ======================================================= */
#define CLOCKS_FC0_STATUS_DIED_Pos        (28UL)                    /*!< DIED (Bit 28) */
#define CLOCKS_FC0_STATUS_DIED_Msk        (0x10000000UL)            /*!< DIED (Bitfield-Mask: 0x01) */
#define CLOCKS_FC0_STATUS_FAST_Pos        (24UL)                    /*!< FAST (Bit 24) */
#define CLOCKS_FC0_STATUS_FAST_Msk        (0x1000000UL)             /*!< FAST (Bitfield-Mask: 0x01) */
#define CLOCKS_FC0_STATUS_SLOW_Pos        (20UL)                    /*!< SLOW (Bit 20) */
#define CLOCKS_FC0_STATUS_SLOW_Msk        (0x100000UL)              /*!< SLOW (Bitfield-Mask: 0x01) */
#define CLOCKS_FC0_STATUS_FAIL_Pos        (16UL)                    /*!< FAIL (Bit 16) */
#define CLOCKS_FC0_STATUS_FAIL_Msk        (0x10000UL)               /*!< FAIL (Bitfield-Mask: 0x01) */
#define CLOCKS_FC0_STATUS_WAITING_Pos     (12UL)                    /*!< WAITING (Bit 12) */
#define CLOCKS_FC0_STATUS_WAITING_Msk     (0x1000UL)                /*!< WAITING (Bitfield-Mask: 0x01) */
#define CLOCKS_FC0_STATUS_RUNNING_Pos     (8UL)                     /*!< RUNNING (Bit 8) */
#define CLOCKS_FC0_STATUS_RUNNING_Msk     (0x100UL)                 /*!< RUNNING (Bitfield-Mask: 0x01) */
#define CLOCKS_FC0_STATUS_DONE_Pos        (4UL)                     /*!< DONE (Bit 4) */
#define CLOCKS_FC0_STATUS_DONE_Msk        (0x10UL)                  /*!< DONE (Bitfield-Mask: 0x01) */
#define CLOCKS_FC0_STATUS_PASS_Pos        (0UL)                     /*!< PASS (Bit 0) */
#define CLOCKS_FC0_STATUS_PASS_Msk        (0x1UL)                   /*!< PASS (Bitfield-Mask: 0x01) */
/* ======================================================  FC0_RESULT  ======================================================= */
#define CLOCKS_FC0_RESULT_KHZ_Pos         (5UL)                     /*!< KHZ (Bit 5) */
#define CLOCKS_FC0_RESULT_KHZ_Msk         (0x3fffffe0UL)            /*!< KHZ (Bitfield-Mask: 0x1ffffff) */
#define CLOCKS_FC0_RESULT_FRAC_Pos        (0UL)                     /*!< FRAC (Bit 0) */
#define CLOCKS_FC0_RESULT_FRAC_Msk        (0x1fUL)                  /*!< FRAC (Bitfield-Mask: 0x1f) */
/* =======================================================  WAKE_EN0  ======================================================== */
#define CLOCKS_WAKE_EN0_clk_sys_sram3_Pos (31UL)                    /*!< clk_sys_sram3 (Bit 31) */
#define CLOCKS_WAKE_EN0_clk_sys_sram3_Msk (0x80000000UL)            /*!< clk_sys_sram3 (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_sys_sram2_Pos (30UL)                    /*!< clk_sys_sram2 (Bit 30) */
#define CLOCKS_WAKE_EN0_clk_sys_sram2_Msk (0x40000000UL)            /*!< clk_sys_sram2 (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_sys_sram1_Pos (29UL)                    /*!< clk_sys_sram1 (Bit 29) */
#define CLOCKS_WAKE_EN0_clk_sys_sram1_Msk (0x20000000UL)            /*!< clk_sys_sram1 (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_sys_sram0_Pos (28UL)                    /*!< clk_sys_sram0 (Bit 28) */
#define CLOCKS_WAKE_EN0_clk_sys_sram0_Msk (0x10000000UL)            /*!< clk_sys_sram0 (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_sys_spi1_Pos  (27UL)                    /*!< clk_sys_spi1 (Bit 27) */
#define CLOCKS_WAKE_EN0_clk_sys_spi1_Msk  (0x8000000UL)             /*!< clk_sys_spi1 (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_peri_spi1_Pos (26UL)                    /*!< clk_peri_spi1 (Bit 26) */
#define CLOCKS_WAKE_EN0_clk_peri_spi1_Msk (0x4000000UL)             /*!< clk_peri_spi1 (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_sys_spi0_Pos  (25UL)                    /*!< clk_sys_spi0 (Bit 25) */
#define CLOCKS_WAKE_EN0_clk_sys_spi0_Msk  (0x2000000UL)             /*!< clk_sys_spi0 (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_peri_spi0_Pos (24UL)                    /*!< clk_peri_spi0 (Bit 24) */
#define CLOCKS_WAKE_EN0_clk_peri_spi0_Msk (0x1000000UL)             /*!< clk_peri_spi0 (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_sys_sio_Pos   (23UL)                    /*!< clk_sys_sio (Bit 23) */
#define CLOCKS_WAKE_EN0_clk_sys_sio_Msk   (0x800000UL)              /*!< clk_sys_sio (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_sys_rtc_Pos   (22UL)                    /*!< clk_sys_rtc (Bit 22) */
#define CLOCKS_WAKE_EN0_clk_sys_rtc_Msk   (0x400000UL)              /*!< clk_sys_rtc (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_rtc_rtc_Pos   (21UL)                    /*!< clk_rtc_rtc (Bit 21) */
#define CLOCKS_WAKE_EN0_clk_rtc_rtc_Msk   (0x200000UL)              /*!< clk_rtc_rtc (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_sys_rosc_Pos  (20UL)                    /*!< clk_sys_rosc (Bit 20) */
#define CLOCKS_WAKE_EN0_clk_sys_rosc_Msk  (0x100000UL)              /*!< clk_sys_rosc (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_sys_rom_Pos   (19UL)                    /*!< clk_sys_rom (Bit 19) */
#define CLOCKS_WAKE_EN0_clk_sys_rom_Msk   (0x80000UL)               /*!< clk_sys_rom (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_sys_resets_Pos (18UL)                   /*!< clk_sys_resets (Bit 18) */
#define CLOCKS_WAKE_EN0_clk_sys_resets_Msk (0x40000UL)              /*!< clk_sys_resets (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_sys_pwm_Pos   (17UL)                    /*!< clk_sys_pwm (Bit 17) */
#define CLOCKS_WAKE_EN0_clk_sys_pwm_Msk   (0x20000UL)               /*!< clk_sys_pwm (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_sys_psm_Pos   (16UL)                    /*!< clk_sys_psm (Bit 16) */
#define CLOCKS_WAKE_EN0_clk_sys_psm_Msk   (0x10000UL)               /*!< clk_sys_psm (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_sys_pll_usb_Pos (15UL)                  /*!< clk_sys_pll_usb (Bit 15) */
#define CLOCKS_WAKE_EN0_clk_sys_pll_usb_Msk (0x8000UL)              /*!< clk_sys_pll_usb (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_sys_pll_sys_Pos (14UL)                  /*!< clk_sys_pll_sys (Bit 14) */
#define CLOCKS_WAKE_EN0_clk_sys_pll_sys_Msk (0x4000UL)              /*!< clk_sys_pll_sys (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_sys_pio1_Pos  (13UL)                    /*!< clk_sys_pio1 (Bit 13) */
#define CLOCKS_WAKE_EN0_clk_sys_pio1_Msk  (0x2000UL)                /*!< clk_sys_pio1 (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_sys_pio0_Pos  (12UL)                    /*!< clk_sys_pio0 (Bit 12) */
#define CLOCKS_WAKE_EN0_clk_sys_pio0_Msk  (0x1000UL)                /*!< clk_sys_pio0 (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_sys_pads_Pos  (11UL)                    /*!< clk_sys_pads (Bit 11) */
#define CLOCKS_WAKE_EN0_clk_sys_pads_Msk  (0x800UL)                 /*!< clk_sys_pads (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_sys_vreg_and_chip_reset_Pos (10UL)      /*!< clk_sys_vreg_and_chip_reset (Bit 10) */
#define CLOCKS_WAKE_EN0_clk_sys_vreg_and_chip_reset_Msk (0x400UL)   /*!< clk_sys_vreg_and_chip_reset (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_sys_jtag_Pos  (9UL)                     /*!< clk_sys_jtag (Bit 9) */
#define CLOCKS_WAKE_EN0_clk_sys_jtag_Msk  (0x200UL)                 /*!< clk_sys_jtag (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_sys_io_Pos    (8UL)                     /*!< clk_sys_io (Bit 8) */
#define CLOCKS_WAKE_EN0_clk_sys_io_Msk    (0x100UL)                 /*!< clk_sys_io (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_sys_i2c1_Pos  (7UL)                     /*!< clk_sys_i2c1 (Bit 7) */
#define CLOCKS_WAKE_EN0_clk_sys_i2c1_Msk  (0x80UL)                  /*!< clk_sys_i2c1 (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_sys_i2c0_Pos  (6UL)                     /*!< clk_sys_i2c0 (Bit 6) */
#define CLOCKS_WAKE_EN0_clk_sys_i2c0_Msk  (0x40UL)                  /*!< clk_sys_i2c0 (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_sys_dma_Pos   (5UL)                     /*!< clk_sys_dma (Bit 5) */
#define CLOCKS_WAKE_EN0_clk_sys_dma_Msk   (0x20UL)                  /*!< clk_sys_dma (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_sys_busfabric_Pos (4UL)                 /*!< clk_sys_busfabric (Bit 4) */
#define CLOCKS_WAKE_EN0_clk_sys_busfabric_Msk (0x10UL)              /*!< clk_sys_busfabric (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_sys_busctrl_Pos (3UL)                   /*!< clk_sys_busctrl (Bit 3) */
#define CLOCKS_WAKE_EN0_clk_sys_busctrl_Msk (0x8UL)                 /*!< clk_sys_busctrl (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_sys_adc_Pos   (2UL)                     /*!< clk_sys_adc (Bit 2) */
#define CLOCKS_WAKE_EN0_clk_sys_adc_Msk   (0x4UL)                   /*!< clk_sys_adc (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_adc_adc_Pos   (1UL)                     /*!< clk_adc_adc (Bit 1) */
#define CLOCKS_WAKE_EN0_clk_adc_adc_Msk   (0x2UL)                   /*!< clk_adc_adc (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN0_clk_sys_clocks_Pos (0UL)                    /*!< clk_sys_clocks (Bit 0) */
#define CLOCKS_WAKE_EN0_clk_sys_clocks_Msk (0x1UL)                  /*!< clk_sys_clocks (Bitfield-Mask: 0x01) */
/* =======================================================  WAKE_EN1  ======================================================== */
#define CLOCKS_WAKE_EN1_clk_sys_xosc_Pos  (14UL)                    /*!< clk_sys_xosc (Bit 14) */
#define CLOCKS_WAKE_EN1_clk_sys_xosc_Msk  (0x4000UL)                /*!< clk_sys_xosc (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN1_clk_sys_xip_Pos   (13UL)                    /*!< clk_sys_xip (Bit 13) */
#define CLOCKS_WAKE_EN1_clk_sys_xip_Msk   (0x2000UL)                /*!< clk_sys_xip (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN1_clk_sys_watchdog_Pos (12UL)                 /*!< clk_sys_watchdog (Bit 12) */
#define CLOCKS_WAKE_EN1_clk_sys_watchdog_Msk (0x1000UL)             /*!< clk_sys_watchdog (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN1_clk_usb_usbctrl_Pos (11UL)                  /*!< clk_usb_usbctrl (Bit 11) */
#define CLOCKS_WAKE_EN1_clk_usb_usbctrl_Msk (0x800UL)               /*!< clk_usb_usbctrl (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN1_clk_sys_usbctrl_Pos (10UL)                  /*!< clk_sys_usbctrl (Bit 10) */
#define CLOCKS_WAKE_EN1_clk_sys_usbctrl_Msk (0x400UL)               /*!< clk_sys_usbctrl (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN1_clk_sys_uart1_Pos (9UL)                     /*!< clk_sys_uart1 (Bit 9) */
#define CLOCKS_WAKE_EN1_clk_sys_uart1_Msk (0x200UL)                 /*!< clk_sys_uart1 (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN1_clk_peri_uart1_Pos (8UL)                    /*!< clk_peri_uart1 (Bit 8) */
#define CLOCKS_WAKE_EN1_clk_peri_uart1_Msk (0x100UL)                /*!< clk_peri_uart1 (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN1_clk_sys_uart0_Pos (7UL)                     /*!< clk_sys_uart0 (Bit 7) */
#define CLOCKS_WAKE_EN1_clk_sys_uart0_Msk (0x80UL)                  /*!< clk_sys_uart0 (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN1_clk_peri_uart0_Pos (6UL)                    /*!< clk_peri_uart0 (Bit 6) */
#define CLOCKS_WAKE_EN1_clk_peri_uart0_Msk (0x40UL)                 /*!< clk_peri_uart0 (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN1_clk_sys_timer_Pos (5UL)                     /*!< clk_sys_timer (Bit 5) */
#define CLOCKS_WAKE_EN1_clk_sys_timer_Msk (0x20UL)                  /*!< clk_sys_timer (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN1_clk_sys_tbman_Pos (4UL)                     /*!< clk_sys_tbman (Bit 4) */
#define CLOCKS_WAKE_EN1_clk_sys_tbman_Msk (0x10UL)                  /*!< clk_sys_tbman (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN1_clk_sys_sysinfo_Pos (3UL)                   /*!< clk_sys_sysinfo (Bit 3) */
#define CLOCKS_WAKE_EN1_clk_sys_sysinfo_Msk (0x8UL)                 /*!< clk_sys_sysinfo (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN1_clk_sys_syscfg_Pos (2UL)                    /*!< clk_sys_syscfg (Bit 2) */
#define CLOCKS_WAKE_EN1_clk_sys_syscfg_Msk (0x4UL)                  /*!< clk_sys_syscfg (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN1_clk_sys_sram5_Pos (1UL)                     /*!< clk_sys_sram5 (Bit 1) */
#define CLOCKS_WAKE_EN1_clk_sys_sram5_Msk (0x2UL)                   /*!< clk_sys_sram5 (Bitfield-Mask: 0x01) */
#define CLOCKS_WAKE_EN1_clk_sys_sram4_Pos (0UL)                     /*!< clk_sys_sram4 (Bit 0) */
#define CLOCKS_WAKE_EN1_clk_sys_sram4_Msk (0x1UL)                   /*!< clk_sys_sram4 (Bitfield-Mask: 0x01) */
/* =======================================================  SLEEP_EN0  ======================================================= */
#define CLOCKS_SLEEP_EN0_clk_sys_sram3_Pos (31UL)                   /*!< clk_sys_sram3 (Bit 31) */
#define CLOCKS_SLEEP_EN0_clk_sys_sram3_Msk (0x80000000UL)           /*!< clk_sys_sram3 (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_sys_sram2_Pos (30UL)                   /*!< clk_sys_sram2 (Bit 30) */
#define CLOCKS_SLEEP_EN0_clk_sys_sram2_Msk (0x40000000UL)           /*!< clk_sys_sram2 (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_sys_sram1_Pos (29UL)                   /*!< clk_sys_sram1 (Bit 29) */
#define CLOCKS_SLEEP_EN0_clk_sys_sram1_Msk (0x20000000UL)           /*!< clk_sys_sram1 (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_sys_sram0_Pos (28UL)                   /*!< clk_sys_sram0 (Bit 28) */
#define CLOCKS_SLEEP_EN0_clk_sys_sram0_Msk (0x10000000UL)           /*!< clk_sys_sram0 (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_sys_spi1_Pos (27UL)                    /*!< clk_sys_spi1 (Bit 27) */
#define CLOCKS_SLEEP_EN0_clk_sys_spi1_Msk (0x8000000UL)             /*!< clk_sys_spi1 (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_peri_spi1_Pos (26UL)                   /*!< clk_peri_spi1 (Bit 26) */
#define CLOCKS_SLEEP_EN0_clk_peri_spi1_Msk (0x4000000UL)            /*!< clk_peri_spi1 (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_sys_spi0_Pos (25UL)                    /*!< clk_sys_spi0 (Bit 25) */
#define CLOCKS_SLEEP_EN0_clk_sys_spi0_Msk (0x2000000UL)             /*!< clk_sys_spi0 (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_peri_spi0_Pos (24UL)                   /*!< clk_peri_spi0 (Bit 24) */
#define CLOCKS_SLEEP_EN0_clk_peri_spi0_Msk (0x1000000UL)            /*!< clk_peri_spi0 (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_sys_sio_Pos  (23UL)                    /*!< clk_sys_sio (Bit 23) */
#define CLOCKS_SLEEP_EN0_clk_sys_sio_Msk  (0x800000UL)              /*!< clk_sys_sio (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_sys_rtc_Pos  (22UL)                    /*!< clk_sys_rtc (Bit 22) */
#define CLOCKS_SLEEP_EN0_clk_sys_rtc_Msk  (0x400000UL)              /*!< clk_sys_rtc (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_rtc_rtc_Pos  (21UL)                    /*!< clk_rtc_rtc (Bit 21) */
#define CLOCKS_SLEEP_EN0_clk_rtc_rtc_Msk  (0x200000UL)              /*!< clk_rtc_rtc (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_sys_rosc_Pos (20UL)                    /*!< clk_sys_rosc (Bit 20) */
#define CLOCKS_SLEEP_EN0_clk_sys_rosc_Msk (0x100000UL)              /*!< clk_sys_rosc (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_sys_rom_Pos  (19UL)                    /*!< clk_sys_rom (Bit 19) */
#define CLOCKS_SLEEP_EN0_clk_sys_rom_Msk  (0x80000UL)               /*!< clk_sys_rom (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_sys_resets_Pos (18UL)                  /*!< clk_sys_resets (Bit 18) */
#define CLOCKS_SLEEP_EN0_clk_sys_resets_Msk (0x40000UL)             /*!< clk_sys_resets (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_sys_pwm_Pos  (17UL)                    /*!< clk_sys_pwm (Bit 17) */
#define CLOCKS_SLEEP_EN0_clk_sys_pwm_Msk  (0x20000UL)               /*!< clk_sys_pwm (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_sys_psm_Pos  (16UL)                    /*!< clk_sys_psm (Bit 16) */
#define CLOCKS_SLEEP_EN0_clk_sys_psm_Msk  (0x10000UL)               /*!< clk_sys_psm (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_sys_pll_usb_Pos (15UL)                 /*!< clk_sys_pll_usb (Bit 15) */
#define CLOCKS_SLEEP_EN0_clk_sys_pll_usb_Msk (0x8000UL)             /*!< clk_sys_pll_usb (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_sys_pll_sys_Pos (14UL)                 /*!< clk_sys_pll_sys (Bit 14) */
#define CLOCKS_SLEEP_EN0_clk_sys_pll_sys_Msk (0x4000UL)             /*!< clk_sys_pll_sys (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_sys_pio1_Pos (13UL)                    /*!< clk_sys_pio1 (Bit 13) */
#define CLOCKS_SLEEP_EN0_clk_sys_pio1_Msk (0x2000UL)                /*!< clk_sys_pio1 (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_sys_pio0_Pos (12UL)                    /*!< clk_sys_pio0 (Bit 12) */
#define CLOCKS_SLEEP_EN0_clk_sys_pio0_Msk (0x1000UL)                /*!< clk_sys_pio0 (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_sys_pads_Pos (11UL)                    /*!< clk_sys_pads (Bit 11) */
#define CLOCKS_SLEEP_EN0_clk_sys_pads_Msk (0x800UL)                 /*!< clk_sys_pads (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_sys_vreg_and_chip_reset_Pos (10UL)     /*!< clk_sys_vreg_and_chip_reset (Bit 10) */
#define CLOCKS_SLEEP_EN0_clk_sys_vreg_and_chip_reset_Msk (0x400UL)  /*!< clk_sys_vreg_and_chip_reset (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_sys_jtag_Pos (9UL)                     /*!< clk_sys_jtag (Bit 9) */
#define CLOCKS_SLEEP_EN0_clk_sys_jtag_Msk (0x200UL)                 /*!< clk_sys_jtag (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_sys_io_Pos   (8UL)                     /*!< clk_sys_io (Bit 8) */
#define CLOCKS_SLEEP_EN0_clk_sys_io_Msk   (0x100UL)                 /*!< clk_sys_io (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_sys_i2c1_Pos (7UL)                     /*!< clk_sys_i2c1 (Bit 7) */
#define CLOCKS_SLEEP_EN0_clk_sys_i2c1_Msk (0x80UL)                  /*!< clk_sys_i2c1 (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_sys_i2c0_Pos (6UL)                     /*!< clk_sys_i2c0 (Bit 6) */
#define CLOCKS_SLEEP_EN0_clk_sys_i2c0_Msk (0x40UL)                  /*!< clk_sys_i2c0 (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_sys_dma_Pos  (5UL)                     /*!< clk_sys_dma (Bit 5) */
#define CLOCKS_SLEEP_EN0_clk_sys_dma_Msk  (0x20UL)                  /*!< clk_sys_dma (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_sys_busfabric_Pos (4UL)                /*!< clk_sys_busfabric (Bit 4) */
#define CLOCKS_SLEEP_EN0_clk_sys_busfabric_Msk (0x10UL)             /*!< clk_sys_busfabric (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_sys_busctrl_Pos (3UL)                  /*!< clk_sys_busctrl (Bit 3) */
#define CLOCKS_SLEEP_EN0_clk_sys_busctrl_Msk (0x8UL)                /*!< clk_sys_busctrl (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_sys_adc_Pos  (2UL)                     /*!< clk_sys_adc (Bit 2) */
#define CLOCKS_SLEEP_EN0_clk_sys_adc_Msk  (0x4UL)                   /*!< clk_sys_adc (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_adc_adc_Pos  (1UL)                     /*!< clk_adc_adc (Bit 1) */
#define CLOCKS_SLEEP_EN0_clk_adc_adc_Msk  (0x2UL)                   /*!< clk_adc_adc (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN0_clk_sys_clocks_Pos (0UL)                   /*!< clk_sys_clocks (Bit 0) */
#define CLOCKS_SLEEP_EN0_clk_sys_clocks_Msk (0x1UL)                 /*!< clk_sys_clocks (Bitfield-Mask: 0x01) */
/* =======================================================  SLEEP_EN1  ======================================================= */
#define CLOCKS_SLEEP_EN1_clk_sys_xosc_Pos (14UL)                    /*!< clk_sys_xosc (Bit 14) */
#define CLOCKS_SLEEP_EN1_clk_sys_xosc_Msk (0x4000UL)                /*!< clk_sys_xosc (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN1_clk_sys_xip_Pos  (13UL)                    /*!< clk_sys_xip (Bit 13) */
#define CLOCKS_SLEEP_EN1_clk_sys_xip_Msk  (0x2000UL)                /*!< clk_sys_xip (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN1_clk_sys_watchdog_Pos (12UL)                /*!< clk_sys_watchdog (Bit 12) */
#define CLOCKS_SLEEP_EN1_clk_sys_watchdog_Msk (0x1000UL)            /*!< clk_sys_watchdog (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN1_clk_usb_usbctrl_Pos (11UL)                 /*!< clk_usb_usbctrl (Bit 11) */
#define CLOCKS_SLEEP_EN1_clk_usb_usbctrl_Msk (0x800UL)              /*!< clk_usb_usbctrl (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN1_clk_sys_usbctrl_Pos (10UL)                 /*!< clk_sys_usbctrl (Bit 10) */
#define CLOCKS_SLEEP_EN1_clk_sys_usbctrl_Msk (0x400UL)              /*!< clk_sys_usbctrl (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN1_clk_sys_uart1_Pos (9UL)                    /*!< clk_sys_uart1 (Bit 9) */
#define CLOCKS_SLEEP_EN1_clk_sys_uart1_Msk (0x200UL)                /*!< clk_sys_uart1 (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN1_clk_peri_uart1_Pos (8UL)                   /*!< clk_peri_uart1 (Bit 8) */
#define CLOCKS_SLEEP_EN1_clk_peri_uart1_Msk (0x100UL)               /*!< clk_peri_uart1 (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN1_clk_sys_uart0_Pos (7UL)                    /*!< clk_sys_uart0 (Bit 7) */
#define CLOCKS_SLEEP_EN1_clk_sys_uart0_Msk (0x80UL)                 /*!< clk_sys_uart0 (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN1_clk_peri_uart0_Pos (6UL)                   /*!< clk_peri_uart0 (Bit 6) */
#define CLOCKS_SLEEP_EN1_clk_peri_uart0_Msk (0x40UL)                /*!< clk_peri_uart0 (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN1_clk_sys_timer_Pos (5UL)                    /*!< clk_sys_timer (Bit 5) */
#define CLOCKS_SLEEP_EN1_clk_sys_timer_Msk (0x20UL)                 /*!< clk_sys_timer (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN1_clk_sys_tbman_Pos (4UL)                    /*!< clk_sys_tbman (Bit 4) */
#define CLOCKS_SLEEP_EN1_clk_sys_tbman_Msk (0x10UL)                 /*!< clk_sys_tbman (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN1_clk_sys_sysinfo_Pos (3UL)                  /*!< clk_sys_sysinfo (Bit 3) */
#define CLOCKS_SLEEP_EN1_clk_sys_sysinfo_Msk (0x8UL)                /*!< clk_sys_sysinfo (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN1_clk_sys_syscfg_Pos (2UL)                   /*!< clk_sys_syscfg (Bit 2) */
#define CLOCKS_SLEEP_EN1_clk_sys_syscfg_Msk (0x4UL)                 /*!< clk_sys_syscfg (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN1_clk_sys_sram5_Pos (1UL)                    /*!< clk_sys_sram5 (Bit 1) */
#define CLOCKS_SLEEP_EN1_clk_sys_sram5_Msk (0x2UL)                  /*!< clk_sys_sram5 (Bitfield-Mask: 0x01) */
#define CLOCKS_SLEEP_EN1_clk_sys_sram4_Pos (0UL)                    /*!< clk_sys_sram4 (Bit 0) */
#define CLOCKS_SLEEP_EN1_clk_sys_sram4_Msk (0x1UL)                  /*!< clk_sys_sram4 (Bitfield-Mask: 0x01) */
/* =======================================================  ENABLED0  ======================================================== */
#define CLOCKS_ENABLED0_clk_sys_sram3_Pos (31UL)                    /*!< clk_sys_sram3 (Bit 31) */
#define CLOCKS_ENABLED0_clk_sys_sram3_Msk (0x80000000UL)            /*!< clk_sys_sram3 (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_sys_sram2_Pos (30UL)                    /*!< clk_sys_sram2 (Bit 30) */
#define CLOCKS_ENABLED0_clk_sys_sram2_Msk (0x40000000UL)            /*!< clk_sys_sram2 (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_sys_sram1_Pos (29UL)                    /*!< clk_sys_sram1 (Bit 29) */
#define CLOCKS_ENABLED0_clk_sys_sram1_Msk (0x20000000UL)            /*!< clk_sys_sram1 (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_sys_sram0_Pos (28UL)                    /*!< clk_sys_sram0 (Bit 28) */
#define CLOCKS_ENABLED0_clk_sys_sram0_Msk (0x10000000UL)            /*!< clk_sys_sram0 (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_sys_spi1_Pos  (27UL)                    /*!< clk_sys_spi1 (Bit 27) */
#define CLOCKS_ENABLED0_clk_sys_spi1_Msk  (0x8000000UL)             /*!< clk_sys_spi1 (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_peri_spi1_Pos (26UL)                    /*!< clk_peri_spi1 (Bit 26) */
#define CLOCKS_ENABLED0_clk_peri_spi1_Msk (0x4000000UL)             /*!< clk_peri_spi1 (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_sys_spi0_Pos  (25UL)                    /*!< clk_sys_spi0 (Bit 25) */
#define CLOCKS_ENABLED0_clk_sys_spi0_Msk  (0x2000000UL)             /*!< clk_sys_spi0 (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_peri_spi0_Pos (24UL)                    /*!< clk_peri_spi0 (Bit 24) */
#define CLOCKS_ENABLED0_clk_peri_spi0_Msk (0x1000000UL)             /*!< clk_peri_spi0 (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_sys_sio_Pos   (23UL)                    /*!< clk_sys_sio (Bit 23) */
#define CLOCKS_ENABLED0_clk_sys_sio_Msk   (0x800000UL)              /*!< clk_sys_sio (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_sys_rtc_Pos   (22UL)                    /*!< clk_sys_rtc (Bit 22) */
#define CLOCKS_ENABLED0_clk_sys_rtc_Msk   (0x400000UL)              /*!< clk_sys_rtc (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_rtc_rtc_Pos   (21UL)                    /*!< clk_rtc_rtc (Bit 21) */
#define CLOCKS_ENABLED0_clk_rtc_rtc_Msk   (0x200000UL)              /*!< clk_rtc_rtc (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_sys_rosc_Pos  (20UL)                    /*!< clk_sys_rosc (Bit 20) */
#define CLOCKS_ENABLED0_clk_sys_rosc_Msk  (0x100000UL)              /*!< clk_sys_rosc (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_sys_rom_Pos   (19UL)                    /*!< clk_sys_rom (Bit 19) */
#define CLOCKS_ENABLED0_clk_sys_rom_Msk   (0x80000UL)               /*!< clk_sys_rom (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_sys_resets_Pos (18UL)                   /*!< clk_sys_resets (Bit 18) */
#define CLOCKS_ENABLED0_clk_sys_resets_Msk (0x40000UL)              /*!< clk_sys_resets (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_sys_pwm_Pos   (17UL)                    /*!< clk_sys_pwm (Bit 17) */
#define CLOCKS_ENABLED0_clk_sys_pwm_Msk   (0x20000UL)               /*!< clk_sys_pwm (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_sys_psm_Pos   (16UL)                    /*!< clk_sys_psm (Bit 16) */
#define CLOCKS_ENABLED0_clk_sys_psm_Msk   (0x10000UL)               /*!< clk_sys_psm (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_sys_pll_usb_Pos (15UL)                  /*!< clk_sys_pll_usb (Bit 15) */
#define CLOCKS_ENABLED0_clk_sys_pll_usb_Msk (0x8000UL)              /*!< clk_sys_pll_usb (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_sys_pll_sys_Pos (14UL)                  /*!< clk_sys_pll_sys (Bit 14) */
#define CLOCKS_ENABLED0_clk_sys_pll_sys_Msk (0x4000UL)              /*!< clk_sys_pll_sys (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_sys_pio1_Pos  (13UL)                    /*!< clk_sys_pio1 (Bit 13) */
#define CLOCKS_ENABLED0_clk_sys_pio1_Msk  (0x2000UL)                /*!< clk_sys_pio1 (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_sys_pio0_Pos  (12UL)                    /*!< clk_sys_pio0 (Bit 12) */
#define CLOCKS_ENABLED0_clk_sys_pio0_Msk  (0x1000UL)                /*!< clk_sys_pio0 (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_sys_pads_Pos  (11UL)                    /*!< clk_sys_pads (Bit 11) */
#define CLOCKS_ENABLED0_clk_sys_pads_Msk  (0x800UL)                 /*!< clk_sys_pads (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_sys_vreg_and_chip_reset_Pos (10UL)      /*!< clk_sys_vreg_and_chip_reset (Bit 10) */
#define CLOCKS_ENABLED0_clk_sys_vreg_and_chip_reset_Msk (0x400UL)   /*!< clk_sys_vreg_and_chip_reset (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_sys_jtag_Pos  (9UL)                     /*!< clk_sys_jtag (Bit 9) */
#define CLOCKS_ENABLED0_clk_sys_jtag_Msk  (0x200UL)                 /*!< clk_sys_jtag (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_sys_io_Pos    (8UL)                     /*!< clk_sys_io (Bit 8) */
#define CLOCKS_ENABLED0_clk_sys_io_Msk    (0x100UL)                 /*!< clk_sys_io (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_sys_i2c1_Pos  (7UL)                     /*!< clk_sys_i2c1 (Bit 7) */
#define CLOCKS_ENABLED0_clk_sys_i2c1_Msk  (0x80UL)                  /*!< clk_sys_i2c1 (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_sys_i2c0_Pos  (6UL)                     /*!< clk_sys_i2c0 (Bit 6) */
#define CLOCKS_ENABLED0_clk_sys_i2c0_Msk  (0x40UL)                  /*!< clk_sys_i2c0 (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_sys_dma_Pos   (5UL)                     /*!< clk_sys_dma (Bit 5) */
#define CLOCKS_ENABLED0_clk_sys_dma_Msk   (0x20UL)                  /*!< clk_sys_dma (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_sys_busfabric_Pos (4UL)                 /*!< clk_sys_busfabric (Bit 4) */
#define CLOCKS_ENABLED0_clk_sys_busfabric_Msk (0x10UL)              /*!< clk_sys_busfabric (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_sys_busctrl_Pos (3UL)                   /*!< clk_sys_busctrl (Bit 3) */
#define CLOCKS_ENABLED0_clk_sys_busctrl_Msk (0x8UL)                 /*!< clk_sys_busctrl (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_sys_adc_Pos   (2UL)                     /*!< clk_sys_adc (Bit 2) */
#define CLOCKS_ENABLED0_clk_sys_adc_Msk   (0x4UL)                   /*!< clk_sys_adc (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_adc_adc_Pos   (1UL)                     /*!< clk_adc_adc (Bit 1) */
#define CLOCKS_ENABLED0_clk_adc_adc_Msk   (0x2UL)                   /*!< clk_adc_adc (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED0_clk_sys_clocks_Pos (0UL)                    /*!< clk_sys_clocks (Bit 0) */
#define CLOCKS_ENABLED0_clk_sys_clocks_Msk (0x1UL)                  /*!< clk_sys_clocks (Bitfield-Mask: 0x01) */
/* =======================================================  ENABLED1  ======================================================== */
#define CLOCKS_ENABLED1_clk_sys_xosc_Pos  (14UL)                    /*!< clk_sys_xosc (Bit 14) */
#define CLOCKS_ENABLED1_clk_sys_xosc_Msk  (0x4000UL)                /*!< clk_sys_xosc (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED1_clk_sys_xip_Pos   (13UL)                    /*!< clk_sys_xip (Bit 13) */
#define CLOCKS_ENABLED1_clk_sys_xip_Msk   (0x2000UL)                /*!< clk_sys_xip (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED1_clk_sys_watchdog_Pos (12UL)                 /*!< clk_sys_watchdog (Bit 12) */
#define CLOCKS_ENABLED1_clk_sys_watchdog_Msk (0x1000UL)             /*!< clk_sys_watchdog (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED1_clk_usb_usbctrl_Pos (11UL)                  /*!< clk_usb_usbctrl (Bit 11) */
#define CLOCKS_ENABLED1_clk_usb_usbctrl_Msk (0x800UL)               /*!< clk_usb_usbctrl (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED1_clk_sys_usbctrl_Pos (10UL)                  /*!< clk_sys_usbctrl (Bit 10) */
#define CLOCKS_ENABLED1_clk_sys_usbctrl_Msk (0x400UL)               /*!< clk_sys_usbctrl (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED1_clk_sys_uart1_Pos (9UL)                     /*!< clk_sys_uart1 (Bit 9) */
#define CLOCKS_ENABLED1_clk_sys_uart1_Msk (0x200UL)                 /*!< clk_sys_uart1 (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED1_clk_peri_uart1_Pos (8UL)                    /*!< clk_peri_uart1 (Bit 8) */
#define CLOCKS_ENABLED1_clk_peri_uart1_Msk (0x100UL)                /*!< clk_peri_uart1 (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED1_clk_sys_uart0_Pos (7UL)                     /*!< clk_sys_uart0 (Bit 7) */
#define CLOCKS_ENABLED1_clk_sys_uart0_Msk (0x80UL)                  /*!< clk_sys_uart0 (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED1_clk_peri_uart0_Pos (6UL)                    /*!< clk_peri_uart0 (Bit 6) */
#define CLOCKS_ENABLED1_clk_peri_uart0_Msk (0x40UL)                 /*!< clk_peri_uart0 (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED1_clk_sys_timer_Pos (5UL)                     /*!< clk_sys_timer (Bit 5) */
#define CLOCKS_ENABLED1_clk_sys_timer_Msk (0x20UL)                  /*!< clk_sys_timer (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED1_clk_sys_tbman_Pos (4UL)                     /*!< clk_sys_tbman (Bit 4) */
#define CLOCKS_ENABLED1_clk_sys_tbman_Msk (0x10UL)                  /*!< clk_sys_tbman (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED1_clk_sys_sysinfo_Pos (3UL)                   /*!< clk_sys_sysinfo (Bit 3) */
#define CLOCKS_ENABLED1_clk_sys_sysinfo_Msk (0x8UL)                 /*!< clk_sys_sysinfo (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED1_clk_sys_syscfg_Pos (2UL)                    /*!< clk_sys_syscfg (Bit 2) */
#define CLOCKS_ENABLED1_clk_sys_syscfg_Msk (0x4UL)                  /*!< clk_sys_syscfg (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED1_clk_sys_sram5_Pos (1UL)                     /*!< clk_sys_sram5 (Bit 1) */
#define CLOCKS_ENABLED1_clk_sys_sram5_Msk (0x2UL)                   /*!< clk_sys_sram5 (Bitfield-Mask: 0x01) */
#define CLOCKS_ENABLED1_clk_sys_sram4_Pos (0UL)                     /*!< clk_sys_sram4 (Bit 0) */
#define CLOCKS_ENABLED1_clk_sys_sram4_Msk (0x1UL)                   /*!< clk_sys_sram4 (Bitfield-Mask: 0x01) */
/* =========================================================  INTR  ========================================================== */
#define CLOCKS_INTR_CLK_SYS_RESUS_Pos     (0UL)                     /*!< CLK_SYS_RESUS (Bit 0) */
#define CLOCKS_INTR_CLK_SYS_RESUS_Msk     (0x1UL)                   /*!< CLK_SYS_RESUS (Bitfield-Mask: 0x01) */
/* =========================================================  INTE  ========================================================== */
#define CLOCKS_INTE_CLK_SYS_RESUS_Pos     (0UL)                     /*!< CLK_SYS_RESUS (Bit 0) */
#define CLOCKS_INTE_CLK_SYS_RESUS_Msk     (0x1UL)                   /*!< CLK_SYS_RESUS (Bitfield-Mask: 0x01) */
/* =========================================================  INTF  ========================================================== */
#define CLOCKS_INTF_CLK_SYS_RESUS_Pos     (0UL)                     /*!< CLK_SYS_RESUS (Bit 0) */
#define CLOCKS_INTF_CLK_SYS_RESUS_Msk     (0x1UL)                   /*!< CLK_SYS_RESUS (Bitfield-Mask: 0x01) */
/* =========================================================  INTS  ========================================================== */
#define CLOCKS_INTS_CLK_SYS_RESUS_Pos     (0UL)                     /*!< CLK_SYS_RESUS (Bit 0) */
#define CLOCKS_INTS_CLK_SYS_RESUS_Msk     (0x1UL)                   /*!< CLK_SYS_RESUS (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                          RESETS                                           ================ */
/* =========================================================================================================================== */

/* =========================================================  RESET  ========================================================= */
#define RESETS_RESET_usbctrl_Pos          (24UL)                    /*!< usbctrl (Bit 24) */
#define RESETS_RESET_usbctrl_Msk          (0x1000000UL)             /*!< usbctrl (Bitfield-Mask: 0x01) */
#define RESETS_RESET_uart1_Pos            (23UL)                    /*!< uart1 (Bit 23) */
#define RESETS_RESET_uart1_Msk            (0x800000UL)              /*!< uart1 (Bitfield-Mask: 0x01) */
#define RESETS_RESET_uart0_Pos            (22UL)                    /*!< uart0 (Bit 22) */
#define RESETS_RESET_uart0_Msk            (0x400000UL)              /*!< uart0 (Bitfield-Mask: 0x01) */
#define RESETS_RESET_timer_Pos            (21UL)                    /*!< timer (Bit 21) */
#define RESETS_RESET_timer_Msk            (0x200000UL)              /*!< timer (Bitfield-Mask: 0x01) */
#define RESETS_RESET_tbman_Pos            (20UL)                    /*!< tbman (Bit 20) */
#define RESETS_RESET_tbman_Msk            (0x100000UL)              /*!< tbman (Bitfield-Mask: 0x01) */
#define RESETS_RESET_sysinfo_Pos          (19UL)                    /*!< sysinfo (Bit 19) */
#define RESETS_RESET_sysinfo_Msk          (0x80000UL)               /*!< sysinfo (Bitfield-Mask: 0x01) */
#define RESETS_RESET_syscfg_Pos           (18UL)                    /*!< syscfg (Bit 18) */
#define RESETS_RESET_syscfg_Msk           (0x40000UL)               /*!< syscfg (Bitfield-Mask: 0x01) */
#define RESETS_RESET_spi1_Pos             (17UL)                    /*!< spi1 (Bit 17) */
#define RESETS_RESET_spi1_Msk             (0x20000UL)               /*!< spi1 (Bitfield-Mask: 0x01) */
#define RESETS_RESET_spi0_Pos             (16UL)                    /*!< spi0 (Bit 16) */
#define RESETS_RESET_spi0_Msk             (0x10000UL)               /*!< spi0 (Bitfield-Mask: 0x01) */
#define RESETS_RESET_rtc_Pos              (15UL)                    /*!< rtc (Bit 15) */
#define RESETS_RESET_rtc_Msk              (0x8000UL)                /*!< rtc (Bitfield-Mask: 0x01) */
#define RESETS_RESET_pwm_Pos              (14UL)                    /*!< pwm (Bit 14) */
#define RESETS_RESET_pwm_Msk              (0x4000UL)                /*!< pwm (Bitfield-Mask: 0x01) */
#define RESETS_RESET_pll_usb_Pos          (13UL)                    /*!< pll_usb (Bit 13) */
#define RESETS_RESET_pll_usb_Msk          (0x2000UL)                /*!< pll_usb (Bitfield-Mask: 0x01) */
#define RESETS_RESET_pll_sys_Pos          (12UL)                    /*!< pll_sys (Bit 12) */
#define RESETS_RESET_pll_sys_Msk          (0x1000UL)                /*!< pll_sys (Bitfield-Mask: 0x01) */
#define RESETS_RESET_pio1_Pos             (11UL)                    /*!< pio1 (Bit 11) */
#define RESETS_RESET_pio1_Msk             (0x800UL)                 /*!< pio1 (Bitfield-Mask: 0x01) */
#define RESETS_RESET_pio0_Pos             (10UL)                    /*!< pio0 (Bit 10) */
#define RESETS_RESET_pio0_Msk             (0x400UL)                 /*!< pio0 (Bitfield-Mask: 0x01) */
#define RESETS_RESET_pads_qspi_Pos        (9UL)                     /*!< pads_qspi (Bit 9) */
#define RESETS_RESET_pads_qspi_Msk        (0x200UL)                 /*!< pads_qspi (Bitfield-Mask: 0x01) */
#define RESETS_RESET_pads_bank0_Pos       (8UL)                     /*!< pads_bank0 (Bit 8) */
#define RESETS_RESET_pads_bank0_Msk       (0x100UL)                 /*!< pads_bank0 (Bitfield-Mask: 0x01) */
#define RESETS_RESET_jtag_Pos             (7UL)                     /*!< jtag (Bit 7) */
#define RESETS_RESET_jtag_Msk             (0x80UL)                  /*!< jtag (Bitfield-Mask: 0x01) */
#define RESETS_RESET_io_qspi_Pos          (6UL)                     /*!< io_qspi (Bit 6) */
#define RESETS_RESET_io_qspi_Msk          (0x40UL)                  /*!< io_qspi (Bitfield-Mask: 0x01) */
#define RESETS_RESET_io_bank0_Pos         (5UL)                     /*!< io_bank0 (Bit 5) */
#define RESETS_RESET_io_bank0_Msk         (0x20UL)                  /*!< io_bank0 (Bitfield-Mask: 0x01) */
#define RESETS_RESET_i2c1_Pos             (4UL)                     /*!< i2c1 (Bit 4) */
#define RESETS_RESET_i2c1_Msk             (0x10UL)                  /*!< i2c1 (Bitfield-Mask: 0x01) */
#define RESETS_RESET_i2c0_Pos             (3UL)                     /*!< i2c0 (Bit 3) */
#define RESETS_RESET_i2c0_Msk             (0x8UL)                   /*!< i2c0 (Bitfield-Mask: 0x01) */
#define RESETS_RESET_dma_Pos              (2UL)                     /*!< dma (Bit 2) */
#define RESETS_RESET_dma_Msk              (0x4UL)                   /*!< dma (Bitfield-Mask: 0x01) */
#define RESETS_RESET_busctrl_Pos          (1UL)                     /*!< busctrl (Bit 1) */
#define RESETS_RESET_busctrl_Msk          (0x2UL)                   /*!< busctrl (Bitfield-Mask: 0x01) */
#define RESETS_RESET_adc_Pos              (0UL)                     /*!< adc (Bit 0) */
#define RESETS_RESET_adc_Msk              (0x1UL)                   /*!< adc (Bitfield-Mask: 0x01) */
/* =========================================================  WDSEL  ========================================================= */
#define RESETS_WDSEL_usbctrl_Pos          (24UL)                    /*!< usbctrl (Bit 24) */
#define RESETS_WDSEL_usbctrl_Msk          (0x1000000UL)             /*!< usbctrl (Bitfield-Mask: 0x01) */
#define RESETS_WDSEL_uart1_Pos            (23UL)                    /*!< uart1 (Bit 23) */
#define RESETS_WDSEL_uart1_Msk            (0x800000UL)              /*!< uart1 (Bitfield-Mask: 0x01) */
#define RESETS_WDSEL_uart0_Pos            (22UL)                    /*!< uart0 (Bit 22) */
#define RESETS_WDSEL_uart0_Msk            (0x400000UL)              /*!< uart0 (Bitfield-Mask: 0x01) */
#define RESETS_WDSEL_timer_Pos            (21UL)                    /*!< timer (Bit 21) */
#define RESETS_WDSEL_timer_Msk            (0x200000UL)              /*!< timer (Bitfield-Mask: 0x01) */
#define RESETS_WDSEL_tbman_Pos            (20UL)                    /*!< tbman (Bit 20) */
#define RESETS_WDSEL_tbman_Msk            (0x100000UL)              /*!< tbman (Bitfield-Mask: 0x01) */
#define RESETS_WDSEL_sysinfo_Pos          (19UL)                    /*!< sysinfo (Bit 19) */
#define RESETS_WDSEL_sysinfo_Msk          (0x80000UL)               /*!< sysinfo (Bitfield-Mask: 0x01) */
#define RESETS_WDSEL_syscfg_Pos           (18UL)                    /*!< syscfg (Bit 18) */
#define RESETS_WDSEL_syscfg_Msk           (0x40000UL)               /*!< syscfg (Bitfield-Mask: 0x01) */
#define RESETS_WDSEL_spi1_Pos             (17UL)                    /*!< spi1 (Bit 17) */
#define RESETS_WDSEL_spi1_Msk             (0x20000UL)               /*!< spi1 (Bitfield-Mask: 0x01) */
#define RESETS_WDSEL_spi0_Pos             (16UL)                    /*!< spi0 (Bit 16) */
#define RESETS_WDSEL_spi0_Msk             (0x10000UL)               /*!< spi0 (Bitfield-Mask: 0x01) */
#define RESETS_WDSEL_rtc_Pos              (15UL)                    /*!< rtc (Bit 15) */
#define RESETS_WDSEL_rtc_Msk              (0x8000UL)                /*!< rtc (Bitfield-Mask: 0x01) */
#define RESETS_WDSEL_pwm_Pos              (14UL)                    /*!< pwm (Bit 14) */
#define RESETS_WDSEL_pwm_Msk              (0x4000UL)                /*!< pwm (Bitfield-Mask: 0x01) */
#define RESETS_WDSEL_pll_usb_Pos          (13UL)                    /*!< pll_usb (Bit 13) */
#define RESETS_WDSEL_pll_usb_Msk          (0x2000UL)                /*!< pll_usb (Bitfield-Mask: 0x01) */
#define RESETS_WDSEL_pll_sys_Pos          (12UL)                    /*!< pll_sys (Bit 12) */
#define RESETS_WDSEL_pll_sys_Msk          (0x1000UL)                /*!< pll_sys (Bitfield-Mask: 0x01) */
#define RESETS_WDSEL_pio1_Pos             (11UL)                    /*!< pio1 (Bit 11) */
#define RESETS_WDSEL_pio1_Msk             (0x800UL)                 /*!< pio1 (Bitfield-Mask: 0x01) */
#define RESETS_WDSEL_pio0_Pos             (10UL)                    /*!< pio0 (Bit 10) */
#define RESETS_WDSEL_pio0_Msk             (0x400UL)                 /*!< pio0 (Bitfield-Mask: 0x01) */
#define RESETS_WDSEL_pads_qspi_Pos        (9UL)                     /*!< pads_qspi (Bit 9) */
#define RESETS_WDSEL_pads_qspi_Msk        (0x200UL)                 /*!< pads_qspi (Bitfield-Mask: 0x01) */
#define RESETS_WDSEL_pads_bank0_Pos       (8UL)                     /*!< pads_bank0 (Bit 8) */
#define RESETS_WDSEL_pads_bank0_Msk       (0x100UL)                 /*!< pads_bank0 (Bitfield-Mask: 0x01) */
#define RESETS_WDSEL_jtag_Pos             (7UL)                     /*!< jtag (Bit 7) */
#define RESETS_WDSEL_jtag_Msk             (0x80UL)                  /*!< jtag (Bitfield-Mask: 0x01) */
#define RESETS_WDSEL_io_qspi_Pos          (6UL)                     /*!< io_qspi (Bit 6) */
#define RESETS_WDSEL_io_qspi_Msk          (0x40UL)                  /*!< io_qspi (Bitfield-Mask: 0x01) */
#define RESETS_WDSEL_io_bank0_Pos         (5UL)                     /*!< io_bank0 (Bit 5) */
#define RESETS_WDSEL_io_bank0_Msk         (0x20UL)                  /*!< io_bank0 (Bitfield-Mask: 0x01) */
#define RESETS_WDSEL_i2c1_Pos             (4UL)                     /*!< i2c1 (Bit 4) */
#define RESETS_WDSEL_i2c1_Msk             (0x10UL)                  /*!< i2c1 (Bitfield-Mask: 0x01) */
#define RESETS_WDSEL_i2c0_Pos             (3UL)                     /*!< i2c0 (Bit 3) */
#define RESETS_WDSEL_i2c0_Msk             (0x8UL)                   /*!< i2c0 (Bitfield-Mask: 0x01) */
#define RESETS_WDSEL_dma_Pos              (2UL)                     /*!< dma (Bit 2) */
#define RESETS_WDSEL_dma_Msk              (0x4UL)                   /*!< dma (Bitfield-Mask: 0x01) */
#define RESETS_WDSEL_busctrl_Pos          (1UL)                     /*!< busctrl (Bit 1) */
#define RESETS_WDSEL_busctrl_Msk          (0x2UL)                   /*!< busctrl (Bitfield-Mask: 0x01) */
#define RESETS_WDSEL_adc_Pos              (0UL)                     /*!< adc (Bit 0) */
#define RESETS_WDSEL_adc_Msk              (0x1UL)                   /*!< adc (Bitfield-Mask: 0x01) */
/* ======================================================  RESET_DONE  ======================================================= */
#define RESETS_RESET_DONE_usbctrl_Pos     (24UL)                    /*!< usbctrl (Bit 24) */
#define RESETS_RESET_DONE_usbctrl_Msk     (0x1000000UL)             /*!< usbctrl (Bitfield-Mask: 0x01) */
#define RESETS_RESET_DONE_uart1_Pos       (23UL)                    /*!< uart1 (Bit 23) */
#define RESETS_RESET_DONE_uart1_Msk       (0x800000UL)              /*!< uart1 (Bitfield-Mask: 0x01) */
#define RESETS_RESET_DONE_uart0_Pos       (22UL)                    /*!< uart0 (Bit 22) */
#define RESETS_RESET_DONE_uart0_Msk       (0x400000UL)              /*!< uart0 (Bitfield-Mask: 0x01) */
#define RESETS_RESET_DONE_timer_Pos       (21UL)                    /*!< timer (Bit 21) */
#define RESETS_RESET_DONE_timer_Msk       (0x200000UL)              /*!< timer (Bitfield-Mask: 0x01) */
#define RESETS_RESET_DONE_tbman_Pos       (20UL)                    /*!< tbman (Bit 20) */
#define RESETS_RESET_DONE_tbman_Msk       (0x100000UL)              /*!< tbman (Bitfield-Mask: 0x01) */
#define RESETS_RESET_DONE_sysinfo_Pos     (19UL)                    /*!< sysinfo (Bit 19) */
#define RESETS_RESET_DONE_sysinfo_Msk     (0x80000UL)               /*!< sysinfo (Bitfield-Mask: 0x01) */
#define RESETS_RESET_DONE_syscfg_Pos      (18UL)                    /*!< syscfg (Bit 18) */
#define RESETS_RESET_DONE_syscfg_Msk      (0x40000UL)               /*!< syscfg (Bitfield-Mask: 0x01) */
#define RESETS_RESET_DONE_spi1_Pos        (17UL)                    /*!< spi1 (Bit 17) */
#define RESETS_RESET_DONE_spi1_Msk        (0x20000UL)               /*!< spi1 (Bitfield-Mask: 0x01) */
#define RESETS_RESET_DONE_spi0_Pos        (16UL)                    /*!< spi0 (Bit 16) */
#define RESETS_RESET_DONE_spi0_Msk        (0x10000UL)               /*!< spi0 (Bitfield-Mask: 0x01) */
#define RESETS_RESET_DONE_rtc_Pos         (15UL)                    /*!< rtc (Bit 15) */
#define RESETS_RESET_DONE_rtc_Msk         (0x8000UL)                /*!< rtc (Bitfield-Mask: 0x01) */
#define RESETS_RESET_DONE_pwm_Pos         (14UL)                    /*!< pwm (Bit 14) */
#define RESETS_RESET_DONE_pwm_Msk         (0x4000UL)                /*!< pwm (Bitfield-Mask: 0x01) */
#define RESETS_RESET_DONE_pll_usb_Pos     (13UL)                    /*!< pll_usb (Bit 13) */
#define RESETS_RESET_DONE_pll_usb_Msk     (0x2000UL)                /*!< pll_usb (Bitfield-Mask: 0x01) */
#define RESETS_RESET_DONE_pll_sys_Pos     (12UL)                    /*!< pll_sys (Bit 12) */
#define RESETS_RESET_DONE_pll_sys_Msk     (0x1000UL)                /*!< pll_sys (Bitfield-Mask: 0x01) */
#define RESETS_RESET_DONE_pio1_Pos        (11UL)                    /*!< pio1 (Bit 11) */
#define RESETS_RESET_DONE_pio1_Msk        (0x800UL)                 /*!< pio1 (Bitfield-Mask: 0x01) */
#define RESETS_RESET_DONE_pio0_Pos        (10UL)                    /*!< pio0 (Bit 10) */
#define RESETS_RESET_DONE_pio0_Msk        (0x400UL)                 /*!< pio0 (Bitfield-Mask: 0x01) */
#define RESETS_RESET_DONE_pads_qspi_Pos   (9UL)                     /*!< pads_qspi (Bit 9) */
#define RESETS_RESET_DONE_pads_qspi_Msk   (0x200UL)                 /*!< pads_qspi (Bitfield-Mask: 0x01) */
#define RESETS_RESET_DONE_pads_bank0_Pos  (8UL)                     /*!< pads_bank0 (Bit 8) */
#define RESETS_RESET_DONE_pads_bank0_Msk  (0x100UL)                 /*!< pads_bank0 (Bitfield-Mask: 0x01) */
#define RESETS_RESET_DONE_jtag_Pos        (7UL)                     /*!< jtag (Bit 7) */
#define RESETS_RESET_DONE_jtag_Msk        (0x80UL)                  /*!< jtag (Bitfield-Mask: 0x01) */
#define RESETS_RESET_DONE_io_qspi_Pos     (6UL)                     /*!< io_qspi (Bit 6) */
#define RESETS_RESET_DONE_io_qspi_Msk     (0x40UL)                  /*!< io_qspi (Bitfield-Mask: 0x01) */
#define RESETS_RESET_DONE_io_bank0_Pos    (5UL)                     /*!< io_bank0 (Bit 5) */
#define RESETS_RESET_DONE_io_bank0_Msk    (0x20UL)                  /*!< io_bank0 (Bitfield-Mask: 0x01) */
#define RESETS_RESET_DONE_i2c1_Pos        (4UL)                     /*!< i2c1 (Bit 4) */
#define RESETS_RESET_DONE_i2c1_Msk        (0x10UL)                  /*!< i2c1 (Bitfield-Mask: 0x01) */
#define RESETS_RESET_DONE_i2c0_Pos        (3UL)                     /*!< i2c0 (Bit 3) */
#define RESETS_RESET_DONE_i2c0_Msk        (0x8UL)                   /*!< i2c0 (Bitfield-Mask: 0x01) */
#define RESETS_RESET_DONE_dma_Pos         (2UL)                     /*!< dma (Bit 2) */
#define RESETS_RESET_DONE_dma_Msk         (0x4UL)                   /*!< dma (Bitfield-Mask: 0x01) */
#define RESETS_RESET_DONE_busctrl_Pos     (1UL)                     /*!< busctrl (Bit 1) */
#define RESETS_RESET_DONE_busctrl_Msk     (0x2UL)                   /*!< busctrl (Bitfield-Mask: 0x01) */
#define RESETS_RESET_DONE_adc_Pos         (0UL)                     /*!< adc (Bit 0) */
#define RESETS_RESET_DONE_adc_Msk         (0x1UL)                   /*!< adc (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                            PSM                                            ================ */
/* =========================================================================================================================== */

/* ========================================================  FRCE_ON  ======================================================== */
#define PSM_FRCE_ON_proc1_Pos             (16UL)                    /*!< proc1 (Bit 16) */
#define PSM_FRCE_ON_proc1_Msk             (0x10000UL)               /*!< proc1 (Bitfield-Mask: 0x01) */
#define PSM_FRCE_ON_proc0_Pos             (15UL)                    /*!< proc0 (Bit 15) */
#define PSM_FRCE_ON_proc0_Msk             (0x8000UL)                /*!< proc0 (Bitfield-Mask: 0x01) */
#define PSM_FRCE_ON_sio_Pos               (14UL)                    /*!< sio (Bit 14) */
#define PSM_FRCE_ON_sio_Msk               (0x4000UL)                /*!< sio (Bitfield-Mask: 0x01) */
#define PSM_FRCE_ON_vreg_and_chip_reset_Pos (13UL)                  /*!< vreg_and_chip_reset (Bit 13) */
#define PSM_FRCE_ON_vreg_and_chip_reset_Msk (0x2000UL)              /*!< vreg_and_chip_reset (Bitfield-Mask: 0x01) */
#define PSM_FRCE_ON_xip_Pos               (12UL)                    /*!< xip (Bit 12) */
#define PSM_FRCE_ON_xip_Msk               (0x1000UL)                /*!< xip (Bitfield-Mask: 0x01) */
#define PSM_FRCE_ON_sram5_Pos             (11UL)                    /*!< sram5 (Bit 11) */
#define PSM_FRCE_ON_sram5_Msk             (0x800UL)                 /*!< sram5 (Bitfield-Mask: 0x01) */
#define PSM_FRCE_ON_sram4_Pos             (10UL)                    /*!< sram4 (Bit 10) */
#define PSM_FRCE_ON_sram4_Msk             (0x400UL)                 /*!< sram4 (Bitfield-Mask: 0x01) */
#define PSM_FRCE_ON_sram3_Pos             (9UL)                     /*!< sram3 (Bit 9) */
#define PSM_FRCE_ON_sram3_Msk             (0x200UL)                 /*!< sram3 (Bitfield-Mask: 0x01) */
#define PSM_FRCE_ON_sram2_Pos             (8UL)                     /*!< sram2 (Bit 8) */
#define PSM_FRCE_ON_sram2_Msk             (0x100UL)                 /*!< sram2 (Bitfield-Mask: 0x01) */
#define PSM_FRCE_ON_sram1_Pos             (7UL)                     /*!< sram1 (Bit 7) */
#define PSM_FRCE_ON_sram1_Msk             (0x80UL)                  /*!< sram1 (Bitfield-Mask: 0x01) */
#define PSM_FRCE_ON_sram0_Pos             (6UL)                     /*!< sram0 (Bit 6) */
#define PSM_FRCE_ON_sram0_Msk             (0x40UL)                  /*!< sram0 (Bitfield-Mask: 0x01) */
#define PSM_FRCE_ON_rom_Pos               (5UL)                     /*!< rom (Bit 5) */
#define PSM_FRCE_ON_rom_Msk               (0x20UL)                  /*!< rom (Bitfield-Mask: 0x01) */
#define PSM_FRCE_ON_busfabric_Pos         (4UL)                     /*!< busfabric (Bit 4) */
#define PSM_FRCE_ON_busfabric_Msk         (0x10UL)                  /*!< busfabric (Bitfield-Mask: 0x01) */
#define PSM_FRCE_ON_resets_Pos            (3UL)                     /*!< resets (Bit 3) */
#define PSM_FRCE_ON_resets_Msk            (0x8UL)                   /*!< resets (Bitfield-Mask: 0x01) */
#define PSM_FRCE_ON_clocks_Pos            (2UL)                     /*!< clocks (Bit 2) */
#define PSM_FRCE_ON_clocks_Msk            (0x4UL)                   /*!< clocks (Bitfield-Mask: 0x01) */
#define PSM_FRCE_ON_xosc_Pos              (1UL)                     /*!< xosc (Bit 1) */
#define PSM_FRCE_ON_xosc_Msk              (0x2UL)                   /*!< xosc (Bitfield-Mask: 0x01) */
#define PSM_FRCE_ON_rosc_Pos              (0UL)                     /*!< rosc (Bit 0) */
#define PSM_FRCE_ON_rosc_Msk              (0x1UL)                   /*!< rosc (Bitfield-Mask: 0x01) */
/* =======================================================  FRCE_OFF  ======================================================== */
#define PSM_FRCE_OFF_proc1_Pos            (16UL)                    /*!< proc1 (Bit 16) */
#define PSM_FRCE_OFF_proc1_Msk            (0x10000UL)               /*!< proc1 (Bitfield-Mask: 0x01) */
#define PSM_FRCE_OFF_proc0_Pos            (15UL)                    /*!< proc0 (Bit 15) */
#define PSM_FRCE_OFF_proc0_Msk            (0x8000UL)                /*!< proc0 (Bitfield-Mask: 0x01) */
#define PSM_FRCE_OFF_sio_Pos              (14UL)                    /*!< sio (Bit 14) */
#define PSM_FRCE_OFF_sio_Msk              (0x4000UL)                /*!< sio (Bitfield-Mask: 0x01) */
#define PSM_FRCE_OFF_vreg_and_chip_reset_Pos (13UL)                 /*!< vreg_and_chip_reset (Bit 13) */
#define PSM_FRCE_OFF_vreg_and_chip_reset_Msk (0x2000UL)             /*!< vreg_and_chip_reset (Bitfield-Mask: 0x01) */
#define PSM_FRCE_OFF_xip_Pos              (12UL)                    /*!< xip (Bit 12) */
#define PSM_FRCE_OFF_xip_Msk              (0x1000UL)                /*!< xip (Bitfield-Mask: 0x01) */
#define PSM_FRCE_OFF_sram5_Pos            (11UL)                    /*!< sram5 (Bit 11) */
#define PSM_FRCE_OFF_sram5_Msk            (0x800UL)                 /*!< sram5 (Bitfield-Mask: 0x01) */
#define PSM_FRCE_OFF_sram4_Pos            (10UL)                    /*!< sram4 (Bit 10) */
#define PSM_FRCE_OFF_sram4_Msk            (0x400UL)                 /*!< sram4 (Bitfield-Mask: 0x01) */
#define PSM_FRCE_OFF_sram3_Pos            (9UL)                     /*!< sram3 (Bit 9) */
#define PSM_FRCE_OFF_sram3_Msk            (0x200UL)                 /*!< sram3 (Bitfield-Mask: 0x01) */
#define PSM_FRCE_OFF_sram2_Pos            (8UL)                     /*!< sram2 (Bit 8) */
#define PSM_FRCE_OFF_sram2_Msk            (0x100UL)                 /*!< sram2 (Bitfield-Mask: 0x01) */
#define PSM_FRCE_OFF_sram1_Pos            (7UL)                     /*!< sram1 (Bit 7) */
#define PSM_FRCE_OFF_sram1_Msk            (0x80UL)                  /*!< sram1 (Bitfield-Mask: 0x01) */
#define PSM_FRCE_OFF_sram0_Pos            (6UL)                     /*!< sram0 (Bit 6) */
#define PSM_FRCE_OFF_sram0_Msk            (0x40UL)                  /*!< sram0 (Bitfield-Mask: 0x01) */
#define PSM_FRCE_OFF_rom_Pos              (5UL)                     /*!< rom (Bit 5) */
#define PSM_FRCE_OFF_rom_Msk              (0x20UL)                  /*!< rom (Bitfield-Mask: 0x01) */
#define PSM_FRCE_OFF_busfabric_Pos        (4UL)                     /*!< busfabric (Bit 4) */
#define PSM_FRCE_OFF_busfabric_Msk        (0x10UL)                  /*!< busfabric (Bitfield-Mask: 0x01) */
#define PSM_FRCE_OFF_resets_Pos           (3UL)                     /*!< resets (Bit 3) */
#define PSM_FRCE_OFF_resets_Msk           (0x8UL)                   /*!< resets (Bitfield-Mask: 0x01) */
#define PSM_FRCE_OFF_clocks_Pos           (2UL)                     /*!< clocks (Bit 2) */
#define PSM_FRCE_OFF_clocks_Msk           (0x4UL)                   /*!< clocks (Bitfield-Mask: 0x01) */
#define PSM_FRCE_OFF_xosc_Pos             (1UL)                     /*!< xosc (Bit 1) */
#define PSM_FRCE_OFF_xosc_Msk             (0x2UL)                   /*!< xosc (Bitfield-Mask: 0x01) */
#define PSM_FRCE_OFF_rosc_Pos             (0UL)                     /*!< rosc (Bit 0) */
#define PSM_FRCE_OFF_rosc_Msk             (0x1UL)                   /*!< rosc (Bitfield-Mask: 0x01) */
/* =========================================================  WDSEL  ========================================================= */
#define PSM_WDSEL_proc1_Pos               (16UL)                    /*!< proc1 (Bit 16) */
#define PSM_WDSEL_proc1_Msk               (0x10000UL)               /*!< proc1 (Bitfield-Mask: 0x01) */
#define PSM_WDSEL_proc0_Pos               (15UL)                    /*!< proc0 (Bit 15) */
#define PSM_WDSEL_proc0_Msk               (0x8000UL)                /*!< proc0 (Bitfield-Mask: 0x01) */
#define PSM_WDSEL_sio_Pos                 (14UL)                    /*!< sio (Bit 14) */
#define PSM_WDSEL_sio_Msk                 (0x4000UL)                /*!< sio (Bitfield-Mask: 0x01) */
#define PSM_WDSEL_vreg_and_chip_reset_Pos (13UL)                    /*!< vreg_and_chip_reset (Bit 13) */
#define PSM_WDSEL_vreg_and_chip_reset_Msk (0x2000UL)                /*!< vreg_and_chip_reset (Bitfield-Mask: 0x01) */
#define PSM_WDSEL_xip_Pos                 (12UL)                    /*!< xip (Bit 12) */
#define PSM_WDSEL_xip_Msk                 (0x1000UL)                /*!< xip (Bitfield-Mask: 0x01) */
#define PSM_WDSEL_sram5_Pos               (11UL)                    /*!< sram5 (Bit 11) */
#define PSM_WDSEL_sram5_Msk               (0x800UL)                 /*!< sram5 (Bitfield-Mask: 0x01) */
#define PSM_WDSEL_sram4_Pos               (10UL)                    /*!< sram4 (Bit 10) */
#define PSM_WDSEL_sram4_Msk               (0x400UL)                 /*!< sram4 (Bitfield-Mask: 0x01) */
#define PSM_WDSEL_sram3_Pos               (9UL)                     /*!< sram3 (Bit 9) */
#define PSM_WDSEL_sram3_Msk               (0x200UL)                 /*!< sram3 (Bitfield-Mask: 0x01) */
#define PSM_WDSEL_sram2_Pos               (8UL)                     /*!< sram2 (Bit 8) */
#define PSM_WDSEL_sram2_Msk               (0x100UL)                 /*!< sram2 (Bitfield-Mask: 0x01) */
#define PSM_WDSEL_sram1_Pos               (7UL)                     /*!< sram1 (Bit 7) */
#define PSM_WDSEL_sram1_Msk               (0x80UL)                  /*!< sram1 (Bitfield-Mask: 0x01) */
#define PSM_WDSEL_sram0_Pos               (6UL)                     /*!< sram0 (Bit 6) */
#define PSM_WDSEL_sram0_Msk               (0x40UL)                  /*!< sram0 (Bitfield-Mask: 0x01) */
#define PSM_WDSEL_rom_Pos                 (5UL)                     /*!< rom (Bit 5) */
#define PSM_WDSEL_rom_Msk                 (0x20UL)                  /*!< rom (Bitfield-Mask: 0x01) */
#define PSM_WDSEL_busfabric_Pos           (4UL)                     /*!< busfabric (Bit 4) */
#define PSM_WDSEL_busfabric_Msk           (0x10UL)                  /*!< busfabric (Bitfield-Mask: 0x01) */
#define PSM_WDSEL_resets_Pos              (3UL)                     /*!< resets (Bit 3) */
#define PSM_WDSEL_resets_Msk              (0x8UL)                   /*!< resets (Bitfield-Mask: 0x01) */
#define PSM_WDSEL_clocks_Pos              (2UL)                     /*!< clocks (Bit 2) */
#define PSM_WDSEL_clocks_Msk              (0x4UL)                   /*!< clocks (Bitfield-Mask: 0x01) */
#define PSM_WDSEL_xosc_Pos                (1UL)                     /*!< xosc (Bit 1) */
#define PSM_WDSEL_xosc_Msk                (0x2UL)                   /*!< xosc (Bitfield-Mask: 0x01) */
#define PSM_WDSEL_rosc_Pos                (0UL)                     /*!< rosc (Bit 0) */
#define PSM_WDSEL_rosc_Msk                (0x1UL)                   /*!< rosc (Bitfield-Mask: 0x01) */
/* =========================================================  DONE  ========================================================== */
#define PSM_DONE_proc1_Pos                (16UL)                    /*!< proc1 (Bit 16) */
#define PSM_DONE_proc1_Msk                (0x10000UL)               /*!< proc1 (Bitfield-Mask: 0x01) */
#define PSM_DONE_proc0_Pos                (15UL)                    /*!< proc0 (Bit 15) */
#define PSM_DONE_proc0_Msk                (0x8000UL)                /*!< proc0 (Bitfield-Mask: 0x01) */
#define PSM_DONE_sio_Pos                  (14UL)                    /*!< sio (Bit 14) */
#define PSM_DONE_sio_Msk                  (0x4000UL)                /*!< sio (Bitfield-Mask: 0x01) */
#define PSM_DONE_vreg_and_chip_reset_Pos  (13UL)                    /*!< vreg_and_chip_reset (Bit 13) */
#define PSM_DONE_vreg_and_chip_reset_Msk  (0x2000UL)                /*!< vreg_and_chip_reset (Bitfield-Mask: 0x01) */
#define PSM_DONE_xip_Pos                  (12UL)                    /*!< xip (Bit 12) */
#define PSM_DONE_xip_Msk                  (0x1000UL)                /*!< xip (Bitfield-Mask: 0x01) */
#define PSM_DONE_sram5_Pos                (11UL)                    /*!< sram5 (Bit 11) */
#define PSM_DONE_sram5_Msk                (0x800UL)                 /*!< sram5 (Bitfield-Mask: 0x01) */
#define PSM_DONE_sram4_Pos                (10UL)                    /*!< sram4 (Bit 10) */
#define PSM_DONE_sram4_Msk                (0x400UL)                 /*!< sram4 (Bitfield-Mask: 0x01) */
#define PSM_DONE_sram3_Pos                (9UL)                     /*!< sram3 (Bit 9) */
#define PSM_DONE_sram3_Msk                (0x200UL)                 /*!< sram3 (Bitfield-Mask: 0x01) */
#define PSM_DONE_sram2_Pos                (8UL)                     /*!< sram2 (Bit 8) */
#define PSM_DONE_sram2_Msk                (0x100UL)                 /*!< sram2 (Bitfield-Mask: 0x01) */
#define PSM_DONE_sram1_Pos                (7UL)                     /*!< sram1 (Bit 7) */
#define PSM_DONE_sram1_Msk                (0x80UL)                  /*!< sram1 (Bitfield-Mask: 0x01) */
#define PSM_DONE_sram0_Pos                (6UL)                     /*!< sram0 (Bit 6) */
#define PSM_DONE_sram0_Msk                (0x40UL)                  /*!< sram0 (Bitfield-Mask: 0x01) */
#define PSM_DONE_rom_Pos                  (5UL)                     /*!< rom (Bit 5) */
#define PSM_DONE_rom_Msk                  (0x20UL)                  /*!< rom (Bitfield-Mask: 0x01) */
#define PSM_DONE_busfabric_Pos            (4UL)                     /*!< busfabric (Bit 4) */
#define PSM_DONE_busfabric_Msk            (0x10UL)                  /*!< busfabric (Bitfield-Mask: 0x01) */
#define PSM_DONE_resets_Pos               (3UL)                     /*!< resets (Bit 3) */
#define PSM_DONE_resets_Msk               (0x8UL)                   /*!< resets (Bitfield-Mask: 0x01) */
#define PSM_DONE_clocks_Pos               (2UL)                     /*!< clocks (Bit 2) */
#define PSM_DONE_clocks_Msk               (0x4UL)                   /*!< clocks (Bitfield-Mask: 0x01) */
#define PSM_DONE_xosc_Pos                 (1UL)                     /*!< xosc (Bit 1) */
#define PSM_DONE_xosc_Msk                 (0x2UL)                   /*!< xosc (Bitfield-Mask: 0x01) */
#define PSM_DONE_rosc_Pos                 (0UL)                     /*!< rosc (Bit 0) */
#define PSM_DONE_rosc_Msk                 (0x1UL)                   /*!< rosc (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                         IO_BANK0                                          ================ */
/* =========================================================================================================================== */

/* =====================================================  GPIO0_STATUS  ====================================================== */
#define IO_BANK0_GPIO0_STATUS_IRQTOPROC_Pos (26UL)                  /*!< IRQTOPROC (Bit 26) */
#define IO_BANK0_GPIO0_STATUS_IRQTOPROC_Msk (0x4000000UL)           /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO0_STATUS_IRQFROMPAD_Pos (24UL)                 /*!< IRQFROMPAD (Bit 24) */
#define IO_BANK0_GPIO0_STATUS_IRQFROMPAD_Msk (0x1000000UL)          /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO0_STATUS_INTOPERI_Pos (19UL)                   /*!< INTOPERI (Bit 19) */
#define IO_BANK0_GPIO0_STATUS_INTOPERI_Msk (0x80000UL)              /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO0_STATUS_INFROMPAD_Pos (17UL)                  /*!< INFROMPAD (Bit 17) */
#define IO_BANK0_GPIO0_STATUS_INFROMPAD_Msk (0x20000UL)             /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO0_STATUS_OETOPAD_Pos (13UL)                    /*!< OETOPAD (Bit 13) */
#define IO_BANK0_GPIO0_STATUS_OETOPAD_Msk (0x2000UL)                /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO0_STATUS_OEFROMPERI_Pos (12UL)                 /*!< OEFROMPERI (Bit 12) */
#define IO_BANK0_GPIO0_STATUS_OEFROMPERI_Msk (0x1000UL)             /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO0_STATUS_OUTTOPAD_Pos (9UL)                    /*!< OUTTOPAD (Bit 9) */
#define IO_BANK0_GPIO0_STATUS_OUTTOPAD_Msk (0x200UL)                /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO0_STATUS_OUTFROMPERI_Pos (8UL)                 /*!< OUTFROMPERI (Bit 8) */
#define IO_BANK0_GPIO0_STATUS_OUTFROMPERI_Msk (0x100UL)             /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ======================================================  GPIO0_CTRL  ======================================================= */
#define IO_BANK0_GPIO0_CTRL_IRQOVER_Pos   (28UL)                    /*!< IRQOVER (Bit 28) */
#define IO_BANK0_GPIO0_CTRL_IRQOVER_Msk   (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO0_CTRL_INOVER_Pos    (16UL)                    /*!< INOVER (Bit 16) */
#define IO_BANK0_GPIO0_CTRL_INOVER_Msk    (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO0_CTRL_OEOVER_Pos    (12UL)                    /*!< OEOVER (Bit 12) */
#define IO_BANK0_GPIO0_CTRL_OEOVER_Msk    (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO0_CTRL_OUTOVER_Pos   (8UL)                     /*!< OUTOVER (Bit 8) */
#define IO_BANK0_GPIO0_CTRL_OUTOVER_Msk   (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO0_CTRL_FUNCSEL_Pos   (0UL)                     /*!< FUNCSEL (Bit 0) */
#define IO_BANK0_GPIO0_CTRL_FUNCSEL_Msk   (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  GPIO1_STATUS  ====================================================== */
#define IO_BANK0_GPIO1_STATUS_IRQTOPROC_Pos (26UL)                  /*!< IRQTOPROC (Bit 26) */
#define IO_BANK0_GPIO1_STATUS_IRQTOPROC_Msk (0x4000000UL)           /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO1_STATUS_IRQFROMPAD_Pos (24UL)                 /*!< IRQFROMPAD (Bit 24) */
#define IO_BANK0_GPIO1_STATUS_IRQFROMPAD_Msk (0x1000000UL)          /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO1_STATUS_INTOPERI_Pos (19UL)                   /*!< INTOPERI (Bit 19) */
#define IO_BANK0_GPIO1_STATUS_INTOPERI_Msk (0x80000UL)              /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO1_STATUS_INFROMPAD_Pos (17UL)                  /*!< INFROMPAD (Bit 17) */
#define IO_BANK0_GPIO1_STATUS_INFROMPAD_Msk (0x20000UL)             /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO1_STATUS_OETOPAD_Pos (13UL)                    /*!< OETOPAD (Bit 13) */
#define IO_BANK0_GPIO1_STATUS_OETOPAD_Msk (0x2000UL)                /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO1_STATUS_OEFROMPERI_Pos (12UL)                 /*!< OEFROMPERI (Bit 12) */
#define IO_BANK0_GPIO1_STATUS_OEFROMPERI_Msk (0x1000UL)             /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO1_STATUS_OUTTOPAD_Pos (9UL)                    /*!< OUTTOPAD (Bit 9) */
#define IO_BANK0_GPIO1_STATUS_OUTTOPAD_Msk (0x200UL)                /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO1_STATUS_OUTFROMPERI_Pos (8UL)                 /*!< OUTFROMPERI (Bit 8) */
#define IO_BANK0_GPIO1_STATUS_OUTFROMPERI_Msk (0x100UL)             /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ======================================================  GPIO1_CTRL  ======================================================= */
#define IO_BANK0_GPIO1_CTRL_IRQOVER_Pos   (28UL)                    /*!< IRQOVER (Bit 28) */
#define IO_BANK0_GPIO1_CTRL_IRQOVER_Msk   (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO1_CTRL_INOVER_Pos    (16UL)                    /*!< INOVER (Bit 16) */
#define IO_BANK0_GPIO1_CTRL_INOVER_Msk    (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO1_CTRL_OEOVER_Pos    (12UL)                    /*!< OEOVER (Bit 12) */
#define IO_BANK0_GPIO1_CTRL_OEOVER_Msk    (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO1_CTRL_OUTOVER_Pos   (8UL)                     /*!< OUTOVER (Bit 8) */
#define IO_BANK0_GPIO1_CTRL_OUTOVER_Msk   (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO1_CTRL_FUNCSEL_Pos   (0UL)                     /*!< FUNCSEL (Bit 0) */
#define IO_BANK0_GPIO1_CTRL_FUNCSEL_Msk   (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  GPIO2_STATUS  ====================================================== */
#define IO_BANK0_GPIO2_STATUS_IRQTOPROC_Pos (26UL)                  /*!< IRQTOPROC (Bit 26) */
#define IO_BANK0_GPIO2_STATUS_IRQTOPROC_Msk (0x4000000UL)           /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO2_STATUS_IRQFROMPAD_Pos (24UL)                 /*!< IRQFROMPAD (Bit 24) */
#define IO_BANK0_GPIO2_STATUS_IRQFROMPAD_Msk (0x1000000UL)          /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO2_STATUS_INTOPERI_Pos (19UL)                   /*!< INTOPERI (Bit 19) */
#define IO_BANK0_GPIO2_STATUS_INTOPERI_Msk (0x80000UL)              /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO2_STATUS_INFROMPAD_Pos (17UL)                  /*!< INFROMPAD (Bit 17) */
#define IO_BANK0_GPIO2_STATUS_INFROMPAD_Msk (0x20000UL)             /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO2_STATUS_OETOPAD_Pos (13UL)                    /*!< OETOPAD (Bit 13) */
#define IO_BANK0_GPIO2_STATUS_OETOPAD_Msk (0x2000UL)                /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO2_STATUS_OEFROMPERI_Pos (12UL)                 /*!< OEFROMPERI (Bit 12) */
#define IO_BANK0_GPIO2_STATUS_OEFROMPERI_Msk (0x1000UL)             /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO2_STATUS_OUTTOPAD_Pos (9UL)                    /*!< OUTTOPAD (Bit 9) */
#define IO_BANK0_GPIO2_STATUS_OUTTOPAD_Msk (0x200UL)                /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO2_STATUS_OUTFROMPERI_Pos (8UL)                 /*!< OUTFROMPERI (Bit 8) */
#define IO_BANK0_GPIO2_STATUS_OUTFROMPERI_Msk (0x100UL)             /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ======================================================  GPIO2_CTRL  ======================================================= */
#define IO_BANK0_GPIO2_CTRL_IRQOVER_Pos   (28UL)                    /*!< IRQOVER (Bit 28) */
#define IO_BANK0_GPIO2_CTRL_IRQOVER_Msk   (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO2_CTRL_INOVER_Pos    (16UL)                    /*!< INOVER (Bit 16) */
#define IO_BANK0_GPIO2_CTRL_INOVER_Msk    (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO2_CTRL_OEOVER_Pos    (12UL)                    /*!< OEOVER (Bit 12) */
#define IO_BANK0_GPIO2_CTRL_OEOVER_Msk    (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO2_CTRL_OUTOVER_Pos   (8UL)                     /*!< OUTOVER (Bit 8) */
#define IO_BANK0_GPIO2_CTRL_OUTOVER_Msk   (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO2_CTRL_FUNCSEL_Pos   (0UL)                     /*!< FUNCSEL (Bit 0) */
#define IO_BANK0_GPIO2_CTRL_FUNCSEL_Msk   (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  GPIO3_STATUS  ====================================================== */
#define IO_BANK0_GPIO3_STATUS_IRQTOPROC_Pos (26UL)                  /*!< IRQTOPROC (Bit 26) */
#define IO_BANK0_GPIO3_STATUS_IRQTOPROC_Msk (0x4000000UL)           /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO3_STATUS_IRQFROMPAD_Pos (24UL)                 /*!< IRQFROMPAD (Bit 24) */
#define IO_BANK0_GPIO3_STATUS_IRQFROMPAD_Msk (0x1000000UL)          /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO3_STATUS_INTOPERI_Pos (19UL)                   /*!< INTOPERI (Bit 19) */
#define IO_BANK0_GPIO3_STATUS_INTOPERI_Msk (0x80000UL)              /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO3_STATUS_INFROMPAD_Pos (17UL)                  /*!< INFROMPAD (Bit 17) */
#define IO_BANK0_GPIO3_STATUS_INFROMPAD_Msk (0x20000UL)             /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO3_STATUS_OETOPAD_Pos (13UL)                    /*!< OETOPAD (Bit 13) */
#define IO_BANK0_GPIO3_STATUS_OETOPAD_Msk (0x2000UL)                /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO3_STATUS_OEFROMPERI_Pos (12UL)                 /*!< OEFROMPERI (Bit 12) */
#define IO_BANK0_GPIO3_STATUS_OEFROMPERI_Msk (0x1000UL)             /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO3_STATUS_OUTTOPAD_Pos (9UL)                    /*!< OUTTOPAD (Bit 9) */
#define IO_BANK0_GPIO3_STATUS_OUTTOPAD_Msk (0x200UL)                /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO3_STATUS_OUTFROMPERI_Pos (8UL)                 /*!< OUTFROMPERI (Bit 8) */
#define IO_BANK0_GPIO3_STATUS_OUTFROMPERI_Msk (0x100UL)             /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ======================================================  GPIO3_CTRL  ======================================================= */
#define IO_BANK0_GPIO3_CTRL_IRQOVER_Pos   (28UL)                    /*!< IRQOVER (Bit 28) */
#define IO_BANK0_GPIO3_CTRL_IRQOVER_Msk   (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO3_CTRL_INOVER_Pos    (16UL)                    /*!< INOVER (Bit 16) */
#define IO_BANK0_GPIO3_CTRL_INOVER_Msk    (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO3_CTRL_OEOVER_Pos    (12UL)                    /*!< OEOVER (Bit 12) */
#define IO_BANK0_GPIO3_CTRL_OEOVER_Msk    (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO3_CTRL_OUTOVER_Pos   (8UL)                     /*!< OUTOVER (Bit 8) */
#define IO_BANK0_GPIO3_CTRL_OUTOVER_Msk   (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO3_CTRL_FUNCSEL_Pos   (0UL)                     /*!< FUNCSEL (Bit 0) */
#define IO_BANK0_GPIO3_CTRL_FUNCSEL_Msk   (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  GPIO4_STATUS  ====================================================== */
#define IO_BANK0_GPIO4_STATUS_IRQTOPROC_Pos (26UL)                  /*!< IRQTOPROC (Bit 26) */
#define IO_BANK0_GPIO4_STATUS_IRQTOPROC_Msk (0x4000000UL)           /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO4_STATUS_IRQFROMPAD_Pos (24UL)                 /*!< IRQFROMPAD (Bit 24) */
#define IO_BANK0_GPIO4_STATUS_IRQFROMPAD_Msk (0x1000000UL)          /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO4_STATUS_INTOPERI_Pos (19UL)                   /*!< INTOPERI (Bit 19) */
#define IO_BANK0_GPIO4_STATUS_INTOPERI_Msk (0x80000UL)              /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO4_STATUS_INFROMPAD_Pos (17UL)                  /*!< INFROMPAD (Bit 17) */
#define IO_BANK0_GPIO4_STATUS_INFROMPAD_Msk (0x20000UL)             /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO4_STATUS_OETOPAD_Pos (13UL)                    /*!< OETOPAD (Bit 13) */
#define IO_BANK0_GPIO4_STATUS_OETOPAD_Msk (0x2000UL)                /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO4_STATUS_OEFROMPERI_Pos (12UL)                 /*!< OEFROMPERI (Bit 12) */
#define IO_BANK0_GPIO4_STATUS_OEFROMPERI_Msk (0x1000UL)             /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO4_STATUS_OUTTOPAD_Pos (9UL)                    /*!< OUTTOPAD (Bit 9) */
#define IO_BANK0_GPIO4_STATUS_OUTTOPAD_Msk (0x200UL)                /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO4_STATUS_OUTFROMPERI_Pos (8UL)                 /*!< OUTFROMPERI (Bit 8) */
#define IO_BANK0_GPIO4_STATUS_OUTFROMPERI_Msk (0x100UL)             /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ======================================================  GPIO4_CTRL  ======================================================= */
#define IO_BANK0_GPIO4_CTRL_IRQOVER_Pos   (28UL)                    /*!< IRQOVER (Bit 28) */
#define IO_BANK0_GPIO4_CTRL_IRQOVER_Msk   (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO4_CTRL_INOVER_Pos    (16UL)                    /*!< INOVER (Bit 16) */
#define IO_BANK0_GPIO4_CTRL_INOVER_Msk    (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO4_CTRL_OEOVER_Pos    (12UL)                    /*!< OEOVER (Bit 12) */
#define IO_BANK0_GPIO4_CTRL_OEOVER_Msk    (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO4_CTRL_OUTOVER_Pos   (8UL)                     /*!< OUTOVER (Bit 8) */
#define IO_BANK0_GPIO4_CTRL_OUTOVER_Msk   (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO4_CTRL_FUNCSEL_Pos   (0UL)                     /*!< FUNCSEL (Bit 0) */
#define IO_BANK0_GPIO4_CTRL_FUNCSEL_Msk   (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  GPIO5_STATUS  ====================================================== */
#define IO_BANK0_GPIO5_STATUS_IRQTOPROC_Pos (26UL)                  /*!< IRQTOPROC (Bit 26) */
#define IO_BANK0_GPIO5_STATUS_IRQTOPROC_Msk (0x4000000UL)           /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO5_STATUS_IRQFROMPAD_Pos (24UL)                 /*!< IRQFROMPAD (Bit 24) */
#define IO_BANK0_GPIO5_STATUS_IRQFROMPAD_Msk (0x1000000UL)          /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO5_STATUS_INTOPERI_Pos (19UL)                   /*!< INTOPERI (Bit 19) */
#define IO_BANK0_GPIO5_STATUS_INTOPERI_Msk (0x80000UL)              /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO5_STATUS_INFROMPAD_Pos (17UL)                  /*!< INFROMPAD (Bit 17) */
#define IO_BANK0_GPIO5_STATUS_INFROMPAD_Msk (0x20000UL)             /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO5_STATUS_OETOPAD_Pos (13UL)                    /*!< OETOPAD (Bit 13) */
#define IO_BANK0_GPIO5_STATUS_OETOPAD_Msk (0x2000UL)                /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO5_STATUS_OEFROMPERI_Pos (12UL)                 /*!< OEFROMPERI (Bit 12) */
#define IO_BANK0_GPIO5_STATUS_OEFROMPERI_Msk (0x1000UL)             /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO5_STATUS_OUTTOPAD_Pos (9UL)                    /*!< OUTTOPAD (Bit 9) */
#define IO_BANK0_GPIO5_STATUS_OUTTOPAD_Msk (0x200UL)                /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO5_STATUS_OUTFROMPERI_Pos (8UL)                 /*!< OUTFROMPERI (Bit 8) */
#define IO_BANK0_GPIO5_STATUS_OUTFROMPERI_Msk (0x100UL)             /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ======================================================  GPIO5_CTRL  ======================================================= */
#define IO_BANK0_GPIO5_CTRL_IRQOVER_Pos   (28UL)                    /*!< IRQOVER (Bit 28) */
#define IO_BANK0_GPIO5_CTRL_IRQOVER_Msk   (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO5_CTRL_INOVER_Pos    (16UL)                    /*!< INOVER (Bit 16) */
#define IO_BANK0_GPIO5_CTRL_INOVER_Msk    (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO5_CTRL_OEOVER_Pos    (12UL)                    /*!< OEOVER (Bit 12) */
#define IO_BANK0_GPIO5_CTRL_OEOVER_Msk    (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO5_CTRL_OUTOVER_Pos   (8UL)                     /*!< OUTOVER (Bit 8) */
#define IO_BANK0_GPIO5_CTRL_OUTOVER_Msk   (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO5_CTRL_FUNCSEL_Pos   (0UL)                     /*!< FUNCSEL (Bit 0) */
#define IO_BANK0_GPIO5_CTRL_FUNCSEL_Msk   (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  GPIO6_STATUS  ====================================================== */
#define IO_BANK0_GPIO6_STATUS_IRQTOPROC_Pos (26UL)                  /*!< IRQTOPROC (Bit 26) */
#define IO_BANK0_GPIO6_STATUS_IRQTOPROC_Msk (0x4000000UL)           /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO6_STATUS_IRQFROMPAD_Pos (24UL)                 /*!< IRQFROMPAD (Bit 24) */
#define IO_BANK0_GPIO6_STATUS_IRQFROMPAD_Msk (0x1000000UL)          /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO6_STATUS_INTOPERI_Pos (19UL)                   /*!< INTOPERI (Bit 19) */
#define IO_BANK0_GPIO6_STATUS_INTOPERI_Msk (0x80000UL)              /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO6_STATUS_INFROMPAD_Pos (17UL)                  /*!< INFROMPAD (Bit 17) */
#define IO_BANK0_GPIO6_STATUS_INFROMPAD_Msk (0x20000UL)             /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO6_STATUS_OETOPAD_Pos (13UL)                    /*!< OETOPAD (Bit 13) */
#define IO_BANK0_GPIO6_STATUS_OETOPAD_Msk (0x2000UL)                /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO6_STATUS_OEFROMPERI_Pos (12UL)                 /*!< OEFROMPERI (Bit 12) */
#define IO_BANK0_GPIO6_STATUS_OEFROMPERI_Msk (0x1000UL)             /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO6_STATUS_OUTTOPAD_Pos (9UL)                    /*!< OUTTOPAD (Bit 9) */
#define IO_BANK0_GPIO6_STATUS_OUTTOPAD_Msk (0x200UL)                /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO6_STATUS_OUTFROMPERI_Pos (8UL)                 /*!< OUTFROMPERI (Bit 8) */
#define IO_BANK0_GPIO6_STATUS_OUTFROMPERI_Msk (0x100UL)             /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ======================================================  GPIO6_CTRL  ======================================================= */
#define IO_BANK0_GPIO6_CTRL_IRQOVER_Pos   (28UL)                    /*!< IRQOVER (Bit 28) */
#define IO_BANK0_GPIO6_CTRL_IRQOVER_Msk   (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO6_CTRL_INOVER_Pos    (16UL)                    /*!< INOVER (Bit 16) */
#define IO_BANK0_GPIO6_CTRL_INOVER_Msk    (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO6_CTRL_OEOVER_Pos    (12UL)                    /*!< OEOVER (Bit 12) */
#define IO_BANK0_GPIO6_CTRL_OEOVER_Msk    (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO6_CTRL_OUTOVER_Pos   (8UL)                     /*!< OUTOVER (Bit 8) */
#define IO_BANK0_GPIO6_CTRL_OUTOVER_Msk   (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO6_CTRL_FUNCSEL_Pos   (0UL)                     /*!< FUNCSEL (Bit 0) */
#define IO_BANK0_GPIO6_CTRL_FUNCSEL_Msk   (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  GPIO7_STATUS  ====================================================== */
#define IO_BANK0_GPIO7_STATUS_IRQTOPROC_Pos (26UL)                  /*!< IRQTOPROC (Bit 26) */
#define IO_BANK0_GPIO7_STATUS_IRQTOPROC_Msk (0x4000000UL)           /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO7_STATUS_IRQFROMPAD_Pos (24UL)                 /*!< IRQFROMPAD (Bit 24) */
#define IO_BANK0_GPIO7_STATUS_IRQFROMPAD_Msk (0x1000000UL)          /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO7_STATUS_INTOPERI_Pos (19UL)                   /*!< INTOPERI (Bit 19) */
#define IO_BANK0_GPIO7_STATUS_INTOPERI_Msk (0x80000UL)              /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO7_STATUS_INFROMPAD_Pos (17UL)                  /*!< INFROMPAD (Bit 17) */
#define IO_BANK0_GPIO7_STATUS_INFROMPAD_Msk (0x20000UL)             /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO7_STATUS_OETOPAD_Pos (13UL)                    /*!< OETOPAD (Bit 13) */
#define IO_BANK0_GPIO7_STATUS_OETOPAD_Msk (0x2000UL)                /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO7_STATUS_OEFROMPERI_Pos (12UL)                 /*!< OEFROMPERI (Bit 12) */
#define IO_BANK0_GPIO7_STATUS_OEFROMPERI_Msk (0x1000UL)             /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO7_STATUS_OUTTOPAD_Pos (9UL)                    /*!< OUTTOPAD (Bit 9) */
#define IO_BANK0_GPIO7_STATUS_OUTTOPAD_Msk (0x200UL)                /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO7_STATUS_OUTFROMPERI_Pos (8UL)                 /*!< OUTFROMPERI (Bit 8) */
#define IO_BANK0_GPIO7_STATUS_OUTFROMPERI_Msk (0x100UL)             /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ======================================================  GPIO7_CTRL  ======================================================= */
#define IO_BANK0_GPIO7_CTRL_IRQOVER_Pos   (28UL)                    /*!< IRQOVER (Bit 28) */
#define IO_BANK0_GPIO7_CTRL_IRQOVER_Msk   (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO7_CTRL_INOVER_Pos    (16UL)                    /*!< INOVER (Bit 16) */
#define IO_BANK0_GPIO7_CTRL_INOVER_Msk    (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO7_CTRL_OEOVER_Pos    (12UL)                    /*!< OEOVER (Bit 12) */
#define IO_BANK0_GPIO7_CTRL_OEOVER_Msk    (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO7_CTRL_OUTOVER_Pos   (8UL)                     /*!< OUTOVER (Bit 8) */
#define IO_BANK0_GPIO7_CTRL_OUTOVER_Msk   (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO7_CTRL_FUNCSEL_Pos   (0UL)                     /*!< FUNCSEL (Bit 0) */
#define IO_BANK0_GPIO7_CTRL_FUNCSEL_Msk   (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  GPIO8_STATUS  ====================================================== */
#define IO_BANK0_GPIO8_STATUS_IRQTOPROC_Pos (26UL)                  /*!< IRQTOPROC (Bit 26) */
#define IO_BANK0_GPIO8_STATUS_IRQTOPROC_Msk (0x4000000UL)           /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO8_STATUS_IRQFROMPAD_Pos (24UL)                 /*!< IRQFROMPAD (Bit 24) */
#define IO_BANK0_GPIO8_STATUS_IRQFROMPAD_Msk (0x1000000UL)          /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO8_STATUS_INTOPERI_Pos (19UL)                   /*!< INTOPERI (Bit 19) */
#define IO_BANK0_GPIO8_STATUS_INTOPERI_Msk (0x80000UL)              /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO8_STATUS_INFROMPAD_Pos (17UL)                  /*!< INFROMPAD (Bit 17) */
#define IO_BANK0_GPIO8_STATUS_INFROMPAD_Msk (0x20000UL)             /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO8_STATUS_OETOPAD_Pos (13UL)                    /*!< OETOPAD (Bit 13) */
#define IO_BANK0_GPIO8_STATUS_OETOPAD_Msk (0x2000UL)                /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO8_STATUS_OEFROMPERI_Pos (12UL)                 /*!< OEFROMPERI (Bit 12) */
#define IO_BANK0_GPIO8_STATUS_OEFROMPERI_Msk (0x1000UL)             /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO8_STATUS_OUTTOPAD_Pos (9UL)                    /*!< OUTTOPAD (Bit 9) */
#define IO_BANK0_GPIO8_STATUS_OUTTOPAD_Msk (0x200UL)                /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO8_STATUS_OUTFROMPERI_Pos (8UL)                 /*!< OUTFROMPERI (Bit 8) */
#define IO_BANK0_GPIO8_STATUS_OUTFROMPERI_Msk (0x100UL)             /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ======================================================  GPIO8_CTRL  ======================================================= */
#define IO_BANK0_GPIO8_CTRL_IRQOVER_Pos   (28UL)                    /*!< IRQOVER (Bit 28) */
#define IO_BANK0_GPIO8_CTRL_IRQOVER_Msk   (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO8_CTRL_INOVER_Pos    (16UL)                    /*!< INOVER (Bit 16) */
#define IO_BANK0_GPIO8_CTRL_INOVER_Msk    (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO8_CTRL_OEOVER_Pos    (12UL)                    /*!< OEOVER (Bit 12) */
#define IO_BANK0_GPIO8_CTRL_OEOVER_Msk    (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO8_CTRL_OUTOVER_Pos   (8UL)                     /*!< OUTOVER (Bit 8) */
#define IO_BANK0_GPIO8_CTRL_OUTOVER_Msk   (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO8_CTRL_FUNCSEL_Pos   (0UL)                     /*!< FUNCSEL (Bit 0) */
#define IO_BANK0_GPIO8_CTRL_FUNCSEL_Msk   (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  GPIO9_STATUS  ====================================================== */
#define IO_BANK0_GPIO9_STATUS_IRQTOPROC_Pos (26UL)                  /*!< IRQTOPROC (Bit 26) */
#define IO_BANK0_GPIO9_STATUS_IRQTOPROC_Msk (0x4000000UL)           /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO9_STATUS_IRQFROMPAD_Pos (24UL)                 /*!< IRQFROMPAD (Bit 24) */
#define IO_BANK0_GPIO9_STATUS_IRQFROMPAD_Msk (0x1000000UL)          /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO9_STATUS_INTOPERI_Pos (19UL)                   /*!< INTOPERI (Bit 19) */
#define IO_BANK0_GPIO9_STATUS_INTOPERI_Msk (0x80000UL)              /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO9_STATUS_INFROMPAD_Pos (17UL)                  /*!< INFROMPAD (Bit 17) */
#define IO_BANK0_GPIO9_STATUS_INFROMPAD_Msk (0x20000UL)             /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO9_STATUS_OETOPAD_Pos (13UL)                    /*!< OETOPAD (Bit 13) */
#define IO_BANK0_GPIO9_STATUS_OETOPAD_Msk (0x2000UL)                /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO9_STATUS_OEFROMPERI_Pos (12UL)                 /*!< OEFROMPERI (Bit 12) */
#define IO_BANK0_GPIO9_STATUS_OEFROMPERI_Msk (0x1000UL)             /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO9_STATUS_OUTTOPAD_Pos (9UL)                    /*!< OUTTOPAD (Bit 9) */
#define IO_BANK0_GPIO9_STATUS_OUTTOPAD_Msk (0x200UL)                /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO9_STATUS_OUTFROMPERI_Pos (8UL)                 /*!< OUTFROMPERI (Bit 8) */
#define IO_BANK0_GPIO9_STATUS_OUTFROMPERI_Msk (0x100UL)             /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ======================================================  GPIO9_CTRL  ======================================================= */
#define IO_BANK0_GPIO9_CTRL_IRQOVER_Pos   (28UL)                    /*!< IRQOVER (Bit 28) */
#define IO_BANK0_GPIO9_CTRL_IRQOVER_Msk   (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO9_CTRL_INOVER_Pos    (16UL)                    /*!< INOVER (Bit 16) */
#define IO_BANK0_GPIO9_CTRL_INOVER_Msk    (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO9_CTRL_OEOVER_Pos    (12UL)                    /*!< OEOVER (Bit 12) */
#define IO_BANK0_GPIO9_CTRL_OEOVER_Msk    (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO9_CTRL_OUTOVER_Pos   (8UL)                     /*!< OUTOVER (Bit 8) */
#define IO_BANK0_GPIO9_CTRL_OUTOVER_Msk   (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO9_CTRL_FUNCSEL_Pos   (0UL)                     /*!< FUNCSEL (Bit 0) */
#define IO_BANK0_GPIO9_CTRL_FUNCSEL_Msk   (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  GPIO10_STATUS  ===================================================== */
#define IO_BANK0_GPIO10_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26) */
#define IO_BANK0_GPIO10_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO10_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24) */
#define IO_BANK0_GPIO10_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO10_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19) */
#define IO_BANK0_GPIO10_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO10_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17) */
#define IO_BANK0_GPIO10_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO10_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13) */
#define IO_BANK0_GPIO10_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO10_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12) */
#define IO_BANK0_GPIO10_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO10_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9) */
#define IO_BANK0_GPIO10_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO10_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8) */
#define IO_BANK0_GPIO10_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ======================================================  GPIO10_CTRL  ====================================================== */
#define IO_BANK0_GPIO10_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28) */
#define IO_BANK0_GPIO10_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO10_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16) */
#define IO_BANK0_GPIO10_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO10_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12) */
#define IO_BANK0_GPIO10_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO10_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8) */
#define IO_BANK0_GPIO10_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO10_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0) */
#define IO_BANK0_GPIO10_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  GPIO11_STATUS  ===================================================== */
#define IO_BANK0_GPIO11_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26) */
#define IO_BANK0_GPIO11_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO11_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24) */
#define IO_BANK0_GPIO11_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO11_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19) */
#define IO_BANK0_GPIO11_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO11_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17) */
#define IO_BANK0_GPIO11_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO11_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13) */
#define IO_BANK0_GPIO11_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO11_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12) */
#define IO_BANK0_GPIO11_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO11_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9) */
#define IO_BANK0_GPIO11_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO11_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8) */
#define IO_BANK0_GPIO11_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ======================================================  GPIO11_CTRL  ====================================================== */
#define IO_BANK0_GPIO11_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28) */
#define IO_BANK0_GPIO11_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO11_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16) */
#define IO_BANK0_GPIO11_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO11_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12) */
#define IO_BANK0_GPIO11_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO11_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8) */
#define IO_BANK0_GPIO11_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO11_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0) */
#define IO_BANK0_GPIO11_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  GPIO12_STATUS  ===================================================== */
#define IO_BANK0_GPIO12_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26) */
#define IO_BANK0_GPIO12_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO12_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24) */
#define IO_BANK0_GPIO12_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO12_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19) */
#define IO_BANK0_GPIO12_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO12_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17) */
#define IO_BANK0_GPIO12_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO12_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13) */
#define IO_BANK0_GPIO12_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO12_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12) */
#define IO_BANK0_GPIO12_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO12_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9) */
#define IO_BANK0_GPIO12_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO12_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8) */
#define IO_BANK0_GPIO12_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ======================================================  GPIO12_CTRL  ====================================================== */
#define IO_BANK0_GPIO12_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28) */
#define IO_BANK0_GPIO12_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO12_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16) */
#define IO_BANK0_GPIO12_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO12_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12) */
#define IO_BANK0_GPIO12_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO12_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8) */
#define IO_BANK0_GPIO12_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO12_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0) */
#define IO_BANK0_GPIO12_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  GPIO13_STATUS  ===================================================== */
#define IO_BANK0_GPIO13_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26) */
#define IO_BANK0_GPIO13_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO13_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24) */
#define IO_BANK0_GPIO13_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO13_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19) */
#define IO_BANK0_GPIO13_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO13_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17) */
#define IO_BANK0_GPIO13_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO13_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13) */
#define IO_BANK0_GPIO13_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO13_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12) */
#define IO_BANK0_GPIO13_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO13_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9) */
#define IO_BANK0_GPIO13_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO13_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8) */
#define IO_BANK0_GPIO13_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ======================================================  GPIO13_CTRL  ====================================================== */
#define IO_BANK0_GPIO13_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28) */
#define IO_BANK0_GPIO13_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO13_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16) */
#define IO_BANK0_GPIO13_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO13_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12) */
#define IO_BANK0_GPIO13_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO13_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8) */
#define IO_BANK0_GPIO13_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO13_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0) */
#define IO_BANK0_GPIO13_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  GPIO14_STATUS  ===================================================== */
#define IO_BANK0_GPIO14_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26) */
#define IO_BANK0_GPIO14_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO14_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24) */
#define IO_BANK0_GPIO14_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO14_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19) */
#define IO_BANK0_GPIO14_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO14_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17) */
#define IO_BANK0_GPIO14_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO14_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13) */
#define IO_BANK0_GPIO14_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO14_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12) */
#define IO_BANK0_GPIO14_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO14_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9) */
#define IO_BANK0_GPIO14_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO14_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8) */
#define IO_BANK0_GPIO14_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ======================================================  GPIO14_CTRL  ====================================================== */
#define IO_BANK0_GPIO14_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28) */
#define IO_BANK0_GPIO14_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO14_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16) */
#define IO_BANK0_GPIO14_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO14_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12) */
#define IO_BANK0_GPIO14_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO14_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8) */
#define IO_BANK0_GPIO14_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO14_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0) */
#define IO_BANK0_GPIO14_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  GPIO15_STATUS  ===================================================== */
#define IO_BANK0_GPIO15_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26) */
#define IO_BANK0_GPIO15_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO15_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24) */
#define IO_BANK0_GPIO15_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO15_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19) */
#define IO_BANK0_GPIO15_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO15_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17) */
#define IO_BANK0_GPIO15_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO15_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13) */
#define IO_BANK0_GPIO15_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO15_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12) */
#define IO_BANK0_GPIO15_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO15_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9) */
#define IO_BANK0_GPIO15_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO15_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8) */
#define IO_BANK0_GPIO15_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ======================================================  GPIO15_CTRL  ====================================================== */
#define IO_BANK0_GPIO15_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28) */
#define IO_BANK0_GPIO15_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO15_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16) */
#define IO_BANK0_GPIO15_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO15_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12) */
#define IO_BANK0_GPIO15_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO15_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8) */
#define IO_BANK0_GPIO15_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO15_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0) */
#define IO_BANK0_GPIO15_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  GPIO16_STATUS  ===================================================== */
#define IO_BANK0_GPIO16_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26) */
#define IO_BANK0_GPIO16_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO16_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24) */
#define IO_BANK0_GPIO16_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO16_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19) */
#define IO_BANK0_GPIO16_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO16_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17) */
#define IO_BANK0_GPIO16_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO16_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13) */
#define IO_BANK0_GPIO16_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO16_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12) */
#define IO_BANK0_GPIO16_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO16_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9) */
#define IO_BANK0_GPIO16_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO16_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8) */
#define IO_BANK0_GPIO16_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ======================================================  GPIO16_CTRL  ====================================================== */
#define IO_BANK0_GPIO16_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28) */
#define IO_BANK0_GPIO16_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO16_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16) */
#define IO_BANK0_GPIO16_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO16_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12) */
#define IO_BANK0_GPIO16_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO16_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8) */
#define IO_BANK0_GPIO16_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO16_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0) */
#define IO_BANK0_GPIO16_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  GPIO17_STATUS  ===================================================== */
#define IO_BANK0_GPIO17_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26) */
#define IO_BANK0_GPIO17_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO17_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24) */
#define IO_BANK0_GPIO17_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO17_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19) */
#define IO_BANK0_GPIO17_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO17_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17) */
#define IO_BANK0_GPIO17_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO17_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13) */
#define IO_BANK0_GPIO17_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO17_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12) */
#define IO_BANK0_GPIO17_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO17_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9) */
#define IO_BANK0_GPIO17_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO17_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8) */
#define IO_BANK0_GPIO17_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ======================================================  GPIO17_CTRL  ====================================================== */
#define IO_BANK0_GPIO17_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28) */
#define IO_BANK0_GPIO17_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO17_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16) */
#define IO_BANK0_GPIO17_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO17_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12) */
#define IO_BANK0_GPIO17_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO17_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8) */
#define IO_BANK0_GPIO17_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO17_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0) */
#define IO_BANK0_GPIO17_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  GPIO18_STATUS  ===================================================== */
#define IO_BANK0_GPIO18_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26) */
#define IO_BANK0_GPIO18_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO18_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24) */
#define IO_BANK0_GPIO18_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO18_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19) */
#define IO_BANK0_GPIO18_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO18_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17) */
#define IO_BANK0_GPIO18_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO18_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13) */
#define IO_BANK0_GPIO18_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO18_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12) */
#define IO_BANK0_GPIO18_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO18_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9) */
#define IO_BANK0_GPIO18_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO18_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8) */
#define IO_BANK0_GPIO18_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ======================================================  GPIO18_CTRL  ====================================================== */
#define IO_BANK0_GPIO18_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28) */
#define IO_BANK0_GPIO18_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO18_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16) */
#define IO_BANK0_GPIO18_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO18_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12) */
#define IO_BANK0_GPIO18_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO18_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8) */
#define IO_BANK0_GPIO18_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO18_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0) */
#define IO_BANK0_GPIO18_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  GPIO19_STATUS  ===================================================== */
#define IO_BANK0_GPIO19_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26) */
#define IO_BANK0_GPIO19_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO19_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24) */
#define IO_BANK0_GPIO19_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO19_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19) */
#define IO_BANK0_GPIO19_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO19_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17) */
#define IO_BANK0_GPIO19_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO19_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13) */
#define IO_BANK0_GPIO19_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO19_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12) */
#define IO_BANK0_GPIO19_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO19_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9) */
#define IO_BANK0_GPIO19_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO19_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8) */
#define IO_BANK0_GPIO19_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ======================================================  GPIO19_CTRL  ====================================================== */
#define IO_BANK0_GPIO19_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28) */
#define IO_BANK0_GPIO19_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO19_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16) */
#define IO_BANK0_GPIO19_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO19_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12) */
#define IO_BANK0_GPIO19_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO19_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8) */
#define IO_BANK0_GPIO19_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO19_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0) */
#define IO_BANK0_GPIO19_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  GPIO20_STATUS  ===================================================== */
#define IO_BANK0_GPIO20_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26) */
#define IO_BANK0_GPIO20_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO20_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24) */
#define IO_BANK0_GPIO20_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO20_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19) */
#define IO_BANK0_GPIO20_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO20_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17) */
#define IO_BANK0_GPIO20_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO20_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13) */
#define IO_BANK0_GPIO20_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO20_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12) */
#define IO_BANK0_GPIO20_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO20_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9) */
#define IO_BANK0_GPIO20_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO20_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8) */
#define IO_BANK0_GPIO20_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ======================================================  GPIO20_CTRL  ====================================================== */
#define IO_BANK0_GPIO20_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28) */
#define IO_BANK0_GPIO20_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO20_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16) */
#define IO_BANK0_GPIO20_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO20_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12) */
#define IO_BANK0_GPIO20_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO20_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8) */
#define IO_BANK0_GPIO20_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO20_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0) */
#define IO_BANK0_GPIO20_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  GPIO21_STATUS  ===================================================== */
#define IO_BANK0_GPIO21_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26) */
#define IO_BANK0_GPIO21_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO21_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24) */
#define IO_BANK0_GPIO21_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO21_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19) */
#define IO_BANK0_GPIO21_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO21_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17) */
#define IO_BANK0_GPIO21_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO21_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13) */
#define IO_BANK0_GPIO21_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO21_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12) */
#define IO_BANK0_GPIO21_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO21_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9) */
#define IO_BANK0_GPIO21_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO21_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8) */
#define IO_BANK0_GPIO21_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ======================================================  GPIO21_CTRL  ====================================================== */
#define IO_BANK0_GPIO21_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28) */
#define IO_BANK0_GPIO21_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO21_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16) */
#define IO_BANK0_GPIO21_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO21_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12) */
#define IO_BANK0_GPIO21_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO21_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8) */
#define IO_BANK0_GPIO21_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO21_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0) */
#define IO_BANK0_GPIO21_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  GPIO22_STATUS  ===================================================== */
#define IO_BANK0_GPIO22_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26) */
#define IO_BANK0_GPIO22_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO22_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24) */
#define IO_BANK0_GPIO22_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO22_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19) */
#define IO_BANK0_GPIO22_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO22_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17) */
#define IO_BANK0_GPIO22_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO22_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13) */
#define IO_BANK0_GPIO22_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO22_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12) */
#define IO_BANK0_GPIO22_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO22_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9) */
#define IO_BANK0_GPIO22_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO22_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8) */
#define IO_BANK0_GPIO22_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ======================================================  GPIO22_CTRL  ====================================================== */
#define IO_BANK0_GPIO22_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28) */
#define IO_BANK0_GPIO22_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO22_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16) */
#define IO_BANK0_GPIO22_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO22_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12) */
#define IO_BANK0_GPIO22_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO22_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8) */
#define IO_BANK0_GPIO22_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO22_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0) */
#define IO_BANK0_GPIO22_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  GPIO23_STATUS  ===================================================== */
#define IO_BANK0_GPIO23_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26) */
#define IO_BANK0_GPIO23_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO23_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24) */
#define IO_BANK0_GPIO23_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO23_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19) */
#define IO_BANK0_GPIO23_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO23_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17) */
#define IO_BANK0_GPIO23_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO23_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13) */
#define IO_BANK0_GPIO23_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO23_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12) */
#define IO_BANK0_GPIO23_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO23_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9) */
#define IO_BANK0_GPIO23_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO23_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8) */
#define IO_BANK0_GPIO23_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ======================================================  GPIO23_CTRL  ====================================================== */
#define IO_BANK0_GPIO23_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28) */
#define IO_BANK0_GPIO23_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO23_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16) */
#define IO_BANK0_GPIO23_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO23_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12) */
#define IO_BANK0_GPIO23_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO23_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8) */
#define IO_BANK0_GPIO23_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO23_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0) */
#define IO_BANK0_GPIO23_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  GPIO24_STATUS  ===================================================== */
#define IO_BANK0_GPIO24_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26) */
#define IO_BANK0_GPIO24_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO24_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24) */
#define IO_BANK0_GPIO24_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO24_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19) */
#define IO_BANK0_GPIO24_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO24_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17) */
#define IO_BANK0_GPIO24_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO24_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13) */
#define IO_BANK0_GPIO24_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO24_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12) */
#define IO_BANK0_GPIO24_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO24_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9) */
#define IO_BANK0_GPIO24_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO24_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8) */
#define IO_BANK0_GPIO24_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ======================================================  GPIO24_CTRL  ====================================================== */
#define IO_BANK0_GPIO24_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28) */
#define IO_BANK0_GPIO24_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO24_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16) */
#define IO_BANK0_GPIO24_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO24_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12) */
#define IO_BANK0_GPIO24_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO24_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8) */
#define IO_BANK0_GPIO24_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO24_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0) */
#define IO_BANK0_GPIO24_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  GPIO25_STATUS  ===================================================== */
#define IO_BANK0_GPIO25_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26) */
#define IO_BANK0_GPIO25_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO25_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24) */
#define IO_BANK0_GPIO25_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO25_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19) */
#define IO_BANK0_GPIO25_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO25_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17) */
#define IO_BANK0_GPIO25_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO25_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13) */
#define IO_BANK0_GPIO25_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO25_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12) */
#define IO_BANK0_GPIO25_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO25_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9) */
#define IO_BANK0_GPIO25_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO25_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8) */
#define IO_BANK0_GPIO25_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ======================================================  GPIO25_CTRL  ====================================================== */
#define IO_BANK0_GPIO25_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28) */
#define IO_BANK0_GPIO25_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO25_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16) */
#define IO_BANK0_GPIO25_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO25_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12) */
#define IO_BANK0_GPIO25_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO25_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8) */
#define IO_BANK0_GPIO25_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO25_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0) */
#define IO_BANK0_GPIO25_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  GPIO26_STATUS  ===================================================== */
#define IO_BANK0_GPIO26_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26) */
#define IO_BANK0_GPIO26_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO26_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24) */
#define IO_BANK0_GPIO26_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO26_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19) */
#define IO_BANK0_GPIO26_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO26_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17) */
#define IO_BANK0_GPIO26_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO26_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13) */
#define IO_BANK0_GPIO26_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO26_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12) */
#define IO_BANK0_GPIO26_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO26_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9) */
#define IO_BANK0_GPIO26_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO26_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8) */
#define IO_BANK0_GPIO26_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ======================================================  GPIO26_CTRL  ====================================================== */
#define IO_BANK0_GPIO26_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28) */
#define IO_BANK0_GPIO26_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO26_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16) */
#define IO_BANK0_GPIO26_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO26_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12) */
#define IO_BANK0_GPIO26_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO26_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8) */
#define IO_BANK0_GPIO26_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO26_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0) */
#define IO_BANK0_GPIO26_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  GPIO27_STATUS  ===================================================== */
#define IO_BANK0_GPIO27_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26) */
#define IO_BANK0_GPIO27_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO27_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24) */
#define IO_BANK0_GPIO27_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO27_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19) */
#define IO_BANK0_GPIO27_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO27_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17) */
#define IO_BANK0_GPIO27_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO27_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13) */
#define IO_BANK0_GPIO27_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO27_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12) */
#define IO_BANK0_GPIO27_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO27_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9) */
#define IO_BANK0_GPIO27_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO27_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8) */
#define IO_BANK0_GPIO27_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ======================================================  GPIO27_CTRL  ====================================================== */
#define IO_BANK0_GPIO27_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28) */
#define IO_BANK0_GPIO27_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO27_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16) */
#define IO_BANK0_GPIO27_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO27_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12) */
#define IO_BANK0_GPIO27_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO27_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8) */
#define IO_BANK0_GPIO27_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO27_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0) */
#define IO_BANK0_GPIO27_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  GPIO28_STATUS  ===================================================== */
#define IO_BANK0_GPIO28_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26) */
#define IO_BANK0_GPIO28_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO28_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24) */
#define IO_BANK0_GPIO28_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO28_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19) */
#define IO_BANK0_GPIO28_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO28_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17) */
#define IO_BANK0_GPIO28_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO28_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13) */
#define IO_BANK0_GPIO28_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO28_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12) */
#define IO_BANK0_GPIO28_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO28_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9) */
#define IO_BANK0_GPIO28_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO28_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8) */
#define IO_BANK0_GPIO28_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ======================================================  GPIO28_CTRL  ====================================================== */
#define IO_BANK0_GPIO28_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28) */
#define IO_BANK0_GPIO28_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO28_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16) */
#define IO_BANK0_GPIO28_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO28_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12) */
#define IO_BANK0_GPIO28_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO28_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8) */
#define IO_BANK0_GPIO28_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO28_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0) */
#define IO_BANK0_GPIO28_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =====================================================  GPIO29_STATUS  ===================================================== */
#define IO_BANK0_GPIO29_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26) */
#define IO_BANK0_GPIO29_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO29_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24) */
#define IO_BANK0_GPIO29_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO29_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19) */
#define IO_BANK0_GPIO29_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO29_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17) */
#define IO_BANK0_GPIO29_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO29_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13) */
#define IO_BANK0_GPIO29_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO29_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12) */
#define IO_BANK0_GPIO29_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO29_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9) */
#define IO_BANK0_GPIO29_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_BANK0_GPIO29_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8) */
#define IO_BANK0_GPIO29_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ======================================================  GPIO29_CTRL  ====================================================== */
#define IO_BANK0_GPIO29_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28) */
#define IO_BANK0_GPIO29_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO29_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16) */
#define IO_BANK0_GPIO29_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO29_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12) */
#define IO_BANK0_GPIO29_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO29_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8) */
#define IO_BANK0_GPIO29_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_BANK0_GPIO29_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0) */
#define IO_BANK0_GPIO29_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =========================================================  INTR0  ========================================================= */
#define IO_BANK0_INTR0_GPIO7_EDGE_HIGH_Pos (31UL)                   /*!< GPIO7_EDGE_HIGH (Bit 31) */
#define IO_BANK0_INTR0_GPIO7_EDGE_HIGH_Msk (0x80000000UL)           /*!< GPIO7_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO7_EDGE_LOW_Pos (30UL)                    /*!< GPIO7_EDGE_LOW (Bit 30) */
#define IO_BANK0_INTR0_GPIO7_EDGE_LOW_Msk (0x40000000UL)            /*!< GPIO7_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO7_LEVEL_HIGH_Pos (29UL)                  /*!< GPIO7_LEVEL_HIGH (Bit 29) */
#define IO_BANK0_INTR0_GPIO7_LEVEL_HIGH_Msk (0x20000000UL)          /*!< GPIO7_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO7_LEVEL_LOW_Pos (28UL)                   /*!< GPIO7_LEVEL_LOW (Bit 28) */
#define IO_BANK0_INTR0_GPIO7_LEVEL_LOW_Msk (0x10000000UL)           /*!< GPIO7_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO6_EDGE_HIGH_Pos (27UL)                   /*!< GPIO6_EDGE_HIGH (Bit 27) */
#define IO_BANK0_INTR0_GPIO6_EDGE_HIGH_Msk (0x8000000UL)            /*!< GPIO6_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO6_EDGE_LOW_Pos (26UL)                    /*!< GPIO6_EDGE_LOW (Bit 26) */
#define IO_BANK0_INTR0_GPIO6_EDGE_LOW_Msk (0x4000000UL)             /*!< GPIO6_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO6_LEVEL_HIGH_Pos (25UL)                  /*!< GPIO6_LEVEL_HIGH (Bit 25) */
#define IO_BANK0_INTR0_GPIO6_LEVEL_HIGH_Msk (0x2000000UL)           /*!< GPIO6_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO6_LEVEL_LOW_Pos (24UL)                   /*!< GPIO6_LEVEL_LOW (Bit 24) */
#define IO_BANK0_INTR0_GPIO6_LEVEL_LOW_Msk (0x1000000UL)            /*!< GPIO6_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO5_EDGE_HIGH_Pos (23UL)                   /*!< GPIO5_EDGE_HIGH (Bit 23) */
#define IO_BANK0_INTR0_GPIO5_EDGE_HIGH_Msk (0x800000UL)             /*!< GPIO5_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO5_EDGE_LOW_Pos (22UL)                    /*!< GPIO5_EDGE_LOW (Bit 22) */
#define IO_BANK0_INTR0_GPIO5_EDGE_LOW_Msk (0x400000UL)              /*!< GPIO5_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO5_LEVEL_HIGH_Pos (21UL)                  /*!< GPIO5_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_INTR0_GPIO5_LEVEL_HIGH_Msk (0x200000UL)            /*!< GPIO5_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO5_LEVEL_LOW_Pos (20UL)                   /*!< GPIO5_LEVEL_LOW (Bit 20) */
#define IO_BANK0_INTR0_GPIO5_LEVEL_LOW_Msk (0x100000UL)             /*!< GPIO5_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO4_EDGE_HIGH_Pos (19UL)                   /*!< GPIO4_EDGE_HIGH (Bit 19) */
#define IO_BANK0_INTR0_GPIO4_EDGE_HIGH_Msk (0x80000UL)              /*!< GPIO4_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO4_EDGE_LOW_Pos (18UL)                    /*!< GPIO4_EDGE_LOW (Bit 18) */
#define IO_BANK0_INTR0_GPIO4_EDGE_LOW_Msk (0x40000UL)               /*!< GPIO4_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO4_LEVEL_HIGH_Pos (17UL)                  /*!< GPIO4_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_INTR0_GPIO4_LEVEL_HIGH_Msk (0x20000UL)             /*!< GPIO4_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO4_LEVEL_LOW_Pos (16UL)                   /*!< GPIO4_LEVEL_LOW (Bit 16) */
#define IO_BANK0_INTR0_GPIO4_LEVEL_LOW_Msk (0x10000UL)              /*!< GPIO4_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO3_EDGE_HIGH_Pos (15UL)                   /*!< GPIO3_EDGE_HIGH (Bit 15) */
#define IO_BANK0_INTR0_GPIO3_EDGE_HIGH_Msk (0x8000UL)               /*!< GPIO3_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO3_EDGE_LOW_Pos (14UL)                    /*!< GPIO3_EDGE_LOW (Bit 14) */
#define IO_BANK0_INTR0_GPIO3_EDGE_LOW_Msk (0x4000UL)                /*!< GPIO3_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO3_LEVEL_HIGH_Pos (13UL)                  /*!< GPIO3_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_INTR0_GPIO3_LEVEL_HIGH_Msk (0x2000UL)              /*!< GPIO3_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO3_LEVEL_LOW_Pos (12UL)                   /*!< GPIO3_LEVEL_LOW (Bit 12) */
#define IO_BANK0_INTR0_GPIO3_LEVEL_LOW_Msk (0x1000UL)               /*!< GPIO3_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO2_EDGE_HIGH_Pos (11UL)                   /*!< GPIO2_EDGE_HIGH (Bit 11) */
#define IO_BANK0_INTR0_GPIO2_EDGE_HIGH_Msk (0x800UL)                /*!< GPIO2_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO2_EDGE_LOW_Pos (10UL)                    /*!< GPIO2_EDGE_LOW (Bit 10) */
#define IO_BANK0_INTR0_GPIO2_EDGE_LOW_Msk (0x400UL)                 /*!< GPIO2_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO2_LEVEL_HIGH_Pos (9UL)                   /*!< GPIO2_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_INTR0_GPIO2_LEVEL_HIGH_Msk (0x200UL)               /*!< GPIO2_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO2_LEVEL_LOW_Pos (8UL)                    /*!< GPIO2_LEVEL_LOW (Bit 8) */
#define IO_BANK0_INTR0_GPIO2_LEVEL_LOW_Msk (0x100UL)                /*!< GPIO2_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO1_EDGE_HIGH_Pos (7UL)                    /*!< GPIO1_EDGE_HIGH (Bit 7) */
#define IO_BANK0_INTR0_GPIO1_EDGE_HIGH_Msk (0x80UL)                 /*!< GPIO1_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO1_EDGE_LOW_Pos (6UL)                     /*!< GPIO1_EDGE_LOW (Bit 6) */
#define IO_BANK0_INTR0_GPIO1_EDGE_LOW_Msk (0x40UL)                  /*!< GPIO1_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO1_LEVEL_HIGH_Pos (5UL)                   /*!< GPIO1_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_INTR0_GPIO1_LEVEL_HIGH_Msk (0x20UL)                /*!< GPIO1_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO1_LEVEL_LOW_Pos (4UL)                    /*!< GPIO1_LEVEL_LOW (Bit 4) */
#define IO_BANK0_INTR0_GPIO1_LEVEL_LOW_Msk (0x10UL)                 /*!< GPIO1_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO0_EDGE_HIGH_Pos (3UL)                    /*!< GPIO0_EDGE_HIGH (Bit 3) */
#define IO_BANK0_INTR0_GPIO0_EDGE_HIGH_Msk (0x8UL)                  /*!< GPIO0_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO0_EDGE_LOW_Pos (2UL)                     /*!< GPIO0_EDGE_LOW (Bit 2) */
#define IO_BANK0_INTR0_GPIO0_EDGE_LOW_Msk (0x4UL)                   /*!< GPIO0_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO0_LEVEL_HIGH_Pos (1UL)                   /*!< GPIO0_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_INTR0_GPIO0_LEVEL_HIGH_Msk (0x2UL)                 /*!< GPIO0_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR0_GPIO0_LEVEL_LOW_Pos (0UL)                    /*!< GPIO0_LEVEL_LOW (Bit 0) */
#define IO_BANK0_INTR0_GPIO0_LEVEL_LOW_Msk (0x1UL)                  /*!< GPIO0_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* =========================================================  INTR1  ========================================================= */
#define IO_BANK0_INTR1_GPIO15_EDGE_HIGH_Pos (31UL)                  /*!< GPIO15_EDGE_HIGH (Bit 31) */
#define IO_BANK0_INTR1_GPIO15_EDGE_HIGH_Msk (0x80000000UL)          /*!< GPIO15_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO15_EDGE_LOW_Pos (30UL)                   /*!< GPIO15_EDGE_LOW (Bit 30) */
#define IO_BANK0_INTR1_GPIO15_EDGE_LOW_Msk (0x40000000UL)           /*!< GPIO15_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO15_LEVEL_HIGH_Pos (29UL)                 /*!< GPIO15_LEVEL_HIGH (Bit 29) */
#define IO_BANK0_INTR1_GPIO15_LEVEL_HIGH_Msk (0x20000000UL)         /*!< GPIO15_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO15_LEVEL_LOW_Pos (28UL)                  /*!< GPIO15_LEVEL_LOW (Bit 28) */
#define IO_BANK0_INTR1_GPIO15_LEVEL_LOW_Msk (0x10000000UL)          /*!< GPIO15_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO14_EDGE_HIGH_Pos (27UL)                  /*!< GPIO14_EDGE_HIGH (Bit 27) */
#define IO_BANK0_INTR1_GPIO14_EDGE_HIGH_Msk (0x8000000UL)           /*!< GPIO14_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO14_EDGE_LOW_Pos (26UL)                   /*!< GPIO14_EDGE_LOW (Bit 26) */
#define IO_BANK0_INTR1_GPIO14_EDGE_LOW_Msk (0x4000000UL)            /*!< GPIO14_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO14_LEVEL_HIGH_Pos (25UL)                 /*!< GPIO14_LEVEL_HIGH (Bit 25) */
#define IO_BANK0_INTR1_GPIO14_LEVEL_HIGH_Msk (0x2000000UL)          /*!< GPIO14_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO14_LEVEL_LOW_Pos (24UL)                  /*!< GPIO14_LEVEL_LOW (Bit 24) */
#define IO_BANK0_INTR1_GPIO14_LEVEL_LOW_Msk (0x1000000UL)           /*!< GPIO14_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO13_EDGE_HIGH_Pos (23UL)                  /*!< GPIO13_EDGE_HIGH (Bit 23) */
#define IO_BANK0_INTR1_GPIO13_EDGE_HIGH_Msk (0x800000UL)            /*!< GPIO13_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO13_EDGE_LOW_Pos (22UL)                   /*!< GPIO13_EDGE_LOW (Bit 22) */
#define IO_BANK0_INTR1_GPIO13_EDGE_LOW_Msk (0x400000UL)             /*!< GPIO13_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO13_LEVEL_HIGH_Pos (21UL)                 /*!< GPIO13_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_INTR1_GPIO13_LEVEL_HIGH_Msk (0x200000UL)           /*!< GPIO13_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO13_LEVEL_LOW_Pos (20UL)                  /*!< GPIO13_LEVEL_LOW (Bit 20) */
#define IO_BANK0_INTR1_GPIO13_LEVEL_LOW_Msk (0x100000UL)            /*!< GPIO13_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO12_EDGE_HIGH_Pos (19UL)                  /*!< GPIO12_EDGE_HIGH (Bit 19) */
#define IO_BANK0_INTR1_GPIO12_EDGE_HIGH_Msk (0x80000UL)             /*!< GPIO12_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO12_EDGE_LOW_Pos (18UL)                   /*!< GPIO12_EDGE_LOW (Bit 18) */
#define IO_BANK0_INTR1_GPIO12_EDGE_LOW_Msk (0x40000UL)              /*!< GPIO12_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO12_LEVEL_HIGH_Pos (17UL)                 /*!< GPIO12_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_INTR1_GPIO12_LEVEL_HIGH_Msk (0x20000UL)            /*!< GPIO12_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO12_LEVEL_LOW_Pos (16UL)                  /*!< GPIO12_LEVEL_LOW (Bit 16) */
#define IO_BANK0_INTR1_GPIO12_LEVEL_LOW_Msk (0x10000UL)             /*!< GPIO12_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO11_EDGE_HIGH_Pos (15UL)                  /*!< GPIO11_EDGE_HIGH (Bit 15) */
#define IO_BANK0_INTR1_GPIO11_EDGE_HIGH_Msk (0x8000UL)              /*!< GPIO11_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO11_EDGE_LOW_Pos (14UL)                   /*!< GPIO11_EDGE_LOW (Bit 14) */
#define IO_BANK0_INTR1_GPIO11_EDGE_LOW_Msk (0x4000UL)               /*!< GPIO11_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO11_LEVEL_HIGH_Pos (13UL)                 /*!< GPIO11_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_INTR1_GPIO11_LEVEL_HIGH_Msk (0x2000UL)             /*!< GPIO11_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO11_LEVEL_LOW_Pos (12UL)                  /*!< GPIO11_LEVEL_LOW (Bit 12) */
#define IO_BANK0_INTR1_GPIO11_LEVEL_LOW_Msk (0x1000UL)              /*!< GPIO11_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO10_EDGE_HIGH_Pos (11UL)                  /*!< GPIO10_EDGE_HIGH (Bit 11) */
#define IO_BANK0_INTR1_GPIO10_EDGE_HIGH_Msk (0x800UL)               /*!< GPIO10_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO10_EDGE_LOW_Pos (10UL)                   /*!< GPIO10_EDGE_LOW (Bit 10) */
#define IO_BANK0_INTR1_GPIO10_EDGE_LOW_Msk (0x400UL)                /*!< GPIO10_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO10_LEVEL_HIGH_Pos (9UL)                  /*!< GPIO10_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_INTR1_GPIO10_LEVEL_HIGH_Msk (0x200UL)              /*!< GPIO10_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO10_LEVEL_LOW_Pos (8UL)                   /*!< GPIO10_LEVEL_LOW (Bit 8) */
#define IO_BANK0_INTR1_GPIO10_LEVEL_LOW_Msk (0x100UL)               /*!< GPIO10_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO9_EDGE_HIGH_Pos (7UL)                    /*!< GPIO9_EDGE_HIGH (Bit 7) */
#define IO_BANK0_INTR1_GPIO9_EDGE_HIGH_Msk (0x80UL)                 /*!< GPIO9_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO9_EDGE_LOW_Pos (6UL)                     /*!< GPIO9_EDGE_LOW (Bit 6) */
#define IO_BANK0_INTR1_GPIO9_EDGE_LOW_Msk (0x40UL)                  /*!< GPIO9_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO9_LEVEL_HIGH_Pos (5UL)                   /*!< GPIO9_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_INTR1_GPIO9_LEVEL_HIGH_Msk (0x20UL)                /*!< GPIO9_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO9_LEVEL_LOW_Pos (4UL)                    /*!< GPIO9_LEVEL_LOW (Bit 4) */
#define IO_BANK0_INTR1_GPIO9_LEVEL_LOW_Msk (0x10UL)                 /*!< GPIO9_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO8_EDGE_HIGH_Pos (3UL)                    /*!< GPIO8_EDGE_HIGH (Bit 3) */
#define IO_BANK0_INTR1_GPIO8_EDGE_HIGH_Msk (0x8UL)                  /*!< GPIO8_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO8_EDGE_LOW_Pos (2UL)                     /*!< GPIO8_EDGE_LOW (Bit 2) */
#define IO_BANK0_INTR1_GPIO8_EDGE_LOW_Msk (0x4UL)                   /*!< GPIO8_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO8_LEVEL_HIGH_Pos (1UL)                   /*!< GPIO8_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_INTR1_GPIO8_LEVEL_HIGH_Msk (0x2UL)                 /*!< GPIO8_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR1_GPIO8_LEVEL_LOW_Pos (0UL)                    /*!< GPIO8_LEVEL_LOW (Bit 0) */
#define IO_BANK0_INTR1_GPIO8_LEVEL_LOW_Msk (0x1UL)                  /*!< GPIO8_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* =========================================================  INTR2  ========================================================= */
#define IO_BANK0_INTR2_GPIO23_EDGE_HIGH_Pos (31UL)                  /*!< GPIO23_EDGE_HIGH (Bit 31) */
#define IO_BANK0_INTR2_GPIO23_EDGE_HIGH_Msk (0x80000000UL)          /*!< GPIO23_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO23_EDGE_LOW_Pos (30UL)                   /*!< GPIO23_EDGE_LOW (Bit 30) */
#define IO_BANK0_INTR2_GPIO23_EDGE_LOW_Msk (0x40000000UL)           /*!< GPIO23_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO23_LEVEL_HIGH_Pos (29UL)                 /*!< GPIO23_LEVEL_HIGH (Bit 29) */
#define IO_BANK0_INTR2_GPIO23_LEVEL_HIGH_Msk (0x20000000UL)         /*!< GPIO23_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO23_LEVEL_LOW_Pos (28UL)                  /*!< GPIO23_LEVEL_LOW (Bit 28) */
#define IO_BANK0_INTR2_GPIO23_LEVEL_LOW_Msk (0x10000000UL)          /*!< GPIO23_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO22_EDGE_HIGH_Pos (27UL)                  /*!< GPIO22_EDGE_HIGH (Bit 27) */
#define IO_BANK0_INTR2_GPIO22_EDGE_HIGH_Msk (0x8000000UL)           /*!< GPIO22_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO22_EDGE_LOW_Pos (26UL)                   /*!< GPIO22_EDGE_LOW (Bit 26) */
#define IO_BANK0_INTR2_GPIO22_EDGE_LOW_Msk (0x4000000UL)            /*!< GPIO22_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO22_LEVEL_HIGH_Pos (25UL)                 /*!< GPIO22_LEVEL_HIGH (Bit 25) */
#define IO_BANK0_INTR2_GPIO22_LEVEL_HIGH_Msk (0x2000000UL)          /*!< GPIO22_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO22_LEVEL_LOW_Pos (24UL)                  /*!< GPIO22_LEVEL_LOW (Bit 24) */
#define IO_BANK0_INTR2_GPIO22_LEVEL_LOW_Msk (0x1000000UL)           /*!< GPIO22_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO21_EDGE_HIGH_Pos (23UL)                  /*!< GPIO21_EDGE_HIGH (Bit 23) */
#define IO_BANK0_INTR2_GPIO21_EDGE_HIGH_Msk (0x800000UL)            /*!< GPIO21_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO21_EDGE_LOW_Pos (22UL)                   /*!< GPIO21_EDGE_LOW (Bit 22) */
#define IO_BANK0_INTR2_GPIO21_EDGE_LOW_Msk (0x400000UL)             /*!< GPIO21_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO21_LEVEL_HIGH_Pos (21UL)                 /*!< GPIO21_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_INTR2_GPIO21_LEVEL_HIGH_Msk (0x200000UL)           /*!< GPIO21_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO21_LEVEL_LOW_Pos (20UL)                  /*!< GPIO21_LEVEL_LOW (Bit 20) */
#define IO_BANK0_INTR2_GPIO21_LEVEL_LOW_Msk (0x100000UL)            /*!< GPIO21_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO20_EDGE_HIGH_Pos (19UL)                  /*!< GPIO20_EDGE_HIGH (Bit 19) */
#define IO_BANK0_INTR2_GPIO20_EDGE_HIGH_Msk (0x80000UL)             /*!< GPIO20_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO20_EDGE_LOW_Pos (18UL)                   /*!< GPIO20_EDGE_LOW (Bit 18) */
#define IO_BANK0_INTR2_GPIO20_EDGE_LOW_Msk (0x40000UL)              /*!< GPIO20_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO20_LEVEL_HIGH_Pos (17UL)                 /*!< GPIO20_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_INTR2_GPIO20_LEVEL_HIGH_Msk (0x20000UL)            /*!< GPIO20_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO20_LEVEL_LOW_Pos (16UL)                  /*!< GPIO20_LEVEL_LOW (Bit 16) */
#define IO_BANK0_INTR2_GPIO20_LEVEL_LOW_Msk (0x10000UL)             /*!< GPIO20_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO19_EDGE_HIGH_Pos (15UL)                  /*!< GPIO19_EDGE_HIGH (Bit 15) */
#define IO_BANK0_INTR2_GPIO19_EDGE_HIGH_Msk (0x8000UL)              /*!< GPIO19_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO19_EDGE_LOW_Pos (14UL)                   /*!< GPIO19_EDGE_LOW (Bit 14) */
#define IO_BANK0_INTR2_GPIO19_EDGE_LOW_Msk (0x4000UL)               /*!< GPIO19_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO19_LEVEL_HIGH_Pos (13UL)                 /*!< GPIO19_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_INTR2_GPIO19_LEVEL_HIGH_Msk (0x2000UL)             /*!< GPIO19_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO19_LEVEL_LOW_Pos (12UL)                  /*!< GPIO19_LEVEL_LOW (Bit 12) */
#define IO_BANK0_INTR2_GPIO19_LEVEL_LOW_Msk (0x1000UL)              /*!< GPIO19_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO18_EDGE_HIGH_Pos (11UL)                  /*!< GPIO18_EDGE_HIGH (Bit 11) */
#define IO_BANK0_INTR2_GPIO18_EDGE_HIGH_Msk (0x800UL)               /*!< GPIO18_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO18_EDGE_LOW_Pos (10UL)                   /*!< GPIO18_EDGE_LOW (Bit 10) */
#define IO_BANK0_INTR2_GPIO18_EDGE_LOW_Msk (0x400UL)                /*!< GPIO18_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO18_LEVEL_HIGH_Pos (9UL)                  /*!< GPIO18_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_INTR2_GPIO18_LEVEL_HIGH_Msk (0x200UL)              /*!< GPIO18_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO18_LEVEL_LOW_Pos (8UL)                   /*!< GPIO18_LEVEL_LOW (Bit 8) */
#define IO_BANK0_INTR2_GPIO18_LEVEL_LOW_Msk (0x100UL)               /*!< GPIO18_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO17_EDGE_HIGH_Pos (7UL)                   /*!< GPIO17_EDGE_HIGH (Bit 7) */
#define IO_BANK0_INTR2_GPIO17_EDGE_HIGH_Msk (0x80UL)                /*!< GPIO17_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO17_EDGE_LOW_Pos (6UL)                    /*!< GPIO17_EDGE_LOW (Bit 6) */
#define IO_BANK0_INTR2_GPIO17_EDGE_LOW_Msk (0x40UL)                 /*!< GPIO17_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO17_LEVEL_HIGH_Pos (5UL)                  /*!< GPIO17_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_INTR2_GPIO17_LEVEL_HIGH_Msk (0x20UL)               /*!< GPIO17_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO17_LEVEL_LOW_Pos (4UL)                   /*!< GPIO17_LEVEL_LOW (Bit 4) */
#define IO_BANK0_INTR2_GPIO17_LEVEL_LOW_Msk (0x10UL)                /*!< GPIO17_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO16_EDGE_HIGH_Pos (3UL)                   /*!< GPIO16_EDGE_HIGH (Bit 3) */
#define IO_BANK0_INTR2_GPIO16_EDGE_HIGH_Msk (0x8UL)                 /*!< GPIO16_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO16_EDGE_LOW_Pos (2UL)                    /*!< GPIO16_EDGE_LOW (Bit 2) */
#define IO_BANK0_INTR2_GPIO16_EDGE_LOW_Msk (0x4UL)                  /*!< GPIO16_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO16_LEVEL_HIGH_Pos (1UL)                  /*!< GPIO16_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_INTR2_GPIO16_LEVEL_HIGH_Msk (0x2UL)                /*!< GPIO16_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR2_GPIO16_LEVEL_LOW_Pos (0UL)                   /*!< GPIO16_LEVEL_LOW (Bit 0) */
#define IO_BANK0_INTR2_GPIO16_LEVEL_LOW_Msk (0x1UL)                 /*!< GPIO16_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* =========================================================  INTR3  ========================================================= */
#define IO_BANK0_INTR3_GPIO29_EDGE_HIGH_Pos (23UL)                  /*!< GPIO29_EDGE_HIGH (Bit 23) */
#define IO_BANK0_INTR3_GPIO29_EDGE_HIGH_Msk (0x800000UL)            /*!< GPIO29_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR3_GPIO29_EDGE_LOW_Pos (22UL)                   /*!< GPIO29_EDGE_LOW (Bit 22) */
#define IO_BANK0_INTR3_GPIO29_EDGE_LOW_Msk (0x400000UL)             /*!< GPIO29_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR3_GPIO29_LEVEL_HIGH_Pos (21UL)                 /*!< GPIO29_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_INTR3_GPIO29_LEVEL_HIGH_Msk (0x200000UL)           /*!< GPIO29_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR3_GPIO29_LEVEL_LOW_Pos (20UL)                  /*!< GPIO29_LEVEL_LOW (Bit 20) */
#define IO_BANK0_INTR3_GPIO29_LEVEL_LOW_Msk (0x100000UL)            /*!< GPIO29_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR3_GPIO28_EDGE_HIGH_Pos (19UL)                  /*!< GPIO28_EDGE_HIGH (Bit 19) */
#define IO_BANK0_INTR3_GPIO28_EDGE_HIGH_Msk (0x80000UL)             /*!< GPIO28_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR3_GPIO28_EDGE_LOW_Pos (18UL)                   /*!< GPIO28_EDGE_LOW (Bit 18) */
#define IO_BANK0_INTR3_GPIO28_EDGE_LOW_Msk (0x40000UL)              /*!< GPIO28_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR3_GPIO28_LEVEL_HIGH_Pos (17UL)                 /*!< GPIO28_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_INTR3_GPIO28_LEVEL_HIGH_Msk (0x20000UL)            /*!< GPIO28_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR3_GPIO28_LEVEL_LOW_Pos (16UL)                  /*!< GPIO28_LEVEL_LOW (Bit 16) */
#define IO_BANK0_INTR3_GPIO28_LEVEL_LOW_Msk (0x10000UL)             /*!< GPIO28_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR3_GPIO27_EDGE_HIGH_Pos (15UL)                  /*!< GPIO27_EDGE_HIGH (Bit 15) */
#define IO_BANK0_INTR3_GPIO27_EDGE_HIGH_Msk (0x8000UL)              /*!< GPIO27_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR3_GPIO27_EDGE_LOW_Pos (14UL)                   /*!< GPIO27_EDGE_LOW (Bit 14) */
#define IO_BANK0_INTR3_GPIO27_EDGE_LOW_Msk (0x4000UL)               /*!< GPIO27_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR3_GPIO27_LEVEL_HIGH_Pos (13UL)                 /*!< GPIO27_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_INTR3_GPIO27_LEVEL_HIGH_Msk (0x2000UL)             /*!< GPIO27_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR3_GPIO27_LEVEL_LOW_Pos (12UL)                  /*!< GPIO27_LEVEL_LOW (Bit 12) */
#define IO_BANK0_INTR3_GPIO27_LEVEL_LOW_Msk (0x1000UL)              /*!< GPIO27_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR3_GPIO26_EDGE_HIGH_Pos (11UL)                  /*!< GPIO26_EDGE_HIGH (Bit 11) */
#define IO_BANK0_INTR3_GPIO26_EDGE_HIGH_Msk (0x800UL)               /*!< GPIO26_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR3_GPIO26_EDGE_LOW_Pos (10UL)                   /*!< GPIO26_EDGE_LOW (Bit 10) */
#define IO_BANK0_INTR3_GPIO26_EDGE_LOW_Msk (0x400UL)                /*!< GPIO26_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR3_GPIO26_LEVEL_HIGH_Pos (9UL)                  /*!< GPIO26_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_INTR3_GPIO26_LEVEL_HIGH_Msk (0x200UL)              /*!< GPIO26_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR3_GPIO26_LEVEL_LOW_Pos (8UL)                   /*!< GPIO26_LEVEL_LOW (Bit 8) */
#define IO_BANK0_INTR3_GPIO26_LEVEL_LOW_Msk (0x100UL)               /*!< GPIO26_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR3_GPIO25_EDGE_HIGH_Pos (7UL)                   /*!< GPIO25_EDGE_HIGH (Bit 7) */
#define IO_BANK0_INTR3_GPIO25_EDGE_HIGH_Msk (0x80UL)                /*!< GPIO25_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR3_GPIO25_EDGE_LOW_Pos (6UL)                    /*!< GPIO25_EDGE_LOW (Bit 6) */
#define IO_BANK0_INTR3_GPIO25_EDGE_LOW_Msk (0x40UL)                 /*!< GPIO25_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR3_GPIO25_LEVEL_HIGH_Pos (5UL)                  /*!< GPIO25_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_INTR3_GPIO25_LEVEL_HIGH_Msk (0x20UL)               /*!< GPIO25_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR3_GPIO25_LEVEL_LOW_Pos (4UL)                   /*!< GPIO25_LEVEL_LOW (Bit 4) */
#define IO_BANK0_INTR3_GPIO25_LEVEL_LOW_Msk (0x10UL)                /*!< GPIO25_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR3_GPIO24_EDGE_HIGH_Pos (3UL)                   /*!< GPIO24_EDGE_HIGH (Bit 3) */
#define IO_BANK0_INTR3_GPIO24_EDGE_HIGH_Msk (0x8UL)                 /*!< GPIO24_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR3_GPIO24_EDGE_LOW_Pos (2UL)                    /*!< GPIO24_EDGE_LOW (Bit 2) */
#define IO_BANK0_INTR3_GPIO24_EDGE_LOW_Msk (0x4UL)                  /*!< GPIO24_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR3_GPIO24_LEVEL_HIGH_Pos (1UL)                  /*!< GPIO24_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_INTR3_GPIO24_LEVEL_HIGH_Msk (0x2UL)                /*!< GPIO24_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_INTR3_GPIO24_LEVEL_LOW_Pos (0UL)                   /*!< GPIO24_LEVEL_LOW (Bit 0) */
#define IO_BANK0_INTR3_GPIO24_LEVEL_LOW_Msk (0x1UL)                 /*!< GPIO24_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ======================================================  PROC0_INTE0  ====================================================== */
#define IO_BANK0_PROC0_INTE0_GPIO7_EDGE_HIGH_Pos (31UL)             /*!< GPIO7_EDGE_HIGH (Bit 31) */
#define IO_BANK0_PROC0_INTE0_GPIO7_EDGE_HIGH_Msk (0x80000000UL)     /*!< GPIO7_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO7_EDGE_LOW_Pos (30UL)              /*!< GPIO7_EDGE_LOW (Bit 30) */
#define IO_BANK0_PROC0_INTE0_GPIO7_EDGE_LOW_Msk (0x40000000UL)      /*!< GPIO7_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO7_LEVEL_HIGH_Pos (29UL)            /*!< GPIO7_LEVEL_HIGH (Bit 29) */
#define IO_BANK0_PROC0_INTE0_GPIO7_LEVEL_HIGH_Msk (0x20000000UL)    /*!< GPIO7_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO7_LEVEL_LOW_Pos (28UL)             /*!< GPIO7_LEVEL_LOW (Bit 28) */
#define IO_BANK0_PROC0_INTE0_GPIO7_LEVEL_LOW_Msk (0x10000000UL)     /*!< GPIO7_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO6_EDGE_HIGH_Pos (27UL)             /*!< GPIO6_EDGE_HIGH (Bit 27) */
#define IO_BANK0_PROC0_INTE0_GPIO6_EDGE_HIGH_Msk (0x8000000UL)      /*!< GPIO6_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO6_EDGE_LOW_Pos (26UL)              /*!< GPIO6_EDGE_LOW (Bit 26) */
#define IO_BANK0_PROC0_INTE0_GPIO6_EDGE_LOW_Msk (0x4000000UL)       /*!< GPIO6_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO6_LEVEL_HIGH_Pos (25UL)            /*!< GPIO6_LEVEL_HIGH (Bit 25) */
#define IO_BANK0_PROC0_INTE0_GPIO6_LEVEL_HIGH_Msk (0x2000000UL)     /*!< GPIO6_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO6_LEVEL_LOW_Pos (24UL)             /*!< GPIO6_LEVEL_LOW (Bit 24) */
#define IO_BANK0_PROC0_INTE0_GPIO6_LEVEL_LOW_Msk (0x1000000UL)      /*!< GPIO6_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO5_EDGE_HIGH_Pos (23UL)             /*!< GPIO5_EDGE_HIGH (Bit 23) */
#define IO_BANK0_PROC0_INTE0_GPIO5_EDGE_HIGH_Msk (0x800000UL)       /*!< GPIO5_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO5_EDGE_LOW_Pos (22UL)              /*!< GPIO5_EDGE_LOW (Bit 22) */
#define IO_BANK0_PROC0_INTE0_GPIO5_EDGE_LOW_Msk (0x400000UL)        /*!< GPIO5_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO5_LEVEL_HIGH_Pos (21UL)            /*!< GPIO5_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_PROC0_INTE0_GPIO5_LEVEL_HIGH_Msk (0x200000UL)      /*!< GPIO5_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO5_LEVEL_LOW_Pos (20UL)             /*!< GPIO5_LEVEL_LOW (Bit 20) */
#define IO_BANK0_PROC0_INTE0_GPIO5_LEVEL_LOW_Msk (0x100000UL)       /*!< GPIO5_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO4_EDGE_HIGH_Pos (19UL)             /*!< GPIO4_EDGE_HIGH (Bit 19) */
#define IO_BANK0_PROC0_INTE0_GPIO4_EDGE_HIGH_Msk (0x80000UL)        /*!< GPIO4_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO4_EDGE_LOW_Pos (18UL)              /*!< GPIO4_EDGE_LOW (Bit 18) */
#define IO_BANK0_PROC0_INTE0_GPIO4_EDGE_LOW_Msk (0x40000UL)         /*!< GPIO4_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO4_LEVEL_HIGH_Pos (17UL)            /*!< GPIO4_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_PROC0_INTE0_GPIO4_LEVEL_HIGH_Msk (0x20000UL)       /*!< GPIO4_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO4_LEVEL_LOW_Pos (16UL)             /*!< GPIO4_LEVEL_LOW (Bit 16) */
#define IO_BANK0_PROC0_INTE0_GPIO4_LEVEL_LOW_Msk (0x10000UL)        /*!< GPIO4_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO3_EDGE_HIGH_Pos (15UL)             /*!< GPIO3_EDGE_HIGH (Bit 15) */
#define IO_BANK0_PROC0_INTE0_GPIO3_EDGE_HIGH_Msk (0x8000UL)         /*!< GPIO3_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO3_EDGE_LOW_Pos (14UL)              /*!< GPIO3_EDGE_LOW (Bit 14) */
#define IO_BANK0_PROC0_INTE0_GPIO3_EDGE_LOW_Msk (0x4000UL)          /*!< GPIO3_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO3_LEVEL_HIGH_Pos (13UL)            /*!< GPIO3_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_PROC0_INTE0_GPIO3_LEVEL_HIGH_Msk (0x2000UL)        /*!< GPIO3_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO3_LEVEL_LOW_Pos (12UL)             /*!< GPIO3_LEVEL_LOW (Bit 12) */
#define IO_BANK0_PROC0_INTE0_GPIO3_LEVEL_LOW_Msk (0x1000UL)         /*!< GPIO3_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO2_EDGE_HIGH_Pos (11UL)             /*!< GPIO2_EDGE_HIGH (Bit 11) */
#define IO_BANK0_PROC0_INTE0_GPIO2_EDGE_HIGH_Msk (0x800UL)          /*!< GPIO2_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO2_EDGE_LOW_Pos (10UL)              /*!< GPIO2_EDGE_LOW (Bit 10) */
#define IO_BANK0_PROC0_INTE0_GPIO2_EDGE_LOW_Msk (0x400UL)           /*!< GPIO2_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO2_LEVEL_HIGH_Pos (9UL)             /*!< GPIO2_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_PROC0_INTE0_GPIO2_LEVEL_HIGH_Msk (0x200UL)         /*!< GPIO2_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO2_LEVEL_LOW_Pos (8UL)              /*!< GPIO2_LEVEL_LOW (Bit 8) */
#define IO_BANK0_PROC0_INTE0_GPIO2_LEVEL_LOW_Msk (0x100UL)          /*!< GPIO2_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO1_EDGE_HIGH_Pos (7UL)              /*!< GPIO1_EDGE_HIGH (Bit 7) */
#define IO_BANK0_PROC0_INTE0_GPIO1_EDGE_HIGH_Msk (0x80UL)           /*!< GPIO1_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO1_EDGE_LOW_Pos (6UL)               /*!< GPIO1_EDGE_LOW (Bit 6) */
#define IO_BANK0_PROC0_INTE0_GPIO1_EDGE_LOW_Msk (0x40UL)            /*!< GPIO1_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO1_LEVEL_HIGH_Pos (5UL)             /*!< GPIO1_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_PROC0_INTE0_GPIO1_LEVEL_HIGH_Msk (0x20UL)          /*!< GPIO1_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO1_LEVEL_LOW_Pos (4UL)              /*!< GPIO1_LEVEL_LOW (Bit 4) */
#define IO_BANK0_PROC0_INTE0_GPIO1_LEVEL_LOW_Msk (0x10UL)           /*!< GPIO1_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO0_EDGE_HIGH_Pos (3UL)              /*!< GPIO0_EDGE_HIGH (Bit 3) */
#define IO_BANK0_PROC0_INTE0_GPIO0_EDGE_HIGH_Msk (0x8UL)            /*!< GPIO0_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO0_EDGE_LOW_Pos (2UL)               /*!< GPIO0_EDGE_LOW (Bit 2) */
#define IO_BANK0_PROC0_INTE0_GPIO0_EDGE_LOW_Msk (0x4UL)             /*!< GPIO0_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO0_LEVEL_HIGH_Pos (1UL)             /*!< GPIO0_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_PROC0_INTE0_GPIO0_LEVEL_HIGH_Msk (0x2UL)           /*!< GPIO0_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE0_GPIO0_LEVEL_LOW_Pos (0UL)              /*!< GPIO0_LEVEL_LOW (Bit 0) */
#define IO_BANK0_PROC0_INTE0_GPIO0_LEVEL_LOW_Msk (0x1UL)            /*!< GPIO0_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ======================================================  PROC0_INTE1  ====================================================== */
#define IO_BANK0_PROC0_INTE1_GPIO15_EDGE_HIGH_Pos (31UL)            /*!< GPIO15_EDGE_HIGH (Bit 31) */
#define IO_BANK0_PROC0_INTE1_GPIO15_EDGE_HIGH_Msk (0x80000000UL)    /*!< GPIO15_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO15_EDGE_LOW_Pos (30UL)             /*!< GPIO15_EDGE_LOW (Bit 30) */
#define IO_BANK0_PROC0_INTE1_GPIO15_EDGE_LOW_Msk (0x40000000UL)     /*!< GPIO15_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO15_LEVEL_HIGH_Pos (29UL)           /*!< GPIO15_LEVEL_HIGH (Bit 29) */
#define IO_BANK0_PROC0_INTE1_GPIO15_LEVEL_HIGH_Msk (0x20000000UL)   /*!< GPIO15_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO15_LEVEL_LOW_Pos (28UL)            /*!< GPIO15_LEVEL_LOW (Bit 28) */
#define IO_BANK0_PROC0_INTE1_GPIO15_LEVEL_LOW_Msk (0x10000000UL)    /*!< GPIO15_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO14_EDGE_HIGH_Pos (27UL)            /*!< GPIO14_EDGE_HIGH (Bit 27) */
#define IO_BANK0_PROC0_INTE1_GPIO14_EDGE_HIGH_Msk (0x8000000UL)     /*!< GPIO14_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO14_EDGE_LOW_Pos (26UL)             /*!< GPIO14_EDGE_LOW (Bit 26) */
#define IO_BANK0_PROC0_INTE1_GPIO14_EDGE_LOW_Msk (0x4000000UL)      /*!< GPIO14_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO14_LEVEL_HIGH_Pos (25UL)           /*!< GPIO14_LEVEL_HIGH (Bit 25) */
#define IO_BANK0_PROC0_INTE1_GPIO14_LEVEL_HIGH_Msk (0x2000000UL)    /*!< GPIO14_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO14_LEVEL_LOW_Pos (24UL)            /*!< GPIO14_LEVEL_LOW (Bit 24) */
#define IO_BANK0_PROC0_INTE1_GPIO14_LEVEL_LOW_Msk (0x1000000UL)     /*!< GPIO14_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO13_EDGE_HIGH_Pos (23UL)            /*!< GPIO13_EDGE_HIGH (Bit 23) */
#define IO_BANK0_PROC0_INTE1_GPIO13_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO13_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO13_EDGE_LOW_Pos (22UL)             /*!< GPIO13_EDGE_LOW (Bit 22) */
#define IO_BANK0_PROC0_INTE1_GPIO13_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO13_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO13_LEVEL_HIGH_Pos (21UL)           /*!< GPIO13_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_PROC0_INTE1_GPIO13_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO13_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO13_LEVEL_LOW_Pos (20UL)            /*!< GPIO13_LEVEL_LOW (Bit 20) */
#define IO_BANK0_PROC0_INTE1_GPIO13_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO13_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO12_EDGE_HIGH_Pos (19UL)            /*!< GPIO12_EDGE_HIGH (Bit 19) */
#define IO_BANK0_PROC0_INTE1_GPIO12_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO12_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO12_EDGE_LOW_Pos (18UL)             /*!< GPIO12_EDGE_LOW (Bit 18) */
#define IO_BANK0_PROC0_INTE1_GPIO12_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO12_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO12_LEVEL_HIGH_Pos (17UL)           /*!< GPIO12_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_PROC0_INTE1_GPIO12_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO12_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO12_LEVEL_LOW_Pos (16UL)            /*!< GPIO12_LEVEL_LOW (Bit 16) */
#define IO_BANK0_PROC0_INTE1_GPIO12_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO12_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO11_EDGE_HIGH_Pos (15UL)            /*!< GPIO11_EDGE_HIGH (Bit 15) */
#define IO_BANK0_PROC0_INTE1_GPIO11_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO11_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO11_EDGE_LOW_Pos (14UL)             /*!< GPIO11_EDGE_LOW (Bit 14) */
#define IO_BANK0_PROC0_INTE1_GPIO11_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO11_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO11_LEVEL_HIGH_Pos (13UL)           /*!< GPIO11_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_PROC0_INTE1_GPIO11_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO11_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO11_LEVEL_LOW_Pos (12UL)            /*!< GPIO11_LEVEL_LOW (Bit 12) */
#define IO_BANK0_PROC0_INTE1_GPIO11_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO11_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO10_EDGE_HIGH_Pos (11UL)            /*!< GPIO10_EDGE_HIGH (Bit 11) */
#define IO_BANK0_PROC0_INTE1_GPIO10_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO10_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO10_EDGE_LOW_Pos (10UL)             /*!< GPIO10_EDGE_LOW (Bit 10) */
#define IO_BANK0_PROC0_INTE1_GPIO10_EDGE_LOW_Msk (0x400UL)          /*!< GPIO10_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO10_LEVEL_HIGH_Pos (9UL)            /*!< GPIO10_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_PROC0_INTE1_GPIO10_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO10_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO10_LEVEL_LOW_Pos (8UL)             /*!< GPIO10_LEVEL_LOW (Bit 8) */
#define IO_BANK0_PROC0_INTE1_GPIO10_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO10_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO9_EDGE_HIGH_Pos (7UL)              /*!< GPIO9_EDGE_HIGH (Bit 7) */
#define IO_BANK0_PROC0_INTE1_GPIO9_EDGE_HIGH_Msk (0x80UL)           /*!< GPIO9_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO9_EDGE_LOW_Pos (6UL)               /*!< GPIO9_EDGE_LOW (Bit 6) */
#define IO_BANK0_PROC0_INTE1_GPIO9_EDGE_LOW_Msk (0x40UL)            /*!< GPIO9_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO9_LEVEL_HIGH_Pos (5UL)             /*!< GPIO9_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_PROC0_INTE1_GPIO9_LEVEL_HIGH_Msk (0x20UL)          /*!< GPIO9_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO9_LEVEL_LOW_Pos (4UL)              /*!< GPIO9_LEVEL_LOW (Bit 4) */
#define IO_BANK0_PROC0_INTE1_GPIO9_LEVEL_LOW_Msk (0x10UL)           /*!< GPIO9_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO8_EDGE_HIGH_Pos (3UL)              /*!< GPIO8_EDGE_HIGH (Bit 3) */
#define IO_BANK0_PROC0_INTE1_GPIO8_EDGE_HIGH_Msk (0x8UL)            /*!< GPIO8_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO8_EDGE_LOW_Pos (2UL)               /*!< GPIO8_EDGE_LOW (Bit 2) */
#define IO_BANK0_PROC0_INTE1_GPIO8_EDGE_LOW_Msk (0x4UL)             /*!< GPIO8_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO8_LEVEL_HIGH_Pos (1UL)             /*!< GPIO8_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_PROC0_INTE1_GPIO8_LEVEL_HIGH_Msk (0x2UL)           /*!< GPIO8_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE1_GPIO8_LEVEL_LOW_Pos (0UL)              /*!< GPIO8_LEVEL_LOW (Bit 0) */
#define IO_BANK0_PROC0_INTE1_GPIO8_LEVEL_LOW_Msk (0x1UL)            /*!< GPIO8_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ======================================================  PROC0_INTE2  ====================================================== */
#define IO_BANK0_PROC0_INTE2_GPIO23_EDGE_HIGH_Pos (31UL)            /*!< GPIO23_EDGE_HIGH (Bit 31) */
#define IO_BANK0_PROC0_INTE2_GPIO23_EDGE_HIGH_Msk (0x80000000UL)    /*!< GPIO23_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO23_EDGE_LOW_Pos (30UL)             /*!< GPIO23_EDGE_LOW (Bit 30) */
#define IO_BANK0_PROC0_INTE2_GPIO23_EDGE_LOW_Msk (0x40000000UL)     /*!< GPIO23_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO23_LEVEL_HIGH_Pos (29UL)           /*!< GPIO23_LEVEL_HIGH (Bit 29) */
#define IO_BANK0_PROC0_INTE2_GPIO23_LEVEL_HIGH_Msk (0x20000000UL)   /*!< GPIO23_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO23_LEVEL_LOW_Pos (28UL)            /*!< GPIO23_LEVEL_LOW (Bit 28) */
#define IO_BANK0_PROC0_INTE2_GPIO23_LEVEL_LOW_Msk (0x10000000UL)    /*!< GPIO23_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO22_EDGE_HIGH_Pos (27UL)            /*!< GPIO22_EDGE_HIGH (Bit 27) */
#define IO_BANK0_PROC0_INTE2_GPIO22_EDGE_HIGH_Msk (0x8000000UL)     /*!< GPIO22_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO22_EDGE_LOW_Pos (26UL)             /*!< GPIO22_EDGE_LOW (Bit 26) */
#define IO_BANK0_PROC0_INTE2_GPIO22_EDGE_LOW_Msk (0x4000000UL)      /*!< GPIO22_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO22_LEVEL_HIGH_Pos (25UL)           /*!< GPIO22_LEVEL_HIGH (Bit 25) */
#define IO_BANK0_PROC0_INTE2_GPIO22_LEVEL_HIGH_Msk (0x2000000UL)    /*!< GPIO22_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO22_LEVEL_LOW_Pos (24UL)            /*!< GPIO22_LEVEL_LOW (Bit 24) */
#define IO_BANK0_PROC0_INTE2_GPIO22_LEVEL_LOW_Msk (0x1000000UL)     /*!< GPIO22_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO21_EDGE_HIGH_Pos (23UL)            /*!< GPIO21_EDGE_HIGH (Bit 23) */
#define IO_BANK0_PROC0_INTE2_GPIO21_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO21_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO21_EDGE_LOW_Pos (22UL)             /*!< GPIO21_EDGE_LOW (Bit 22) */
#define IO_BANK0_PROC0_INTE2_GPIO21_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO21_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO21_LEVEL_HIGH_Pos (21UL)           /*!< GPIO21_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_PROC0_INTE2_GPIO21_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO21_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO21_LEVEL_LOW_Pos (20UL)            /*!< GPIO21_LEVEL_LOW (Bit 20) */
#define IO_BANK0_PROC0_INTE2_GPIO21_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO21_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO20_EDGE_HIGH_Pos (19UL)            /*!< GPIO20_EDGE_HIGH (Bit 19) */
#define IO_BANK0_PROC0_INTE2_GPIO20_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO20_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO20_EDGE_LOW_Pos (18UL)             /*!< GPIO20_EDGE_LOW (Bit 18) */
#define IO_BANK0_PROC0_INTE2_GPIO20_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO20_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO20_LEVEL_HIGH_Pos (17UL)           /*!< GPIO20_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_PROC0_INTE2_GPIO20_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO20_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO20_LEVEL_LOW_Pos (16UL)            /*!< GPIO20_LEVEL_LOW (Bit 16) */
#define IO_BANK0_PROC0_INTE2_GPIO20_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO20_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO19_EDGE_HIGH_Pos (15UL)            /*!< GPIO19_EDGE_HIGH (Bit 15) */
#define IO_BANK0_PROC0_INTE2_GPIO19_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO19_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO19_EDGE_LOW_Pos (14UL)             /*!< GPIO19_EDGE_LOW (Bit 14) */
#define IO_BANK0_PROC0_INTE2_GPIO19_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO19_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO19_LEVEL_HIGH_Pos (13UL)           /*!< GPIO19_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_PROC0_INTE2_GPIO19_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO19_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO19_LEVEL_LOW_Pos (12UL)            /*!< GPIO19_LEVEL_LOW (Bit 12) */
#define IO_BANK0_PROC0_INTE2_GPIO19_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO19_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO18_EDGE_HIGH_Pos (11UL)            /*!< GPIO18_EDGE_HIGH (Bit 11) */
#define IO_BANK0_PROC0_INTE2_GPIO18_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO18_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO18_EDGE_LOW_Pos (10UL)             /*!< GPIO18_EDGE_LOW (Bit 10) */
#define IO_BANK0_PROC0_INTE2_GPIO18_EDGE_LOW_Msk (0x400UL)          /*!< GPIO18_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO18_LEVEL_HIGH_Pos (9UL)            /*!< GPIO18_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_PROC0_INTE2_GPIO18_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO18_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO18_LEVEL_LOW_Pos (8UL)             /*!< GPIO18_LEVEL_LOW (Bit 8) */
#define IO_BANK0_PROC0_INTE2_GPIO18_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO18_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO17_EDGE_HIGH_Pos (7UL)             /*!< GPIO17_EDGE_HIGH (Bit 7) */
#define IO_BANK0_PROC0_INTE2_GPIO17_EDGE_HIGH_Msk (0x80UL)          /*!< GPIO17_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO17_EDGE_LOW_Pos (6UL)              /*!< GPIO17_EDGE_LOW (Bit 6) */
#define IO_BANK0_PROC0_INTE2_GPIO17_EDGE_LOW_Msk (0x40UL)           /*!< GPIO17_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO17_LEVEL_HIGH_Pos (5UL)            /*!< GPIO17_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_PROC0_INTE2_GPIO17_LEVEL_HIGH_Msk (0x20UL)         /*!< GPIO17_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO17_LEVEL_LOW_Pos (4UL)             /*!< GPIO17_LEVEL_LOW (Bit 4) */
#define IO_BANK0_PROC0_INTE2_GPIO17_LEVEL_LOW_Msk (0x10UL)          /*!< GPIO17_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO16_EDGE_HIGH_Pos (3UL)             /*!< GPIO16_EDGE_HIGH (Bit 3) */
#define IO_BANK0_PROC0_INTE2_GPIO16_EDGE_HIGH_Msk (0x8UL)           /*!< GPIO16_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO16_EDGE_LOW_Pos (2UL)              /*!< GPIO16_EDGE_LOW (Bit 2) */
#define IO_BANK0_PROC0_INTE2_GPIO16_EDGE_LOW_Msk (0x4UL)            /*!< GPIO16_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO16_LEVEL_HIGH_Pos (1UL)            /*!< GPIO16_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_PROC0_INTE2_GPIO16_LEVEL_HIGH_Msk (0x2UL)          /*!< GPIO16_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE2_GPIO16_LEVEL_LOW_Pos (0UL)             /*!< GPIO16_LEVEL_LOW (Bit 0) */
#define IO_BANK0_PROC0_INTE2_GPIO16_LEVEL_LOW_Msk (0x1UL)           /*!< GPIO16_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ======================================================  PROC0_INTE3  ====================================================== */
#define IO_BANK0_PROC0_INTE3_GPIO29_EDGE_HIGH_Pos (23UL)            /*!< GPIO29_EDGE_HIGH (Bit 23) */
#define IO_BANK0_PROC0_INTE3_GPIO29_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO29_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE3_GPIO29_EDGE_LOW_Pos (22UL)             /*!< GPIO29_EDGE_LOW (Bit 22) */
#define IO_BANK0_PROC0_INTE3_GPIO29_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO29_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE3_GPIO29_LEVEL_HIGH_Pos (21UL)           /*!< GPIO29_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_PROC0_INTE3_GPIO29_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO29_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE3_GPIO29_LEVEL_LOW_Pos (20UL)            /*!< GPIO29_LEVEL_LOW (Bit 20) */
#define IO_BANK0_PROC0_INTE3_GPIO29_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO29_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE3_GPIO28_EDGE_HIGH_Pos (19UL)            /*!< GPIO28_EDGE_HIGH (Bit 19) */
#define IO_BANK0_PROC0_INTE3_GPIO28_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO28_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE3_GPIO28_EDGE_LOW_Pos (18UL)             /*!< GPIO28_EDGE_LOW (Bit 18) */
#define IO_BANK0_PROC0_INTE3_GPIO28_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO28_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE3_GPIO28_LEVEL_HIGH_Pos (17UL)           /*!< GPIO28_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_PROC0_INTE3_GPIO28_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO28_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE3_GPIO28_LEVEL_LOW_Pos (16UL)            /*!< GPIO28_LEVEL_LOW (Bit 16) */
#define IO_BANK0_PROC0_INTE3_GPIO28_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO28_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE3_GPIO27_EDGE_HIGH_Pos (15UL)            /*!< GPIO27_EDGE_HIGH (Bit 15) */
#define IO_BANK0_PROC0_INTE3_GPIO27_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO27_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE3_GPIO27_EDGE_LOW_Pos (14UL)             /*!< GPIO27_EDGE_LOW (Bit 14) */
#define IO_BANK0_PROC0_INTE3_GPIO27_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO27_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE3_GPIO27_LEVEL_HIGH_Pos (13UL)           /*!< GPIO27_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_PROC0_INTE3_GPIO27_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO27_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE3_GPIO27_LEVEL_LOW_Pos (12UL)            /*!< GPIO27_LEVEL_LOW (Bit 12) */
#define IO_BANK0_PROC0_INTE3_GPIO27_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO27_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE3_GPIO26_EDGE_HIGH_Pos (11UL)            /*!< GPIO26_EDGE_HIGH (Bit 11) */
#define IO_BANK0_PROC0_INTE3_GPIO26_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO26_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE3_GPIO26_EDGE_LOW_Pos (10UL)             /*!< GPIO26_EDGE_LOW (Bit 10) */
#define IO_BANK0_PROC0_INTE3_GPIO26_EDGE_LOW_Msk (0x400UL)          /*!< GPIO26_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE3_GPIO26_LEVEL_HIGH_Pos (9UL)            /*!< GPIO26_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_PROC0_INTE3_GPIO26_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO26_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE3_GPIO26_LEVEL_LOW_Pos (8UL)             /*!< GPIO26_LEVEL_LOW (Bit 8) */
#define IO_BANK0_PROC0_INTE3_GPIO26_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO26_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE3_GPIO25_EDGE_HIGH_Pos (7UL)             /*!< GPIO25_EDGE_HIGH (Bit 7) */
#define IO_BANK0_PROC0_INTE3_GPIO25_EDGE_HIGH_Msk (0x80UL)          /*!< GPIO25_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE3_GPIO25_EDGE_LOW_Pos (6UL)              /*!< GPIO25_EDGE_LOW (Bit 6) */
#define IO_BANK0_PROC0_INTE3_GPIO25_EDGE_LOW_Msk (0x40UL)           /*!< GPIO25_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE3_GPIO25_LEVEL_HIGH_Pos (5UL)            /*!< GPIO25_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_PROC0_INTE3_GPIO25_LEVEL_HIGH_Msk (0x20UL)         /*!< GPIO25_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE3_GPIO25_LEVEL_LOW_Pos (4UL)             /*!< GPIO25_LEVEL_LOW (Bit 4) */
#define IO_BANK0_PROC0_INTE3_GPIO25_LEVEL_LOW_Msk (0x10UL)          /*!< GPIO25_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE3_GPIO24_EDGE_HIGH_Pos (3UL)             /*!< GPIO24_EDGE_HIGH (Bit 3) */
#define IO_BANK0_PROC0_INTE3_GPIO24_EDGE_HIGH_Msk (0x8UL)           /*!< GPIO24_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE3_GPIO24_EDGE_LOW_Pos (2UL)              /*!< GPIO24_EDGE_LOW (Bit 2) */
#define IO_BANK0_PROC0_INTE3_GPIO24_EDGE_LOW_Msk (0x4UL)            /*!< GPIO24_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE3_GPIO24_LEVEL_HIGH_Pos (1UL)            /*!< GPIO24_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_PROC0_INTE3_GPIO24_LEVEL_HIGH_Msk (0x2UL)          /*!< GPIO24_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTE3_GPIO24_LEVEL_LOW_Pos (0UL)             /*!< GPIO24_LEVEL_LOW (Bit 0) */
#define IO_BANK0_PROC0_INTE3_GPIO24_LEVEL_LOW_Msk (0x1UL)           /*!< GPIO24_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ======================================================  PROC0_INTF0  ====================================================== */
#define IO_BANK0_PROC0_INTF0_GPIO7_EDGE_HIGH_Pos (31UL)             /*!< GPIO7_EDGE_HIGH (Bit 31) */
#define IO_BANK0_PROC0_INTF0_GPIO7_EDGE_HIGH_Msk (0x80000000UL)     /*!< GPIO7_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO7_EDGE_LOW_Pos (30UL)              /*!< GPIO7_EDGE_LOW (Bit 30) */
#define IO_BANK0_PROC0_INTF0_GPIO7_EDGE_LOW_Msk (0x40000000UL)      /*!< GPIO7_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO7_LEVEL_HIGH_Pos (29UL)            /*!< GPIO7_LEVEL_HIGH (Bit 29) */
#define IO_BANK0_PROC0_INTF0_GPIO7_LEVEL_HIGH_Msk (0x20000000UL)    /*!< GPIO7_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO7_LEVEL_LOW_Pos (28UL)             /*!< GPIO7_LEVEL_LOW (Bit 28) */
#define IO_BANK0_PROC0_INTF0_GPIO7_LEVEL_LOW_Msk (0x10000000UL)     /*!< GPIO7_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO6_EDGE_HIGH_Pos (27UL)             /*!< GPIO6_EDGE_HIGH (Bit 27) */
#define IO_BANK0_PROC0_INTF0_GPIO6_EDGE_HIGH_Msk (0x8000000UL)      /*!< GPIO6_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO6_EDGE_LOW_Pos (26UL)              /*!< GPIO6_EDGE_LOW (Bit 26) */
#define IO_BANK0_PROC0_INTF0_GPIO6_EDGE_LOW_Msk (0x4000000UL)       /*!< GPIO6_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO6_LEVEL_HIGH_Pos (25UL)            /*!< GPIO6_LEVEL_HIGH (Bit 25) */
#define IO_BANK0_PROC0_INTF0_GPIO6_LEVEL_HIGH_Msk (0x2000000UL)     /*!< GPIO6_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO6_LEVEL_LOW_Pos (24UL)             /*!< GPIO6_LEVEL_LOW (Bit 24) */
#define IO_BANK0_PROC0_INTF0_GPIO6_LEVEL_LOW_Msk (0x1000000UL)      /*!< GPIO6_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO5_EDGE_HIGH_Pos (23UL)             /*!< GPIO5_EDGE_HIGH (Bit 23) */
#define IO_BANK0_PROC0_INTF0_GPIO5_EDGE_HIGH_Msk (0x800000UL)       /*!< GPIO5_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO5_EDGE_LOW_Pos (22UL)              /*!< GPIO5_EDGE_LOW (Bit 22) */
#define IO_BANK0_PROC0_INTF0_GPIO5_EDGE_LOW_Msk (0x400000UL)        /*!< GPIO5_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO5_LEVEL_HIGH_Pos (21UL)            /*!< GPIO5_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_PROC0_INTF0_GPIO5_LEVEL_HIGH_Msk (0x200000UL)      /*!< GPIO5_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO5_LEVEL_LOW_Pos (20UL)             /*!< GPIO5_LEVEL_LOW (Bit 20) */
#define IO_BANK0_PROC0_INTF0_GPIO5_LEVEL_LOW_Msk (0x100000UL)       /*!< GPIO5_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO4_EDGE_HIGH_Pos (19UL)             /*!< GPIO4_EDGE_HIGH (Bit 19) */
#define IO_BANK0_PROC0_INTF0_GPIO4_EDGE_HIGH_Msk (0x80000UL)        /*!< GPIO4_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO4_EDGE_LOW_Pos (18UL)              /*!< GPIO4_EDGE_LOW (Bit 18) */
#define IO_BANK0_PROC0_INTF0_GPIO4_EDGE_LOW_Msk (0x40000UL)         /*!< GPIO4_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO4_LEVEL_HIGH_Pos (17UL)            /*!< GPIO4_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_PROC0_INTF0_GPIO4_LEVEL_HIGH_Msk (0x20000UL)       /*!< GPIO4_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO4_LEVEL_LOW_Pos (16UL)             /*!< GPIO4_LEVEL_LOW (Bit 16) */
#define IO_BANK0_PROC0_INTF0_GPIO4_LEVEL_LOW_Msk (0x10000UL)        /*!< GPIO4_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO3_EDGE_HIGH_Pos (15UL)             /*!< GPIO3_EDGE_HIGH (Bit 15) */
#define IO_BANK0_PROC0_INTF0_GPIO3_EDGE_HIGH_Msk (0x8000UL)         /*!< GPIO3_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO3_EDGE_LOW_Pos (14UL)              /*!< GPIO3_EDGE_LOW (Bit 14) */
#define IO_BANK0_PROC0_INTF0_GPIO3_EDGE_LOW_Msk (0x4000UL)          /*!< GPIO3_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO3_LEVEL_HIGH_Pos (13UL)            /*!< GPIO3_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_PROC0_INTF0_GPIO3_LEVEL_HIGH_Msk (0x2000UL)        /*!< GPIO3_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO3_LEVEL_LOW_Pos (12UL)             /*!< GPIO3_LEVEL_LOW (Bit 12) */
#define IO_BANK0_PROC0_INTF0_GPIO3_LEVEL_LOW_Msk (0x1000UL)         /*!< GPIO3_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO2_EDGE_HIGH_Pos (11UL)             /*!< GPIO2_EDGE_HIGH (Bit 11) */
#define IO_BANK0_PROC0_INTF0_GPIO2_EDGE_HIGH_Msk (0x800UL)          /*!< GPIO2_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO2_EDGE_LOW_Pos (10UL)              /*!< GPIO2_EDGE_LOW (Bit 10) */
#define IO_BANK0_PROC0_INTF0_GPIO2_EDGE_LOW_Msk (0x400UL)           /*!< GPIO2_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO2_LEVEL_HIGH_Pos (9UL)             /*!< GPIO2_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_PROC0_INTF0_GPIO2_LEVEL_HIGH_Msk (0x200UL)         /*!< GPIO2_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO2_LEVEL_LOW_Pos (8UL)              /*!< GPIO2_LEVEL_LOW (Bit 8) */
#define IO_BANK0_PROC0_INTF0_GPIO2_LEVEL_LOW_Msk (0x100UL)          /*!< GPIO2_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO1_EDGE_HIGH_Pos (7UL)              /*!< GPIO1_EDGE_HIGH (Bit 7) */
#define IO_BANK0_PROC0_INTF0_GPIO1_EDGE_HIGH_Msk (0x80UL)           /*!< GPIO1_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO1_EDGE_LOW_Pos (6UL)               /*!< GPIO1_EDGE_LOW (Bit 6) */
#define IO_BANK0_PROC0_INTF0_GPIO1_EDGE_LOW_Msk (0x40UL)            /*!< GPIO1_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO1_LEVEL_HIGH_Pos (5UL)             /*!< GPIO1_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_PROC0_INTF0_GPIO1_LEVEL_HIGH_Msk (0x20UL)          /*!< GPIO1_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO1_LEVEL_LOW_Pos (4UL)              /*!< GPIO1_LEVEL_LOW (Bit 4) */
#define IO_BANK0_PROC0_INTF0_GPIO1_LEVEL_LOW_Msk (0x10UL)           /*!< GPIO1_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO0_EDGE_HIGH_Pos (3UL)              /*!< GPIO0_EDGE_HIGH (Bit 3) */
#define IO_BANK0_PROC0_INTF0_GPIO0_EDGE_HIGH_Msk (0x8UL)            /*!< GPIO0_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO0_EDGE_LOW_Pos (2UL)               /*!< GPIO0_EDGE_LOW (Bit 2) */
#define IO_BANK0_PROC0_INTF0_GPIO0_EDGE_LOW_Msk (0x4UL)             /*!< GPIO0_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO0_LEVEL_HIGH_Pos (1UL)             /*!< GPIO0_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_PROC0_INTF0_GPIO0_LEVEL_HIGH_Msk (0x2UL)           /*!< GPIO0_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF0_GPIO0_LEVEL_LOW_Pos (0UL)              /*!< GPIO0_LEVEL_LOW (Bit 0) */
#define IO_BANK0_PROC0_INTF0_GPIO0_LEVEL_LOW_Msk (0x1UL)            /*!< GPIO0_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ======================================================  PROC0_INTF1  ====================================================== */
#define IO_BANK0_PROC0_INTF1_GPIO15_EDGE_HIGH_Pos (31UL)            /*!< GPIO15_EDGE_HIGH (Bit 31) */
#define IO_BANK0_PROC0_INTF1_GPIO15_EDGE_HIGH_Msk (0x80000000UL)    /*!< GPIO15_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO15_EDGE_LOW_Pos (30UL)             /*!< GPIO15_EDGE_LOW (Bit 30) */
#define IO_BANK0_PROC0_INTF1_GPIO15_EDGE_LOW_Msk (0x40000000UL)     /*!< GPIO15_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO15_LEVEL_HIGH_Pos (29UL)           /*!< GPIO15_LEVEL_HIGH (Bit 29) */
#define IO_BANK0_PROC0_INTF1_GPIO15_LEVEL_HIGH_Msk (0x20000000UL)   /*!< GPIO15_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO15_LEVEL_LOW_Pos (28UL)            /*!< GPIO15_LEVEL_LOW (Bit 28) */
#define IO_BANK0_PROC0_INTF1_GPIO15_LEVEL_LOW_Msk (0x10000000UL)    /*!< GPIO15_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO14_EDGE_HIGH_Pos (27UL)            /*!< GPIO14_EDGE_HIGH (Bit 27) */
#define IO_BANK0_PROC0_INTF1_GPIO14_EDGE_HIGH_Msk (0x8000000UL)     /*!< GPIO14_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO14_EDGE_LOW_Pos (26UL)             /*!< GPIO14_EDGE_LOW (Bit 26) */
#define IO_BANK0_PROC0_INTF1_GPIO14_EDGE_LOW_Msk (0x4000000UL)      /*!< GPIO14_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO14_LEVEL_HIGH_Pos (25UL)           /*!< GPIO14_LEVEL_HIGH (Bit 25) */
#define IO_BANK0_PROC0_INTF1_GPIO14_LEVEL_HIGH_Msk (0x2000000UL)    /*!< GPIO14_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO14_LEVEL_LOW_Pos (24UL)            /*!< GPIO14_LEVEL_LOW (Bit 24) */
#define IO_BANK0_PROC0_INTF1_GPIO14_LEVEL_LOW_Msk (0x1000000UL)     /*!< GPIO14_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO13_EDGE_HIGH_Pos (23UL)            /*!< GPIO13_EDGE_HIGH (Bit 23) */
#define IO_BANK0_PROC0_INTF1_GPIO13_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO13_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO13_EDGE_LOW_Pos (22UL)             /*!< GPIO13_EDGE_LOW (Bit 22) */
#define IO_BANK0_PROC0_INTF1_GPIO13_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO13_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO13_LEVEL_HIGH_Pos (21UL)           /*!< GPIO13_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_PROC0_INTF1_GPIO13_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO13_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO13_LEVEL_LOW_Pos (20UL)            /*!< GPIO13_LEVEL_LOW (Bit 20) */
#define IO_BANK0_PROC0_INTF1_GPIO13_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO13_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO12_EDGE_HIGH_Pos (19UL)            /*!< GPIO12_EDGE_HIGH (Bit 19) */
#define IO_BANK0_PROC0_INTF1_GPIO12_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO12_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO12_EDGE_LOW_Pos (18UL)             /*!< GPIO12_EDGE_LOW (Bit 18) */
#define IO_BANK0_PROC0_INTF1_GPIO12_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO12_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO12_LEVEL_HIGH_Pos (17UL)           /*!< GPIO12_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_PROC0_INTF1_GPIO12_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO12_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO12_LEVEL_LOW_Pos (16UL)            /*!< GPIO12_LEVEL_LOW (Bit 16) */
#define IO_BANK0_PROC0_INTF1_GPIO12_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO12_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO11_EDGE_HIGH_Pos (15UL)            /*!< GPIO11_EDGE_HIGH (Bit 15) */
#define IO_BANK0_PROC0_INTF1_GPIO11_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO11_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO11_EDGE_LOW_Pos (14UL)             /*!< GPIO11_EDGE_LOW (Bit 14) */
#define IO_BANK0_PROC0_INTF1_GPIO11_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO11_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO11_LEVEL_HIGH_Pos (13UL)           /*!< GPIO11_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_PROC0_INTF1_GPIO11_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO11_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO11_LEVEL_LOW_Pos (12UL)            /*!< GPIO11_LEVEL_LOW (Bit 12) */
#define IO_BANK0_PROC0_INTF1_GPIO11_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO11_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO10_EDGE_HIGH_Pos (11UL)            /*!< GPIO10_EDGE_HIGH (Bit 11) */
#define IO_BANK0_PROC0_INTF1_GPIO10_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO10_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO10_EDGE_LOW_Pos (10UL)             /*!< GPIO10_EDGE_LOW (Bit 10) */
#define IO_BANK0_PROC0_INTF1_GPIO10_EDGE_LOW_Msk (0x400UL)          /*!< GPIO10_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO10_LEVEL_HIGH_Pos (9UL)            /*!< GPIO10_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_PROC0_INTF1_GPIO10_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO10_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO10_LEVEL_LOW_Pos (8UL)             /*!< GPIO10_LEVEL_LOW (Bit 8) */
#define IO_BANK0_PROC0_INTF1_GPIO10_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO10_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO9_EDGE_HIGH_Pos (7UL)              /*!< GPIO9_EDGE_HIGH (Bit 7) */
#define IO_BANK0_PROC0_INTF1_GPIO9_EDGE_HIGH_Msk (0x80UL)           /*!< GPIO9_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO9_EDGE_LOW_Pos (6UL)               /*!< GPIO9_EDGE_LOW (Bit 6) */
#define IO_BANK0_PROC0_INTF1_GPIO9_EDGE_LOW_Msk (0x40UL)            /*!< GPIO9_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO9_LEVEL_HIGH_Pos (5UL)             /*!< GPIO9_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_PROC0_INTF1_GPIO9_LEVEL_HIGH_Msk (0x20UL)          /*!< GPIO9_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO9_LEVEL_LOW_Pos (4UL)              /*!< GPIO9_LEVEL_LOW (Bit 4) */
#define IO_BANK0_PROC0_INTF1_GPIO9_LEVEL_LOW_Msk (0x10UL)           /*!< GPIO9_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO8_EDGE_HIGH_Pos (3UL)              /*!< GPIO8_EDGE_HIGH (Bit 3) */
#define IO_BANK0_PROC0_INTF1_GPIO8_EDGE_HIGH_Msk (0x8UL)            /*!< GPIO8_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO8_EDGE_LOW_Pos (2UL)               /*!< GPIO8_EDGE_LOW (Bit 2) */
#define IO_BANK0_PROC0_INTF1_GPIO8_EDGE_LOW_Msk (0x4UL)             /*!< GPIO8_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO8_LEVEL_HIGH_Pos (1UL)             /*!< GPIO8_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_PROC0_INTF1_GPIO8_LEVEL_HIGH_Msk (0x2UL)           /*!< GPIO8_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF1_GPIO8_LEVEL_LOW_Pos (0UL)              /*!< GPIO8_LEVEL_LOW (Bit 0) */
#define IO_BANK0_PROC0_INTF1_GPIO8_LEVEL_LOW_Msk (0x1UL)            /*!< GPIO8_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ======================================================  PROC0_INTF2  ====================================================== */
#define IO_BANK0_PROC0_INTF2_GPIO23_EDGE_HIGH_Pos (31UL)            /*!< GPIO23_EDGE_HIGH (Bit 31) */
#define IO_BANK0_PROC0_INTF2_GPIO23_EDGE_HIGH_Msk (0x80000000UL)    /*!< GPIO23_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO23_EDGE_LOW_Pos (30UL)             /*!< GPIO23_EDGE_LOW (Bit 30) */
#define IO_BANK0_PROC0_INTF2_GPIO23_EDGE_LOW_Msk (0x40000000UL)     /*!< GPIO23_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO23_LEVEL_HIGH_Pos (29UL)           /*!< GPIO23_LEVEL_HIGH (Bit 29) */
#define IO_BANK0_PROC0_INTF2_GPIO23_LEVEL_HIGH_Msk (0x20000000UL)   /*!< GPIO23_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO23_LEVEL_LOW_Pos (28UL)            /*!< GPIO23_LEVEL_LOW (Bit 28) */
#define IO_BANK0_PROC0_INTF2_GPIO23_LEVEL_LOW_Msk (0x10000000UL)    /*!< GPIO23_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO22_EDGE_HIGH_Pos (27UL)            /*!< GPIO22_EDGE_HIGH (Bit 27) */
#define IO_BANK0_PROC0_INTF2_GPIO22_EDGE_HIGH_Msk (0x8000000UL)     /*!< GPIO22_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO22_EDGE_LOW_Pos (26UL)             /*!< GPIO22_EDGE_LOW (Bit 26) */
#define IO_BANK0_PROC0_INTF2_GPIO22_EDGE_LOW_Msk (0x4000000UL)      /*!< GPIO22_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO22_LEVEL_HIGH_Pos (25UL)           /*!< GPIO22_LEVEL_HIGH (Bit 25) */
#define IO_BANK0_PROC0_INTF2_GPIO22_LEVEL_HIGH_Msk (0x2000000UL)    /*!< GPIO22_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO22_LEVEL_LOW_Pos (24UL)            /*!< GPIO22_LEVEL_LOW (Bit 24) */
#define IO_BANK0_PROC0_INTF2_GPIO22_LEVEL_LOW_Msk (0x1000000UL)     /*!< GPIO22_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO21_EDGE_HIGH_Pos (23UL)            /*!< GPIO21_EDGE_HIGH (Bit 23) */
#define IO_BANK0_PROC0_INTF2_GPIO21_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO21_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO21_EDGE_LOW_Pos (22UL)             /*!< GPIO21_EDGE_LOW (Bit 22) */
#define IO_BANK0_PROC0_INTF2_GPIO21_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO21_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO21_LEVEL_HIGH_Pos (21UL)           /*!< GPIO21_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_PROC0_INTF2_GPIO21_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO21_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO21_LEVEL_LOW_Pos (20UL)            /*!< GPIO21_LEVEL_LOW (Bit 20) */
#define IO_BANK0_PROC0_INTF2_GPIO21_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO21_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO20_EDGE_HIGH_Pos (19UL)            /*!< GPIO20_EDGE_HIGH (Bit 19) */
#define IO_BANK0_PROC0_INTF2_GPIO20_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO20_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO20_EDGE_LOW_Pos (18UL)             /*!< GPIO20_EDGE_LOW (Bit 18) */
#define IO_BANK0_PROC0_INTF2_GPIO20_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO20_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO20_LEVEL_HIGH_Pos (17UL)           /*!< GPIO20_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_PROC0_INTF2_GPIO20_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO20_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO20_LEVEL_LOW_Pos (16UL)            /*!< GPIO20_LEVEL_LOW (Bit 16) */
#define IO_BANK0_PROC0_INTF2_GPIO20_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO20_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO19_EDGE_HIGH_Pos (15UL)            /*!< GPIO19_EDGE_HIGH (Bit 15) */
#define IO_BANK0_PROC0_INTF2_GPIO19_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO19_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO19_EDGE_LOW_Pos (14UL)             /*!< GPIO19_EDGE_LOW (Bit 14) */
#define IO_BANK0_PROC0_INTF2_GPIO19_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO19_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO19_LEVEL_HIGH_Pos (13UL)           /*!< GPIO19_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_PROC0_INTF2_GPIO19_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO19_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO19_LEVEL_LOW_Pos (12UL)            /*!< GPIO19_LEVEL_LOW (Bit 12) */
#define IO_BANK0_PROC0_INTF2_GPIO19_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO19_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO18_EDGE_HIGH_Pos (11UL)            /*!< GPIO18_EDGE_HIGH (Bit 11) */
#define IO_BANK0_PROC0_INTF2_GPIO18_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO18_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO18_EDGE_LOW_Pos (10UL)             /*!< GPIO18_EDGE_LOW (Bit 10) */
#define IO_BANK0_PROC0_INTF2_GPIO18_EDGE_LOW_Msk (0x400UL)          /*!< GPIO18_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO18_LEVEL_HIGH_Pos (9UL)            /*!< GPIO18_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_PROC0_INTF2_GPIO18_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO18_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO18_LEVEL_LOW_Pos (8UL)             /*!< GPIO18_LEVEL_LOW (Bit 8) */
#define IO_BANK0_PROC0_INTF2_GPIO18_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO18_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO17_EDGE_HIGH_Pos (7UL)             /*!< GPIO17_EDGE_HIGH (Bit 7) */
#define IO_BANK0_PROC0_INTF2_GPIO17_EDGE_HIGH_Msk (0x80UL)          /*!< GPIO17_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO17_EDGE_LOW_Pos (6UL)              /*!< GPIO17_EDGE_LOW (Bit 6) */
#define IO_BANK0_PROC0_INTF2_GPIO17_EDGE_LOW_Msk (0x40UL)           /*!< GPIO17_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO17_LEVEL_HIGH_Pos (5UL)            /*!< GPIO17_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_PROC0_INTF2_GPIO17_LEVEL_HIGH_Msk (0x20UL)         /*!< GPIO17_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO17_LEVEL_LOW_Pos (4UL)             /*!< GPIO17_LEVEL_LOW (Bit 4) */
#define IO_BANK0_PROC0_INTF2_GPIO17_LEVEL_LOW_Msk (0x10UL)          /*!< GPIO17_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO16_EDGE_HIGH_Pos (3UL)             /*!< GPIO16_EDGE_HIGH (Bit 3) */
#define IO_BANK0_PROC0_INTF2_GPIO16_EDGE_HIGH_Msk (0x8UL)           /*!< GPIO16_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO16_EDGE_LOW_Pos (2UL)              /*!< GPIO16_EDGE_LOW (Bit 2) */
#define IO_BANK0_PROC0_INTF2_GPIO16_EDGE_LOW_Msk (0x4UL)            /*!< GPIO16_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO16_LEVEL_HIGH_Pos (1UL)            /*!< GPIO16_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_PROC0_INTF2_GPIO16_LEVEL_HIGH_Msk (0x2UL)          /*!< GPIO16_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF2_GPIO16_LEVEL_LOW_Pos (0UL)             /*!< GPIO16_LEVEL_LOW (Bit 0) */
#define IO_BANK0_PROC0_INTF2_GPIO16_LEVEL_LOW_Msk (0x1UL)           /*!< GPIO16_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ======================================================  PROC0_INTF3  ====================================================== */
#define IO_BANK0_PROC0_INTF3_GPIO29_EDGE_HIGH_Pos (23UL)            /*!< GPIO29_EDGE_HIGH (Bit 23) */
#define IO_BANK0_PROC0_INTF3_GPIO29_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO29_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF3_GPIO29_EDGE_LOW_Pos (22UL)             /*!< GPIO29_EDGE_LOW (Bit 22) */
#define IO_BANK0_PROC0_INTF3_GPIO29_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO29_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF3_GPIO29_LEVEL_HIGH_Pos (21UL)           /*!< GPIO29_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_PROC0_INTF3_GPIO29_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO29_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF3_GPIO29_LEVEL_LOW_Pos (20UL)            /*!< GPIO29_LEVEL_LOW (Bit 20) */
#define IO_BANK0_PROC0_INTF3_GPIO29_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO29_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF3_GPIO28_EDGE_HIGH_Pos (19UL)            /*!< GPIO28_EDGE_HIGH (Bit 19) */
#define IO_BANK0_PROC0_INTF3_GPIO28_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO28_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF3_GPIO28_EDGE_LOW_Pos (18UL)             /*!< GPIO28_EDGE_LOW (Bit 18) */
#define IO_BANK0_PROC0_INTF3_GPIO28_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO28_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF3_GPIO28_LEVEL_HIGH_Pos (17UL)           /*!< GPIO28_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_PROC0_INTF3_GPIO28_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO28_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF3_GPIO28_LEVEL_LOW_Pos (16UL)            /*!< GPIO28_LEVEL_LOW (Bit 16) */
#define IO_BANK0_PROC0_INTF3_GPIO28_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO28_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF3_GPIO27_EDGE_HIGH_Pos (15UL)            /*!< GPIO27_EDGE_HIGH (Bit 15) */
#define IO_BANK0_PROC0_INTF3_GPIO27_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO27_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF3_GPIO27_EDGE_LOW_Pos (14UL)             /*!< GPIO27_EDGE_LOW (Bit 14) */
#define IO_BANK0_PROC0_INTF3_GPIO27_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO27_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF3_GPIO27_LEVEL_HIGH_Pos (13UL)           /*!< GPIO27_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_PROC0_INTF3_GPIO27_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO27_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF3_GPIO27_LEVEL_LOW_Pos (12UL)            /*!< GPIO27_LEVEL_LOW (Bit 12) */
#define IO_BANK0_PROC0_INTF3_GPIO27_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO27_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF3_GPIO26_EDGE_HIGH_Pos (11UL)            /*!< GPIO26_EDGE_HIGH (Bit 11) */
#define IO_BANK0_PROC0_INTF3_GPIO26_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO26_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF3_GPIO26_EDGE_LOW_Pos (10UL)             /*!< GPIO26_EDGE_LOW (Bit 10) */
#define IO_BANK0_PROC0_INTF3_GPIO26_EDGE_LOW_Msk (0x400UL)          /*!< GPIO26_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF3_GPIO26_LEVEL_HIGH_Pos (9UL)            /*!< GPIO26_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_PROC0_INTF3_GPIO26_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO26_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF3_GPIO26_LEVEL_LOW_Pos (8UL)             /*!< GPIO26_LEVEL_LOW (Bit 8) */
#define IO_BANK0_PROC0_INTF3_GPIO26_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO26_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF3_GPIO25_EDGE_HIGH_Pos (7UL)             /*!< GPIO25_EDGE_HIGH (Bit 7) */
#define IO_BANK0_PROC0_INTF3_GPIO25_EDGE_HIGH_Msk (0x80UL)          /*!< GPIO25_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF3_GPIO25_EDGE_LOW_Pos (6UL)              /*!< GPIO25_EDGE_LOW (Bit 6) */
#define IO_BANK0_PROC0_INTF3_GPIO25_EDGE_LOW_Msk (0x40UL)           /*!< GPIO25_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF3_GPIO25_LEVEL_HIGH_Pos (5UL)            /*!< GPIO25_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_PROC0_INTF3_GPIO25_LEVEL_HIGH_Msk (0x20UL)         /*!< GPIO25_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF3_GPIO25_LEVEL_LOW_Pos (4UL)             /*!< GPIO25_LEVEL_LOW (Bit 4) */
#define IO_BANK0_PROC0_INTF3_GPIO25_LEVEL_LOW_Msk (0x10UL)          /*!< GPIO25_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF3_GPIO24_EDGE_HIGH_Pos (3UL)             /*!< GPIO24_EDGE_HIGH (Bit 3) */
#define IO_BANK0_PROC0_INTF3_GPIO24_EDGE_HIGH_Msk (0x8UL)           /*!< GPIO24_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF3_GPIO24_EDGE_LOW_Pos (2UL)              /*!< GPIO24_EDGE_LOW (Bit 2) */
#define IO_BANK0_PROC0_INTF3_GPIO24_EDGE_LOW_Msk (0x4UL)            /*!< GPIO24_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF3_GPIO24_LEVEL_HIGH_Pos (1UL)            /*!< GPIO24_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_PROC0_INTF3_GPIO24_LEVEL_HIGH_Msk (0x2UL)          /*!< GPIO24_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTF3_GPIO24_LEVEL_LOW_Pos (0UL)             /*!< GPIO24_LEVEL_LOW (Bit 0) */
#define IO_BANK0_PROC0_INTF3_GPIO24_LEVEL_LOW_Msk (0x1UL)           /*!< GPIO24_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ======================================================  PROC0_INTS0  ====================================================== */
#define IO_BANK0_PROC0_INTS0_GPIO7_EDGE_HIGH_Pos (31UL)             /*!< GPIO7_EDGE_HIGH (Bit 31) */
#define IO_BANK0_PROC0_INTS0_GPIO7_EDGE_HIGH_Msk (0x80000000UL)     /*!< GPIO7_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO7_EDGE_LOW_Pos (30UL)              /*!< GPIO7_EDGE_LOW (Bit 30) */
#define IO_BANK0_PROC0_INTS0_GPIO7_EDGE_LOW_Msk (0x40000000UL)      /*!< GPIO7_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO7_LEVEL_HIGH_Pos (29UL)            /*!< GPIO7_LEVEL_HIGH (Bit 29) */
#define IO_BANK0_PROC0_INTS0_GPIO7_LEVEL_HIGH_Msk (0x20000000UL)    /*!< GPIO7_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO7_LEVEL_LOW_Pos (28UL)             /*!< GPIO7_LEVEL_LOW (Bit 28) */
#define IO_BANK0_PROC0_INTS0_GPIO7_LEVEL_LOW_Msk (0x10000000UL)     /*!< GPIO7_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO6_EDGE_HIGH_Pos (27UL)             /*!< GPIO6_EDGE_HIGH (Bit 27) */
#define IO_BANK0_PROC0_INTS0_GPIO6_EDGE_HIGH_Msk (0x8000000UL)      /*!< GPIO6_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO6_EDGE_LOW_Pos (26UL)              /*!< GPIO6_EDGE_LOW (Bit 26) */
#define IO_BANK0_PROC0_INTS0_GPIO6_EDGE_LOW_Msk (0x4000000UL)       /*!< GPIO6_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO6_LEVEL_HIGH_Pos (25UL)            /*!< GPIO6_LEVEL_HIGH (Bit 25) */
#define IO_BANK0_PROC0_INTS0_GPIO6_LEVEL_HIGH_Msk (0x2000000UL)     /*!< GPIO6_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO6_LEVEL_LOW_Pos (24UL)             /*!< GPIO6_LEVEL_LOW (Bit 24) */
#define IO_BANK0_PROC0_INTS0_GPIO6_LEVEL_LOW_Msk (0x1000000UL)      /*!< GPIO6_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO5_EDGE_HIGH_Pos (23UL)             /*!< GPIO5_EDGE_HIGH (Bit 23) */
#define IO_BANK0_PROC0_INTS0_GPIO5_EDGE_HIGH_Msk (0x800000UL)       /*!< GPIO5_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO5_EDGE_LOW_Pos (22UL)              /*!< GPIO5_EDGE_LOW (Bit 22) */
#define IO_BANK0_PROC0_INTS0_GPIO5_EDGE_LOW_Msk (0x400000UL)        /*!< GPIO5_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO5_LEVEL_HIGH_Pos (21UL)            /*!< GPIO5_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_PROC0_INTS0_GPIO5_LEVEL_HIGH_Msk (0x200000UL)      /*!< GPIO5_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO5_LEVEL_LOW_Pos (20UL)             /*!< GPIO5_LEVEL_LOW (Bit 20) */
#define IO_BANK0_PROC0_INTS0_GPIO5_LEVEL_LOW_Msk (0x100000UL)       /*!< GPIO5_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO4_EDGE_HIGH_Pos (19UL)             /*!< GPIO4_EDGE_HIGH (Bit 19) */
#define IO_BANK0_PROC0_INTS0_GPIO4_EDGE_HIGH_Msk (0x80000UL)        /*!< GPIO4_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO4_EDGE_LOW_Pos (18UL)              /*!< GPIO4_EDGE_LOW (Bit 18) */
#define IO_BANK0_PROC0_INTS0_GPIO4_EDGE_LOW_Msk (0x40000UL)         /*!< GPIO4_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO4_LEVEL_HIGH_Pos (17UL)            /*!< GPIO4_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_PROC0_INTS0_GPIO4_LEVEL_HIGH_Msk (0x20000UL)       /*!< GPIO4_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO4_LEVEL_LOW_Pos (16UL)             /*!< GPIO4_LEVEL_LOW (Bit 16) */
#define IO_BANK0_PROC0_INTS0_GPIO4_LEVEL_LOW_Msk (0x10000UL)        /*!< GPIO4_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO3_EDGE_HIGH_Pos (15UL)             /*!< GPIO3_EDGE_HIGH (Bit 15) */
#define IO_BANK0_PROC0_INTS0_GPIO3_EDGE_HIGH_Msk (0x8000UL)         /*!< GPIO3_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO3_EDGE_LOW_Pos (14UL)              /*!< GPIO3_EDGE_LOW (Bit 14) */
#define IO_BANK0_PROC0_INTS0_GPIO3_EDGE_LOW_Msk (0x4000UL)          /*!< GPIO3_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO3_LEVEL_HIGH_Pos (13UL)            /*!< GPIO3_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_PROC0_INTS0_GPIO3_LEVEL_HIGH_Msk (0x2000UL)        /*!< GPIO3_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO3_LEVEL_LOW_Pos (12UL)             /*!< GPIO3_LEVEL_LOW (Bit 12) */
#define IO_BANK0_PROC0_INTS0_GPIO3_LEVEL_LOW_Msk (0x1000UL)         /*!< GPIO3_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO2_EDGE_HIGH_Pos (11UL)             /*!< GPIO2_EDGE_HIGH (Bit 11) */
#define IO_BANK0_PROC0_INTS0_GPIO2_EDGE_HIGH_Msk (0x800UL)          /*!< GPIO2_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO2_EDGE_LOW_Pos (10UL)              /*!< GPIO2_EDGE_LOW (Bit 10) */
#define IO_BANK0_PROC0_INTS0_GPIO2_EDGE_LOW_Msk (0x400UL)           /*!< GPIO2_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO2_LEVEL_HIGH_Pos (9UL)             /*!< GPIO2_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_PROC0_INTS0_GPIO2_LEVEL_HIGH_Msk (0x200UL)         /*!< GPIO2_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO2_LEVEL_LOW_Pos (8UL)              /*!< GPIO2_LEVEL_LOW (Bit 8) */
#define IO_BANK0_PROC0_INTS0_GPIO2_LEVEL_LOW_Msk (0x100UL)          /*!< GPIO2_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO1_EDGE_HIGH_Pos (7UL)              /*!< GPIO1_EDGE_HIGH (Bit 7) */
#define IO_BANK0_PROC0_INTS0_GPIO1_EDGE_HIGH_Msk (0x80UL)           /*!< GPIO1_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO1_EDGE_LOW_Pos (6UL)               /*!< GPIO1_EDGE_LOW (Bit 6) */
#define IO_BANK0_PROC0_INTS0_GPIO1_EDGE_LOW_Msk (0x40UL)            /*!< GPIO1_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO1_LEVEL_HIGH_Pos (5UL)             /*!< GPIO1_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_PROC0_INTS0_GPIO1_LEVEL_HIGH_Msk (0x20UL)          /*!< GPIO1_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO1_LEVEL_LOW_Pos (4UL)              /*!< GPIO1_LEVEL_LOW (Bit 4) */
#define IO_BANK0_PROC0_INTS0_GPIO1_LEVEL_LOW_Msk (0x10UL)           /*!< GPIO1_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO0_EDGE_HIGH_Pos (3UL)              /*!< GPIO0_EDGE_HIGH (Bit 3) */
#define IO_BANK0_PROC0_INTS0_GPIO0_EDGE_HIGH_Msk (0x8UL)            /*!< GPIO0_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO0_EDGE_LOW_Pos (2UL)               /*!< GPIO0_EDGE_LOW (Bit 2) */
#define IO_BANK0_PROC0_INTS0_GPIO0_EDGE_LOW_Msk (0x4UL)             /*!< GPIO0_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO0_LEVEL_HIGH_Pos (1UL)             /*!< GPIO0_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_PROC0_INTS0_GPIO0_LEVEL_HIGH_Msk (0x2UL)           /*!< GPIO0_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS0_GPIO0_LEVEL_LOW_Pos (0UL)              /*!< GPIO0_LEVEL_LOW (Bit 0) */
#define IO_BANK0_PROC0_INTS0_GPIO0_LEVEL_LOW_Msk (0x1UL)            /*!< GPIO0_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ======================================================  PROC0_INTS1  ====================================================== */
#define IO_BANK0_PROC0_INTS1_GPIO15_EDGE_HIGH_Pos (31UL)            /*!< GPIO15_EDGE_HIGH (Bit 31) */
#define IO_BANK0_PROC0_INTS1_GPIO15_EDGE_HIGH_Msk (0x80000000UL)    /*!< GPIO15_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO15_EDGE_LOW_Pos (30UL)             /*!< GPIO15_EDGE_LOW (Bit 30) */
#define IO_BANK0_PROC0_INTS1_GPIO15_EDGE_LOW_Msk (0x40000000UL)     /*!< GPIO15_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO15_LEVEL_HIGH_Pos (29UL)           /*!< GPIO15_LEVEL_HIGH (Bit 29) */
#define IO_BANK0_PROC0_INTS1_GPIO15_LEVEL_HIGH_Msk (0x20000000UL)   /*!< GPIO15_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO15_LEVEL_LOW_Pos (28UL)            /*!< GPIO15_LEVEL_LOW (Bit 28) */
#define IO_BANK0_PROC0_INTS1_GPIO15_LEVEL_LOW_Msk (0x10000000UL)    /*!< GPIO15_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO14_EDGE_HIGH_Pos (27UL)            /*!< GPIO14_EDGE_HIGH (Bit 27) */
#define IO_BANK0_PROC0_INTS1_GPIO14_EDGE_HIGH_Msk (0x8000000UL)     /*!< GPIO14_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO14_EDGE_LOW_Pos (26UL)             /*!< GPIO14_EDGE_LOW (Bit 26) */
#define IO_BANK0_PROC0_INTS1_GPIO14_EDGE_LOW_Msk (0x4000000UL)      /*!< GPIO14_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO14_LEVEL_HIGH_Pos (25UL)           /*!< GPIO14_LEVEL_HIGH (Bit 25) */
#define IO_BANK0_PROC0_INTS1_GPIO14_LEVEL_HIGH_Msk (0x2000000UL)    /*!< GPIO14_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO14_LEVEL_LOW_Pos (24UL)            /*!< GPIO14_LEVEL_LOW (Bit 24) */
#define IO_BANK0_PROC0_INTS1_GPIO14_LEVEL_LOW_Msk (0x1000000UL)     /*!< GPIO14_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO13_EDGE_HIGH_Pos (23UL)            /*!< GPIO13_EDGE_HIGH (Bit 23) */
#define IO_BANK0_PROC0_INTS1_GPIO13_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO13_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO13_EDGE_LOW_Pos (22UL)             /*!< GPIO13_EDGE_LOW (Bit 22) */
#define IO_BANK0_PROC0_INTS1_GPIO13_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO13_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO13_LEVEL_HIGH_Pos (21UL)           /*!< GPIO13_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_PROC0_INTS1_GPIO13_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO13_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO13_LEVEL_LOW_Pos (20UL)            /*!< GPIO13_LEVEL_LOW (Bit 20) */
#define IO_BANK0_PROC0_INTS1_GPIO13_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO13_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO12_EDGE_HIGH_Pos (19UL)            /*!< GPIO12_EDGE_HIGH (Bit 19) */
#define IO_BANK0_PROC0_INTS1_GPIO12_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO12_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO12_EDGE_LOW_Pos (18UL)             /*!< GPIO12_EDGE_LOW (Bit 18) */
#define IO_BANK0_PROC0_INTS1_GPIO12_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO12_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO12_LEVEL_HIGH_Pos (17UL)           /*!< GPIO12_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_PROC0_INTS1_GPIO12_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO12_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO12_LEVEL_LOW_Pos (16UL)            /*!< GPIO12_LEVEL_LOW (Bit 16) */
#define IO_BANK0_PROC0_INTS1_GPIO12_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO12_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO11_EDGE_HIGH_Pos (15UL)            /*!< GPIO11_EDGE_HIGH (Bit 15) */
#define IO_BANK0_PROC0_INTS1_GPIO11_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO11_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO11_EDGE_LOW_Pos (14UL)             /*!< GPIO11_EDGE_LOW (Bit 14) */
#define IO_BANK0_PROC0_INTS1_GPIO11_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO11_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO11_LEVEL_HIGH_Pos (13UL)           /*!< GPIO11_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_PROC0_INTS1_GPIO11_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO11_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO11_LEVEL_LOW_Pos (12UL)            /*!< GPIO11_LEVEL_LOW (Bit 12) */
#define IO_BANK0_PROC0_INTS1_GPIO11_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO11_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO10_EDGE_HIGH_Pos (11UL)            /*!< GPIO10_EDGE_HIGH (Bit 11) */
#define IO_BANK0_PROC0_INTS1_GPIO10_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO10_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO10_EDGE_LOW_Pos (10UL)             /*!< GPIO10_EDGE_LOW (Bit 10) */
#define IO_BANK0_PROC0_INTS1_GPIO10_EDGE_LOW_Msk (0x400UL)          /*!< GPIO10_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO10_LEVEL_HIGH_Pos (9UL)            /*!< GPIO10_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_PROC0_INTS1_GPIO10_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO10_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO10_LEVEL_LOW_Pos (8UL)             /*!< GPIO10_LEVEL_LOW (Bit 8) */
#define IO_BANK0_PROC0_INTS1_GPIO10_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO10_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO9_EDGE_HIGH_Pos (7UL)              /*!< GPIO9_EDGE_HIGH (Bit 7) */
#define IO_BANK0_PROC0_INTS1_GPIO9_EDGE_HIGH_Msk (0x80UL)           /*!< GPIO9_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO9_EDGE_LOW_Pos (6UL)               /*!< GPIO9_EDGE_LOW (Bit 6) */
#define IO_BANK0_PROC0_INTS1_GPIO9_EDGE_LOW_Msk (0x40UL)            /*!< GPIO9_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO9_LEVEL_HIGH_Pos (5UL)             /*!< GPIO9_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_PROC0_INTS1_GPIO9_LEVEL_HIGH_Msk (0x20UL)          /*!< GPIO9_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO9_LEVEL_LOW_Pos (4UL)              /*!< GPIO9_LEVEL_LOW (Bit 4) */
#define IO_BANK0_PROC0_INTS1_GPIO9_LEVEL_LOW_Msk (0x10UL)           /*!< GPIO9_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO8_EDGE_HIGH_Pos (3UL)              /*!< GPIO8_EDGE_HIGH (Bit 3) */
#define IO_BANK0_PROC0_INTS1_GPIO8_EDGE_HIGH_Msk (0x8UL)            /*!< GPIO8_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO8_EDGE_LOW_Pos (2UL)               /*!< GPIO8_EDGE_LOW (Bit 2) */
#define IO_BANK0_PROC0_INTS1_GPIO8_EDGE_LOW_Msk (0x4UL)             /*!< GPIO8_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO8_LEVEL_HIGH_Pos (1UL)             /*!< GPIO8_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_PROC0_INTS1_GPIO8_LEVEL_HIGH_Msk (0x2UL)           /*!< GPIO8_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS1_GPIO8_LEVEL_LOW_Pos (0UL)              /*!< GPIO8_LEVEL_LOW (Bit 0) */
#define IO_BANK0_PROC0_INTS1_GPIO8_LEVEL_LOW_Msk (0x1UL)            /*!< GPIO8_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ======================================================  PROC0_INTS2  ====================================================== */
#define IO_BANK0_PROC0_INTS2_GPIO23_EDGE_HIGH_Pos (31UL)            /*!< GPIO23_EDGE_HIGH (Bit 31) */
#define IO_BANK0_PROC0_INTS2_GPIO23_EDGE_HIGH_Msk (0x80000000UL)    /*!< GPIO23_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO23_EDGE_LOW_Pos (30UL)             /*!< GPIO23_EDGE_LOW (Bit 30) */
#define IO_BANK0_PROC0_INTS2_GPIO23_EDGE_LOW_Msk (0x40000000UL)     /*!< GPIO23_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO23_LEVEL_HIGH_Pos (29UL)           /*!< GPIO23_LEVEL_HIGH (Bit 29) */
#define IO_BANK0_PROC0_INTS2_GPIO23_LEVEL_HIGH_Msk (0x20000000UL)   /*!< GPIO23_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO23_LEVEL_LOW_Pos (28UL)            /*!< GPIO23_LEVEL_LOW (Bit 28) */
#define IO_BANK0_PROC0_INTS2_GPIO23_LEVEL_LOW_Msk (0x10000000UL)    /*!< GPIO23_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO22_EDGE_HIGH_Pos (27UL)            /*!< GPIO22_EDGE_HIGH (Bit 27) */
#define IO_BANK0_PROC0_INTS2_GPIO22_EDGE_HIGH_Msk (0x8000000UL)     /*!< GPIO22_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO22_EDGE_LOW_Pos (26UL)             /*!< GPIO22_EDGE_LOW (Bit 26) */
#define IO_BANK0_PROC0_INTS2_GPIO22_EDGE_LOW_Msk (0x4000000UL)      /*!< GPIO22_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO22_LEVEL_HIGH_Pos (25UL)           /*!< GPIO22_LEVEL_HIGH (Bit 25) */
#define IO_BANK0_PROC0_INTS2_GPIO22_LEVEL_HIGH_Msk (0x2000000UL)    /*!< GPIO22_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO22_LEVEL_LOW_Pos (24UL)            /*!< GPIO22_LEVEL_LOW (Bit 24) */
#define IO_BANK0_PROC0_INTS2_GPIO22_LEVEL_LOW_Msk (0x1000000UL)     /*!< GPIO22_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO21_EDGE_HIGH_Pos (23UL)            /*!< GPIO21_EDGE_HIGH (Bit 23) */
#define IO_BANK0_PROC0_INTS2_GPIO21_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO21_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO21_EDGE_LOW_Pos (22UL)             /*!< GPIO21_EDGE_LOW (Bit 22) */
#define IO_BANK0_PROC0_INTS2_GPIO21_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO21_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO21_LEVEL_HIGH_Pos (21UL)           /*!< GPIO21_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_PROC0_INTS2_GPIO21_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO21_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO21_LEVEL_LOW_Pos (20UL)            /*!< GPIO21_LEVEL_LOW (Bit 20) */
#define IO_BANK0_PROC0_INTS2_GPIO21_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO21_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO20_EDGE_HIGH_Pos (19UL)            /*!< GPIO20_EDGE_HIGH (Bit 19) */
#define IO_BANK0_PROC0_INTS2_GPIO20_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO20_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO20_EDGE_LOW_Pos (18UL)             /*!< GPIO20_EDGE_LOW (Bit 18) */
#define IO_BANK0_PROC0_INTS2_GPIO20_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO20_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO20_LEVEL_HIGH_Pos (17UL)           /*!< GPIO20_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_PROC0_INTS2_GPIO20_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO20_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO20_LEVEL_LOW_Pos (16UL)            /*!< GPIO20_LEVEL_LOW (Bit 16) */
#define IO_BANK0_PROC0_INTS2_GPIO20_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO20_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO19_EDGE_HIGH_Pos (15UL)            /*!< GPIO19_EDGE_HIGH (Bit 15) */
#define IO_BANK0_PROC0_INTS2_GPIO19_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO19_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO19_EDGE_LOW_Pos (14UL)             /*!< GPIO19_EDGE_LOW (Bit 14) */
#define IO_BANK0_PROC0_INTS2_GPIO19_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO19_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO19_LEVEL_HIGH_Pos (13UL)           /*!< GPIO19_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_PROC0_INTS2_GPIO19_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO19_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO19_LEVEL_LOW_Pos (12UL)            /*!< GPIO19_LEVEL_LOW (Bit 12) */
#define IO_BANK0_PROC0_INTS2_GPIO19_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO19_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO18_EDGE_HIGH_Pos (11UL)            /*!< GPIO18_EDGE_HIGH (Bit 11) */
#define IO_BANK0_PROC0_INTS2_GPIO18_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO18_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO18_EDGE_LOW_Pos (10UL)             /*!< GPIO18_EDGE_LOW (Bit 10) */
#define IO_BANK0_PROC0_INTS2_GPIO18_EDGE_LOW_Msk (0x400UL)          /*!< GPIO18_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO18_LEVEL_HIGH_Pos (9UL)            /*!< GPIO18_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_PROC0_INTS2_GPIO18_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO18_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO18_LEVEL_LOW_Pos (8UL)             /*!< GPIO18_LEVEL_LOW (Bit 8) */
#define IO_BANK0_PROC0_INTS2_GPIO18_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO18_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO17_EDGE_HIGH_Pos (7UL)             /*!< GPIO17_EDGE_HIGH (Bit 7) */
#define IO_BANK0_PROC0_INTS2_GPIO17_EDGE_HIGH_Msk (0x80UL)          /*!< GPIO17_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO17_EDGE_LOW_Pos (6UL)              /*!< GPIO17_EDGE_LOW (Bit 6) */
#define IO_BANK0_PROC0_INTS2_GPIO17_EDGE_LOW_Msk (0x40UL)           /*!< GPIO17_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO17_LEVEL_HIGH_Pos (5UL)            /*!< GPIO17_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_PROC0_INTS2_GPIO17_LEVEL_HIGH_Msk (0x20UL)         /*!< GPIO17_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO17_LEVEL_LOW_Pos (4UL)             /*!< GPIO17_LEVEL_LOW (Bit 4) */
#define IO_BANK0_PROC0_INTS2_GPIO17_LEVEL_LOW_Msk (0x10UL)          /*!< GPIO17_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO16_EDGE_HIGH_Pos (3UL)             /*!< GPIO16_EDGE_HIGH (Bit 3) */
#define IO_BANK0_PROC0_INTS2_GPIO16_EDGE_HIGH_Msk (0x8UL)           /*!< GPIO16_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO16_EDGE_LOW_Pos (2UL)              /*!< GPIO16_EDGE_LOW (Bit 2) */
#define IO_BANK0_PROC0_INTS2_GPIO16_EDGE_LOW_Msk (0x4UL)            /*!< GPIO16_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO16_LEVEL_HIGH_Pos (1UL)            /*!< GPIO16_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_PROC0_INTS2_GPIO16_LEVEL_HIGH_Msk (0x2UL)          /*!< GPIO16_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS2_GPIO16_LEVEL_LOW_Pos (0UL)             /*!< GPIO16_LEVEL_LOW (Bit 0) */
#define IO_BANK0_PROC0_INTS2_GPIO16_LEVEL_LOW_Msk (0x1UL)           /*!< GPIO16_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ======================================================  PROC0_INTS3  ====================================================== */
#define IO_BANK0_PROC0_INTS3_GPIO29_EDGE_HIGH_Pos (23UL)            /*!< GPIO29_EDGE_HIGH (Bit 23) */
#define IO_BANK0_PROC0_INTS3_GPIO29_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO29_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS3_GPIO29_EDGE_LOW_Pos (22UL)             /*!< GPIO29_EDGE_LOW (Bit 22) */
#define IO_BANK0_PROC0_INTS3_GPIO29_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO29_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS3_GPIO29_LEVEL_HIGH_Pos (21UL)           /*!< GPIO29_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_PROC0_INTS3_GPIO29_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO29_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS3_GPIO29_LEVEL_LOW_Pos (20UL)            /*!< GPIO29_LEVEL_LOW (Bit 20) */
#define IO_BANK0_PROC0_INTS3_GPIO29_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO29_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS3_GPIO28_EDGE_HIGH_Pos (19UL)            /*!< GPIO28_EDGE_HIGH (Bit 19) */
#define IO_BANK0_PROC0_INTS3_GPIO28_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO28_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS3_GPIO28_EDGE_LOW_Pos (18UL)             /*!< GPIO28_EDGE_LOW (Bit 18) */
#define IO_BANK0_PROC0_INTS3_GPIO28_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO28_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS3_GPIO28_LEVEL_HIGH_Pos (17UL)           /*!< GPIO28_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_PROC0_INTS3_GPIO28_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO28_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS3_GPIO28_LEVEL_LOW_Pos (16UL)            /*!< GPIO28_LEVEL_LOW (Bit 16) */
#define IO_BANK0_PROC0_INTS3_GPIO28_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO28_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS3_GPIO27_EDGE_HIGH_Pos (15UL)            /*!< GPIO27_EDGE_HIGH (Bit 15) */
#define IO_BANK0_PROC0_INTS3_GPIO27_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO27_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS3_GPIO27_EDGE_LOW_Pos (14UL)             /*!< GPIO27_EDGE_LOW (Bit 14) */
#define IO_BANK0_PROC0_INTS3_GPIO27_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO27_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS3_GPIO27_LEVEL_HIGH_Pos (13UL)           /*!< GPIO27_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_PROC0_INTS3_GPIO27_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO27_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS3_GPIO27_LEVEL_LOW_Pos (12UL)            /*!< GPIO27_LEVEL_LOW (Bit 12) */
#define IO_BANK0_PROC0_INTS3_GPIO27_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO27_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS3_GPIO26_EDGE_HIGH_Pos (11UL)            /*!< GPIO26_EDGE_HIGH (Bit 11) */
#define IO_BANK0_PROC0_INTS3_GPIO26_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO26_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS3_GPIO26_EDGE_LOW_Pos (10UL)             /*!< GPIO26_EDGE_LOW (Bit 10) */
#define IO_BANK0_PROC0_INTS3_GPIO26_EDGE_LOW_Msk (0x400UL)          /*!< GPIO26_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS3_GPIO26_LEVEL_HIGH_Pos (9UL)            /*!< GPIO26_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_PROC0_INTS3_GPIO26_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO26_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS3_GPIO26_LEVEL_LOW_Pos (8UL)             /*!< GPIO26_LEVEL_LOW (Bit 8) */
#define IO_BANK0_PROC0_INTS3_GPIO26_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO26_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS3_GPIO25_EDGE_HIGH_Pos (7UL)             /*!< GPIO25_EDGE_HIGH (Bit 7) */
#define IO_BANK0_PROC0_INTS3_GPIO25_EDGE_HIGH_Msk (0x80UL)          /*!< GPIO25_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS3_GPIO25_EDGE_LOW_Pos (6UL)              /*!< GPIO25_EDGE_LOW (Bit 6) */
#define IO_BANK0_PROC0_INTS3_GPIO25_EDGE_LOW_Msk (0x40UL)           /*!< GPIO25_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS3_GPIO25_LEVEL_HIGH_Pos (5UL)            /*!< GPIO25_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_PROC0_INTS3_GPIO25_LEVEL_HIGH_Msk (0x20UL)         /*!< GPIO25_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS3_GPIO25_LEVEL_LOW_Pos (4UL)             /*!< GPIO25_LEVEL_LOW (Bit 4) */
#define IO_BANK0_PROC0_INTS3_GPIO25_LEVEL_LOW_Msk (0x10UL)          /*!< GPIO25_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS3_GPIO24_EDGE_HIGH_Pos (3UL)             /*!< GPIO24_EDGE_HIGH (Bit 3) */
#define IO_BANK0_PROC0_INTS3_GPIO24_EDGE_HIGH_Msk (0x8UL)           /*!< GPIO24_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS3_GPIO24_EDGE_LOW_Pos (2UL)              /*!< GPIO24_EDGE_LOW (Bit 2) */
#define IO_BANK0_PROC0_INTS3_GPIO24_EDGE_LOW_Msk (0x4UL)            /*!< GPIO24_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS3_GPIO24_LEVEL_HIGH_Pos (1UL)            /*!< GPIO24_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_PROC0_INTS3_GPIO24_LEVEL_HIGH_Msk (0x2UL)          /*!< GPIO24_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC0_INTS3_GPIO24_LEVEL_LOW_Pos (0UL)             /*!< GPIO24_LEVEL_LOW (Bit 0) */
#define IO_BANK0_PROC0_INTS3_GPIO24_LEVEL_LOW_Msk (0x1UL)           /*!< GPIO24_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ======================================================  PROC1_INTE0  ====================================================== */
#define IO_BANK0_PROC1_INTE0_GPIO7_EDGE_HIGH_Pos (31UL)             /*!< GPIO7_EDGE_HIGH (Bit 31) */
#define IO_BANK0_PROC1_INTE0_GPIO7_EDGE_HIGH_Msk (0x80000000UL)     /*!< GPIO7_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO7_EDGE_LOW_Pos (30UL)              /*!< GPIO7_EDGE_LOW (Bit 30) */
#define IO_BANK0_PROC1_INTE0_GPIO7_EDGE_LOW_Msk (0x40000000UL)      /*!< GPIO7_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO7_LEVEL_HIGH_Pos (29UL)            /*!< GPIO7_LEVEL_HIGH (Bit 29) */
#define IO_BANK0_PROC1_INTE0_GPIO7_LEVEL_HIGH_Msk (0x20000000UL)    /*!< GPIO7_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO7_LEVEL_LOW_Pos (28UL)             /*!< GPIO7_LEVEL_LOW (Bit 28) */
#define IO_BANK0_PROC1_INTE0_GPIO7_LEVEL_LOW_Msk (0x10000000UL)     /*!< GPIO7_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO6_EDGE_HIGH_Pos (27UL)             /*!< GPIO6_EDGE_HIGH (Bit 27) */
#define IO_BANK0_PROC1_INTE0_GPIO6_EDGE_HIGH_Msk (0x8000000UL)      /*!< GPIO6_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO6_EDGE_LOW_Pos (26UL)              /*!< GPIO6_EDGE_LOW (Bit 26) */
#define IO_BANK0_PROC1_INTE0_GPIO6_EDGE_LOW_Msk (0x4000000UL)       /*!< GPIO6_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO6_LEVEL_HIGH_Pos (25UL)            /*!< GPIO6_LEVEL_HIGH (Bit 25) */
#define IO_BANK0_PROC1_INTE0_GPIO6_LEVEL_HIGH_Msk (0x2000000UL)     /*!< GPIO6_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO6_LEVEL_LOW_Pos (24UL)             /*!< GPIO6_LEVEL_LOW (Bit 24) */
#define IO_BANK0_PROC1_INTE0_GPIO6_LEVEL_LOW_Msk (0x1000000UL)      /*!< GPIO6_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO5_EDGE_HIGH_Pos (23UL)             /*!< GPIO5_EDGE_HIGH (Bit 23) */
#define IO_BANK0_PROC1_INTE0_GPIO5_EDGE_HIGH_Msk (0x800000UL)       /*!< GPIO5_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO5_EDGE_LOW_Pos (22UL)              /*!< GPIO5_EDGE_LOW (Bit 22) */
#define IO_BANK0_PROC1_INTE0_GPIO5_EDGE_LOW_Msk (0x400000UL)        /*!< GPIO5_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO5_LEVEL_HIGH_Pos (21UL)            /*!< GPIO5_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_PROC1_INTE0_GPIO5_LEVEL_HIGH_Msk (0x200000UL)      /*!< GPIO5_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO5_LEVEL_LOW_Pos (20UL)             /*!< GPIO5_LEVEL_LOW (Bit 20) */
#define IO_BANK0_PROC1_INTE0_GPIO5_LEVEL_LOW_Msk (0x100000UL)       /*!< GPIO5_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO4_EDGE_HIGH_Pos (19UL)             /*!< GPIO4_EDGE_HIGH (Bit 19) */
#define IO_BANK0_PROC1_INTE0_GPIO4_EDGE_HIGH_Msk (0x80000UL)        /*!< GPIO4_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO4_EDGE_LOW_Pos (18UL)              /*!< GPIO4_EDGE_LOW (Bit 18) */
#define IO_BANK0_PROC1_INTE0_GPIO4_EDGE_LOW_Msk (0x40000UL)         /*!< GPIO4_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO4_LEVEL_HIGH_Pos (17UL)            /*!< GPIO4_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_PROC1_INTE0_GPIO4_LEVEL_HIGH_Msk (0x20000UL)       /*!< GPIO4_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO4_LEVEL_LOW_Pos (16UL)             /*!< GPIO4_LEVEL_LOW (Bit 16) */
#define IO_BANK0_PROC1_INTE0_GPIO4_LEVEL_LOW_Msk (0x10000UL)        /*!< GPIO4_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO3_EDGE_HIGH_Pos (15UL)             /*!< GPIO3_EDGE_HIGH (Bit 15) */
#define IO_BANK0_PROC1_INTE0_GPIO3_EDGE_HIGH_Msk (0x8000UL)         /*!< GPIO3_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO3_EDGE_LOW_Pos (14UL)              /*!< GPIO3_EDGE_LOW (Bit 14) */
#define IO_BANK0_PROC1_INTE0_GPIO3_EDGE_LOW_Msk (0x4000UL)          /*!< GPIO3_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO3_LEVEL_HIGH_Pos (13UL)            /*!< GPIO3_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_PROC1_INTE0_GPIO3_LEVEL_HIGH_Msk (0x2000UL)        /*!< GPIO3_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO3_LEVEL_LOW_Pos (12UL)             /*!< GPIO3_LEVEL_LOW (Bit 12) */
#define IO_BANK0_PROC1_INTE0_GPIO3_LEVEL_LOW_Msk (0x1000UL)         /*!< GPIO3_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO2_EDGE_HIGH_Pos (11UL)             /*!< GPIO2_EDGE_HIGH (Bit 11) */
#define IO_BANK0_PROC1_INTE0_GPIO2_EDGE_HIGH_Msk (0x800UL)          /*!< GPIO2_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO2_EDGE_LOW_Pos (10UL)              /*!< GPIO2_EDGE_LOW (Bit 10) */
#define IO_BANK0_PROC1_INTE0_GPIO2_EDGE_LOW_Msk (0x400UL)           /*!< GPIO2_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO2_LEVEL_HIGH_Pos (9UL)             /*!< GPIO2_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_PROC1_INTE0_GPIO2_LEVEL_HIGH_Msk (0x200UL)         /*!< GPIO2_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO2_LEVEL_LOW_Pos (8UL)              /*!< GPIO2_LEVEL_LOW (Bit 8) */
#define IO_BANK0_PROC1_INTE0_GPIO2_LEVEL_LOW_Msk (0x100UL)          /*!< GPIO2_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO1_EDGE_HIGH_Pos (7UL)              /*!< GPIO1_EDGE_HIGH (Bit 7) */
#define IO_BANK0_PROC1_INTE0_GPIO1_EDGE_HIGH_Msk (0x80UL)           /*!< GPIO1_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO1_EDGE_LOW_Pos (6UL)               /*!< GPIO1_EDGE_LOW (Bit 6) */
#define IO_BANK0_PROC1_INTE0_GPIO1_EDGE_LOW_Msk (0x40UL)            /*!< GPIO1_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO1_LEVEL_HIGH_Pos (5UL)             /*!< GPIO1_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_PROC1_INTE0_GPIO1_LEVEL_HIGH_Msk (0x20UL)          /*!< GPIO1_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO1_LEVEL_LOW_Pos (4UL)              /*!< GPIO1_LEVEL_LOW (Bit 4) */
#define IO_BANK0_PROC1_INTE0_GPIO1_LEVEL_LOW_Msk (0x10UL)           /*!< GPIO1_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO0_EDGE_HIGH_Pos (3UL)              /*!< GPIO0_EDGE_HIGH (Bit 3) */
#define IO_BANK0_PROC1_INTE0_GPIO0_EDGE_HIGH_Msk (0x8UL)            /*!< GPIO0_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO0_EDGE_LOW_Pos (2UL)               /*!< GPIO0_EDGE_LOW (Bit 2) */
#define IO_BANK0_PROC1_INTE0_GPIO0_EDGE_LOW_Msk (0x4UL)             /*!< GPIO0_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO0_LEVEL_HIGH_Pos (1UL)             /*!< GPIO0_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_PROC1_INTE0_GPIO0_LEVEL_HIGH_Msk (0x2UL)           /*!< GPIO0_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE0_GPIO0_LEVEL_LOW_Pos (0UL)              /*!< GPIO0_LEVEL_LOW (Bit 0) */
#define IO_BANK0_PROC1_INTE0_GPIO0_LEVEL_LOW_Msk (0x1UL)            /*!< GPIO0_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ======================================================  PROC1_INTE1  ====================================================== */
#define IO_BANK0_PROC1_INTE1_GPIO15_EDGE_HIGH_Pos (31UL)            /*!< GPIO15_EDGE_HIGH (Bit 31) */
#define IO_BANK0_PROC1_INTE1_GPIO15_EDGE_HIGH_Msk (0x80000000UL)    /*!< GPIO15_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO15_EDGE_LOW_Pos (30UL)             /*!< GPIO15_EDGE_LOW (Bit 30) */
#define IO_BANK0_PROC1_INTE1_GPIO15_EDGE_LOW_Msk (0x40000000UL)     /*!< GPIO15_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO15_LEVEL_HIGH_Pos (29UL)           /*!< GPIO15_LEVEL_HIGH (Bit 29) */
#define IO_BANK0_PROC1_INTE1_GPIO15_LEVEL_HIGH_Msk (0x20000000UL)   /*!< GPIO15_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO15_LEVEL_LOW_Pos (28UL)            /*!< GPIO15_LEVEL_LOW (Bit 28) */
#define IO_BANK0_PROC1_INTE1_GPIO15_LEVEL_LOW_Msk (0x10000000UL)    /*!< GPIO15_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO14_EDGE_HIGH_Pos (27UL)            /*!< GPIO14_EDGE_HIGH (Bit 27) */
#define IO_BANK0_PROC1_INTE1_GPIO14_EDGE_HIGH_Msk (0x8000000UL)     /*!< GPIO14_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO14_EDGE_LOW_Pos (26UL)             /*!< GPIO14_EDGE_LOW (Bit 26) */
#define IO_BANK0_PROC1_INTE1_GPIO14_EDGE_LOW_Msk (0x4000000UL)      /*!< GPIO14_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO14_LEVEL_HIGH_Pos (25UL)           /*!< GPIO14_LEVEL_HIGH (Bit 25) */
#define IO_BANK0_PROC1_INTE1_GPIO14_LEVEL_HIGH_Msk (0x2000000UL)    /*!< GPIO14_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO14_LEVEL_LOW_Pos (24UL)            /*!< GPIO14_LEVEL_LOW (Bit 24) */
#define IO_BANK0_PROC1_INTE1_GPIO14_LEVEL_LOW_Msk (0x1000000UL)     /*!< GPIO14_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO13_EDGE_HIGH_Pos (23UL)            /*!< GPIO13_EDGE_HIGH (Bit 23) */
#define IO_BANK0_PROC1_INTE1_GPIO13_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO13_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO13_EDGE_LOW_Pos (22UL)             /*!< GPIO13_EDGE_LOW (Bit 22) */
#define IO_BANK0_PROC1_INTE1_GPIO13_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO13_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO13_LEVEL_HIGH_Pos (21UL)           /*!< GPIO13_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_PROC1_INTE1_GPIO13_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO13_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO13_LEVEL_LOW_Pos (20UL)            /*!< GPIO13_LEVEL_LOW (Bit 20) */
#define IO_BANK0_PROC1_INTE1_GPIO13_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO13_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO12_EDGE_HIGH_Pos (19UL)            /*!< GPIO12_EDGE_HIGH (Bit 19) */
#define IO_BANK0_PROC1_INTE1_GPIO12_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO12_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO12_EDGE_LOW_Pos (18UL)             /*!< GPIO12_EDGE_LOW (Bit 18) */
#define IO_BANK0_PROC1_INTE1_GPIO12_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO12_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO12_LEVEL_HIGH_Pos (17UL)           /*!< GPIO12_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_PROC1_INTE1_GPIO12_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO12_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO12_LEVEL_LOW_Pos (16UL)            /*!< GPIO12_LEVEL_LOW (Bit 16) */
#define IO_BANK0_PROC1_INTE1_GPIO12_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO12_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO11_EDGE_HIGH_Pos (15UL)            /*!< GPIO11_EDGE_HIGH (Bit 15) */
#define IO_BANK0_PROC1_INTE1_GPIO11_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO11_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO11_EDGE_LOW_Pos (14UL)             /*!< GPIO11_EDGE_LOW (Bit 14) */
#define IO_BANK0_PROC1_INTE1_GPIO11_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO11_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO11_LEVEL_HIGH_Pos (13UL)           /*!< GPIO11_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_PROC1_INTE1_GPIO11_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO11_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO11_LEVEL_LOW_Pos (12UL)            /*!< GPIO11_LEVEL_LOW (Bit 12) */
#define IO_BANK0_PROC1_INTE1_GPIO11_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO11_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO10_EDGE_HIGH_Pos (11UL)            /*!< GPIO10_EDGE_HIGH (Bit 11) */
#define IO_BANK0_PROC1_INTE1_GPIO10_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO10_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO10_EDGE_LOW_Pos (10UL)             /*!< GPIO10_EDGE_LOW (Bit 10) */
#define IO_BANK0_PROC1_INTE1_GPIO10_EDGE_LOW_Msk (0x400UL)          /*!< GPIO10_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO10_LEVEL_HIGH_Pos (9UL)            /*!< GPIO10_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_PROC1_INTE1_GPIO10_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO10_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO10_LEVEL_LOW_Pos (8UL)             /*!< GPIO10_LEVEL_LOW (Bit 8) */
#define IO_BANK0_PROC1_INTE1_GPIO10_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO10_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO9_EDGE_HIGH_Pos (7UL)              /*!< GPIO9_EDGE_HIGH (Bit 7) */
#define IO_BANK0_PROC1_INTE1_GPIO9_EDGE_HIGH_Msk (0x80UL)           /*!< GPIO9_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO9_EDGE_LOW_Pos (6UL)               /*!< GPIO9_EDGE_LOW (Bit 6) */
#define IO_BANK0_PROC1_INTE1_GPIO9_EDGE_LOW_Msk (0x40UL)            /*!< GPIO9_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO9_LEVEL_HIGH_Pos (5UL)             /*!< GPIO9_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_PROC1_INTE1_GPIO9_LEVEL_HIGH_Msk (0x20UL)          /*!< GPIO9_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO9_LEVEL_LOW_Pos (4UL)              /*!< GPIO9_LEVEL_LOW (Bit 4) */
#define IO_BANK0_PROC1_INTE1_GPIO9_LEVEL_LOW_Msk (0x10UL)           /*!< GPIO9_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO8_EDGE_HIGH_Pos (3UL)              /*!< GPIO8_EDGE_HIGH (Bit 3) */
#define IO_BANK0_PROC1_INTE1_GPIO8_EDGE_HIGH_Msk (0x8UL)            /*!< GPIO8_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO8_EDGE_LOW_Pos (2UL)               /*!< GPIO8_EDGE_LOW (Bit 2) */
#define IO_BANK0_PROC1_INTE1_GPIO8_EDGE_LOW_Msk (0x4UL)             /*!< GPIO8_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO8_LEVEL_HIGH_Pos (1UL)             /*!< GPIO8_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_PROC1_INTE1_GPIO8_LEVEL_HIGH_Msk (0x2UL)           /*!< GPIO8_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE1_GPIO8_LEVEL_LOW_Pos (0UL)              /*!< GPIO8_LEVEL_LOW (Bit 0) */
#define IO_BANK0_PROC1_INTE1_GPIO8_LEVEL_LOW_Msk (0x1UL)            /*!< GPIO8_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ======================================================  PROC1_INTE2  ====================================================== */
#define IO_BANK0_PROC1_INTE2_GPIO23_EDGE_HIGH_Pos (31UL)            /*!< GPIO23_EDGE_HIGH (Bit 31) */
#define IO_BANK0_PROC1_INTE2_GPIO23_EDGE_HIGH_Msk (0x80000000UL)    /*!< GPIO23_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO23_EDGE_LOW_Pos (30UL)             /*!< GPIO23_EDGE_LOW (Bit 30) */
#define IO_BANK0_PROC1_INTE2_GPIO23_EDGE_LOW_Msk (0x40000000UL)     /*!< GPIO23_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO23_LEVEL_HIGH_Pos (29UL)           /*!< GPIO23_LEVEL_HIGH (Bit 29) */
#define IO_BANK0_PROC1_INTE2_GPIO23_LEVEL_HIGH_Msk (0x20000000UL)   /*!< GPIO23_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO23_LEVEL_LOW_Pos (28UL)            /*!< GPIO23_LEVEL_LOW (Bit 28) */
#define IO_BANK0_PROC1_INTE2_GPIO23_LEVEL_LOW_Msk (0x10000000UL)    /*!< GPIO23_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO22_EDGE_HIGH_Pos (27UL)            /*!< GPIO22_EDGE_HIGH (Bit 27) */
#define IO_BANK0_PROC1_INTE2_GPIO22_EDGE_HIGH_Msk (0x8000000UL)     /*!< GPIO22_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO22_EDGE_LOW_Pos (26UL)             /*!< GPIO22_EDGE_LOW (Bit 26) */
#define IO_BANK0_PROC1_INTE2_GPIO22_EDGE_LOW_Msk (0x4000000UL)      /*!< GPIO22_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO22_LEVEL_HIGH_Pos (25UL)           /*!< GPIO22_LEVEL_HIGH (Bit 25) */
#define IO_BANK0_PROC1_INTE2_GPIO22_LEVEL_HIGH_Msk (0x2000000UL)    /*!< GPIO22_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO22_LEVEL_LOW_Pos (24UL)            /*!< GPIO22_LEVEL_LOW (Bit 24) */
#define IO_BANK0_PROC1_INTE2_GPIO22_LEVEL_LOW_Msk (0x1000000UL)     /*!< GPIO22_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO21_EDGE_HIGH_Pos (23UL)            /*!< GPIO21_EDGE_HIGH (Bit 23) */
#define IO_BANK0_PROC1_INTE2_GPIO21_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO21_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO21_EDGE_LOW_Pos (22UL)             /*!< GPIO21_EDGE_LOW (Bit 22) */
#define IO_BANK0_PROC1_INTE2_GPIO21_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO21_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO21_LEVEL_HIGH_Pos (21UL)           /*!< GPIO21_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_PROC1_INTE2_GPIO21_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO21_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO21_LEVEL_LOW_Pos (20UL)            /*!< GPIO21_LEVEL_LOW (Bit 20) */
#define IO_BANK0_PROC1_INTE2_GPIO21_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO21_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO20_EDGE_HIGH_Pos (19UL)            /*!< GPIO20_EDGE_HIGH (Bit 19) */
#define IO_BANK0_PROC1_INTE2_GPIO20_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO20_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO20_EDGE_LOW_Pos (18UL)             /*!< GPIO20_EDGE_LOW (Bit 18) */
#define IO_BANK0_PROC1_INTE2_GPIO20_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO20_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO20_LEVEL_HIGH_Pos (17UL)           /*!< GPIO20_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_PROC1_INTE2_GPIO20_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO20_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO20_LEVEL_LOW_Pos (16UL)            /*!< GPIO20_LEVEL_LOW (Bit 16) */
#define IO_BANK0_PROC1_INTE2_GPIO20_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO20_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO19_EDGE_HIGH_Pos (15UL)            /*!< GPIO19_EDGE_HIGH (Bit 15) */
#define IO_BANK0_PROC1_INTE2_GPIO19_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO19_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO19_EDGE_LOW_Pos (14UL)             /*!< GPIO19_EDGE_LOW (Bit 14) */
#define IO_BANK0_PROC1_INTE2_GPIO19_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO19_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO19_LEVEL_HIGH_Pos (13UL)           /*!< GPIO19_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_PROC1_INTE2_GPIO19_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO19_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO19_LEVEL_LOW_Pos (12UL)            /*!< GPIO19_LEVEL_LOW (Bit 12) */
#define IO_BANK0_PROC1_INTE2_GPIO19_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO19_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO18_EDGE_HIGH_Pos (11UL)            /*!< GPIO18_EDGE_HIGH (Bit 11) */
#define IO_BANK0_PROC1_INTE2_GPIO18_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO18_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO18_EDGE_LOW_Pos (10UL)             /*!< GPIO18_EDGE_LOW (Bit 10) */
#define IO_BANK0_PROC1_INTE2_GPIO18_EDGE_LOW_Msk (0x400UL)          /*!< GPIO18_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO18_LEVEL_HIGH_Pos (9UL)            /*!< GPIO18_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_PROC1_INTE2_GPIO18_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO18_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO18_LEVEL_LOW_Pos (8UL)             /*!< GPIO18_LEVEL_LOW (Bit 8) */
#define IO_BANK0_PROC1_INTE2_GPIO18_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO18_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO17_EDGE_HIGH_Pos (7UL)             /*!< GPIO17_EDGE_HIGH (Bit 7) */
#define IO_BANK0_PROC1_INTE2_GPIO17_EDGE_HIGH_Msk (0x80UL)          /*!< GPIO17_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO17_EDGE_LOW_Pos (6UL)              /*!< GPIO17_EDGE_LOW (Bit 6) */
#define IO_BANK0_PROC1_INTE2_GPIO17_EDGE_LOW_Msk (0x40UL)           /*!< GPIO17_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO17_LEVEL_HIGH_Pos (5UL)            /*!< GPIO17_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_PROC1_INTE2_GPIO17_LEVEL_HIGH_Msk (0x20UL)         /*!< GPIO17_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO17_LEVEL_LOW_Pos (4UL)             /*!< GPIO17_LEVEL_LOW (Bit 4) */
#define IO_BANK0_PROC1_INTE2_GPIO17_LEVEL_LOW_Msk (0x10UL)          /*!< GPIO17_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO16_EDGE_HIGH_Pos (3UL)             /*!< GPIO16_EDGE_HIGH (Bit 3) */
#define IO_BANK0_PROC1_INTE2_GPIO16_EDGE_HIGH_Msk (0x8UL)           /*!< GPIO16_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO16_EDGE_LOW_Pos (2UL)              /*!< GPIO16_EDGE_LOW (Bit 2) */
#define IO_BANK0_PROC1_INTE2_GPIO16_EDGE_LOW_Msk (0x4UL)            /*!< GPIO16_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO16_LEVEL_HIGH_Pos (1UL)            /*!< GPIO16_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_PROC1_INTE2_GPIO16_LEVEL_HIGH_Msk (0x2UL)          /*!< GPIO16_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE2_GPIO16_LEVEL_LOW_Pos (0UL)             /*!< GPIO16_LEVEL_LOW (Bit 0) */
#define IO_BANK0_PROC1_INTE2_GPIO16_LEVEL_LOW_Msk (0x1UL)           /*!< GPIO16_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ======================================================  PROC1_INTE3  ====================================================== */
#define IO_BANK0_PROC1_INTE3_GPIO29_EDGE_HIGH_Pos (23UL)            /*!< GPIO29_EDGE_HIGH (Bit 23) */
#define IO_BANK0_PROC1_INTE3_GPIO29_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO29_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE3_GPIO29_EDGE_LOW_Pos (22UL)             /*!< GPIO29_EDGE_LOW (Bit 22) */
#define IO_BANK0_PROC1_INTE3_GPIO29_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO29_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE3_GPIO29_LEVEL_HIGH_Pos (21UL)           /*!< GPIO29_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_PROC1_INTE3_GPIO29_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO29_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE3_GPIO29_LEVEL_LOW_Pos (20UL)            /*!< GPIO29_LEVEL_LOW (Bit 20) */
#define IO_BANK0_PROC1_INTE3_GPIO29_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO29_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE3_GPIO28_EDGE_HIGH_Pos (19UL)            /*!< GPIO28_EDGE_HIGH (Bit 19) */
#define IO_BANK0_PROC1_INTE3_GPIO28_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO28_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE3_GPIO28_EDGE_LOW_Pos (18UL)             /*!< GPIO28_EDGE_LOW (Bit 18) */
#define IO_BANK0_PROC1_INTE3_GPIO28_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO28_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE3_GPIO28_LEVEL_HIGH_Pos (17UL)           /*!< GPIO28_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_PROC1_INTE3_GPIO28_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO28_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE3_GPIO28_LEVEL_LOW_Pos (16UL)            /*!< GPIO28_LEVEL_LOW (Bit 16) */
#define IO_BANK0_PROC1_INTE3_GPIO28_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO28_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE3_GPIO27_EDGE_HIGH_Pos (15UL)            /*!< GPIO27_EDGE_HIGH (Bit 15) */
#define IO_BANK0_PROC1_INTE3_GPIO27_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO27_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE3_GPIO27_EDGE_LOW_Pos (14UL)             /*!< GPIO27_EDGE_LOW (Bit 14) */
#define IO_BANK0_PROC1_INTE3_GPIO27_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO27_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE3_GPIO27_LEVEL_HIGH_Pos (13UL)           /*!< GPIO27_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_PROC1_INTE3_GPIO27_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO27_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE3_GPIO27_LEVEL_LOW_Pos (12UL)            /*!< GPIO27_LEVEL_LOW (Bit 12) */
#define IO_BANK0_PROC1_INTE3_GPIO27_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO27_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE3_GPIO26_EDGE_HIGH_Pos (11UL)            /*!< GPIO26_EDGE_HIGH (Bit 11) */
#define IO_BANK0_PROC1_INTE3_GPIO26_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO26_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE3_GPIO26_EDGE_LOW_Pos (10UL)             /*!< GPIO26_EDGE_LOW (Bit 10) */
#define IO_BANK0_PROC1_INTE3_GPIO26_EDGE_LOW_Msk (0x400UL)          /*!< GPIO26_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE3_GPIO26_LEVEL_HIGH_Pos (9UL)            /*!< GPIO26_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_PROC1_INTE3_GPIO26_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO26_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE3_GPIO26_LEVEL_LOW_Pos (8UL)             /*!< GPIO26_LEVEL_LOW (Bit 8) */
#define IO_BANK0_PROC1_INTE3_GPIO26_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO26_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE3_GPIO25_EDGE_HIGH_Pos (7UL)             /*!< GPIO25_EDGE_HIGH (Bit 7) */
#define IO_BANK0_PROC1_INTE3_GPIO25_EDGE_HIGH_Msk (0x80UL)          /*!< GPIO25_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE3_GPIO25_EDGE_LOW_Pos (6UL)              /*!< GPIO25_EDGE_LOW (Bit 6) */
#define IO_BANK0_PROC1_INTE3_GPIO25_EDGE_LOW_Msk (0x40UL)           /*!< GPIO25_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE3_GPIO25_LEVEL_HIGH_Pos (5UL)            /*!< GPIO25_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_PROC1_INTE3_GPIO25_LEVEL_HIGH_Msk (0x20UL)         /*!< GPIO25_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE3_GPIO25_LEVEL_LOW_Pos (4UL)             /*!< GPIO25_LEVEL_LOW (Bit 4) */
#define IO_BANK0_PROC1_INTE3_GPIO25_LEVEL_LOW_Msk (0x10UL)          /*!< GPIO25_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE3_GPIO24_EDGE_HIGH_Pos (3UL)             /*!< GPIO24_EDGE_HIGH (Bit 3) */
#define IO_BANK0_PROC1_INTE3_GPIO24_EDGE_HIGH_Msk (0x8UL)           /*!< GPIO24_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE3_GPIO24_EDGE_LOW_Pos (2UL)              /*!< GPIO24_EDGE_LOW (Bit 2) */
#define IO_BANK0_PROC1_INTE3_GPIO24_EDGE_LOW_Msk (0x4UL)            /*!< GPIO24_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE3_GPIO24_LEVEL_HIGH_Pos (1UL)            /*!< GPIO24_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_PROC1_INTE3_GPIO24_LEVEL_HIGH_Msk (0x2UL)          /*!< GPIO24_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTE3_GPIO24_LEVEL_LOW_Pos (0UL)             /*!< GPIO24_LEVEL_LOW (Bit 0) */
#define IO_BANK0_PROC1_INTE3_GPIO24_LEVEL_LOW_Msk (0x1UL)           /*!< GPIO24_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ======================================================  PROC1_INTF0  ====================================================== */
#define IO_BANK0_PROC1_INTF0_GPIO7_EDGE_HIGH_Pos (31UL)             /*!< GPIO7_EDGE_HIGH (Bit 31) */
#define IO_BANK0_PROC1_INTF0_GPIO7_EDGE_HIGH_Msk (0x80000000UL)     /*!< GPIO7_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO7_EDGE_LOW_Pos (30UL)              /*!< GPIO7_EDGE_LOW (Bit 30) */
#define IO_BANK0_PROC1_INTF0_GPIO7_EDGE_LOW_Msk (0x40000000UL)      /*!< GPIO7_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO7_LEVEL_HIGH_Pos (29UL)            /*!< GPIO7_LEVEL_HIGH (Bit 29) */
#define IO_BANK0_PROC1_INTF0_GPIO7_LEVEL_HIGH_Msk (0x20000000UL)    /*!< GPIO7_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO7_LEVEL_LOW_Pos (28UL)             /*!< GPIO7_LEVEL_LOW (Bit 28) */
#define IO_BANK0_PROC1_INTF0_GPIO7_LEVEL_LOW_Msk (0x10000000UL)     /*!< GPIO7_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO6_EDGE_HIGH_Pos (27UL)             /*!< GPIO6_EDGE_HIGH (Bit 27) */
#define IO_BANK0_PROC1_INTF0_GPIO6_EDGE_HIGH_Msk (0x8000000UL)      /*!< GPIO6_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO6_EDGE_LOW_Pos (26UL)              /*!< GPIO6_EDGE_LOW (Bit 26) */
#define IO_BANK0_PROC1_INTF0_GPIO6_EDGE_LOW_Msk (0x4000000UL)       /*!< GPIO6_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO6_LEVEL_HIGH_Pos (25UL)            /*!< GPIO6_LEVEL_HIGH (Bit 25) */
#define IO_BANK0_PROC1_INTF0_GPIO6_LEVEL_HIGH_Msk (0x2000000UL)     /*!< GPIO6_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO6_LEVEL_LOW_Pos (24UL)             /*!< GPIO6_LEVEL_LOW (Bit 24) */
#define IO_BANK0_PROC1_INTF0_GPIO6_LEVEL_LOW_Msk (0x1000000UL)      /*!< GPIO6_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO5_EDGE_HIGH_Pos (23UL)             /*!< GPIO5_EDGE_HIGH (Bit 23) */
#define IO_BANK0_PROC1_INTF0_GPIO5_EDGE_HIGH_Msk (0x800000UL)       /*!< GPIO5_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO5_EDGE_LOW_Pos (22UL)              /*!< GPIO5_EDGE_LOW (Bit 22) */
#define IO_BANK0_PROC1_INTF0_GPIO5_EDGE_LOW_Msk (0x400000UL)        /*!< GPIO5_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO5_LEVEL_HIGH_Pos (21UL)            /*!< GPIO5_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_PROC1_INTF0_GPIO5_LEVEL_HIGH_Msk (0x200000UL)      /*!< GPIO5_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO5_LEVEL_LOW_Pos (20UL)             /*!< GPIO5_LEVEL_LOW (Bit 20) */
#define IO_BANK0_PROC1_INTF0_GPIO5_LEVEL_LOW_Msk (0x100000UL)       /*!< GPIO5_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO4_EDGE_HIGH_Pos (19UL)             /*!< GPIO4_EDGE_HIGH (Bit 19) */
#define IO_BANK0_PROC1_INTF0_GPIO4_EDGE_HIGH_Msk (0x80000UL)        /*!< GPIO4_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO4_EDGE_LOW_Pos (18UL)              /*!< GPIO4_EDGE_LOW (Bit 18) */
#define IO_BANK0_PROC1_INTF0_GPIO4_EDGE_LOW_Msk (0x40000UL)         /*!< GPIO4_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO4_LEVEL_HIGH_Pos (17UL)            /*!< GPIO4_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_PROC1_INTF0_GPIO4_LEVEL_HIGH_Msk (0x20000UL)       /*!< GPIO4_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO4_LEVEL_LOW_Pos (16UL)             /*!< GPIO4_LEVEL_LOW (Bit 16) */
#define IO_BANK0_PROC1_INTF0_GPIO4_LEVEL_LOW_Msk (0x10000UL)        /*!< GPIO4_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO3_EDGE_HIGH_Pos (15UL)             /*!< GPIO3_EDGE_HIGH (Bit 15) */
#define IO_BANK0_PROC1_INTF0_GPIO3_EDGE_HIGH_Msk (0x8000UL)         /*!< GPIO3_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO3_EDGE_LOW_Pos (14UL)              /*!< GPIO3_EDGE_LOW (Bit 14) */
#define IO_BANK0_PROC1_INTF0_GPIO3_EDGE_LOW_Msk (0x4000UL)          /*!< GPIO3_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO3_LEVEL_HIGH_Pos (13UL)            /*!< GPIO3_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_PROC1_INTF0_GPIO3_LEVEL_HIGH_Msk (0x2000UL)        /*!< GPIO3_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO3_LEVEL_LOW_Pos (12UL)             /*!< GPIO3_LEVEL_LOW (Bit 12) */
#define IO_BANK0_PROC1_INTF0_GPIO3_LEVEL_LOW_Msk (0x1000UL)         /*!< GPIO3_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO2_EDGE_HIGH_Pos (11UL)             /*!< GPIO2_EDGE_HIGH (Bit 11) */
#define IO_BANK0_PROC1_INTF0_GPIO2_EDGE_HIGH_Msk (0x800UL)          /*!< GPIO2_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO2_EDGE_LOW_Pos (10UL)              /*!< GPIO2_EDGE_LOW (Bit 10) */
#define IO_BANK0_PROC1_INTF0_GPIO2_EDGE_LOW_Msk (0x400UL)           /*!< GPIO2_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO2_LEVEL_HIGH_Pos (9UL)             /*!< GPIO2_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_PROC1_INTF0_GPIO2_LEVEL_HIGH_Msk (0x200UL)         /*!< GPIO2_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO2_LEVEL_LOW_Pos (8UL)              /*!< GPIO2_LEVEL_LOW (Bit 8) */
#define IO_BANK0_PROC1_INTF0_GPIO2_LEVEL_LOW_Msk (0x100UL)          /*!< GPIO2_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO1_EDGE_HIGH_Pos (7UL)              /*!< GPIO1_EDGE_HIGH (Bit 7) */
#define IO_BANK0_PROC1_INTF0_GPIO1_EDGE_HIGH_Msk (0x80UL)           /*!< GPIO1_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO1_EDGE_LOW_Pos (6UL)               /*!< GPIO1_EDGE_LOW (Bit 6) */
#define IO_BANK0_PROC1_INTF0_GPIO1_EDGE_LOW_Msk (0x40UL)            /*!< GPIO1_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO1_LEVEL_HIGH_Pos (5UL)             /*!< GPIO1_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_PROC1_INTF0_GPIO1_LEVEL_HIGH_Msk (0x20UL)          /*!< GPIO1_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO1_LEVEL_LOW_Pos (4UL)              /*!< GPIO1_LEVEL_LOW (Bit 4) */
#define IO_BANK0_PROC1_INTF0_GPIO1_LEVEL_LOW_Msk (0x10UL)           /*!< GPIO1_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO0_EDGE_HIGH_Pos (3UL)              /*!< GPIO0_EDGE_HIGH (Bit 3) */
#define IO_BANK0_PROC1_INTF0_GPIO0_EDGE_HIGH_Msk (0x8UL)            /*!< GPIO0_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO0_EDGE_LOW_Pos (2UL)               /*!< GPIO0_EDGE_LOW (Bit 2) */
#define IO_BANK0_PROC1_INTF0_GPIO0_EDGE_LOW_Msk (0x4UL)             /*!< GPIO0_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO0_LEVEL_HIGH_Pos (1UL)             /*!< GPIO0_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_PROC1_INTF0_GPIO0_LEVEL_HIGH_Msk (0x2UL)           /*!< GPIO0_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF0_GPIO0_LEVEL_LOW_Pos (0UL)              /*!< GPIO0_LEVEL_LOW (Bit 0) */
#define IO_BANK0_PROC1_INTF0_GPIO0_LEVEL_LOW_Msk (0x1UL)            /*!< GPIO0_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ======================================================  PROC1_INTF1  ====================================================== */
#define IO_BANK0_PROC1_INTF1_GPIO15_EDGE_HIGH_Pos (31UL)            /*!< GPIO15_EDGE_HIGH (Bit 31) */
#define IO_BANK0_PROC1_INTF1_GPIO15_EDGE_HIGH_Msk (0x80000000UL)    /*!< GPIO15_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO15_EDGE_LOW_Pos (30UL)             /*!< GPIO15_EDGE_LOW (Bit 30) */
#define IO_BANK0_PROC1_INTF1_GPIO15_EDGE_LOW_Msk (0x40000000UL)     /*!< GPIO15_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO15_LEVEL_HIGH_Pos (29UL)           /*!< GPIO15_LEVEL_HIGH (Bit 29) */
#define IO_BANK0_PROC1_INTF1_GPIO15_LEVEL_HIGH_Msk (0x20000000UL)   /*!< GPIO15_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO15_LEVEL_LOW_Pos (28UL)            /*!< GPIO15_LEVEL_LOW (Bit 28) */
#define IO_BANK0_PROC1_INTF1_GPIO15_LEVEL_LOW_Msk (0x10000000UL)    /*!< GPIO15_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO14_EDGE_HIGH_Pos (27UL)            /*!< GPIO14_EDGE_HIGH (Bit 27) */
#define IO_BANK0_PROC1_INTF1_GPIO14_EDGE_HIGH_Msk (0x8000000UL)     /*!< GPIO14_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO14_EDGE_LOW_Pos (26UL)             /*!< GPIO14_EDGE_LOW (Bit 26) */
#define IO_BANK0_PROC1_INTF1_GPIO14_EDGE_LOW_Msk (0x4000000UL)      /*!< GPIO14_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO14_LEVEL_HIGH_Pos (25UL)           /*!< GPIO14_LEVEL_HIGH (Bit 25) */
#define IO_BANK0_PROC1_INTF1_GPIO14_LEVEL_HIGH_Msk (0x2000000UL)    /*!< GPIO14_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO14_LEVEL_LOW_Pos (24UL)            /*!< GPIO14_LEVEL_LOW (Bit 24) */
#define IO_BANK0_PROC1_INTF1_GPIO14_LEVEL_LOW_Msk (0x1000000UL)     /*!< GPIO14_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO13_EDGE_HIGH_Pos (23UL)            /*!< GPIO13_EDGE_HIGH (Bit 23) */
#define IO_BANK0_PROC1_INTF1_GPIO13_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO13_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO13_EDGE_LOW_Pos (22UL)             /*!< GPIO13_EDGE_LOW (Bit 22) */
#define IO_BANK0_PROC1_INTF1_GPIO13_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO13_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO13_LEVEL_HIGH_Pos (21UL)           /*!< GPIO13_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_PROC1_INTF1_GPIO13_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO13_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO13_LEVEL_LOW_Pos (20UL)            /*!< GPIO13_LEVEL_LOW (Bit 20) */
#define IO_BANK0_PROC1_INTF1_GPIO13_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO13_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO12_EDGE_HIGH_Pos (19UL)            /*!< GPIO12_EDGE_HIGH (Bit 19) */
#define IO_BANK0_PROC1_INTF1_GPIO12_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO12_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO12_EDGE_LOW_Pos (18UL)             /*!< GPIO12_EDGE_LOW (Bit 18) */
#define IO_BANK0_PROC1_INTF1_GPIO12_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO12_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO12_LEVEL_HIGH_Pos (17UL)           /*!< GPIO12_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_PROC1_INTF1_GPIO12_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO12_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO12_LEVEL_LOW_Pos (16UL)            /*!< GPIO12_LEVEL_LOW (Bit 16) */
#define IO_BANK0_PROC1_INTF1_GPIO12_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO12_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO11_EDGE_HIGH_Pos (15UL)            /*!< GPIO11_EDGE_HIGH (Bit 15) */
#define IO_BANK0_PROC1_INTF1_GPIO11_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO11_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO11_EDGE_LOW_Pos (14UL)             /*!< GPIO11_EDGE_LOW (Bit 14) */
#define IO_BANK0_PROC1_INTF1_GPIO11_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO11_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO11_LEVEL_HIGH_Pos (13UL)           /*!< GPIO11_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_PROC1_INTF1_GPIO11_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO11_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO11_LEVEL_LOW_Pos (12UL)            /*!< GPIO11_LEVEL_LOW (Bit 12) */
#define IO_BANK0_PROC1_INTF1_GPIO11_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO11_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO10_EDGE_HIGH_Pos (11UL)            /*!< GPIO10_EDGE_HIGH (Bit 11) */
#define IO_BANK0_PROC1_INTF1_GPIO10_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO10_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO10_EDGE_LOW_Pos (10UL)             /*!< GPIO10_EDGE_LOW (Bit 10) */
#define IO_BANK0_PROC1_INTF1_GPIO10_EDGE_LOW_Msk (0x400UL)          /*!< GPIO10_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO10_LEVEL_HIGH_Pos (9UL)            /*!< GPIO10_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_PROC1_INTF1_GPIO10_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO10_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO10_LEVEL_LOW_Pos (8UL)             /*!< GPIO10_LEVEL_LOW (Bit 8) */
#define IO_BANK0_PROC1_INTF1_GPIO10_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO10_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO9_EDGE_HIGH_Pos (7UL)              /*!< GPIO9_EDGE_HIGH (Bit 7) */
#define IO_BANK0_PROC1_INTF1_GPIO9_EDGE_HIGH_Msk (0x80UL)           /*!< GPIO9_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO9_EDGE_LOW_Pos (6UL)               /*!< GPIO9_EDGE_LOW (Bit 6) */
#define IO_BANK0_PROC1_INTF1_GPIO9_EDGE_LOW_Msk (0x40UL)            /*!< GPIO9_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO9_LEVEL_HIGH_Pos (5UL)             /*!< GPIO9_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_PROC1_INTF1_GPIO9_LEVEL_HIGH_Msk (0x20UL)          /*!< GPIO9_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO9_LEVEL_LOW_Pos (4UL)              /*!< GPIO9_LEVEL_LOW (Bit 4) */
#define IO_BANK0_PROC1_INTF1_GPIO9_LEVEL_LOW_Msk (0x10UL)           /*!< GPIO9_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO8_EDGE_HIGH_Pos (3UL)              /*!< GPIO8_EDGE_HIGH (Bit 3) */
#define IO_BANK0_PROC1_INTF1_GPIO8_EDGE_HIGH_Msk (0x8UL)            /*!< GPIO8_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO8_EDGE_LOW_Pos (2UL)               /*!< GPIO8_EDGE_LOW (Bit 2) */
#define IO_BANK0_PROC1_INTF1_GPIO8_EDGE_LOW_Msk (0x4UL)             /*!< GPIO8_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO8_LEVEL_HIGH_Pos (1UL)             /*!< GPIO8_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_PROC1_INTF1_GPIO8_LEVEL_HIGH_Msk (0x2UL)           /*!< GPIO8_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF1_GPIO8_LEVEL_LOW_Pos (0UL)              /*!< GPIO8_LEVEL_LOW (Bit 0) */
#define IO_BANK0_PROC1_INTF1_GPIO8_LEVEL_LOW_Msk (0x1UL)            /*!< GPIO8_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ======================================================  PROC1_INTF2  ====================================================== */
#define IO_BANK0_PROC1_INTF2_GPIO23_EDGE_HIGH_Pos (31UL)            /*!< GPIO23_EDGE_HIGH (Bit 31) */
#define IO_BANK0_PROC1_INTF2_GPIO23_EDGE_HIGH_Msk (0x80000000UL)    /*!< GPIO23_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO23_EDGE_LOW_Pos (30UL)             /*!< GPIO23_EDGE_LOW (Bit 30) */
#define IO_BANK0_PROC1_INTF2_GPIO23_EDGE_LOW_Msk (0x40000000UL)     /*!< GPIO23_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO23_LEVEL_HIGH_Pos (29UL)           /*!< GPIO23_LEVEL_HIGH (Bit 29) */
#define IO_BANK0_PROC1_INTF2_GPIO23_LEVEL_HIGH_Msk (0x20000000UL)   /*!< GPIO23_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO23_LEVEL_LOW_Pos (28UL)            /*!< GPIO23_LEVEL_LOW (Bit 28) */
#define IO_BANK0_PROC1_INTF2_GPIO23_LEVEL_LOW_Msk (0x10000000UL)    /*!< GPIO23_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO22_EDGE_HIGH_Pos (27UL)            /*!< GPIO22_EDGE_HIGH (Bit 27) */
#define IO_BANK0_PROC1_INTF2_GPIO22_EDGE_HIGH_Msk (0x8000000UL)     /*!< GPIO22_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO22_EDGE_LOW_Pos (26UL)             /*!< GPIO22_EDGE_LOW (Bit 26) */
#define IO_BANK0_PROC1_INTF2_GPIO22_EDGE_LOW_Msk (0x4000000UL)      /*!< GPIO22_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO22_LEVEL_HIGH_Pos (25UL)           /*!< GPIO22_LEVEL_HIGH (Bit 25) */
#define IO_BANK0_PROC1_INTF2_GPIO22_LEVEL_HIGH_Msk (0x2000000UL)    /*!< GPIO22_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO22_LEVEL_LOW_Pos (24UL)            /*!< GPIO22_LEVEL_LOW (Bit 24) */
#define IO_BANK0_PROC1_INTF2_GPIO22_LEVEL_LOW_Msk (0x1000000UL)     /*!< GPIO22_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO21_EDGE_HIGH_Pos (23UL)            /*!< GPIO21_EDGE_HIGH (Bit 23) */
#define IO_BANK0_PROC1_INTF2_GPIO21_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO21_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO21_EDGE_LOW_Pos (22UL)             /*!< GPIO21_EDGE_LOW (Bit 22) */
#define IO_BANK0_PROC1_INTF2_GPIO21_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO21_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO21_LEVEL_HIGH_Pos (21UL)           /*!< GPIO21_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_PROC1_INTF2_GPIO21_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO21_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO21_LEVEL_LOW_Pos (20UL)            /*!< GPIO21_LEVEL_LOW (Bit 20) */
#define IO_BANK0_PROC1_INTF2_GPIO21_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO21_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO20_EDGE_HIGH_Pos (19UL)            /*!< GPIO20_EDGE_HIGH (Bit 19) */
#define IO_BANK0_PROC1_INTF2_GPIO20_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO20_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO20_EDGE_LOW_Pos (18UL)             /*!< GPIO20_EDGE_LOW (Bit 18) */
#define IO_BANK0_PROC1_INTF2_GPIO20_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO20_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO20_LEVEL_HIGH_Pos (17UL)           /*!< GPIO20_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_PROC1_INTF2_GPIO20_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO20_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO20_LEVEL_LOW_Pos (16UL)            /*!< GPIO20_LEVEL_LOW (Bit 16) */
#define IO_BANK0_PROC1_INTF2_GPIO20_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO20_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO19_EDGE_HIGH_Pos (15UL)            /*!< GPIO19_EDGE_HIGH (Bit 15) */
#define IO_BANK0_PROC1_INTF2_GPIO19_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO19_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO19_EDGE_LOW_Pos (14UL)             /*!< GPIO19_EDGE_LOW (Bit 14) */
#define IO_BANK0_PROC1_INTF2_GPIO19_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO19_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO19_LEVEL_HIGH_Pos (13UL)           /*!< GPIO19_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_PROC1_INTF2_GPIO19_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO19_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO19_LEVEL_LOW_Pos (12UL)            /*!< GPIO19_LEVEL_LOW (Bit 12) */
#define IO_BANK0_PROC1_INTF2_GPIO19_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO19_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO18_EDGE_HIGH_Pos (11UL)            /*!< GPIO18_EDGE_HIGH (Bit 11) */
#define IO_BANK0_PROC1_INTF2_GPIO18_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO18_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO18_EDGE_LOW_Pos (10UL)             /*!< GPIO18_EDGE_LOW (Bit 10) */
#define IO_BANK0_PROC1_INTF2_GPIO18_EDGE_LOW_Msk (0x400UL)          /*!< GPIO18_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO18_LEVEL_HIGH_Pos (9UL)            /*!< GPIO18_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_PROC1_INTF2_GPIO18_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO18_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO18_LEVEL_LOW_Pos (8UL)             /*!< GPIO18_LEVEL_LOW (Bit 8) */
#define IO_BANK0_PROC1_INTF2_GPIO18_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO18_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO17_EDGE_HIGH_Pos (7UL)             /*!< GPIO17_EDGE_HIGH (Bit 7) */
#define IO_BANK0_PROC1_INTF2_GPIO17_EDGE_HIGH_Msk (0x80UL)          /*!< GPIO17_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO17_EDGE_LOW_Pos (6UL)              /*!< GPIO17_EDGE_LOW (Bit 6) */
#define IO_BANK0_PROC1_INTF2_GPIO17_EDGE_LOW_Msk (0x40UL)           /*!< GPIO17_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO17_LEVEL_HIGH_Pos (5UL)            /*!< GPIO17_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_PROC1_INTF2_GPIO17_LEVEL_HIGH_Msk (0x20UL)         /*!< GPIO17_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO17_LEVEL_LOW_Pos (4UL)             /*!< GPIO17_LEVEL_LOW (Bit 4) */
#define IO_BANK0_PROC1_INTF2_GPIO17_LEVEL_LOW_Msk (0x10UL)          /*!< GPIO17_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO16_EDGE_HIGH_Pos (3UL)             /*!< GPIO16_EDGE_HIGH (Bit 3) */
#define IO_BANK0_PROC1_INTF2_GPIO16_EDGE_HIGH_Msk (0x8UL)           /*!< GPIO16_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO16_EDGE_LOW_Pos (2UL)              /*!< GPIO16_EDGE_LOW (Bit 2) */
#define IO_BANK0_PROC1_INTF2_GPIO16_EDGE_LOW_Msk (0x4UL)            /*!< GPIO16_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO16_LEVEL_HIGH_Pos (1UL)            /*!< GPIO16_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_PROC1_INTF2_GPIO16_LEVEL_HIGH_Msk (0x2UL)          /*!< GPIO16_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF2_GPIO16_LEVEL_LOW_Pos (0UL)             /*!< GPIO16_LEVEL_LOW (Bit 0) */
#define IO_BANK0_PROC1_INTF2_GPIO16_LEVEL_LOW_Msk (0x1UL)           /*!< GPIO16_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ======================================================  PROC1_INTF3  ====================================================== */
#define IO_BANK0_PROC1_INTF3_GPIO29_EDGE_HIGH_Pos (23UL)            /*!< GPIO29_EDGE_HIGH (Bit 23) */
#define IO_BANK0_PROC1_INTF3_GPIO29_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO29_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF3_GPIO29_EDGE_LOW_Pos (22UL)             /*!< GPIO29_EDGE_LOW (Bit 22) */
#define IO_BANK0_PROC1_INTF3_GPIO29_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO29_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF3_GPIO29_LEVEL_HIGH_Pos (21UL)           /*!< GPIO29_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_PROC1_INTF3_GPIO29_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO29_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF3_GPIO29_LEVEL_LOW_Pos (20UL)            /*!< GPIO29_LEVEL_LOW (Bit 20) */
#define IO_BANK0_PROC1_INTF3_GPIO29_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO29_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF3_GPIO28_EDGE_HIGH_Pos (19UL)            /*!< GPIO28_EDGE_HIGH (Bit 19) */
#define IO_BANK0_PROC1_INTF3_GPIO28_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO28_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF3_GPIO28_EDGE_LOW_Pos (18UL)             /*!< GPIO28_EDGE_LOW (Bit 18) */
#define IO_BANK0_PROC1_INTF3_GPIO28_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO28_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF3_GPIO28_LEVEL_HIGH_Pos (17UL)           /*!< GPIO28_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_PROC1_INTF3_GPIO28_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO28_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF3_GPIO28_LEVEL_LOW_Pos (16UL)            /*!< GPIO28_LEVEL_LOW (Bit 16) */
#define IO_BANK0_PROC1_INTF3_GPIO28_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO28_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF3_GPIO27_EDGE_HIGH_Pos (15UL)            /*!< GPIO27_EDGE_HIGH (Bit 15) */
#define IO_BANK0_PROC1_INTF3_GPIO27_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO27_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF3_GPIO27_EDGE_LOW_Pos (14UL)             /*!< GPIO27_EDGE_LOW (Bit 14) */
#define IO_BANK0_PROC1_INTF3_GPIO27_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO27_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF3_GPIO27_LEVEL_HIGH_Pos (13UL)           /*!< GPIO27_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_PROC1_INTF3_GPIO27_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO27_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF3_GPIO27_LEVEL_LOW_Pos (12UL)            /*!< GPIO27_LEVEL_LOW (Bit 12) */
#define IO_BANK0_PROC1_INTF3_GPIO27_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO27_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF3_GPIO26_EDGE_HIGH_Pos (11UL)            /*!< GPIO26_EDGE_HIGH (Bit 11) */
#define IO_BANK0_PROC1_INTF3_GPIO26_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO26_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF3_GPIO26_EDGE_LOW_Pos (10UL)             /*!< GPIO26_EDGE_LOW (Bit 10) */
#define IO_BANK0_PROC1_INTF3_GPIO26_EDGE_LOW_Msk (0x400UL)          /*!< GPIO26_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF3_GPIO26_LEVEL_HIGH_Pos (9UL)            /*!< GPIO26_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_PROC1_INTF3_GPIO26_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO26_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF3_GPIO26_LEVEL_LOW_Pos (8UL)             /*!< GPIO26_LEVEL_LOW (Bit 8) */
#define IO_BANK0_PROC1_INTF3_GPIO26_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO26_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF3_GPIO25_EDGE_HIGH_Pos (7UL)             /*!< GPIO25_EDGE_HIGH (Bit 7) */
#define IO_BANK0_PROC1_INTF3_GPIO25_EDGE_HIGH_Msk (0x80UL)          /*!< GPIO25_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF3_GPIO25_EDGE_LOW_Pos (6UL)              /*!< GPIO25_EDGE_LOW (Bit 6) */
#define IO_BANK0_PROC1_INTF3_GPIO25_EDGE_LOW_Msk (0x40UL)           /*!< GPIO25_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF3_GPIO25_LEVEL_HIGH_Pos (5UL)            /*!< GPIO25_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_PROC1_INTF3_GPIO25_LEVEL_HIGH_Msk (0x20UL)         /*!< GPIO25_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF3_GPIO25_LEVEL_LOW_Pos (4UL)             /*!< GPIO25_LEVEL_LOW (Bit 4) */
#define IO_BANK0_PROC1_INTF3_GPIO25_LEVEL_LOW_Msk (0x10UL)          /*!< GPIO25_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF3_GPIO24_EDGE_HIGH_Pos (3UL)             /*!< GPIO24_EDGE_HIGH (Bit 3) */
#define IO_BANK0_PROC1_INTF3_GPIO24_EDGE_HIGH_Msk (0x8UL)           /*!< GPIO24_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF3_GPIO24_EDGE_LOW_Pos (2UL)              /*!< GPIO24_EDGE_LOW (Bit 2) */
#define IO_BANK0_PROC1_INTF3_GPIO24_EDGE_LOW_Msk (0x4UL)            /*!< GPIO24_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF3_GPIO24_LEVEL_HIGH_Pos (1UL)            /*!< GPIO24_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_PROC1_INTF3_GPIO24_LEVEL_HIGH_Msk (0x2UL)          /*!< GPIO24_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTF3_GPIO24_LEVEL_LOW_Pos (0UL)             /*!< GPIO24_LEVEL_LOW (Bit 0) */
#define IO_BANK0_PROC1_INTF3_GPIO24_LEVEL_LOW_Msk (0x1UL)           /*!< GPIO24_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ======================================================  PROC1_INTS0  ====================================================== */
#define IO_BANK0_PROC1_INTS0_GPIO7_EDGE_HIGH_Pos (31UL)             /*!< GPIO7_EDGE_HIGH (Bit 31) */
#define IO_BANK0_PROC1_INTS0_GPIO7_EDGE_HIGH_Msk (0x80000000UL)     /*!< GPIO7_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO7_EDGE_LOW_Pos (30UL)              /*!< GPIO7_EDGE_LOW (Bit 30) */
#define IO_BANK0_PROC1_INTS0_GPIO7_EDGE_LOW_Msk (0x40000000UL)      /*!< GPIO7_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO7_LEVEL_HIGH_Pos (29UL)            /*!< GPIO7_LEVEL_HIGH (Bit 29) */
#define IO_BANK0_PROC1_INTS0_GPIO7_LEVEL_HIGH_Msk (0x20000000UL)    /*!< GPIO7_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO7_LEVEL_LOW_Pos (28UL)             /*!< GPIO7_LEVEL_LOW (Bit 28) */
#define IO_BANK0_PROC1_INTS0_GPIO7_LEVEL_LOW_Msk (0x10000000UL)     /*!< GPIO7_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO6_EDGE_HIGH_Pos (27UL)             /*!< GPIO6_EDGE_HIGH (Bit 27) */
#define IO_BANK0_PROC1_INTS0_GPIO6_EDGE_HIGH_Msk (0x8000000UL)      /*!< GPIO6_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO6_EDGE_LOW_Pos (26UL)              /*!< GPIO6_EDGE_LOW (Bit 26) */
#define IO_BANK0_PROC1_INTS0_GPIO6_EDGE_LOW_Msk (0x4000000UL)       /*!< GPIO6_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO6_LEVEL_HIGH_Pos (25UL)            /*!< GPIO6_LEVEL_HIGH (Bit 25) */
#define IO_BANK0_PROC1_INTS0_GPIO6_LEVEL_HIGH_Msk (0x2000000UL)     /*!< GPIO6_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO6_LEVEL_LOW_Pos (24UL)             /*!< GPIO6_LEVEL_LOW (Bit 24) */
#define IO_BANK0_PROC1_INTS0_GPIO6_LEVEL_LOW_Msk (0x1000000UL)      /*!< GPIO6_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO5_EDGE_HIGH_Pos (23UL)             /*!< GPIO5_EDGE_HIGH (Bit 23) */
#define IO_BANK0_PROC1_INTS0_GPIO5_EDGE_HIGH_Msk (0x800000UL)       /*!< GPIO5_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO5_EDGE_LOW_Pos (22UL)              /*!< GPIO5_EDGE_LOW (Bit 22) */
#define IO_BANK0_PROC1_INTS0_GPIO5_EDGE_LOW_Msk (0x400000UL)        /*!< GPIO5_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO5_LEVEL_HIGH_Pos (21UL)            /*!< GPIO5_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_PROC1_INTS0_GPIO5_LEVEL_HIGH_Msk (0x200000UL)      /*!< GPIO5_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO5_LEVEL_LOW_Pos (20UL)             /*!< GPIO5_LEVEL_LOW (Bit 20) */
#define IO_BANK0_PROC1_INTS0_GPIO5_LEVEL_LOW_Msk (0x100000UL)       /*!< GPIO5_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO4_EDGE_HIGH_Pos (19UL)             /*!< GPIO4_EDGE_HIGH (Bit 19) */
#define IO_BANK0_PROC1_INTS0_GPIO4_EDGE_HIGH_Msk (0x80000UL)        /*!< GPIO4_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO4_EDGE_LOW_Pos (18UL)              /*!< GPIO4_EDGE_LOW (Bit 18) */
#define IO_BANK0_PROC1_INTS0_GPIO4_EDGE_LOW_Msk (0x40000UL)         /*!< GPIO4_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO4_LEVEL_HIGH_Pos (17UL)            /*!< GPIO4_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_PROC1_INTS0_GPIO4_LEVEL_HIGH_Msk (0x20000UL)       /*!< GPIO4_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO4_LEVEL_LOW_Pos (16UL)             /*!< GPIO4_LEVEL_LOW (Bit 16) */
#define IO_BANK0_PROC1_INTS0_GPIO4_LEVEL_LOW_Msk (0x10000UL)        /*!< GPIO4_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO3_EDGE_HIGH_Pos (15UL)             /*!< GPIO3_EDGE_HIGH (Bit 15) */
#define IO_BANK0_PROC1_INTS0_GPIO3_EDGE_HIGH_Msk (0x8000UL)         /*!< GPIO3_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO3_EDGE_LOW_Pos (14UL)              /*!< GPIO3_EDGE_LOW (Bit 14) */
#define IO_BANK0_PROC1_INTS0_GPIO3_EDGE_LOW_Msk (0x4000UL)          /*!< GPIO3_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO3_LEVEL_HIGH_Pos (13UL)            /*!< GPIO3_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_PROC1_INTS0_GPIO3_LEVEL_HIGH_Msk (0x2000UL)        /*!< GPIO3_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO3_LEVEL_LOW_Pos (12UL)             /*!< GPIO3_LEVEL_LOW (Bit 12) */
#define IO_BANK0_PROC1_INTS0_GPIO3_LEVEL_LOW_Msk (0x1000UL)         /*!< GPIO3_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO2_EDGE_HIGH_Pos (11UL)             /*!< GPIO2_EDGE_HIGH (Bit 11) */
#define IO_BANK0_PROC1_INTS0_GPIO2_EDGE_HIGH_Msk (0x800UL)          /*!< GPIO2_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO2_EDGE_LOW_Pos (10UL)              /*!< GPIO2_EDGE_LOW (Bit 10) */
#define IO_BANK0_PROC1_INTS0_GPIO2_EDGE_LOW_Msk (0x400UL)           /*!< GPIO2_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO2_LEVEL_HIGH_Pos (9UL)             /*!< GPIO2_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_PROC1_INTS0_GPIO2_LEVEL_HIGH_Msk (0x200UL)         /*!< GPIO2_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO2_LEVEL_LOW_Pos (8UL)              /*!< GPIO2_LEVEL_LOW (Bit 8) */
#define IO_BANK0_PROC1_INTS0_GPIO2_LEVEL_LOW_Msk (0x100UL)          /*!< GPIO2_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO1_EDGE_HIGH_Pos (7UL)              /*!< GPIO1_EDGE_HIGH (Bit 7) */
#define IO_BANK0_PROC1_INTS0_GPIO1_EDGE_HIGH_Msk (0x80UL)           /*!< GPIO1_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO1_EDGE_LOW_Pos (6UL)               /*!< GPIO1_EDGE_LOW (Bit 6) */
#define IO_BANK0_PROC1_INTS0_GPIO1_EDGE_LOW_Msk (0x40UL)            /*!< GPIO1_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO1_LEVEL_HIGH_Pos (5UL)             /*!< GPIO1_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_PROC1_INTS0_GPIO1_LEVEL_HIGH_Msk (0x20UL)          /*!< GPIO1_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO1_LEVEL_LOW_Pos (4UL)              /*!< GPIO1_LEVEL_LOW (Bit 4) */
#define IO_BANK0_PROC1_INTS0_GPIO1_LEVEL_LOW_Msk (0x10UL)           /*!< GPIO1_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO0_EDGE_HIGH_Pos (3UL)              /*!< GPIO0_EDGE_HIGH (Bit 3) */
#define IO_BANK0_PROC1_INTS0_GPIO0_EDGE_HIGH_Msk (0x8UL)            /*!< GPIO0_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO0_EDGE_LOW_Pos (2UL)               /*!< GPIO0_EDGE_LOW (Bit 2) */
#define IO_BANK0_PROC1_INTS0_GPIO0_EDGE_LOW_Msk (0x4UL)             /*!< GPIO0_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO0_LEVEL_HIGH_Pos (1UL)             /*!< GPIO0_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_PROC1_INTS0_GPIO0_LEVEL_HIGH_Msk (0x2UL)           /*!< GPIO0_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS0_GPIO0_LEVEL_LOW_Pos (0UL)              /*!< GPIO0_LEVEL_LOW (Bit 0) */
#define IO_BANK0_PROC1_INTS0_GPIO0_LEVEL_LOW_Msk (0x1UL)            /*!< GPIO0_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ======================================================  PROC1_INTS1  ====================================================== */
#define IO_BANK0_PROC1_INTS1_GPIO15_EDGE_HIGH_Pos (31UL)            /*!< GPIO15_EDGE_HIGH (Bit 31) */
#define IO_BANK0_PROC1_INTS1_GPIO15_EDGE_HIGH_Msk (0x80000000UL)    /*!< GPIO15_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO15_EDGE_LOW_Pos (30UL)             /*!< GPIO15_EDGE_LOW (Bit 30) */
#define IO_BANK0_PROC1_INTS1_GPIO15_EDGE_LOW_Msk (0x40000000UL)     /*!< GPIO15_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO15_LEVEL_HIGH_Pos (29UL)           /*!< GPIO15_LEVEL_HIGH (Bit 29) */
#define IO_BANK0_PROC1_INTS1_GPIO15_LEVEL_HIGH_Msk (0x20000000UL)   /*!< GPIO15_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO15_LEVEL_LOW_Pos (28UL)            /*!< GPIO15_LEVEL_LOW (Bit 28) */
#define IO_BANK0_PROC1_INTS1_GPIO15_LEVEL_LOW_Msk (0x10000000UL)    /*!< GPIO15_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO14_EDGE_HIGH_Pos (27UL)            /*!< GPIO14_EDGE_HIGH (Bit 27) */
#define IO_BANK0_PROC1_INTS1_GPIO14_EDGE_HIGH_Msk (0x8000000UL)     /*!< GPIO14_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO14_EDGE_LOW_Pos (26UL)             /*!< GPIO14_EDGE_LOW (Bit 26) */
#define IO_BANK0_PROC1_INTS1_GPIO14_EDGE_LOW_Msk (0x4000000UL)      /*!< GPIO14_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO14_LEVEL_HIGH_Pos (25UL)           /*!< GPIO14_LEVEL_HIGH (Bit 25) */
#define IO_BANK0_PROC1_INTS1_GPIO14_LEVEL_HIGH_Msk (0x2000000UL)    /*!< GPIO14_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO14_LEVEL_LOW_Pos (24UL)            /*!< GPIO14_LEVEL_LOW (Bit 24) */
#define IO_BANK0_PROC1_INTS1_GPIO14_LEVEL_LOW_Msk (0x1000000UL)     /*!< GPIO14_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO13_EDGE_HIGH_Pos (23UL)            /*!< GPIO13_EDGE_HIGH (Bit 23) */
#define IO_BANK0_PROC1_INTS1_GPIO13_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO13_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO13_EDGE_LOW_Pos (22UL)             /*!< GPIO13_EDGE_LOW (Bit 22) */
#define IO_BANK0_PROC1_INTS1_GPIO13_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO13_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO13_LEVEL_HIGH_Pos (21UL)           /*!< GPIO13_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_PROC1_INTS1_GPIO13_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO13_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO13_LEVEL_LOW_Pos (20UL)            /*!< GPIO13_LEVEL_LOW (Bit 20) */
#define IO_BANK0_PROC1_INTS1_GPIO13_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO13_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO12_EDGE_HIGH_Pos (19UL)            /*!< GPIO12_EDGE_HIGH (Bit 19) */
#define IO_BANK0_PROC1_INTS1_GPIO12_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO12_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO12_EDGE_LOW_Pos (18UL)             /*!< GPIO12_EDGE_LOW (Bit 18) */
#define IO_BANK0_PROC1_INTS1_GPIO12_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO12_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO12_LEVEL_HIGH_Pos (17UL)           /*!< GPIO12_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_PROC1_INTS1_GPIO12_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO12_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO12_LEVEL_LOW_Pos (16UL)            /*!< GPIO12_LEVEL_LOW (Bit 16) */
#define IO_BANK0_PROC1_INTS1_GPIO12_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO12_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO11_EDGE_HIGH_Pos (15UL)            /*!< GPIO11_EDGE_HIGH (Bit 15) */
#define IO_BANK0_PROC1_INTS1_GPIO11_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO11_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO11_EDGE_LOW_Pos (14UL)             /*!< GPIO11_EDGE_LOW (Bit 14) */
#define IO_BANK0_PROC1_INTS1_GPIO11_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO11_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO11_LEVEL_HIGH_Pos (13UL)           /*!< GPIO11_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_PROC1_INTS1_GPIO11_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO11_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO11_LEVEL_LOW_Pos (12UL)            /*!< GPIO11_LEVEL_LOW (Bit 12) */
#define IO_BANK0_PROC1_INTS1_GPIO11_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO11_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO10_EDGE_HIGH_Pos (11UL)            /*!< GPIO10_EDGE_HIGH (Bit 11) */
#define IO_BANK0_PROC1_INTS1_GPIO10_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO10_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO10_EDGE_LOW_Pos (10UL)             /*!< GPIO10_EDGE_LOW (Bit 10) */
#define IO_BANK0_PROC1_INTS1_GPIO10_EDGE_LOW_Msk (0x400UL)          /*!< GPIO10_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO10_LEVEL_HIGH_Pos (9UL)            /*!< GPIO10_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_PROC1_INTS1_GPIO10_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO10_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO10_LEVEL_LOW_Pos (8UL)             /*!< GPIO10_LEVEL_LOW (Bit 8) */
#define IO_BANK0_PROC1_INTS1_GPIO10_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO10_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO9_EDGE_HIGH_Pos (7UL)              /*!< GPIO9_EDGE_HIGH (Bit 7) */
#define IO_BANK0_PROC1_INTS1_GPIO9_EDGE_HIGH_Msk (0x80UL)           /*!< GPIO9_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO9_EDGE_LOW_Pos (6UL)               /*!< GPIO9_EDGE_LOW (Bit 6) */
#define IO_BANK0_PROC1_INTS1_GPIO9_EDGE_LOW_Msk (0x40UL)            /*!< GPIO9_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO9_LEVEL_HIGH_Pos (5UL)             /*!< GPIO9_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_PROC1_INTS1_GPIO9_LEVEL_HIGH_Msk (0x20UL)          /*!< GPIO9_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO9_LEVEL_LOW_Pos (4UL)              /*!< GPIO9_LEVEL_LOW (Bit 4) */
#define IO_BANK0_PROC1_INTS1_GPIO9_LEVEL_LOW_Msk (0x10UL)           /*!< GPIO9_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO8_EDGE_HIGH_Pos (3UL)              /*!< GPIO8_EDGE_HIGH (Bit 3) */
#define IO_BANK0_PROC1_INTS1_GPIO8_EDGE_HIGH_Msk (0x8UL)            /*!< GPIO8_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO8_EDGE_LOW_Pos (2UL)               /*!< GPIO8_EDGE_LOW (Bit 2) */
#define IO_BANK0_PROC1_INTS1_GPIO8_EDGE_LOW_Msk (0x4UL)             /*!< GPIO8_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO8_LEVEL_HIGH_Pos (1UL)             /*!< GPIO8_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_PROC1_INTS1_GPIO8_LEVEL_HIGH_Msk (0x2UL)           /*!< GPIO8_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS1_GPIO8_LEVEL_LOW_Pos (0UL)              /*!< GPIO8_LEVEL_LOW (Bit 0) */
#define IO_BANK0_PROC1_INTS1_GPIO8_LEVEL_LOW_Msk (0x1UL)            /*!< GPIO8_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ======================================================  PROC1_INTS2  ====================================================== */
#define IO_BANK0_PROC1_INTS2_GPIO23_EDGE_HIGH_Pos (31UL)            /*!< GPIO23_EDGE_HIGH (Bit 31) */
#define IO_BANK0_PROC1_INTS2_GPIO23_EDGE_HIGH_Msk (0x80000000UL)    /*!< GPIO23_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO23_EDGE_LOW_Pos (30UL)             /*!< GPIO23_EDGE_LOW (Bit 30) */
#define IO_BANK0_PROC1_INTS2_GPIO23_EDGE_LOW_Msk (0x40000000UL)     /*!< GPIO23_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO23_LEVEL_HIGH_Pos (29UL)           /*!< GPIO23_LEVEL_HIGH (Bit 29) */
#define IO_BANK0_PROC1_INTS2_GPIO23_LEVEL_HIGH_Msk (0x20000000UL)   /*!< GPIO23_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO23_LEVEL_LOW_Pos (28UL)            /*!< GPIO23_LEVEL_LOW (Bit 28) */
#define IO_BANK0_PROC1_INTS2_GPIO23_LEVEL_LOW_Msk (0x10000000UL)    /*!< GPIO23_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO22_EDGE_HIGH_Pos (27UL)            /*!< GPIO22_EDGE_HIGH (Bit 27) */
#define IO_BANK0_PROC1_INTS2_GPIO22_EDGE_HIGH_Msk (0x8000000UL)     /*!< GPIO22_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO22_EDGE_LOW_Pos (26UL)             /*!< GPIO22_EDGE_LOW (Bit 26) */
#define IO_BANK0_PROC1_INTS2_GPIO22_EDGE_LOW_Msk (0x4000000UL)      /*!< GPIO22_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO22_LEVEL_HIGH_Pos (25UL)           /*!< GPIO22_LEVEL_HIGH (Bit 25) */
#define IO_BANK0_PROC1_INTS2_GPIO22_LEVEL_HIGH_Msk (0x2000000UL)    /*!< GPIO22_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO22_LEVEL_LOW_Pos (24UL)            /*!< GPIO22_LEVEL_LOW (Bit 24) */
#define IO_BANK0_PROC1_INTS2_GPIO22_LEVEL_LOW_Msk (0x1000000UL)     /*!< GPIO22_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO21_EDGE_HIGH_Pos (23UL)            /*!< GPIO21_EDGE_HIGH (Bit 23) */
#define IO_BANK0_PROC1_INTS2_GPIO21_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO21_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO21_EDGE_LOW_Pos (22UL)             /*!< GPIO21_EDGE_LOW (Bit 22) */
#define IO_BANK0_PROC1_INTS2_GPIO21_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO21_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO21_LEVEL_HIGH_Pos (21UL)           /*!< GPIO21_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_PROC1_INTS2_GPIO21_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO21_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO21_LEVEL_LOW_Pos (20UL)            /*!< GPIO21_LEVEL_LOW (Bit 20) */
#define IO_BANK0_PROC1_INTS2_GPIO21_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO21_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO20_EDGE_HIGH_Pos (19UL)            /*!< GPIO20_EDGE_HIGH (Bit 19) */
#define IO_BANK0_PROC1_INTS2_GPIO20_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO20_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO20_EDGE_LOW_Pos (18UL)             /*!< GPIO20_EDGE_LOW (Bit 18) */
#define IO_BANK0_PROC1_INTS2_GPIO20_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO20_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO20_LEVEL_HIGH_Pos (17UL)           /*!< GPIO20_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_PROC1_INTS2_GPIO20_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO20_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO20_LEVEL_LOW_Pos (16UL)            /*!< GPIO20_LEVEL_LOW (Bit 16) */
#define IO_BANK0_PROC1_INTS2_GPIO20_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO20_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO19_EDGE_HIGH_Pos (15UL)            /*!< GPIO19_EDGE_HIGH (Bit 15) */
#define IO_BANK0_PROC1_INTS2_GPIO19_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO19_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO19_EDGE_LOW_Pos (14UL)             /*!< GPIO19_EDGE_LOW (Bit 14) */
#define IO_BANK0_PROC1_INTS2_GPIO19_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO19_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO19_LEVEL_HIGH_Pos (13UL)           /*!< GPIO19_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_PROC1_INTS2_GPIO19_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO19_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO19_LEVEL_LOW_Pos (12UL)            /*!< GPIO19_LEVEL_LOW (Bit 12) */
#define IO_BANK0_PROC1_INTS2_GPIO19_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO19_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO18_EDGE_HIGH_Pos (11UL)            /*!< GPIO18_EDGE_HIGH (Bit 11) */
#define IO_BANK0_PROC1_INTS2_GPIO18_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO18_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO18_EDGE_LOW_Pos (10UL)             /*!< GPIO18_EDGE_LOW (Bit 10) */
#define IO_BANK0_PROC1_INTS2_GPIO18_EDGE_LOW_Msk (0x400UL)          /*!< GPIO18_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO18_LEVEL_HIGH_Pos (9UL)            /*!< GPIO18_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_PROC1_INTS2_GPIO18_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO18_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO18_LEVEL_LOW_Pos (8UL)             /*!< GPIO18_LEVEL_LOW (Bit 8) */
#define IO_BANK0_PROC1_INTS2_GPIO18_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO18_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO17_EDGE_HIGH_Pos (7UL)             /*!< GPIO17_EDGE_HIGH (Bit 7) */
#define IO_BANK0_PROC1_INTS2_GPIO17_EDGE_HIGH_Msk (0x80UL)          /*!< GPIO17_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO17_EDGE_LOW_Pos (6UL)              /*!< GPIO17_EDGE_LOW (Bit 6) */
#define IO_BANK0_PROC1_INTS2_GPIO17_EDGE_LOW_Msk (0x40UL)           /*!< GPIO17_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO17_LEVEL_HIGH_Pos (5UL)            /*!< GPIO17_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_PROC1_INTS2_GPIO17_LEVEL_HIGH_Msk (0x20UL)         /*!< GPIO17_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO17_LEVEL_LOW_Pos (4UL)             /*!< GPIO17_LEVEL_LOW (Bit 4) */
#define IO_BANK0_PROC1_INTS2_GPIO17_LEVEL_LOW_Msk (0x10UL)          /*!< GPIO17_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO16_EDGE_HIGH_Pos (3UL)             /*!< GPIO16_EDGE_HIGH (Bit 3) */
#define IO_BANK0_PROC1_INTS2_GPIO16_EDGE_HIGH_Msk (0x8UL)           /*!< GPIO16_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO16_EDGE_LOW_Pos (2UL)              /*!< GPIO16_EDGE_LOW (Bit 2) */
#define IO_BANK0_PROC1_INTS2_GPIO16_EDGE_LOW_Msk (0x4UL)            /*!< GPIO16_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO16_LEVEL_HIGH_Pos (1UL)            /*!< GPIO16_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_PROC1_INTS2_GPIO16_LEVEL_HIGH_Msk (0x2UL)          /*!< GPIO16_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS2_GPIO16_LEVEL_LOW_Pos (0UL)             /*!< GPIO16_LEVEL_LOW (Bit 0) */
#define IO_BANK0_PROC1_INTS2_GPIO16_LEVEL_LOW_Msk (0x1UL)           /*!< GPIO16_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ======================================================  PROC1_INTS3  ====================================================== */
#define IO_BANK0_PROC1_INTS3_GPIO29_EDGE_HIGH_Pos (23UL)            /*!< GPIO29_EDGE_HIGH (Bit 23) */
#define IO_BANK0_PROC1_INTS3_GPIO29_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO29_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS3_GPIO29_EDGE_LOW_Pos (22UL)             /*!< GPIO29_EDGE_LOW (Bit 22) */
#define IO_BANK0_PROC1_INTS3_GPIO29_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO29_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS3_GPIO29_LEVEL_HIGH_Pos (21UL)           /*!< GPIO29_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_PROC1_INTS3_GPIO29_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO29_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS3_GPIO29_LEVEL_LOW_Pos (20UL)            /*!< GPIO29_LEVEL_LOW (Bit 20) */
#define IO_BANK0_PROC1_INTS3_GPIO29_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO29_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS3_GPIO28_EDGE_HIGH_Pos (19UL)            /*!< GPIO28_EDGE_HIGH (Bit 19) */
#define IO_BANK0_PROC1_INTS3_GPIO28_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO28_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS3_GPIO28_EDGE_LOW_Pos (18UL)             /*!< GPIO28_EDGE_LOW (Bit 18) */
#define IO_BANK0_PROC1_INTS3_GPIO28_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO28_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS3_GPIO28_LEVEL_HIGH_Pos (17UL)           /*!< GPIO28_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_PROC1_INTS3_GPIO28_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO28_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS3_GPIO28_LEVEL_LOW_Pos (16UL)            /*!< GPIO28_LEVEL_LOW (Bit 16) */
#define IO_BANK0_PROC1_INTS3_GPIO28_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO28_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS3_GPIO27_EDGE_HIGH_Pos (15UL)            /*!< GPIO27_EDGE_HIGH (Bit 15) */
#define IO_BANK0_PROC1_INTS3_GPIO27_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO27_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS3_GPIO27_EDGE_LOW_Pos (14UL)             /*!< GPIO27_EDGE_LOW (Bit 14) */
#define IO_BANK0_PROC1_INTS3_GPIO27_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO27_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS3_GPIO27_LEVEL_HIGH_Pos (13UL)           /*!< GPIO27_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_PROC1_INTS3_GPIO27_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO27_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS3_GPIO27_LEVEL_LOW_Pos (12UL)            /*!< GPIO27_LEVEL_LOW (Bit 12) */
#define IO_BANK0_PROC1_INTS3_GPIO27_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO27_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS3_GPIO26_EDGE_HIGH_Pos (11UL)            /*!< GPIO26_EDGE_HIGH (Bit 11) */
#define IO_BANK0_PROC1_INTS3_GPIO26_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO26_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS3_GPIO26_EDGE_LOW_Pos (10UL)             /*!< GPIO26_EDGE_LOW (Bit 10) */
#define IO_BANK0_PROC1_INTS3_GPIO26_EDGE_LOW_Msk (0x400UL)          /*!< GPIO26_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS3_GPIO26_LEVEL_HIGH_Pos (9UL)            /*!< GPIO26_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_PROC1_INTS3_GPIO26_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO26_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS3_GPIO26_LEVEL_LOW_Pos (8UL)             /*!< GPIO26_LEVEL_LOW (Bit 8) */
#define IO_BANK0_PROC1_INTS3_GPIO26_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO26_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS3_GPIO25_EDGE_HIGH_Pos (7UL)             /*!< GPIO25_EDGE_HIGH (Bit 7) */
#define IO_BANK0_PROC1_INTS3_GPIO25_EDGE_HIGH_Msk (0x80UL)          /*!< GPIO25_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS3_GPIO25_EDGE_LOW_Pos (6UL)              /*!< GPIO25_EDGE_LOW (Bit 6) */
#define IO_BANK0_PROC1_INTS3_GPIO25_EDGE_LOW_Msk (0x40UL)           /*!< GPIO25_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS3_GPIO25_LEVEL_HIGH_Pos (5UL)            /*!< GPIO25_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_PROC1_INTS3_GPIO25_LEVEL_HIGH_Msk (0x20UL)         /*!< GPIO25_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS3_GPIO25_LEVEL_LOW_Pos (4UL)             /*!< GPIO25_LEVEL_LOW (Bit 4) */
#define IO_BANK0_PROC1_INTS3_GPIO25_LEVEL_LOW_Msk (0x10UL)          /*!< GPIO25_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS3_GPIO24_EDGE_HIGH_Pos (3UL)             /*!< GPIO24_EDGE_HIGH (Bit 3) */
#define IO_BANK0_PROC1_INTS3_GPIO24_EDGE_HIGH_Msk (0x8UL)           /*!< GPIO24_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS3_GPIO24_EDGE_LOW_Pos (2UL)              /*!< GPIO24_EDGE_LOW (Bit 2) */
#define IO_BANK0_PROC1_INTS3_GPIO24_EDGE_LOW_Msk (0x4UL)            /*!< GPIO24_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS3_GPIO24_LEVEL_HIGH_Pos (1UL)            /*!< GPIO24_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_PROC1_INTS3_GPIO24_LEVEL_HIGH_Msk (0x2UL)          /*!< GPIO24_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_PROC1_INTS3_GPIO24_LEVEL_LOW_Pos (0UL)             /*!< GPIO24_LEVEL_LOW (Bit 0) */
#define IO_BANK0_PROC1_INTS3_GPIO24_LEVEL_LOW_Msk (0x1UL)           /*!< GPIO24_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ==================================================  DORMANT_WAKE_INTE0  =================================================== */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_EDGE_HIGH_Pos (31UL)      /*!< GPIO7_EDGE_HIGH (Bit 31) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_EDGE_HIGH_Msk (0x80000000UL) /*!< GPIO7_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_EDGE_LOW_Pos (30UL)       /*!< GPIO7_EDGE_LOW (Bit 30) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_EDGE_LOW_Msk (0x40000000UL) /*!< GPIO7_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_LEVEL_HIGH_Pos (29UL)     /*!< GPIO7_LEVEL_HIGH (Bit 29) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_LEVEL_HIGH_Msk (0x20000000UL) /*!< GPIO7_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_LEVEL_LOW_Pos (28UL)      /*!< GPIO7_LEVEL_LOW (Bit 28) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_LEVEL_LOW_Msk (0x10000000UL) /*!< GPIO7_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_EDGE_HIGH_Pos (27UL)      /*!< GPIO6_EDGE_HIGH (Bit 27) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_EDGE_HIGH_Msk (0x8000000UL) /*!< GPIO6_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_EDGE_LOW_Pos (26UL)       /*!< GPIO6_EDGE_LOW (Bit 26) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_EDGE_LOW_Msk (0x4000000UL) /*!< GPIO6_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_LEVEL_HIGH_Pos (25UL)     /*!< GPIO6_LEVEL_HIGH (Bit 25) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_LEVEL_HIGH_Msk (0x2000000UL) /*!< GPIO6_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_LEVEL_LOW_Pos (24UL)      /*!< GPIO6_LEVEL_LOW (Bit 24) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_LEVEL_LOW_Msk (0x1000000UL) /*!< GPIO6_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_EDGE_HIGH_Pos (23UL)      /*!< GPIO5_EDGE_HIGH (Bit 23) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO5_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_EDGE_LOW_Pos (22UL)       /*!< GPIO5_EDGE_LOW (Bit 22) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_EDGE_LOW_Msk (0x400000UL) /*!< GPIO5_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_LEVEL_HIGH_Pos (21UL)     /*!< GPIO5_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO5_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_LEVEL_LOW_Pos (20UL)      /*!< GPIO5_LEVEL_LOW (Bit 20) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO5_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_EDGE_HIGH_Pos (19UL)      /*!< GPIO4_EDGE_HIGH (Bit 19) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_EDGE_HIGH_Msk (0x80000UL) /*!< GPIO4_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_EDGE_LOW_Pos (18UL)       /*!< GPIO4_EDGE_LOW (Bit 18) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_EDGE_LOW_Msk (0x40000UL)  /*!< GPIO4_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_LEVEL_HIGH_Pos (17UL)     /*!< GPIO4_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO4_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_LEVEL_LOW_Pos (16UL)      /*!< GPIO4_LEVEL_LOW (Bit 16) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_LEVEL_LOW_Msk (0x10000UL) /*!< GPIO4_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_EDGE_HIGH_Pos (15UL)      /*!< GPIO3_EDGE_HIGH (Bit 15) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_EDGE_HIGH_Msk (0x8000UL)  /*!< GPIO3_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_EDGE_LOW_Pos (14UL)       /*!< GPIO3_EDGE_LOW (Bit 14) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_EDGE_LOW_Msk (0x4000UL)   /*!< GPIO3_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_LEVEL_HIGH_Pos (13UL)     /*!< GPIO3_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_LEVEL_HIGH_Msk (0x2000UL) /*!< GPIO3_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_LEVEL_LOW_Pos (12UL)      /*!< GPIO3_LEVEL_LOW (Bit 12) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_LEVEL_LOW_Msk (0x1000UL)  /*!< GPIO3_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_EDGE_HIGH_Pos (11UL)      /*!< GPIO2_EDGE_HIGH (Bit 11) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_EDGE_HIGH_Msk (0x800UL)   /*!< GPIO2_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_EDGE_LOW_Pos (10UL)       /*!< GPIO2_EDGE_LOW (Bit 10) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_EDGE_LOW_Msk (0x400UL)    /*!< GPIO2_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_LEVEL_HIGH_Pos (9UL)      /*!< GPIO2_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_LEVEL_HIGH_Msk (0x200UL)  /*!< GPIO2_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_LEVEL_LOW_Pos (8UL)       /*!< GPIO2_LEVEL_LOW (Bit 8) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_LEVEL_LOW_Msk (0x100UL)   /*!< GPIO2_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_EDGE_HIGH_Pos (7UL)       /*!< GPIO1_EDGE_HIGH (Bit 7) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_EDGE_HIGH_Msk (0x80UL)    /*!< GPIO1_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_EDGE_LOW_Pos (6UL)        /*!< GPIO1_EDGE_LOW (Bit 6) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_EDGE_LOW_Msk (0x40UL)     /*!< GPIO1_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_LEVEL_HIGH_Pos (5UL)      /*!< GPIO1_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_LEVEL_HIGH_Msk (0x20UL)   /*!< GPIO1_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_LEVEL_LOW_Pos (4UL)       /*!< GPIO1_LEVEL_LOW (Bit 4) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_LEVEL_LOW_Msk (0x10UL)    /*!< GPIO1_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_EDGE_HIGH_Pos (3UL)       /*!< GPIO0_EDGE_HIGH (Bit 3) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_EDGE_HIGH_Msk (0x8UL)     /*!< GPIO0_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_EDGE_LOW_Pos (2UL)        /*!< GPIO0_EDGE_LOW (Bit 2) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_EDGE_LOW_Msk (0x4UL)      /*!< GPIO0_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_LEVEL_HIGH_Pos (1UL)      /*!< GPIO0_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_LEVEL_HIGH_Msk (0x2UL)    /*!< GPIO0_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_LEVEL_LOW_Pos (0UL)       /*!< GPIO0_LEVEL_LOW (Bit 0) */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_LEVEL_LOW_Msk (0x1UL)     /*!< GPIO0_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ==================================================  DORMANT_WAKE_INTE1  =================================================== */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_EDGE_HIGH_Pos (31UL)     /*!< GPIO15_EDGE_HIGH (Bit 31) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_EDGE_HIGH_Msk (0x80000000UL) /*!< GPIO15_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_EDGE_LOW_Pos (30UL)      /*!< GPIO15_EDGE_LOW (Bit 30) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_EDGE_LOW_Msk (0x40000000UL) /*!< GPIO15_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_LEVEL_HIGH_Pos (29UL)    /*!< GPIO15_LEVEL_HIGH (Bit 29) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_LEVEL_HIGH_Msk (0x20000000UL) /*!< GPIO15_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_LEVEL_LOW_Pos (28UL)     /*!< GPIO15_LEVEL_LOW (Bit 28) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_LEVEL_LOW_Msk (0x10000000UL) /*!< GPIO15_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_EDGE_HIGH_Pos (27UL)     /*!< GPIO14_EDGE_HIGH (Bit 27) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_EDGE_HIGH_Msk (0x8000000UL) /*!< GPIO14_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_EDGE_LOW_Pos (26UL)      /*!< GPIO14_EDGE_LOW (Bit 26) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_EDGE_LOW_Msk (0x4000000UL) /*!< GPIO14_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_LEVEL_HIGH_Pos (25UL)    /*!< GPIO14_LEVEL_HIGH (Bit 25) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_LEVEL_HIGH_Msk (0x2000000UL) /*!< GPIO14_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_LEVEL_LOW_Pos (24UL)     /*!< GPIO14_LEVEL_LOW (Bit 24) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_LEVEL_LOW_Msk (0x1000000UL) /*!< GPIO14_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_EDGE_HIGH_Pos (23UL)     /*!< GPIO13_EDGE_HIGH (Bit 23) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO13_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_EDGE_LOW_Pos (22UL)      /*!< GPIO13_EDGE_LOW (Bit 22) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_EDGE_LOW_Msk (0x400000UL) /*!< GPIO13_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_LEVEL_HIGH_Pos (21UL)    /*!< GPIO13_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO13_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_LEVEL_LOW_Pos (20UL)     /*!< GPIO13_LEVEL_LOW (Bit 20) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO13_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_EDGE_HIGH_Pos (19UL)     /*!< GPIO12_EDGE_HIGH (Bit 19) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_EDGE_HIGH_Msk (0x80000UL) /*!< GPIO12_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_EDGE_LOW_Pos (18UL)      /*!< GPIO12_EDGE_LOW (Bit 18) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_EDGE_LOW_Msk (0x40000UL) /*!< GPIO12_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_LEVEL_HIGH_Pos (17UL)    /*!< GPIO12_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO12_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_LEVEL_LOW_Pos (16UL)     /*!< GPIO12_LEVEL_LOW (Bit 16) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_LEVEL_LOW_Msk (0x10000UL) /*!< GPIO12_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_EDGE_HIGH_Pos (15UL)     /*!< GPIO11_EDGE_HIGH (Bit 15) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_EDGE_HIGH_Msk (0x8000UL) /*!< GPIO11_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_EDGE_LOW_Pos (14UL)      /*!< GPIO11_EDGE_LOW (Bit 14) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_EDGE_LOW_Msk (0x4000UL)  /*!< GPIO11_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_LEVEL_HIGH_Pos (13UL)    /*!< GPIO11_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_LEVEL_HIGH_Msk (0x2000UL) /*!< GPIO11_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_LEVEL_LOW_Pos (12UL)     /*!< GPIO11_LEVEL_LOW (Bit 12) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_LEVEL_LOW_Msk (0x1000UL) /*!< GPIO11_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_EDGE_HIGH_Pos (11UL)     /*!< GPIO10_EDGE_HIGH (Bit 11) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_EDGE_HIGH_Msk (0x800UL)  /*!< GPIO10_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_EDGE_LOW_Pos (10UL)      /*!< GPIO10_EDGE_LOW (Bit 10) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_EDGE_LOW_Msk (0x400UL)   /*!< GPIO10_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_LEVEL_HIGH_Pos (9UL)     /*!< GPIO10_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_LEVEL_HIGH_Msk (0x200UL) /*!< GPIO10_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_LEVEL_LOW_Pos (8UL)      /*!< GPIO10_LEVEL_LOW (Bit 8) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_LEVEL_LOW_Msk (0x100UL)  /*!< GPIO10_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_EDGE_HIGH_Pos (7UL)       /*!< GPIO9_EDGE_HIGH (Bit 7) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_EDGE_HIGH_Msk (0x80UL)    /*!< GPIO9_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_EDGE_LOW_Pos (6UL)        /*!< GPIO9_EDGE_LOW (Bit 6) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_EDGE_LOW_Msk (0x40UL)     /*!< GPIO9_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_LEVEL_HIGH_Pos (5UL)      /*!< GPIO9_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_LEVEL_HIGH_Msk (0x20UL)   /*!< GPIO9_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_LEVEL_LOW_Pos (4UL)       /*!< GPIO9_LEVEL_LOW (Bit 4) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_LEVEL_LOW_Msk (0x10UL)    /*!< GPIO9_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_EDGE_HIGH_Pos (3UL)       /*!< GPIO8_EDGE_HIGH (Bit 3) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_EDGE_HIGH_Msk (0x8UL)     /*!< GPIO8_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_EDGE_LOW_Pos (2UL)        /*!< GPIO8_EDGE_LOW (Bit 2) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_EDGE_LOW_Msk (0x4UL)      /*!< GPIO8_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_LEVEL_HIGH_Pos (1UL)      /*!< GPIO8_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_LEVEL_HIGH_Msk (0x2UL)    /*!< GPIO8_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_LEVEL_LOW_Pos (0UL)       /*!< GPIO8_LEVEL_LOW (Bit 0) */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_LEVEL_LOW_Msk (0x1UL)     /*!< GPIO8_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ==================================================  DORMANT_WAKE_INTE2  =================================================== */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_EDGE_HIGH_Pos (31UL)     /*!< GPIO23_EDGE_HIGH (Bit 31) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_EDGE_HIGH_Msk (0x80000000UL) /*!< GPIO23_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_EDGE_LOW_Pos (30UL)      /*!< GPIO23_EDGE_LOW (Bit 30) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_EDGE_LOW_Msk (0x40000000UL) /*!< GPIO23_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_LEVEL_HIGH_Pos (29UL)    /*!< GPIO23_LEVEL_HIGH (Bit 29) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_LEVEL_HIGH_Msk (0x20000000UL) /*!< GPIO23_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_LEVEL_LOW_Pos (28UL)     /*!< GPIO23_LEVEL_LOW (Bit 28) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_LEVEL_LOW_Msk (0x10000000UL) /*!< GPIO23_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_EDGE_HIGH_Pos (27UL)     /*!< GPIO22_EDGE_HIGH (Bit 27) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_EDGE_HIGH_Msk (0x8000000UL) /*!< GPIO22_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_EDGE_LOW_Pos (26UL)      /*!< GPIO22_EDGE_LOW (Bit 26) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_EDGE_LOW_Msk (0x4000000UL) /*!< GPIO22_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_LEVEL_HIGH_Pos (25UL)    /*!< GPIO22_LEVEL_HIGH (Bit 25) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_LEVEL_HIGH_Msk (0x2000000UL) /*!< GPIO22_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_LEVEL_LOW_Pos (24UL)     /*!< GPIO22_LEVEL_LOW (Bit 24) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_LEVEL_LOW_Msk (0x1000000UL) /*!< GPIO22_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_EDGE_HIGH_Pos (23UL)     /*!< GPIO21_EDGE_HIGH (Bit 23) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO21_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_EDGE_LOW_Pos (22UL)      /*!< GPIO21_EDGE_LOW (Bit 22) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_EDGE_LOW_Msk (0x400000UL) /*!< GPIO21_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_LEVEL_HIGH_Pos (21UL)    /*!< GPIO21_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO21_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_LEVEL_LOW_Pos (20UL)     /*!< GPIO21_LEVEL_LOW (Bit 20) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO21_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_EDGE_HIGH_Pos (19UL)     /*!< GPIO20_EDGE_HIGH (Bit 19) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_EDGE_HIGH_Msk (0x80000UL) /*!< GPIO20_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_EDGE_LOW_Pos (18UL)      /*!< GPIO20_EDGE_LOW (Bit 18) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_EDGE_LOW_Msk (0x40000UL) /*!< GPIO20_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_LEVEL_HIGH_Pos (17UL)    /*!< GPIO20_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO20_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_LEVEL_LOW_Pos (16UL)     /*!< GPIO20_LEVEL_LOW (Bit 16) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_LEVEL_LOW_Msk (0x10000UL) /*!< GPIO20_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_EDGE_HIGH_Pos (15UL)     /*!< GPIO19_EDGE_HIGH (Bit 15) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_EDGE_HIGH_Msk (0x8000UL) /*!< GPIO19_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_EDGE_LOW_Pos (14UL)      /*!< GPIO19_EDGE_LOW (Bit 14) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_EDGE_LOW_Msk (0x4000UL)  /*!< GPIO19_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_LEVEL_HIGH_Pos (13UL)    /*!< GPIO19_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_LEVEL_HIGH_Msk (0x2000UL) /*!< GPIO19_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_LEVEL_LOW_Pos (12UL)     /*!< GPIO19_LEVEL_LOW (Bit 12) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_LEVEL_LOW_Msk (0x1000UL) /*!< GPIO19_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_EDGE_HIGH_Pos (11UL)     /*!< GPIO18_EDGE_HIGH (Bit 11) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_EDGE_HIGH_Msk (0x800UL)  /*!< GPIO18_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_EDGE_LOW_Pos (10UL)      /*!< GPIO18_EDGE_LOW (Bit 10) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_EDGE_LOW_Msk (0x400UL)   /*!< GPIO18_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_LEVEL_HIGH_Pos (9UL)     /*!< GPIO18_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_LEVEL_HIGH_Msk (0x200UL) /*!< GPIO18_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_LEVEL_LOW_Pos (8UL)      /*!< GPIO18_LEVEL_LOW (Bit 8) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_LEVEL_LOW_Msk (0x100UL)  /*!< GPIO18_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_EDGE_HIGH_Pos (7UL)      /*!< GPIO17_EDGE_HIGH (Bit 7) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_EDGE_HIGH_Msk (0x80UL)   /*!< GPIO17_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_EDGE_LOW_Pos (6UL)       /*!< GPIO17_EDGE_LOW (Bit 6) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_EDGE_LOW_Msk (0x40UL)    /*!< GPIO17_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_LEVEL_HIGH_Pos (5UL)     /*!< GPIO17_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_LEVEL_HIGH_Msk (0x20UL)  /*!< GPIO17_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_LEVEL_LOW_Pos (4UL)      /*!< GPIO17_LEVEL_LOW (Bit 4) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_LEVEL_LOW_Msk (0x10UL)   /*!< GPIO17_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_EDGE_HIGH_Pos (3UL)      /*!< GPIO16_EDGE_HIGH (Bit 3) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_EDGE_HIGH_Msk (0x8UL)    /*!< GPIO16_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_EDGE_LOW_Pos (2UL)       /*!< GPIO16_EDGE_LOW (Bit 2) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_EDGE_LOW_Msk (0x4UL)     /*!< GPIO16_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_LEVEL_HIGH_Pos (1UL)     /*!< GPIO16_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_LEVEL_HIGH_Msk (0x2UL)   /*!< GPIO16_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_LEVEL_LOW_Pos (0UL)      /*!< GPIO16_LEVEL_LOW (Bit 0) */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_LEVEL_LOW_Msk (0x1UL)    /*!< GPIO16_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ==================================================  DORMANT_WAKE_INTE3  =================================================== */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_EDGE_HIGH_Pos (23UL)     /*!< GPIO29_EDGE_HIGH (Bit 23) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO29_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_EDGE_LOW_Pos (22UL)      /*!< GPIO29_EDGE_LOW (Bit 22) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_EDGE_LOW_Msk (0x400000UL) /*!< GPIO29_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_LEVEL_HIGH_Pos (21UL)    /*!< GPIO29_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO29_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_LEVEL_LOW_Pos (20UL)     /*!< GPIO29_LEVEL_LOW (Bit 20) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO29_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_EDGE_HIGH_Pos (19UL)     /*!< GPIO28_EDGE_HIGH (Bit 19) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_EDGE_HIGH_Msk (0x80000UL) /*!< GPIO28_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_EDGE_LOW_Pos (18UL)      /*!< GPIO28_EDGE_LOW (Bit 18) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_EDGE_LOW_Msk (0x40000UL) /*!< GPIO28_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_LEVEL_HIGH_Pos (17UL)    /*!< GPIO28_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO28_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_LEVEL_LOW_Pos (16UL)     /*!< GPIO28_LEVEL_LOW (Bit 16) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_LEVEL_LOW_Msk (0x10000UL) /*!< GPIO28_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_EDGE_HIGH_Pos (15UL)     /*!< GPIO27_EDGE_HIGH (Bit 15) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_EDGE_HIGH_Msk (0x8000UL) /*!< GPIO27_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_EDGE_LOW_Pos (14UL)      /*!< GPIO27_EDGE_LOW (Bit 14) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_EDGE_LOW_Msk (0x4000UL)  /*!< GPIO27_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_LEVEL_HIGH_Pos (13UL)    /*!< GPIO27_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_LEVEL_HIGH_Msk (0x2000UL) /*!< GPIO27_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_LEVEL_LOW_Pos (12UL)     /*!< GPIO27_LEVEL_LOW (Bit 12) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_LEVEL_LOW_Msk (0x1000UL) /*!< GPIO27_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_EDGE_HIGH_Pos (11UL)     /*!< GPIO26_EDGE_HIGH (Bit 11) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_EDGE_HIGH_Msk (0x800UL)  /*!< GPIO26_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_EDGE_LOW_Pos (10UL)      /*!< GPIO26_EDGE_LOW (Bit 10) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_EDGE_LOW_Msk (0x400UL)   /*!< GPIO26_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_LEVEL_HIGH_Pos (9UL)     /*!< GPIO26_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_LEVEL_HIGH_Msk (0x200UL) /*!< GPIO26_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_LEVEL_LOW_Pos (8UL)      /*!< GPIO26_LEVEL_LOW (Bit 8) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_LEVEL_LOW_Msk (0x100UL)  /*!< GPIO26_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_EDGE_HIGH_Pos (7UL)      /*!< GPIO25_EDGE_HIGH (Bit 7) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_EDGE_HIGH_Msk (0x80UL)   /*!< GPIO25_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_EDGE_LOW_Pos (6UL)       /*!< GPIO25_EDGE_LOW (Bit 6) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_EDGE_LOW_Msk (0x40UL)    /*!< GPIO25_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_LEVEL_HIGH_Pos (5UL)     /*!< GPIO25_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_LEVEL_HIGH_Msk (0x20UL)  /*!< GPIO25_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_LEVEL_LOW_Pos (4UL)      /*!< GPIO25_LEVEL_LOW (Bit 4) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_LEVEL_LOW_Msk (0x10UL)   /*!< GPIO25_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_EDGE_HIGH_Pos (3UL)      /*!< GPIO24_EDGE_HIGH (Bit 3) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_EDGE_HIGH_Msk (0x8UL)    /*!< GPIO24_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_EDGE_LOW_Pos (2UL)       /*!< GPIO24_EDGE_LOW (Bit 2) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_EDGE_LOW_Msk (0x4UL)     /*!< GPIO24_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_LEVEL_HIGH_Pos (1UL)     /*!< GPIO24_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_LEVEL_HIGH_Msk (0x2UL)   /*!< GPIO24_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_LEVEL_LOW_Pos (0UL)      /*!< GPIO24_LEVEL_LOW (Bit 0) */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_LEVEL_LOW_Msk (0x1UL)    /*!< GPIO24_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ==================================================  DORMANT_WAKE_INTF0  =================================================== */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_EDGE_HIGH_Pos (31UL)      /*!< GPIO7_EDGE_HIGH (Bit 31) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_EDGE_HIGH_Msk (0x80000000UL) /*!< GPIO7_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_EDGE_LOW_Pos (30UL)       /*!< GPIO7_EDGE_LOW (Bit 30) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_EDGE_LOW_Msk (0x40000000UL) /*!< GPIO7_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_LEVEL_HIGH_Pos (29UL)     /*!< GPIO7_LEVEL_HIGH (Bit 29) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_LEVEL_HIGH_Msk (0x20000000UL) /*!< GPIO7_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_LEVEL_LOW_Pos (28UL)      /*!< GPIO7_LEVEL_LOW (Bit 28) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_LEVEL_LOW_Msk (0x10000000UL) /*!< GPIO7_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_EDGE_HIGH_Pos (27UL)      /*!< GPIO6_EDGE_HIGH (Bit 27) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_EDGE_HIGH_Msk (0x8000000UL) /*!< GPIO6_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_EDGE_LOW_Pos (26UL)       /*!< GPIO6_EDGE_LOW (Bit 26) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_EDGE_LOW_Msk (0x4000000UL) /*!< GPIO6_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_LEVEL_HIGH_Pos (25UL)     /*!< GPIO6_LEVEL_HIGH (Bit 25) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_LEVEL_HIGH_Msk (0x2000000UL) /*!< GPIO6_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_LEVEL_LOW_Pos (24UL)      /*!< GPIO6_LEVEL_LOW (Bit 24) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_LEVEL_LOW_Msk (0x1000000UL) /*!< GPIO6_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_EDGE_HIGH_Pos (23UL)      /*!< GPIO5_EDGE_HIGH (Bit 23) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO5_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_EDGE_LOW_Pos (22UL)       /*!< GPIO5_EDGE_LOW (Bit 22) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_EDGE_LOW_Msk (0x400000UL) /*!< GPIO5_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_LEVEL_HIGH_Pos (21UL)     /*!< GPIO5_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO5_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_LEVEL_LOW_Pos (20UL)      /*!< GPIO5_LEVEL_LOW (Bit 20) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO5_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_EDGE_HIGH_Pos (19UL)      /*!< GPIO4_EDGE_HIGH (Bit 19) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_EDGE_HIGH_Msk (0x80000UL) /*!< GPIO4_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_EDGE_LOW_Pos (18UL)       /*!< GPIO4_EDGE_LOW (Bit 18) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_EDGE_LOW_Msk (0x40000UL)  /*!< GPIO4_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_LEVEL_HIGH_Pos (17UL)     /*!< GPIO4_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO4_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_LEVEL_LOW_Pos (16UL)      /*!< GPIO4_LEVEL_LOW (Bit 16) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_LEVEL_LOW_Msk (0x10000UL) /*!< GPIO4_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_EDGE_HIGH_Pos (15UL)      /*!< GPIO3_EDGE_HIGH (Bit 15) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_EDGE_HIGH_Msk (0x8000UL)  /*!< GPIO3_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_EDGE_LOW_Pos (14UL)       /*!< GPIO3_EDGE_LOW (Bit 14) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_EDGE_LOW_Msk (0x4000UL)   /*!< GPIO3_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_LEVEL_HIGH_Pos (13UL)     /*!< GPIO3_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_LEVEL_HIGH_Msk (0x2000UL) /*!< GPIO3_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_LEVEL_LOW_Pos (12UL)      /*!< GPIO3_LEVEL_LOW (Bit 12) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_LEVEL_LOW_Msk (0x1000UL)  /*!< GPIO3_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_EDGE_HIGH_Pos (11UL)      /*!< GPIO2_EDGE_HIGH (Bit 11) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_EDGE_HIGH_Msk (0x800UL)   /*!< GPIO2_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_EDGE_LOW_Pos (10UL)       /*!< GPIO2_EDGE_LOW (Bit 10) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_EDGE_LOW_Msk (0x400UL)    /*!< GPIO2_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_LEVEL_HIGH_Pos (9UL)      /*!< GPIO2_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_LEVEL_HIGH_Msk (0x200UL)  /*!< GPIO2_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_LEVEL_LOW_Pos (8UL)       /*!< GPIO2_LEVEL_LOW (Bit 8) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_LEVEL_LOW_Msk (0x100UL)   /*!< GPIO2_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_EDGE_HIGH_Pos (7UL)       /*!< GPIO1_EDGE_HIGH (Bit 7) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_EDGE_HIGH_Msk (0x80UL)    /*!< GPIO1_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_EDGE_LOW_Pos (6UL)        /*!< GPIO1_EDGE_LOW (Bit 6) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_EDGE_LOW_Msk (0x40UL)     /*!< GPIO1_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_LEVEL_HIGH_Pos (5UL)      /*!< GPIO1_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_LEVEL_HIGH_Msk (0x20UL)   /*!< GPIO1_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_LEVEL_LOW_Pos (4UL)       /*!< GPIO1_LEVEL_LOW (Bit 4) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_LEVEL_LOW_Msk (0x10UL)    /*!< GPIO1_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_EDGE_HIGH_Pos (3UL)       /*!< GPIO0_EDGE_HIGH (Bit 3) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_EDGE_HIGH_Msk (0x8UL)     /*!< GPIO0_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_EDGE_LOW_Pos (2UL)        /*!< GPIO0_EDGE_LOW (Bit 2) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_EDGE_LOW_Msk (0x4UL)      /*!< GPIO0_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_LEVEL_HIGH_Pos (1UL)      /*!< GPIO0_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_LEVEL_HIGH_Msk (0x2UL)    /*!< GPIO0_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_LEVEL_LOW_Pos (0UL)       /*!< GPIO0_LEVEL_LOW (Bit 0) */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_LEVEL_LOW_Msk (0x1UL)     /*!< GPIO0_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ==================================================  DORMANT_WAKE_INTF1  =================================================== */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_EDGE_HIGH_Pos (31UL)     /*!< GPIO15_EDGE_HIGH (Bit 31) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_EDGE_HIGH_Msk (0x80000000UL) /*!< GPIO15_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_EDGE_LOW_Pos (30UL)      /*!< GPIO15_EDGE_LOW (Bit 30) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_EDGE_LOW_Msk (0x40000000UL) /*!< GPIO15_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_LEVEL_HIGH_Pos (29UL)    /*!< GPIO15_LEVEL_HIGH (Bit 29) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_LEVEL_HIGH_Msk (0x20000000UL) /*!< GPIO15_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_LEVEL_LOW_Pos (28UL)     /*!< GPIO15_LEVEL_LOW (Bit 28) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_LEVEL_LOW_Msk (0x10000000UL) /*!< GPIO15_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_EDGE_HIGH_Pos (27UL)     /*!< GPIO14_EDGE_HIGH (Bit 27) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_EDGE_HIGH_Msk (0x8000000UL) /*!< GPIO14_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_EDGE_LOW_Pos (26UL)      /*!< GPIO14_EDGE_LOW (Bit 26) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_EDGE_LOW_Msk (0x4000000UL) /*!< GPIO14_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_LEVEL_HIGH_Pos (25UL)    /*!< GPIO14_LEVEL_HIGH (Bit 25) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_LEVEL_HIGH_Msk (0x2000000UL) /*!< GPIO14_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_LEVEL_LOW_Pos (24UL)     /*!< GPIO14_LEVEL_LOW (Bit 24) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_LEVEL_LOW_Msk (0x1000000UL) /*!< GPIO14_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_EDGE_HIGH_Pos (23UL)     /*!< GPIO13_EDGE_HIGH (Bit 23) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO13_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_EDGE_LOW_Pos (22UL)      /*!< GPIO13_EDGE_LOW (Bit 22) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_EDGE_LOW_Msk (0x400000UL) /*!< GPIO13_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_LEVEL_HIGH_Pos (21UL)    /*!< GPIO13_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO13_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_LEVEL_LOW_Pos (20UL)     /*!< GPIO13_LEVEL_LOW (Bit 20) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO13_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_EDGE_HIGH_Pos (19UL)     /*!< GPIO12_EDGE_HIGH (Bit 19) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_EDGE_HIGH_Msk (0x80000UL) /*!< GPIO12_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_EDGE_LOW_Pos (18UL)      /*!< GPIO12_EDGE_LOW (Bit 18) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_EDGE_LOW_Msk (0x40000UL) /*!< GPIO12_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_LEVEL_HIGH_Pos (17UL)    /*!< GPIO12_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO12_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_LEVEL_LOW_Pos (16UL)     /*!< GPIO12_LEVEL_LOW (Bit 16) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_LEVEL_LOW_Msk (0x10000UL) /*!< GPIO12_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_EDGE_HIGH_Pos (15UL)     /*!< GPIO11_EDGE_HIGH (Bit 15) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_EDGE_HIGH_Msk (0x8000UL) /*!< GPIO11_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_EDGE_LOW_Pos (14UL)      /*!< GPIO11_EDGE_LOW (Bit 14) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_EDGE_LOW_Msk (0x4000UL)  /*!< GPIO11_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_LEVEL_HIGH_Pos (13UL)    /*!< GPIO11_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_LEVEL_HIGH_Msk (0x2000UL) /*!< GPIO11_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_LEVEL_LOW_Pos (12UL)     /*!< GPIO11_LEVEL_LOW (Bit 12) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_LEVEL_LOW_Msk (0x1000UL) /*!< GPIO11_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_EDGE_HIGH_Pos (11UL)     /*!< GPIO10_EDGE_HIGH (Bit 11) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_EDGE_HIGH_Msk (0x800UL)  /*!< GPIO10_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_EDGE_LOW_Pos (10UL)      /*!< GPIO10_EDGE_LOW (Bit 10) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_EDGE_LOW_Msk (0x400UL)   /*!< GPIO10_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_LEVEL_HIGH_Pos (9UL)     /*!< GPIO10_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_LEVEL_HIGH_Msk (0x200UL) /*!< GPIO10_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_LEVEL_LOW_Pos (8UL)      /*!< GPIO10_LEVEL_LOW (Bit 8) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_LEVEL_LOW_Msk (0x100UL)  /*!< GPIO10_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_EDGE_HIGH_Pos (7UL)       /*!< GPIO9_EDGE_HIGH (Bit 7) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_EDGE_HIGH_Msk (0x80UL)    /*!< GPIO9_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_EDGE_LOW_Pos (6UL)        /*!< GPIO9_EDGE_LOW (Bit 6) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_EDGE_LOW_Msk (0x40UL)     /*!< GPIO9_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_LEVEL_HIGH_Pos (5UL)      /*!< GPIO9_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_LEVEL_HIGH_Msk (0x20UL)   /*!< GPIO9_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_LEVEL_LOW_Pos (4UL)       /*!< GPIO9_LEVEL_LOW (Bit 4) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_LEVEL_LOW_Msk (0x10UL)    /*!< GPIO9_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_EDGE_HIGH_Pos (3UL)       /*!< GPIO8_EDGE_HIGH (Bit 3) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_EDGE_HIGH_Msk (0x8UL)     /*!< GPIO8_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_EDGE_LOW_Pos (2UL)        /*!< GPIO8_EDGE_LOW (Bit 2) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_EDGE_LOW_Msk (0x4UL)      /*!< GPIO8_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_LEVEL_HIGH_Pos (1UL)      /*!< GPIO8_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_LEVEL_HIGH_Msk (0x2UL)    /*!< GPIO8_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_LEVEL_LOW_Pos (0UL)       /*!< GPIO8_LEVEL_LOW (Bit 0) */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_LEVEL_LOW_Msk (0x1UL)     /*!< GPIO8_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ==================================================  DORMANT_WAKE_INTF2  =================================================== */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_EDGE_HIGH_Pos (31UL)     /*!< GPIO23_EDGE_HIGH (Bit 31) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_EDGE_HIGH_Msk (0x80000000UL) /*!< GPIO23_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_EDGE_LOW_Pos (30UL)      /*!< GPIO23_EDGE_LOW (Bit 30) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_EDGE_LOW_Msk (0x40000000UL) /*!< GPIO23_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_LEVEL_HIGH_Pos (29UL)    /*!< GPIO23_LEVEL_HIGH (Bit 29) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_LEVEL_HIGH_Msk (0x20000000UL) /*!< GPIO23_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_LEVEL_LOW_Pos (28UL)     /*!< GPIO23_LEVEL_LOW (Bit 28) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_LEVEL_LOW_Msk (0x10000000UL) /*!< GPIO23_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_EDGE_HIGH_Pos (27UL)     /*!< GPIO22_EDGE_HIGH (Bit 27) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_EDGE_HIGH_Msk (0x8000000UL) /*!< GPIO22_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_EDGE_LOW_Pos (26UL)      /*!< GPIO22_EDGE_LOW (Bit 26) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_EDGE_LOW_Msk (0x4000000UL) /*!< GPIO22_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_LEVEL_HIGH_Pos (25UL)    /*!< GPIO22_LEVEL_HIGH (Bit 25) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_LEVEL_HIGH_Msk (0x2000000UL) /*!< GPIO22_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_LEVEL_LOW_Pos (24UL)     /*!< GPIO22_LEVEL_LOW (Bit 24) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_LEVEL_LOW_Msk (0x1000000UL) /*!< GPIO22_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_EDGE_HIGH_Pos (23UL)     /*!< GPIO21_EDGE_HIGH (Bit 23) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO21_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_EDGE_LOW_Pos (22UL)      /*!< GPIO21_EDGE_LOW (Bit 22) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_EDGE_LOW_Msk (0x400000UL) /*!< GPIO21_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_LEVEL_HIGH_Pos (21UL)    /*!< GPIO21_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO21_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_LEVEL_LOW_Pos (20UL)     /*!< GPIO21_LEVEL_LOW (Bit 20) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO21_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_EDGE_HIGH_Pos (19UL)     /*!< GPIO20_EDGE_HIGH (Bit 19) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_EDGE_HIGH_Msk (0x80000UL) /*!< GPIO20_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_EDGE_LOW_Pos (18UL)      /*!< GPIO20_EDGE_LOW (Bit 18) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_EDGE_LOW_Msk (0x40000UL) /*!< GPIO20_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_LEVEL_HIGH_Pos (17UL)    /*!< GPIO20_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO20_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_LEVEL_LOW_Pos (16UL)     /*!< GPIO20_LEVEL_LOW (Bit 16) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_LEVEL_LOW_Msk (0x10000UL) /*!< GPIO20_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_EDGE_HIGH_Pos (15UL)     /*!< GPIO19_EDGE_HIGH (Bit 15) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_EDGE_HIGH_Msk (0x8000UL) /*!< GPIO19_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_EDGE_LOW_Pos (14UL)      /*!< GPIO19_EDGE_LOW (Bit 14) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_EDGE_LOW_Msk (0x4000UL)  /*!< GPIO19_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_LEVEL_HIGH_Pos (13UL)    /*!< GPIO19_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_LEVEL_HIGH_Msk (0x2000UL) /*!< GPIO19_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_LEVEL_LOW_Pos (12UL)     /*!< GPIO19_LEVEL_LOW (Bit 12) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_LEVEL_LOW_Msk (0x1000UL) /*!< GPIO19_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_EDGE_HIGH_Pos (11UL)     /*!< GPIO18_EDGE_HIGH (Bit 11) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_EDGE_HIGH_Msk (0x800UL)  /*!< GPIO18_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_EDGE_LOW_Pos (10UL)      /*!< GPIO18_EDGE_LOW (Bit 10) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_EDGE_LOW_Msk (0x400UL)   /*!< GPIO18_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_LEVEL_HIGH_Pos (9UL)     /*!< GPIO18_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_LEVEL_HIGH_Msk (0x200UL) /*!< GPIO18_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_LEVEL_LOW_Pos (8UL)      /*!< GPIO18_LEVEL_LOW (Bit 8) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_LEVEL_LOW_Msk (0x100UL)  /*!< GPIO18_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_EDGE_HIGH_Pos (7UL)      /*!< GPIO17_EDGE_HIGH (Bit 7) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_EDGE_HIGH_Msk (0x80UL)   /*!< GPIO17_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_EDGE_LOW_Pos (6UL)       /*!< GPIO17_EDGE_LOW (Bit 6) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_EDGE_LOW_Msk (0x40UL)    /*!< GPIO17_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_LEVEL_HIGH_Pos (5UL)     /*!< GPIO17_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_LEVEL_HIGH_Msk (0x20UL)  /*!< GPIO17_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_LEVEL_LOW_Pos (4UL)      /*!< GPIO17_LEVEL_LOW (Bit 4) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_LEVEL_LOW_Msk (0x10UL)   /*!< GPIO17_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_EDGE_HIGH_Pos (3UL)      /*!< GPIO16_EDGE_HIGH (Bit 3) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_EDGE_HIGH_Msk (0x8UL)    /*!< GPIO16_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_EDGE_LOW_Pos (2UL)       /*!< GPIO16_EDGE_LOW (Bit 2) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_EDGE_LOW_Msk (0x4UL)     /*!< GPIO16_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_LEVEL_HIGH_Pos (1UL)     /*!< GPIO16_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_LEVEL_HIGH_Msk (0x2UL)   /*!< GPIO16_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_LEVEL_LOW_Pos (0UL)      /*!< GPIO16_LEVEL_LOW (Bit 0) */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_LEVEL_LOW_Msk (0x1UL)    /*!< GPIO16_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ==================================================  DORMANT_WAKE_INTF3  =================================================== */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_EDGE_HIGH_Pos (23UL)     /*!< GPIO29_EDGE_HIGH (Bit 23) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO29_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_EDGE_LOW_Pos (22UL)      /*!< GPIO29_EDGE_LOW (Bit 22) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_EDGE_LOW_Msk (0x400000UL) /*!< GPIO29_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_LEVEL_HIGH_Pos (21UL)    /*!< GPIO29_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO29_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_LEVEL_LOW_Pos (20UL)     /*!< GPIO29_LEVEL_LOW (Bit 20) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO29_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_EDGE_HIGH_Pos (19UL)     /*!< GPIO28_EDGE_HIGH (Bit 19) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_EDGE_HIGH_Msk (0x80000UL) /*!< GPIO28_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_EDGE_LOW_Pos (18UL)      /*!< GPIO28_EDGE_LOW (Bit 18) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_EDGE_LOW_Msk (0x40000UL) /*!< GPIO28_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_LEVEL_HIGH_Pos (17UL)    /*!< GPIO28_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO28_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_LEVEL_LOW_Pos (16UL)     /*!< GPIO28_LEVEL_LOW (Bit 16) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_LEVEL_LOW_Msk (0x10000UL) /*!< GPIO28_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_EDGE_HIGH_Pos (15UL)     /*!< GPIO27_EDGE_HIGH (Bit 15) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_EDGE_HIGH_Msk (0x8000UL) /*!< GPIO27_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_EDGE_LOW_Pos (14UL)      /*!< GPIO27_EDGE_LOW (Bit 14) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_EDGE_LOW_Msk (0x4000UL)  /*!< GPIO27_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_LEVEL_HIGH_Pos (13UL)    /*!< GPIO27_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_LEVEL_HIGH_Msk (0x2000UL) /*!< GPIO27_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_LEVEL_LOW_Pos (12UL)     /*!< GPIO27_LEVEL_LOW (Bit 12) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_LEVEL_LOW_Msk (0x1000UL) /*!< GPIO27_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_EDGE_HIGH_Pos (11UL)     /*!< GPIO26_EDGE_HIGH (Bit 11) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_EDGE_HIGH_Msk (0x800UL)  /*!< GPIO26_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_EDGE_LOW_Pos (10UL)      /*!< GPIO26_EDGE_LOW (Bit 10) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_EDGE_LOW_Msk (0x400UL)   /*!< GPIO26_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_LEVEL_HIGH_Pos (9UL)     /*!< GPIO26_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_LEVEL_HIGH_Msk (0x200UL) /*!< GPIO26_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_LEVEL_LOW_Pos (8UL)      /*!< GPIO26_LEVEL_LOW (Bit 8) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_LEVEL_LOW_Msk (0x100UL)  /*!< GPIO26_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_EDGE_HIGH_Pos (7UL)      /*!< GPIO25_EDGE_HIGH (Bit 7) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_EDGE_HIGH_Msk (0x80UL)   /*!< GPIO25_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_EDGE_LOW_Pos (6UL)       /*!< GPIO25_EDGE_LOW (Bit 6) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_EDGE_LOW_Msk (0x40UL)    /*!< GPIO25_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_LEVEL_HIGH_Pos (5UL)     /*!< GPIO25_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_LEVEL_HIGH_Msk (0x20UL)  /*!< GPIO25_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_LEVEL_LOW_Pos (4UL)      /*!< GPIO25_LEVEL_LOW (Bit 4) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_LEVEL_LOW_Msk (0x10UL)   /*!< GPIO25_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_EDGE_HIGH_Pos (3UL)      /*!< GPIO24_EDGE_HIGH (Bit 3) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_EDGE_HIGH_Msk (0x8UL)    /*!< GPIO24_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_EDGE_LOW_Pos (2UL)       /*!< GPIO24_EDGE_LOW (Bit 2) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_EDGE_LOW_Msk (0x4UL)     /*!< GPIO24_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_LEVEL_HIGH_Pos (1UL)     /*!< GPIO24_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_LEVEL_HIGH_Msk (0x2UL)   /*!< GPIO24_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_LEVEL_LOW_Pos (0UL)      /*!< GPIO24_LEVEL_LOW (Bit 0) */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_LEVEL_LOW_Msk (0x1UL)    /*!< GPIO24_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ==================================================  DORMANT_WAKE_INTS0  =================================================== */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_EDGE_HIGH_Pos (31UL)      /*!< GPIO7_EDGE_HIGH (Bit 31) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_EDGE_HIGH_Msk (0x80000000UL) /*!< GPIO7_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_EDGE_LOW_Pos (30UL)       /*!< GPIO7_EDGE_LOW (Bit 30) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_EDGE_LOW_Msk (0x40000000UL) /*!< GPIO7_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_LEVEL_HIGH_Pos (29UL)     /*!< GPIO7_LEVEL_HIGH (Bit 29) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_LEVEL_HIGH_Msk (0x20000000UL) /*!< GPIO7_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_LEVEL_LOW_Pos (28UL)      /*!< GPIO7_LEVEL_LOW (Bit 28) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_LEVEL_LOW_Msk (0x10000000UL) /*!< GPIO7_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_EDGE_HIGH_Pos (27UL)      /*!< GPIO6_EDGE_HIGH (Bit 27) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_EDGE_HIGH_Msk (0x8000000UL) /*!< GPIO6_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_EDGE_LOW_Pos (26UL)       /*!< GPIO6_EDGE_LOW (Bit 26) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_EDGE_LOW_Msk (0x4000000UL) /*!< GPIO6_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_LEVEL_HIGH_Pos (25UL)     /*!< GPIO6_LEVEL_HIGH (Bit 25) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_LEVEL_HIGH_Msk (0x2000000UL) /*!< GPIO6_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_LEVEL_LOW_Pos (24UL)      /*!< GPIO6_LEVEL_LOW (Bit 24) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_LEVEL_LOW_Msk (0x1000000UL) /*!< GPIO6_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_EDGE_HIGH_Pos (23UL)      /*!< GPIO5_EDGE_HIGH (Bit 23) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO5_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_EDGE_LOW_Pos (22UL)       /*!< GPIO5_EDGE_LOW (Bit 22) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_EDGE_LOW_Msk (0x400000UL) /*!< GPIO5_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_LEVEL_HIGH_Pos (21UL)     /*!< GPIO5_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO5_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_LEVEL_LOW_Pos (20UL)      /*!< GPIO5_LEVEL_LOW (Bit 20) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO5_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_EDGE_HIGH_Pos (19UL)      /*!< GPIO4_EDGE_HIGH (Bit 19) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_EDGE_HIGH_Msk (0x80000UL) /*!< GPIO4_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_EDGE_LOW_Pos (18UL)       /*!< GPIO4_EDGE_LOW (Bit 18) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_EDGE_LOW_Msk (0x40000UL)  /*!< GPIO4_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_LEVEL_HIGH_Pos (17UL)     /*!< GPIO4_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO4_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_LEVEL_LOW_Pos (16UL)      /*!< GPIO4_LEVEL_LOW (Bit 16) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_LEVEL_LOW_Msk (0x10000UL) /*!< GPIO4_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_EDGE_HIGH_Pos (15UL)      /*!< GPIO3_EDGE_HIGH (Bit 15) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_EDGE_HIGH_Msk (0x8000UL)  /*!< GPIO3_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_EDGE_LOW_Pos (14UL)       /*!< GPIO3_EDGE_LOW (Bit 14) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_EDGE_LOW_Msk (0x4000UL)   /*!< GPIO3_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_LEVEL_HIGH_Pos (13UL)     /*!< GPIO3_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_LEVEL_HIGH_Msk (0x2000UL) /*!< GPIO3_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_LEVEL_LOW_Pos (12UL)      /*!< GPIO3_LEVEL_LOW (Bit 12) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_LEVEL_LOW_Msk (0x1000UL)  /*!< GPIO3_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_EDGE_HIGH_Pos (11UL)      /*!< GPIO2_EDGE_HIGH (Bit 11) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_EDGE_HIGH_Msk (0x800UL)   /*!< GPIO2_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_EDGE_LOW_Pos (10UL)       /*!< GPIO2_EDGE_LOW (Bit 10) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_EDGE_LOW_Msk (0x400UL)    /*!< GPIO2_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_LEVEL_HIGH_Pos (9UL)      /*!< GPIO2_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_LEVEL_HIGH_Msk (0x200UL)  /*!< GPIO2_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_LEVEL_LOW_Pos (8UL)       /*!< GPIO2_LEVEL_LOW (Bit 8) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_LEVEL_LOW_Msk (0x100UL)   /*!< GPIO2_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_EDGE_HIGH_Pos (7UL)       /*!< GPIO1_EDGE_HIGH (Bit 7) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_EDGE_HIGH_Msk (0x80UL)    /*!< GPIO1_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_EDGE_LOW_Pos (6UL)        /*!< GPIO1_EDGE_LOW (Bit 6) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_EDGE_LOW_Msk (0x40UL)     /*!< GPIO1_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_LEVEL_HIGH_Pos (5UL)      /*!< GPIO1_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_LEVEL_HIGH_Msk (0x20UL)   /*!< GPIO1_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_LEVEL_LOW_Pos (4UL)       /*!< GPIO1_LEVEL_LOW (Bit 4) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_LEVEL_LOW_Msk (0x10UL)    /*!< GPIO1_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_EDGE_HIGH_Pos (3UL)       /*!< GPIO0_EDGE_HIGH (Bit 3) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_EDGE_HIGH_Msk (0x8UL)     /*!< GPIO0_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_EDGE_LOW_Pos (2UL)        /*!< GPIO0_EDGE_LOW (Bit 2) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_EDGE_LOW_Msk (0x4UL)      /*!< GPIO0_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_LEVEL_HIGH_Pos (1UL)      /*!< GPIO0_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_LEVEL_HIGH_Msk (0x2UL)    /*!< GPIO0_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_LEVEL_LOW_Pos (0UL)       /*!< GPIO0_LEVEL_LOW (Bit 0) */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_LEVEL_LOW_Msk (0x1UL)     /*!< GPIO0_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ==================================================  DORMANT_WAKE_INTS1  =================================================== */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_EDGE_HIGH_Pos (31UL)     /*!< GPIO15_EDGE_HIGH (Bit 31) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_EDGE_HIGH_Msk (0x80000000UL) /*!< GPIO15_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_EDGE_LOW_Pos (30UL)      /*!< GPIO15_EDGE_LOW (Bit 30) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_EDGE_LOW_Msk (0x40000000UL) /*!< GPIO15_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_LEVEL_HIGH_Pos (29UL)    /*!< GPIO15_LEVEL_HIGH (Bit 29) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_LEVEL_HIGH_Msk (0x20000000UL) /*!< GPIO15_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_LEVEL_LOW_Pos (28UL)     /*!< GPIO15_LEVEL_LOW (Bit 28) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_LEVEL_LOW_Msk (0x10000000UL) /*!< GPIO15_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_EDGE_HIGH_Pos (27UL)     /*!< GPIO14_EDGE_HIGH (Bit 27) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_EDGE_HIGH_Msk (0x8000000UL) /*!< GPIO14_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_EDGE_LOW_Pos (26UL)      /*!< GPIO14_EDGE_LOW (Bit 26) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_EDGE_LOW_Msk (0x4000000UL) /*!< GPIO14_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_LEVEL_HIGH_Pos (25UL)    /*!< GPIO14_LEVEL_HIGH (Bit 25) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_LEVEL_HIGH_Msk (0x2000000UL) /*!< GPIO14_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_LEVEL_LOW_Pos (24UL)     /*!< GPIO14_LEVEL_LOW (Bit 24) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_LEVEL_LOW_Msk (0x1000000UL) /*!< GPIO14_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_EDGE_HIGH_Pos (23UL)     /*!< GPIO13_EDGE_HIGH (Bit 23) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO13_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_EDGE_LOW_Pos (22UL)      /*!< GPIO13_EDGE_LOW (Bit 22) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_EDGE_LOW_Msk (0x400000UL) /*!< GPIO13_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_LEVEL_HIGH_Pos (21UL)    /*!< GPIO13_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO13_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_LEVEL_LOW_Pos (20UL)     /*!< GPIO13_LEVEL_LOW (Bit 20) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO13_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_EDGE_HIGH_Pos (19UL)     /*!< GPIO12_EDGE_HIGH (Bit 19) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_EDGE_HIGH_Msk (0x80000UL) /*!< GPIO12_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_EDGE_LOW_Pos (18UL)      /*!< GPIO12_EDGE_LOW (Bit 18) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_EDGE_LOW_Msk (0x40000UL) /*!< GPIO12_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_LEVEL_HIGH_Pos (17UL)    /*!< GPIO12_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO12_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_LEVEL_LOW_Pos (16UL)     /*!< GPIO12_LEVEL_LOW (Bit 16) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_LEVEL_LOW_Msk (0x10000UL) /*!< GPIO12_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_EDGE_HIGH_Pos (15UL)     /*!< GPIO11_EDGE_HIGH (Bit 15) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_EDGE_HIGH_Msk (0x8000UL) /*!< GPIO11_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_EDGE_LOW_Pos (14UL)      /*!< GPIO11_EDGE_LOW (Bit 14) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_EDGE_LOW_Msk (0x4000UL)  /*!< GPIO11_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_LEVEL_HIGH_Pos (13UL)    /*!< GPIO11_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_LEVEL_HIGH_Msk (0x2000UL) /*!< GPIO11_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_LEVEL_LOW_Pos (12UL)     /*!< GPIO11_LEVEL_LOW (Bit 12) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_LEVEL_LOW_Msk (0x1000UL) /*!< GPIO11_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_EDGE_HIGH_Pos (11UL)     /*!< GPIO10_EDGE_HIGH (Bit 11) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_EDGE_HIGH_Msk (0x800UL)  /*!< GPIO10_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_EDGE_LOW_Pos (10UL)      /*!< GPIO10_EDGE_LOW (Bit 10) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_EDGE_LOW_Msk (0x400UL)   /*!< GPIO10_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_LEVEL_HIGH_Pos (9UL)     /*!< GPIO10_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_LEVEL_HIGH_Msk (0x200UL) /*!< GPIO10_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_LEVEL_LOW_Pos (8UL)      /*!< GPIO10_LEVEL_LOW (Bit 8) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_LEVEL_LOW_Msk (0x100UL)  /*!< GPIO10_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_EDGE_HIGH_Pos (7UL)       /*!< GPIO9_EDGE_HIGH (Bit 7) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_EDGE_HIGH_Msk (0x80UL)    /*!< GPIO9_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_EDGE_LOW_Pos (6UL)        /*!< GPIO9_EDGE_LOW (Bit 6) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_EDGE_LOW_Msk (0x40UL)     /*!< GPIO9_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_LEVEL_HIGH_Pos (5UL)      /*!< GPIO9_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_LEVEL_HIGH_Msk (0x20UL)   /*!< GPIO9_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_LEVEL_LOW_Pos (4UL)       /*!< GPIO9_LEVEL_LOW (Bit 4) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_LEVEL_LOW_Msk (0x10UL)    /*!< GPIO9_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_EDGE_HIGH_Pos (3UL)       /*!< GPIO8_EDGE_HIGH (Bit 3) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_EDGE_HIGH_Msk (0x8UL)     /*!< GPIO8_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_EDGE_LOW_Pos (2UL)        /*!< GPIO8_EDGE_LOW (Bit 2) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_EDGE_LOW_Msk (0x4UL)      /*!< GPIO8_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_LEVEL_HIGH_Pos (1UL)      /*!< GPIO8_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_LEVEL_HIGH_Msk (0x2UL)    /*!< GPIO8_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_LEVEL_LOW_Pos (0UL)       /*!< GPIO8_LEVEL_LOW (Bit 0) */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_LEVEL_LOW_Msk (0x1UL)     /*!< GPIO8_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ==================================================  DORMANT_WAKE_INTS2  =================================================== */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_EDGE_HIGH_Pos (31UL)     /*!< GPIO23_EDGE_HIGH (Bit 31) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_EDGE_HIGH_Msk (0x80000000UL) /*!< GPIO23_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_EDGE_LOW_Pos (30UL)      /*!< GPIO23_EDGE_LOW (Bit 30) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_EDGE_LOW_Msk (0x40000000UL) /*!< GPIO23_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_LEVEL_HIGH_Pos (29UL)    /*!< GPIO23_LEVEL_HIGH (Bit 29) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_LEVEL_HIGH_Msk (0x20000000UL) /*!< GPIO23_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_LEVEL_LOW_Pos (28UL)     /*!< GPIO23_LEVEL_LOW (Bit 28) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_LEVEL_LOW_Msk (0x10000000UL) /*!< GPIO23_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_EDGE_HIGH_Pos (27UL)     /*!< GPIO22_EDGE_HIGH (Bit 27) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_EDGE_HIGH_Msk (0x8000000UL) /*!< GPIO22_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_EDGE_LOW_Pos (26UL)      /*!< GPIO22_EDGE_LOW (Bit 26) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_EDGE_LOW_Msk (0x4000000UL) /*!< GPIO22_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_LEVEL_HIGH_Pos (25UL)    /*!< GPIO22_LEVEL_HIGH (Bit 25) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_LEVEL_HIGH_Msk (0x2000000UL) /*!< GPIO22_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_LEVEL_LOW_Pos (24UL)     /*!< GPIO22_LEVEL_LOW (Bit 24) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_LEVEL_LOW_Msk (0x1000000UL) /*!< GPIO22_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_EDGE_HIGH_Pos (23UL)     /*!< GPIO21_EDGE_HIGH (Bit 23) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO21_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_EDGE_LOW_Pos (22UL)      /*!< GPIO21_EDGE_LOW (Bit 22) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_EDGE_LOW_Msk (0x400000UL) /*!< GPIO21_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_LEVEL_HIGH_Pos (21UL)    /*!< GPIO21_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO21_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_LEVEL_LOW_Pos (20UL)     /*!< GPIO21_LEVEL_LOW (Bit 20) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO21_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_EDGE_HIGH_Pos (19UL)     /*!< GPIO20_EDGE_HIGH (Bit 19) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_EDGE_HIGH_Msk (0x80000UL) /*!< GPIO20_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_EDGE_LOW_Pos (18UL)      /*!< GPIO20_EDGE_LOW (Bit 18) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_EDGE_LOW_Msk (0x40000UL) /*!< GPIO20_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_LEVEL_HIGH_Pos (17UL)    /*!< GPIO20_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO20_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_LEVEL_LOW_Pos (16UL)     /*!< GPIO20_LEVEL_LOW (Bit 16) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_LEVEL_LOW_Msk (0x10000UL) /*!< GPIO20_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_EDGE_HIGH_Pos (15UL)     /*!< GPIO19_EDGE_HIGH (Bit 15) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_EDGE_HIGH_Msk (0x8000UL) /*!< GPIO19_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_EDGE_LOW_Pos (14UL)      /*!< GPIO19_EDGE_LOW (Bit 14) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_EDGE_LOW_Msk (0x4000UL)  /*!< GPIO19_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_LEVEL_HIGH_Pos (13UL)    /*!< GPIO19_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_LEVEL_HIGH_Msk (0x2000UL) /*!< GPIO19_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_LEVEL_LOW_Pos (12UL)     /*!< GPIO19_LEVEL_LOW (Bit 12) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_LEVEL_LOW_Msk (0x1000UL) /*!< GPIO19_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_EDGE_HIGH_Pos (11UL)     /*!< GPIO18_EDGE_HIGH (Bit 11) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_EDGE_HIGH_Msk (0x800UL)  /*!< GPIO18_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_EDGE_LOW_Pos (10UL)      /*!< GPIO18_EDGE_LOW (Bit 10) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_EDGE_LOW_Msk (0x400UL)   /*!< GPIO18_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_LEVEL_HIGH_Pos (9UL)     /*!< GPIO18_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_LEVEL_HIGH_Msk (0x200UL) /*!< GPIO18_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_LEVEL_LOW_Pos (8UL)      /*!< GPIO18_LEVEL_LOW (Bit 8) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_LEVEL_LOW_Msk (0x100UL)  /*!< GPIO18_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_EDGE_HIGH_Pos (7UL)      /*!< GPIO17_EDGE_HIGH (Bit 7) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_EDGE_HIGH_Msk (0x80UL)   /*!< GPIO17_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_EDGE_LOW_Pos (6UL)       /*!< GPIO17_EDGE_LOW (Bit 6) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_EDGE_LOW_Msk (0x40UL)    /*!< GPIO17_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_LEVEL_HIGH_Pos (5UL)     /*!< GPIO17_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_LEVEL_HIGH_Msk (0x20UL)  /*!< GPIO17_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_LEVEL_LOW_Pos (4UL)      /*!< GPIO17_LEVEL_LOW (Bit 4) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_LEVEL_LOW_Msk (0x10UL)   /*!< GPIO17_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_EDGE_HIGH_Pos (3UL)      /*!< GPIO16_EDGE_HIGH (Bit 3) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_EDGE_HIGH_Msk (0x8UL)    /*!< GPIO16_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_EDGE_LOW_Pos (2UL)       /*!< GPIO16_EDGE_LOW (Bit 2) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_EDGE_LOW_Msk (0x4UL)     /*!< GPIO16_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_LEVEL_HIGH_Pos (1UL)     /*!< GPIO16_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_LEVEL_HIGH_Msk (0x2UL)   /*!< GPIO16_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_LEVEL_LOW_Pos (0UL)      /*!< GPIO16_LEVEL_LOW (Bit 0) */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_LEVEL_LOW_Msk (0x1UL)    /*!< GPIO16_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ==================================================  DORMANT_WAKE_INTS3  =================================================== */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_EDGE_HIGH_Pos (23UL)     /*!< GPIO29_EDGE_HIGH (Bit 23) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO29_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_EDGE_LOW_Pos (22UL)      /*!< GPIO29_EDGE_LOW (Bit 22) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_EDGE_LOW_Msk (0x400000UL) /*!< GPIO29_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_LEVEL_HIGH_Pos (21UL)    /*!< GPIO29_LEVEL_HIGH (Bit 21) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO29_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_LEVEL_LOW_Pos (20UL)     /*!< GPIO29_LEVEL_LOW (Bit 20) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO29_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_EDGE_HIGH_Pos (19UL)     /*!< GPIO28_EDGE_HIGH (Bit 19) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_EDGE_HIGH_Msk (0x80000UL) /*!< GPIO28_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_EDGE_LOW_Pos (18UL)      /*!< GPIO28_EDGE_LOW (Bit 18) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_EDGE_LOW_Msk (0x40000UL) /*!< GPIO28_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_LEVEL_HIGH_Pos (17UL)    /*!< GPIO28_LEVEL_HIGH (Bit 17) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO28_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_LEVEL_LOW_Pos (16UL)     /*!< GPIO28_LEVEL_LOW (Bit 16) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_LEVEL_LOW_Msk (0x10000UL) /*!< GPIO28_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_EDGE_HIGH_Pos (15UL)     /*!< GPIO27_EDGE_HIGH (Bit 15) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_EDGE_HIGH_Msk (0x8000UL) /*!< GPIO27_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_EDGE_LOW_Pos (14UL)      /*!< GPIO27_EDGE_LOW (Bit 14) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_EDGE_LOW_Msk (0x4000UL)  /*!< GPIO27_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_LEVEL_HIGH_Pos (13UL)    /*!< GPIO27_LEVEL_HIGH (Bit 13) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_LEVEL_HIGH_Msk (0x2000UL) /*!< GPIO27_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_LEVEL_LOW_Pos (12UL)     /*!< GPIO27_LEVEL_LOW (Bit 12) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_LEVEL_LOW_Msk (0x1000UL) /*!< GPIO27_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_EDGE_HIGH_Pos (11UL)     /*!< GPIO26_EDGE_HIGH (Bit 11) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_EDGE_HIGH_Msk (0x800UL)  /*!< GPIO26_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_EDGE_LOW_Pos (10UL)      /*!< GPIO26_EDGE_LOW (Bit 10) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_EDGE_LOW_Msk (0x400UL)   /*!< GPIO26_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_LEVEL_HIGH_Pos (9UL)     /*!< GPIO26_LEVEL_HIGH (Bit 9) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_LEVEL_HIGH_Msk (0x200UL) /*!< GPIO26_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_LEVEL_LOW_Pos (8UL)      /*!< GPIO26_LEVEL_LOW (Bit 8) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_LEVEL_LOW_Msk (0x100UL)  /*!< GPIO26_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_EDGE_HIGH_Pos (7UL)      /*!< GPIO25_EDGE_HIGH (Bit 7) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_EDGE_HIGH_Msk (0x80UL)   /*!< GPIO25_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_EDGE_LOW_Pos (6UL)       /*!< GPIO25_EDGE_LOW (Bit 6) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_EDGE_LOW_Msk (0x40UL)    /*!< GPIO25_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_LEVEL_HIGH_Pos (5UL)     /*!< GPIO25_LEVEL_HIGH (Bit 5) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_LEVEL_HIGH_Msk (0x20UL)  /*!< GPIO25_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_LEVEL_LOW_Pos (4UL)      /*!< GPIO25_LEVEL_LOW (Bit 4) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_LEVEL_LOW_Msk (0x10UL)   /*!< GPIO25_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_EDGE_HIGH_Pos (3UL)      /*!< GPIO24_EDGE_HIGH (Bit 3) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_EDGE_HIGH_Msk (0x8UL)    /*!< GPIO24_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_EDGE_LOW_Pos (2UL)       /*!< GPIO24_EDGE_LOW (Bit 2) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_EDGE_LOW_Msk (0x4UL)     /*!< GPIO24_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_LEVEL_HIGH_Pos (1UL)     /*!< GPIO24_LEVEL_HIGH (Bit 1) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_LEVEL_HIGH_Msk (0x2UL)   /*!< GPIO24_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_LEVEL_LOW_Pos (0UL)      /*!< GPIO24_LEVEL_LOW (Bit 0) */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_LEVEL_LOW_Msk (0x1UL)    /*!< GPIO24_LEVEL_LOW (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                          IO_QSPI                                          ================ */
/* =========================================================================================================================== */

/* =================================================  GPIO_QSPI_SCLK_STATUS  ================================================= */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_IRQTOPROC_Pos (26UL)          /*!< IRQTOPROC (Bit 26) */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_IRQTOPROC_Msk (0x4000000UL)   /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_IRQFROMPAD_Pos (24UL)         /*!< IRQFROMPAD (Bit 24) */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_IRQFROMPAD_Msk (0x1000000UL)  /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_INTOPERI_Pos (19UL)           /*!< INTOPERI (Bit 19) */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_INTOPERI_Msk (0x80000UL)      /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_INFROMPAD_Pos (17UL)          /*!< INFROMPAD (Bit 17) */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_INFROMPAD_Msk (0x20000UL)     /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_OETOPAD_Pos (13UL)            /*!< OETOPAD (Bit 13) */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_OETOPAD_Msk (0x2000UL)        /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_OEFROMPERI_Pos (12UL)         /*!< OEFROMPERI (Bit 12) */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_OEFROMPERI_Msk (0x1000UL)     /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_OUTTOPAD_Pos (9UL)            /*!< OUTTOPAD (Bit 9) */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_OUTTOPAD_Msk (0x200UL)        /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_OUTFROMPERI_Pos (8UL)         /*!< OUTFROMPERI (Bit 8) */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_OUTFROMPERI_Msk (0x100UL)     /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ==================================================  GPIO_QSPI_SCLK_CTRL  ================================================== */
#define IO_QSPI_GPIO_QSPI_SCLK_CTRL_IRQOVER_Pos (28UL)              /*!< IRQOVER (Bit 28) */
#define IO_QSPI_GPIO_QSPI_SCLK_CTRL_IRQOVER_Msk (0x30000000UL)      /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_QSPI_GPIO_QSPI_SCLK_CTRL_INOVER_Pos (16UL)               /*!< INOVER (Bit 16) */
#define IO_QSPI_GPIO_QSPI_SCLK_CTRL_INOVER_Msk (0x30000UL)          /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_QSPI_GPIO_QSPI_SCLK_CTRL_OEOVER_Pos (12UL)               /*!< OEOVER (Bit 12) */
#define IO_QSPI_GPIO_QSPI_SCLK_CTRL_OEOVER_Msk (0x3000UL)           /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_QSPI_GPIO_QSPI_SCLK_CTRL_OUTOVER_Pos (8UL)               /*!< OUTOVER (Bit 8) */
#define IO_QSPI_GPIO_QSPI_SCLK_CTRL_OUTOVER_Msk (0x300UL)           /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_QSPI_GPIO_QSPI_SCLK_CTRL_FUNCSEL_Pos (0UL)               /*!< FUNCSEL (Bit 0) */
#define IO_QSPI_GPIO_QSPI_SCLK_CTRL_FUNCSEL_Msk (0x1fUL)            /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* ==================================================  GPIO_QSPI_SS_STATUS  ================================================== */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_IRQTOPROC_Pos (26UL)            /*!< IRQTOPROC (Bit 26) */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_IRQTOPROC_Msk (0x4000000UL)     /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_IRQFROMPAD_Pos (24UL)           /*!< IRQFROMPAD (Bit 24) */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_IRQFROMPAD_Msk (0x1000000UL)    /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_INTOPERI_Pos (19UL)             /*!< INTOPERI (Bit 19) */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_INTOPERI_Msk (0x80000UL)        /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_INFROMPAD_Pos (17UL)            /*!< INFROMPAD (Bit 17) */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_INFROMPAD_Msk (0x20000UL)       /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_OETOPAD_Pos (13UL)              /*!< OETOPAD (Bit 13) */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_OETOPAD_Msk (0x2000UL)          /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_OEFROMPERI_Pos (12UL)           /*!< OEFROMPERI (Bit 12) */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_OEFROMPERI_Msk (0x1000UL)       /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_OUTTOPAD_Pos (9UL)              /*!< OUTTOPAD (Bit 9) */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_OUTTOPAD_Msk (0x200UL)          /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_OUTFROMPERI_Pos (8UL)           /*!< OUTFROMPERI (Bit 8) */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_OUTFROMPERI_Msk (0x100UL)       /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ===================================================  GPIO_QSPI_SS_CTRL  =================================================== */
#define IO_QSPI_GPIO_QSPI_SS_CTRL_IRQOVER_Pos (28UL)                /*!< IRQOVER (Bit 28) */
#define IO_QSPI_GPIO_QSPI_SS_CTRL_IRQOVER_Msk (0x30000000UL)        /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_QSPI_GPIO_QSPI_SS_CTRL_INOVER_Pos (16UL)                 /*!< INOVER (Bit 16) */
#define IO_QSPI_GPIO_QSPI_SS_CTRL_INOVER_Msk (0x30000UL)            /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_QSPI_GPIO_QSPI_SS_CTRL_OEOVER_Pos (12UL)                 /*!< OEOVER (Bit 12) */
#define IO_QSPI_GPIO_QSPI_SS_CTRL_OEOVER_Msk (0x3000UL)             /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_QSPI_GPIO_QSPI_SS_CTRL_OUTOVER_Pos (8UL)                 /*!< OUTOVER (Bit 8) */
#define IO_QSPI_GPIO_QSPI_SS_CTRL_OUTOVER_Msk (0x300UL)             /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_QSPI_GPIO_QSPI_SS_CTRL_FUNCSEL_Pos (0UL)                 /*!< FUNCSEL (Bit 0) */
#define IO_QSPI_GPIO_QSPI_SS_CTRL_FUNCSEL_Msk (0x1fUL)              /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =================================================  GPIO_QSPI_SD0_STATUS  ================================================== */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_IRQTOPROC_Pos (26UL)           /*!< IRQTOPROC (Bit 26) */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_IRQTOPROC_Msk (0x4000000UL)    /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_IRQFROMPAD_Pos (24UL)          /*!< IRQFROMPAD (Bit 24) */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_IRQFROMPAD_Msk (0x1000000UL)   /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_INTOPERI_Pos (19UL)            /*!< INTOPERI (Bit 19) */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_INTOPERI_Msk (0x80000UL)       /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_INFROMPAD_Pos (17UL)           /*!< INFROMPAD (Bit 17) */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_INFROMPAD_Msk (0x20000UL)      /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_OETOPAD_Pos (13UL)             /*!< OETOPAD (Bit 13) */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_OETOPAD_Msk (0x2000UL)         /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_OEFROMPERI_Pos (12UL)          /*!< OEFROMPERI (Bit 12) */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_OEFROMPERI_Msk (0x1000UL)      /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_OUTTOPAD_Pos (9UL)             /*!< OUTTOPAD (Bit 9) */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_OUTTOPAD_Msk (0x200UL)         /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_OUTFROMPERI_Pos (8UL)          /*!< OUTFROMPERI (Bit 8) */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_OUTFROMPERI_Msk (0x100UL)      /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ==================================================  GPIO_QSPI_SD0_CTRL  =================================================== */
#define IO_QSPI_GPIO_QSPI_SD0_CTRL_IRQOVER_Pos (28UL)               /*!< IRQOVER (Bit 28) */
#define IO_QSPI_GPIO_QSPI_SD0_CTRL_IRQOVER_Msk (0x30000000UL)       /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_QSPI_GPIO_QSPI_SD0_CTRL_INOVER_Pos (16UL)                /*!< INOVER (Bit 16) */
#define IO_QSPI_GPIO_QSPI_SD0_CTRL_INOVER_Msk (0x30000UL)           /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_QSPI_GPIO_QSPI_SD0_CTRL_OEOVER_Pos (12UL)                /*!< OEOVER (Bit 12) */
#define IO_QSPI_GPIO_QSPI_SD0_CTRL_OEOVER_Msk (0x3000UL)            /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_QSPI_GPIO_QSPI_SD0_CTRL_OUTOVER_Pos (8UL)                /*!< OUTOVER (Bit 8) */
#define IO_QSPI_GPIO_QSPI_SD0_CTRL_OUTOVER_Msk (0x300UL)            /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_QSPI_GPIO_QSPI_SD0_CTRL_FUNCSEL_Pos (0UL)                /*!< FUNCSEL (Bit 0) */
#define IO_QSPI_GPIO_QSPI_SD0_CTRL_FUNCSEL_Msk (0x1fUL)             /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =================================================  GPIO_QSPI_SD1_STATUS  ================================================== */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_IRQTOPROC_Pos (26UL)           /*!< IRQTOPROC (Bit 26) */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_IRQTOPROC_Msk (0x4000000UL)    /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_IRQFROMPAD_Pos (24UL)          /*!< IRQFROMPAD (Bit 24) */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_IRQFROMPAD_Msk (0x1000000UL)   /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_INTOPERI_Pos (19UL)            /*!< INTOPERI (Bit 19) */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_INTOPERI_Msk (0x80000UL)       /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_INFROMPAD_Pos (17UL)           /*!< INFROMPAD (Bit 17) */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_INFROMPAD_Msk (0x20000UL)      /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_OETOPAD_Pos (13UL)             /*!< OETOPAD (Bit 13) */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_OETOPAD_Msk (0x2000UL)         /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_OEFROMPERI_Pos (12UL)          /*!< OEFROMPERI (Bit 12) */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_OEFROMPERI_Msk (0x1000UL)      /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_OUTTOPAD_Pos (9UL)             /*!< OUTTOPAD (Bit 9) */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_OUTTOPAD_Msk (0x200UL)         /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_OUTFROMPERI_Pos (8UL)          /*!< OUTFROMPERI (Bit 8) */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_OUTFROMPERI_Msk (0x100UL)      /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ==================================================  GPIO_QSPI_SD1_CTRL  =================================================== */
#define IO_QSPI_GPIO_QSPI_SD1_CTRL_IRQOVER_Pos (28UL)               /*!< IRQOVER (Bit 28) */
#define IO_QSPI_GPIO_QSPI_SD1_CTRL_IRQOVER_Msk (0x30000000UL)       /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_QSPI_GPIO_QSPI_SD1_CTRL_INOVER_Pos (16UL)                /*!< INOVER (Bit 16) */
#define IO_QSPI_GPIO_QSPI_SD1_CTRL_INOVER_Msk (0x30000UL)           /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_QSPI_GPIO_QSPI_SD1_CTRL_OEOVER_Pos (12UL)                /*!< OEOVER (Bit 12) */
#define IO_QSPI_GPIO_QSPI_SD1_CTRL_OEOVER_Msk (0x3000UL)            /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_QSPI_GPIO_QSPI_SD1_CTRL_OUTOVER_Pos (8UL)                /*!< OUTOVER (Bit 8) */
#define IO_QSPI_GPIO_QSPI_SD1_CTRL_OUTOVER_Msk (0x300UL)            /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_QSPI_GPIO_QSPI_SD1_CTRL_FUNCSEL_Pos (0UL)                /*!< FUNCSEL (Bit 0) */
#define IO_QSPI_GPIO_QSPI_SD1_CTRL_FUNCSEL_Msk (0x1fUL)             /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =================================================  GPIO_QSPI_SD2_STATUS  ================================================== */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_IRQTOPROC_Pos (26UL)           /*!< IRQTOPROC (Bit 26) */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_IRQTOPROC_Msk (0x4000000UL)    /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_IRQFROMPAD_Pos (24UL)          /*!< IRQFROMPAD (Bit 24) */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_IRQFROMPAD_Msk (0x1000000UL)   /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_INTOPERI_Pos (19UL)            /*!< INTOPERI (Bit 19) */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_INTOPERI_Msk (0x80000UL)       /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_INFROMPAD_Pos (17UL)           /*!< INFROMPAD (Bit 17) */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_INFROMPAD_Msk (0x20000UL)      /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_OETOPAD_Pos (13UL)             /*!< OETOPAD (Bit 13) */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_OETOPAD_Msk (0x2000UL)         /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_OEFROMPERI_Pos (12UL)          /*!< OEFROMPERI (Bit 12) */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_OEFROMPERI_Msk (0x1000UL)      /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_OUTTOPAD_Pos (9UL)             /*!< OUTTOPAD (Bit 9) */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_OUTTOPAD_Msk (0x200UL)         /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_OUTFROMPERI_Pos (8UL)          /*!< OUTFROMPERI (Bit 8) */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_OUTFROMPERI_Msk (0x100UL)      /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ==================================================  GPIO_QSPI_SD2_CTRL  =================================================== */
#define IO_QSPI_GPIO_QSPI_SD2_CTRL_IRQOVER_Pos (28UL)               /*!< IRQOVER (Bit 28) */
#define IO_QSPI_GPIO_QSPI_SD2_CTRL_IRQOVER_Msk (0x30000000UL)       /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_QSPI_GPIO_QSPI_SD2_CTRL_INOVER_Pos (16UL)                /*!< INOVER (Bit 16) */
#define IO_QSPI_GPIO_QSPI_SD2_CTRL_INOVER_Msk (0x30000UL)           /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_QSPI_GPIO_QSPI_SD2_CTRL_OEOVER_Pos (12UL)                /*!< OEOVER (Bit 12) */
#define IO_QSPI_GPIO_QSPI_SD2_CTRL_OEOVER_Msk (0x3000UL)            /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_QSPI_GPIO_QSPI_SD2_CTRL_OUTOVER_Pos (8UL)                /*!< OUTOVER (Bit 8) */
#define IO_QSPI_GPIO_QSPI_SD2_CTRL_OUTOVER_Msk (0x300UL)            /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_QSPI_GPIO_QSPI_SD2_CTRL_FUNCSEL_Pos (0UL)                /*!< FUNCSEL (Bit 0) */
#define IO_QSPI_GPIO_QSPI_SD2_CTRL_FUNCSEL_Msk (0x1fUL)             /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =================================================  GPIO_QSPI_SD3_STATUS  ================================================== */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_IRQTOPROC_Pos (26UL)           /*!< IRQTOPROC (Bit 26) */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_IRQTOPROC_Msk (0x4000000UL)    /*!< IRQTOPROC (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_IRQFROMPAD_Pos (24UL)          /*!< IRQFROMPAD (Bit 24) */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_IRQFROMPAD_Msk (0x1000000UL)   /*!< IRQFROMPAD (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_INTOPERI_Pos (19UL)            /*!< INTOPERI (Bit 19) */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_INTOPERI_Msk (0x80000UL)       /*!< INTOPERI (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_INFROMPAD_Pos (17UL)           /*!< INFROMPAD (Bit 17) */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_INFROMPAD_Msk (0x20000UL)      /*!< INFROMPAD (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_OETOPAD_Pos (13UL)             /*!< OETOPAD (Bit 13) */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_OETOPAD_Msk (0x2000UL)         /*!< OETOPAD (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_OEFROMPERI_Pos (12UL)          /*!< OEFROMPERI (Bit 12) */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_OEFROMPERI_Msk (0x1000UL)      /*!< OEFROMPERI (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_OUTTOPAD_Pos (9UL)             /*!< OUTTOPAD (Bit 9) */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_OUTTOPAD_Msk (0x200UL)         /*!< OUTTOPAD (Bitfield-Mask: 0x01) */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_OUTFROMPERI_Pos (8UL)          /*!< OUTFROMPERI (Bit 8) */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_OUTFROMPERI_Msk (0x100UL)      /*!< OUTFROMPERI (Bitfield-Mask: 0x01) */
/* ==================================================  GPIO_QSPI_SD3_CTRL  =================================================== */
#define IO_QSPI_GPIO_QSPI_SD3_CTRL_IRQOVER_Pos (28UL)               /*!< IRQOVER (Bit 28) */
#define IO_QSPI_GPIO_QSPI_SD3_CTRL_IRQOVER_Msk (0x30000000UL)       /*!< IRQOVER (Bitfield-Mask: 0x03) */
#define IO_QSPI_GPIO_QSPI_SD3_CTRL_INOVER_Pos (16UL)                /*!< INOVER (Bit 16) */
#define IO_QSPI_GPIO_QSPI_SD3_CTRL_INOVER_Msk (0x30000UL)           /*!< INOVER (Bitfield-Mask: 0x03) */
#define IO_QSPI_GPIO_QSPI_SD3_CTRL_OEOVER_Pos (12UL)                /*!< OEOVER (Bit 12) */
#define IO_QSPI_GPIO_QSPI_SD3_CTRL_OEOVER_Msk (0x3000UL)            /*!< OEOVER (Bitfield-Mask: 0x03) */
#define IO_QSPI_GPIO_QSPI_SD3_CTRL_OUTOVER_Pos (8UL)                /*!< OUTOVER (Bit 8) */
#define IO_QSPI_GPIO_QSPI_SD3_CTRL_OUTOVER_Msk (0x300UL)            /*!< OUTOVER (Bitfield-Mask: 0x03) */
#define IO_QSPI_GPIO_QSPI_SD3_CTRL_FUNCSEL_Pos (0UL)                /*!< FUNCSEL (Bit 0) */
#define IO_QSPI_GPIO_QSPI_SD3_CTRL_FUNCSEL_Msk (0x1fUL)             /*!< FUNCSEL (Bitfield-Mask: 0x1f) */
/* =========================================================  INTR  ========================================================== */
#define IO_QSPI_INTR_GPIO_QSPI_SD3_EDGE_HIGH_Pos (23UL)             /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bit 23) */
#define IO_QSPI_INTR_GPIO_QSPI_SD3_EDGE_HIGH_Msk (0x800000UL)       /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_INTR_GPIO_QSPI_SD3_EDGE_LOW_Pos (22UL)              /*!< GPIO_QSPI_SD3_EDGE_LOW (Bit 22) */
#define IO_QSPI_INTR_GPIO_QSPI_SD3_EDGE_LOW_Msk (0x400000UL)        /*!< GPIO_QSPI_SD3_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_INTR_GPIO_QSPI_SD3_LEVEL_HIGH_Pos (21UL)            /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bit 21) */
#define IO_QSPI_INTR_GPIO_QSPI_SD3_LEVEL_HIGH_Msk (0x200000UL)      /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_INTR_GPIO_QSPI_SD3_LEVEL_LOW_Pos (20UL)             /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bit 20) */
#define IO_QSPI_INTR_GPIO_QSPI_SD3_LEVEL_LOW_Msk (0x100000UL)       /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_INTR_GPIO_QSPI_SD2_EDGE_HIGH_Pos (19UL)             /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bit 19) */
#define IO_QSPI_INTR_GPIO_QSPI_SD2_EDGE_HIGH_Msk (0x80000UL)        /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_INTR_GPIO_QSPI_SD2_EDGE_LOW_Pos (18UL)              /*!< GPIO_QSPI_SD2_EDGE_LOW (Bit 18) */
#define IO_QSPI_INTR_GPIO_QSPI_SD2_EDGE_LOW_Msk (0x40000UL)         /*!< GPIO_QSPI_SD2_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_INTR_GPIO_QSPI_SD2_LEVEL_HIGH_Pos (17UL)            /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bit 17) */
#define IO_QSPI_INTR_GPIO_QSPI_SD2_LEVEL_HIGH_Msk (0x20000UL)       /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_INTR_GPIO_QSPI_SD2_LEVEL_LOW_Pos (16UL)             /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bit 16) */
#define IO_QSPI_INTR_GPIO_QSPI_SD2_LEVEL_LOW_Msk (0x10000UL)        /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_INTR_GPIO_QSPI_SD1_EDGE_HIGH_Pos (15UL)             /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bit 15) */
#define IO_QSPI_INTR_GPIO_QSPI_SD1_EDGE_HIGH_Msk (0x8000UL)         /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_INTR_GPIO_QSPI_SD1_EDGE_LOW_Pos (14UL)              /*!< GPIO_QSPI_SD1_EDGE_LOW (Bit 14) */
#define IO_QSPI_INTR_GPIO_QSPI_SD1_EDGE_LOW_Msk (0x4000UL)          /*!< GPIO_QSPI_SD1_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_INTR_GPIO_QSPI_SD1_LEVEL_HIGH_Pos (13UL)            /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bit 13) */
#define IO_QSPI_INTR_GPIO_QSPI_SD1_LEVEL_HIGH_Msk (0x2000UL)        /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_INTR_GPIO_QSPI_SD1_LEVEL_LOW_Pos (12UL)             /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bit 12) */
#define IO_QSPI_INTR_GPIO_QSPI_SD1_LEVEL_LOW_Msk (0x1000UL)         /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_INTR_GPIO_QSPI_SD0_EDGE_HIGH_Pos (11UL)             /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bit 11) */
#define IO_QSPI_INTR_GPIO_QSPI_SD0_EDGE_HIGH_Msk (0x800UL)          /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_INTR_GPIO_QSPI_SD0_EDGE_LOW_Pos (10UL)              /*!< GPIO_QSPI_SD0_EDGE_LOW (Bit 10) */
#define IO_QSPI_INTR_GPIO_QSPI_SD0_EDGE_LOW_Msk (0x400UL)           /*!< GPIO_QSPI_SD0_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_INTR_GPIO_QSPI_SD0_LEVEL_HIGH_Pos (9UL)             /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bit 9) */
#define IO_QSPI_INTR_GPIO_QSPI_SD0_LEVEL_HIGH_Msk (0x200UL)         /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_INTR_GPIO_QSPI_SD0_LEVEL_LOW_Pos (8UL)              /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bit 8) */
#define IO_QSPI_INTR_GPIO_QSPI_SD0_LEVEL_LOW_Msk (0x100UL)          /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_INTR_GPIO_QSPI_SS_EDGE_HIGH_Pos (7UL)               /*!< GPIO_QSPI_SS_EDGE_HIGH (Bit 7) */
#define IO_QSPI_INTR_GPIO_QSPI_SS_EDGE_HIGH_Msk (0x80UL)            /*!< GPIO_QSPI_SS_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_INTR_GPIO_QSPI_SS_EDGE_LOW_Pos (6UL)                /*!< GPIO_QSPI_SS_EDGE_LOW (Bit 6) */
#define IO_QSPI_INTR_GPIO_QSPI_SS_EDGE_LOW_Msk (0x40UL)             /*!< GPIO_QSPI_SS_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_INTR_GPIO_QSPI_SS_LEVEL_HIGH_Pos (5UL)              /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bit 5) */
#define IO_QSPI_INTR_GPIO_QSPI_SS_LEVEL_HIGH_Msk (0x20UL)           /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_INTR_GPIO_QSPI_SS_LEVEL_LOW_Pos (4UL)               /*!< GPIO_QSPI_SS_LEVEL_LOW (Bit 4) */
#define IO_QSPI_INTR_GPIO_QSPI_SS_LEVEL_LOW_Msk (0x10UL)            /*!< GPIO_QSPI_SS_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_INTR_GPIO_QSPI_SCLK_EDGE_HIGH_Pos (3UL)             /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bit 3) */
#define IO_QSPI_INTR_GPIO_QSPI_SCLK_EDGE_HIGH_Msk (0x8UL)           /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_INTR_GPIO_QSPI_SCLK_EDGE_LOW_Pos (2UL)              /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bit 2) */
#define IO_QSPI_INTR_GPIO_QSPI_SCLK_EDGE_LOW_Msk (0x4UL)            /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_INTR_GPIO_QSPI_SCLK_LEVEL_HIGH_Pos (1UL)            /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bit 1) */
#define IO_QSPI_INTR_GPIO_QSPI_SCLK_LEVEL_HIGH_Msk (0x2UL)          /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_INTR_GPIO_QSPI_SCLK_LEVEL_LOW_Pos (0UL)             /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bit 0) */
#define IO_QSPI_INTR_GPIO_QSPI_SCLK_LEVEL_LOW_Msk (0x1UL)           /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ======================================================  PROC0_INTE  ======================================================= */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_EDGE_HIGH_Pos (23UL)       /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bit 23) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_EDGE_LOW_Pos (22UL)        /*!< GPIO_QSPI_SD3_EDGE_LOW (Bit 22) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_EDGE_LOW_Msk (0x400000UL)  /*!< GPIO_QSPI_SD3_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_LEVEL_HIGH_Pos (21UL)      /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bit 21) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_LEVEL_LOW_Pos (20UL)       /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bit 20) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_EDGE_HIGH_Pos (19UL)       /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bit 19) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_EDGE_HIGH_Msk (0x80000UL)  /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_EDGE_LOW_Pos (18UL)        /*!< GPIO_QSPI_SD2_EDGE_LOW (Bit 18) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_EDGE_LOW_Msk (0x40000UL)   /*!< GPIO_QSPI_SD2_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_LEVEL_HIGH_Pos (17UL)      /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bit 17) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_LEVEL_LOW_Pos (16UL)       /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bit 16) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_LEVEL_LOW_Msk (0x10000UL)  /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_EDGE_HIGH_Pos (15UL)       /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bit 15) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_EDGE_HIGH_Msk (0x8000UL)   /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_EDGE_LOW_Pos (14UL)        /*!< GPIO_QSPI_SD1_EDGE_LOW (Bit 14) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_EDGE_LOW_Msk (0x4000UL)    /*!< GPIO_QSPI_SD1_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_LEVEL_HIGH_Pos (13UL)      /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bit 13) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_LEVEL_HIGH_Msk (0x2000UL)  /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_LEVEL_LOW_Pos (12UL)       /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bit 12) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_LEVEL_LOW_Msk (0x1000UL)   /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_EDGE_HIGH_Pos (11UL)       /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bit 11) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_EDGE_HIGH_Msk (0x800UL)    /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_EDGE_LOW_Pos (10UL)        /*!< GPIO_QSPI_SD0_EDGE_LOW (Bit 10) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_EDGE_LOW_Msk (0x400UL)     /*!< GPIO_QSPI_SD0_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_LEVEL_HIGH_Pos (9UL)       /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bit 9) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_LEVEL_HIGH_Msk (0x200UL)   /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_LEVEL_LOW_Pos (8UL)        /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bit 8) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_LEVEL_LOW_Msk (0x100UL)    /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_EDGE_HIGH_Pos (7UL)         /*!< GPIO_QSPI_SS_EDGE_HIGH (Bit 7) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_EDGE_HIGH_Msk (0x80UL)      /*!< GPIO_QSPI_SS_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_EDGE_LOW_Pos (6UL)          /*!< GPIO_QSPI_SS_EDGE_LOW (Bit 6) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_EDGE_LOW_Msk (0x40UL)       /*!< GPIO_QSPI_SS_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_LEVEL_HIGH_Pos (5UL)        /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bit 5) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_LEVEL_HIGH_Msk (0x20UL)     /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_LEVEL_LOW_Pos (4UL)         /*!< GPIO_QSPI_SS_LEVEL_LOW (Bit 4) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_LEVEL_LOW_Msk (0x10UL)      /*!< GPIO_QSPI_SS_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_EDGE_HIGH_Pos (3UL)       /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bit 3) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_EDGE_HIGH_Msk (0x8UL)     /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_EDGE_LOW_Pos (2UL)        /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bit 2) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_EDGE_LOW_Msk (0x4UL)      /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_LEVEL_HIGH_Pos (1UL)      /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bit 1) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_LEVEL_HIGH_Msk (0x2UL)    /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_LEVEL_LOW_Pos (0UL)       /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bit 0) */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_LEVEL_LOW_Msk (0x1UL)     /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ======================================================  PROC0_INTF  ======================================================= */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_EDGE_HIGH_Pos (23UL)       /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bit 23) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_EDGE_LOW_Pos (22UL)        /*!< GPIO_QSPI_SD3_EDGE_LOW (Bit 22) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_EDGE_LOW_Msk (0x400000UL)  /*!< GPIO_QSPI_SD3_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_LEVEL_HIGH_Pos (21UL)      /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bit 21) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_LEVEL_LOW_Pos (20UL)       /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bit 20) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_EDGE_HIGH_Pos (19UL)       /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bit 19) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_EDGE_HIGH_Msk (0x80000UL)  /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_EDGE_LOW_Pos (18UL)        /*!< GPIO_QSPI_SD2_EDGE_LOW (Bit 18) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_EDGE_LOW_Msk (0x40000UL)   /*!< GPIO_QSPI_SD2_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_LEVEL_HIGH_Pos (17UL)      /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bit 17) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_LEVEL_LOW_Pos (16UL)       /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bit 16) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_LEVEL_LOW_Msk (0x10000UL)  /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_EDGE_HIGH_Pos (15UL)       /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bit 15) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_EDGE_HIGH_Msk (0x8000UL)   /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_EDGE_LOW_Pos (14UL)        /*!< GPIO_QSPI_SD1_EDGE_LOW (Bit 14) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_EDGE_LOW_Msk (0x4000UL)    /*!< GPIO_QSPI_SD1_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_LEVEL_HIGH_Pos (13UL)      /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bit 13) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_LEVEL_HIGH_Msk (0x2000UL)  /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_LEVEL_LOW_Pos (12UL)       /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bit 12) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_LEVEL_LOW_Msk (0x1000UL)   /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_EDGE_HIGH_Pos (11UL)       /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bit 11) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_EDGE_HIGH_Msk (0x800UL)    /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_EDGE_LOW_Pos (10UL)        /*!< GPIO_QSPI_SD0_EDGE_LOW (Bit 10) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_EDGE_LOW_Msk (0x400UL)     /*!< GPIO_QSPI_SD0_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_LEVEL_HIGH_Pos (9UL)       /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bit 9) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_LEVEL_HIGH_Msk (0x200UL)   /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_LEVEL_LOW_Pos (8UL)        /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bit 8) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_LEVEL_LOW_Msk (0x100UL)    /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_EDGE_HIGH_Pos (7UL)         /*!< GPIO_QSPI_SS_EDGE_HIGH (Bit 7) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_EDGE_HIGH_Msk (0x80UL)      /*!< GPIO_QSPI_SS_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_EDGE_LOW_Pos (6UL)          /*!< GPIO_QSPI_SS_EDGE_LOW (Bit 6) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_EDGE_LOW_Msk (0x40UL)       /*!< GPIO_QSPI_SS_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_LEVEL_HIGH_Pos (5UL)        /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bit 5) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_LEVEL_HIGH_Msk (0x20UL)     /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_LEVEL_LOW_Pos (4UL)         /*!< GPIO_QSPI_SS_LEVEL_LOW (Bit 4) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_LEVEL_LOW_Msk (0x10UL)      /*!< GPIO_QSPI_SS_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_EDGE_HIGH_Pos (3UL)       /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bit 3) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_EDGE_HIGH_Msk (0x8UL)     /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_EDGE_LOW_Pos (2UL)        /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bit 2) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_EDGE_LOW_Msk (0x4UL)      /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_LEVEL_HIGH_Pos (1UL)      /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bit 1) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_LEVEL_HIGH_Msk (0x2UL)    /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_LEVEL_LOW_Pos (0UL)       /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bit 0) */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_LEVEL_LOW_Msk (0x1UL)     /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ======================================================  PROC0_INTS  ======================================================= */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_EDGE_HIGH_Pos (23UL)       /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bit 23) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_EDGE_LOW_Pos (22UL)        /*!< GPIO_QSPI_SD3_EDGE_LOW (Bit 22) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_EDGE_LOW_Msk (0x400000UL)  /*!< GPIO_QSPI_SD3_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_LEVEL_HIGH_Pos (21UL)      /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bit 21) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_LEVEL_LOW_Pos (20UL)       /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bit 20) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_EDGE_HIGH_Pos (19UL)       /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bit 19) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_EDGE_HIGH_Msk (0x80000UL)  /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_EDGE_LOW_Pos (18UL)        /*!< GPIO_QSPI_SD2_EDGE_LOW (Bit 18) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_EDGE_LOW_Msk (0x40000UL)   /*!< GPIO_QSPI_SD2_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_LEVEL_HIGH_Pos (17UL)      /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bit 17) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_LEVEL_LOW_Pos (16UL)       /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bit 16) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_LEVEL_LOW_Msk (0x10000UL)  /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_EDGE_HIGH_Pos (15UL)       /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bit 15) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_EDGE_HIGH_Msk (0x8000UL)   /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_EDGE_LOW_Pos (14UL)        /*!< GPIO_QSPI_SD1_EDGE_LOW (Bit 14) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_EDGE_LOW_Msk (0x4000UL)    /*!< GPIO_QSPI_SD1_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_LEVEL_HIGH_Pos (13UL)      /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bit 13) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_LEVEL_HIGH_Msk (0x2000UL)  /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_LEVEL_LOW_Pos (12UL)       /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bit 12) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_LEVEL_LOW_Msk (0x1000UL)   /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_EDGE_HIGH_Pos (11UL)       /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bit 11) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_EDGE_HIGH_Msk (0x800UL)    /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_EDGE_LOW_Pos (10UL)        /*!< GPIO_QSPI_SD0_EDGE_LOW (Bit 10) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_EDGE_LOW_Msk (0x400UL)     /*!< GPIO_QSPI_SD0_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_LEVEL_HIGH_Pos (9UL)       /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bit 9) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_LEVEL_HIGH_Msk (0x200UL)   /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_LEVEL_LOW_Pos (8UL)        /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bit 8) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_LEVEL_LOW_Msk (0x100UL)    /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_EDGE_HIGH_Pos (7UL)         /*!< GPIO_QSPI_SS_EDGE_HIGH (Bit 7) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_EDGE_HIGH_Msk (0x80UL)      /*!< GPIO_QSPI_SS_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_EDGE_LOW_Pos (6UL)          /*!< GPIO_QSPI_SS_EDGE_LOW (Bit 6) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_EDGE_LOW_Msk (0x40UL)       /*!< GPIO_QSPI_SS_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_LEVEL_HIGH_Pos (5UL)        /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bit 5) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_LEVEL_HIGH_Msk (0x20UL)     /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_LEVEL_LOW_Pos (4UL)         /*!< GPIO_QSPI_SS_LEVEL_LOW (Bit 4) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_LEVEL_LOW_Msk (0x10UL)      /*!< GPIO_QSPI_SS_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_EDGE_HIGH_Pos (3UL)       /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bit 3) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_EDGE_HIGH_Msk (0x8UL)     /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_EDGE_LOW_Pos (2UL)        /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bit 2) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_EDGE_LOW_Msk (0x4UL)      /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_LEVEL_HIGH_Pos (1UL)      /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bit 1) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_LEVEL_HIGH_Msk (0x2UL)    /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_LEVEL_LOW_Pos (0UL)       /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bit 0) */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_LEVEL_LOW_Msk (0x1UL)     /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ======================================================  PROC1_INTE  ======================================================= */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_EDGE_HIGH_Pos (23UL)       /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bit 23) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_EDGE_LOW_Pos (22UL)        /*!< GPIO_QSPI_SD3_EDGE_LOW (Bit 22) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_EDGE_LOW_Msk (0x400000UL)  /*!< GPIO_QSPI_SD3_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_LEVEL_HIGH_Pos (21UL)      /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bit 21) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_LEVEL_LOW_Pos (20UL)       /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bit 20) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_EDGE_HIGH_Pos (19UL)       /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bit 19) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_EDGE_HIGH_Msk (0x80000UL)  /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_EDGE_LOW_Pos (18UL)        /*!< GPIO_QSPI_SD2_EDGE_LOW (Bit 18) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_EDGE_LOW_Msk (0x40000UL)   /*!< GPIO_QSPI_SD2_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_LEVEL_HIGH_Pos (17UL)      /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bit 17) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_LEVEL_LOW_Pos (16UL)       /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bit 16) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_LEVEL_LOW_Msk (0x10000UL)  /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_EDGE_HIGH_Pos (15UL)       /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bit 15) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_EDGE_HIGH_Msk (0x8000UL)   /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_EDGE_LOW_Pos (14UL)        /*!< GPIO_QSPI_SD1_EDGE_LOW (Bit 14) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_EDGE_LOW_Msk (0x4000UL)    /*!< GPIO_QSPI_SD1_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_LEVEL_HIGH_Pos (13UL)      /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bit 13) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_LEVEL_HIGH_Msk (0x2000UL)  /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_LEVEL_LOW_Pos (12UL)       /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bit 12) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_LEVEL_LOW_Msk (0x1000UL)   /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_EDGE_HIGH_Pos (11UL)       /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bit 11) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_EDGE_HIGH_Msk (0x800UL)    /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_EDGE_LOW_Pos (10UL)        /*!< GPIO_QSPI_SD0_EDGE_LOW (Bit 10) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_EDGE_LOW_Msk (0x400UL)     /*!< GPIO_QSPI_SD0_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_LEVEL_HIGH_Pos (9UL)       /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bit 9) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_LEVEL_HIGH_Msk (0x200UL)   /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_LEVEL_LOW_Pos (8UL)        /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bit 8) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_LEVEL_LOW_Msk (0x100UL)    /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_EDGE_HIGH_Pos (7UL)         /*!< GPIO_QSPI_SS_EDGE_HIGH (Bit 7) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_EDGE_HIGH_Msk (0x80UL)      /*!< GPIO_QSPI_SS_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_EDGE_LOW_Pos (6UL)          /*!< GPIO_QSPI_SS_EDGE_LOW (Bit 6) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_EDGE_LOW_Msk (0x40UL)       /*!< GPIO_QSPI_SS_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_LEVEL_HIGH_Pos (5UL)        /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bit 5) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_LEVEL_HIGH_Msk (0x20UL)     /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_LEVEL_LOW_Pos (4UL)         /*!< GPIO_QSPI_SS_LEVEL_LOW (Bit 4) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_LEVEL_LOW_Msk (0x10UL)      /*!< GPIO_QSPI_SS_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_EDGE_HIGH_Pos (3UL)       /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bit 3) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_EDGE_HIGH_Msk (0x8UL)     /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_EDGE_LOW_Pos (2UL)        /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bit 2) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_EDGE_LOW_Msk (0x4UL)      /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_LEVEL_HIGH_Pos (1UL)      /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bit 1) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_LEVEL_HIGH_Msk (0x2UL)    /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_LEVEL_LOW_Pos (0UL)       /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bit 0) */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_LEVEL_LOW_Msk (0x1UL)     /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ======================================================  PROC1_INTF  ======================================================= */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_EDGE_HIGH_Pos (23UL)       /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bit 23) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_EDGE_LOW_Pos (22UL)        /*!< GPIO_QSPI_SD3_EDGE_LOW (Bit 22) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_EDGE_LOW_Msk (0x400000UL)  /*!< GPIO_QSPI_SD3_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_LEVEL_HIGH_Pos (21UL)      /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bit 21) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_LEVEL_LOW_Pos (20UL)       /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bit 20) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_EDGE_HIGH_Pos (19UL)       /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bit 19) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_EDGE_HIGH_Msk (0x80000UL)  /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_EDGE_LOW_Pos (18UL)        /*!< GPIO_QSPI_SD2_EDGE_LOW (Bit 18) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_EDGE_LOW_Msk (0x40000UL)   /*!< GPIO_QSPI_SD2_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_LEVEL_HIGH_Pos (17UL)      /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bit 17) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_LEVEL_LOW_Pos (16UL)       /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bit 16) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_LEVEL_LOW_Msk (0x10000UL)  /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_EDGE_HIGH_Pos (15UL)       /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bit 15) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_EDGE_HIGH_Msk (0x8000UL)   /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_EDGE_LOW_Pos (14UL)        /*!< GPIO_QSPI_SD1_EDGE_LOW (Bit 14) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_EDGE_LOW_Msk (0x4000UL)    /*!< GPIO_QSPI_SD1_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_LEVEL_HIGH_Pos (13UL)      /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bit 13) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_LEVEL_HIGH_Msk (0x2000UL)  /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_LEVEL_LOW_Pos (12UL)       /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bit 12) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_LEVEL_LOW_Msk (0x1000UL)   /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_EDGE_HIGH_Pos (11UL)       /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bit 11) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_EDGE_HIGH_Msk (0x800UL)    /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_EDGE_LOW_Pos (10UL)        /*!< GPIO_QSPI_SD0_EDGE_LOW (Bit 10) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_EDGE_LOW_Msk (0x400UL)     /*!< GPIO_QSPI_SD0_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_LEVEL_HIGH_Pos (9UL)       /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bit 9) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_LEVEL_HIGH_Msk (0x200UL)   /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_LEVEL_LOW_Pos (8UL)        /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bit 8) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_LEVEL_LOW_Msk (0x100UL)    /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_EDGE_HIGH_Pos (7UL)         /*!< GPIO_QSPI_SS_EDGE_HIGH (Bit 7) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_EDGE_HIGH_Msk (0x80UL)      /*!< GPIO_QSPI_SS_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_EDGE_LOW_Pos (6UL)          /*!< GPIO_QSPI_SS_EDGE_LOW (Bit 6) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_EDGE_LOW_Msk (0x40UL)       /*!< GPIO_QSPI_SS_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_LEVEL_HIGH_Pos (5UL)        /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bit 5) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_LEVEL_HIGH_Msk (0x20UL)     /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_LEVEL_LOW_Pos (4UL)         /*!< GPIO_QSPI_SS_LEVEL_LOW (Bit 4) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_LEVEL_LOW_Msk (0x10UL)      /*!< GPIO_QSPI_SS_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_EDGE_HIGH_Pos (3UL)       /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bit 3) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_EDGE_HIGH_Msk (0x8UL)     /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_EDGE_LOW_Pos (2UL)        /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bit 2) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_EDGE_LOW_Msk (0x4UL)      /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_LEVEL_HIGH_Pos (1UL)      /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bit 1) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_LEVEL_HIGH_Msk (0x2UL)    /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_LEVEL_LOW_Pos (0UL)       /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bit 0) */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_LEVEL_LOW_Msk (0x1UL)     /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ======================================================  PROC1_INTS  ======================================================= */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_EDGE_HIGH_Pos (23UL)       /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bit 23) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_EDGE_LOW_Pos (22UL)        /*!< GPIO_QSPI_SD3_EDGE_LOW (Bit 22) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_EDGE_LOW_Msk (0x400000UL)  /*!< GPIO_QSPI_SD3_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_LEVEL_HIGH_Pos (21UL)      /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bit 21) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_LEVEL_LOW_Pos (20UL)       /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bit 20) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_EDGE_HIGH_Pos (19UL)       /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bit 19) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_EDGE_HIGH_Msk (0x80000UL)  /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_EDGE_LOW_Pos (18UL)        /*!< GPIO_QSPI_SD2_EDGE_LOW (Bit 18) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_EDGE_LOW_Msk (0x40000UL)   /*!< GPIO_QSPI_SD2_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_LEVEL_HIGH_Pos (17UL)      /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bit 17) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_LEVEL_LOW_Pos (16UL)       /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bit 16) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_LEVEL_LOW_Msk (0x10000UL)  /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_EDGE_HIGH_Pos (15UL)       /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bit 15) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_EDGE_HIGH_Msk (0x8000UL)   /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_EDGE_LOW_Pos (14UL)        /*!< GPIO_QSPI_SD1_EDGE_LOW (Bit 14) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_EDGE_LOW_Msk (0x4000UL)    /*!< GPIO_QSPI_SD1_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_LEVEL_HIGH_Pos (13UL)      /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bit 13) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_LEVEL_HIGH_Msk (0x2000UL)  /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_LEVEL_LOW_Pos (12UL)       /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bit 12) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_LEVEL_LOW_Msk (0x1000UL)   /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_EDGE_HIGH_Pos (11UL)       /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bit 11) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_EDGE_HIGH_Msk (0x800UL)    /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_EDGE_LOW_Pos (10UL)        /*!< GPIO_QSPI_SD0_EDGE_LOW (Bit 10) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_EDGE_LOW_Msk (0x400UL)     /*!< GPIO_QSPI_SD0_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_LEVEL_HIGH_Pos (9UL)       /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bit 9) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_LEVEL_HIGH_Msk (0x200UL)   /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_LEVEL_LOW_Pos (8UL)        /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bit 8) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_LEVEL_LOW_Msk (0x100UL)    /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_EDGE_HIGH_Pos (7UL)         /*!< GPIO_QSPI_SS_EDGE_HIGH (Bit 7) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_EDGE_HIGH_Msk (0x80UL)      /*!< GPIO_QSPI_SS_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_EDGE_LOW_Pos (6UL)          /*!< GPIO_QSPI_SS_EDGE_LOW (Bit 6) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_EDGE_LOW_Msk (0x40UL)       /*!< GPIO_QSPI_SS_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_LEVEL_HIGH_Pos (5UL)        /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bit 5) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_LEVEL_HIGH_Msk (0x20UL)     /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_LEVEL_LOW_Pos (4UL)         /*!< GPIO_QSPI_SS_LEVEL_LOW (Bit 4) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_LEVEL_LOW_Msk (0x10UL)      /*!< GPIO_QSPI_SS_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_EDGE_HIGH_Pos (3UL)       /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bit 3) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_EDGE_HIGH_Msk (0x8UL)     /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_EDGE_LOW_Pos (2UL)        /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bit 2) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_EDGE_LOW_Msk (0x4UL)      /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_LEVEL_HIGH_Pos (1UL)      /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bit 1) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_LEVEL_HIGH_Msk (0x2UL)    /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_LEVEL_LOW_Pos (0UL)       /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bit 0) */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_LEVEL_LOW_Msk (0x1UL)     /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ===================================================  DORMANT_WAKE_INTE  =================================================== */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_EDGE_HIGH_Pos (23UL) /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bit 23) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_EDGE_LOW_Pos (22UL) /*!< GPIO_QSPI_SD3_EDGE_LOW (Bit 22) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_EDGE_LOW_Msk (0x400000UL) /*!< GPIO_QSPI_SD3_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_LEVEL_HIGH_Pos (21UL) /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bit 21) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_LEVEL_LOW_Pos (20UL) /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bit 20) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_EDGE_HIGH_Pos (19UL) /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bit 19) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_EDGE_HIGH_Msk (0x80000UL) /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_EDGE_LOW_Pos (18UL) /*!< GPIO_QSPI_SD2_EDGE_LOW (Bit 18) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_EDGE_LOW_Msk (0x40000UL) /*!< GPIO_QSPI_SD2_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_LEVEL_HIGH_Pos (17UL) /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bit 17) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_LEVEL_LOW_Pos (16UL) /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bit 16) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_LEVEL_LOW_Msk (0x10000UL) /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_EDGE_HIGH_Pos (15UL) /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bit 15) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_EDGE_HIGH_Msk (0x8000UL) /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_EDGE_LOW_Pos (14UL) /*!< GPIO_QSPI_SD1_EDGE_LOW (Bit 14) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_EDGE_LOW_Msk (0x4000UL) /*!< GPIO_QSPI_SD1_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_LEVEL_HIGH_Pos (13UL) /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bit 13) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_LEVEL_HIGH_Msk (0x2000UL) /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_LEVEL_LOW_Pos (12UL) /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bit 12) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_LEVEL_LOW_Msk (0x1000UL) /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_EDGE_HIGH_Pos (11UL) /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bit 11) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_EDGE_HIGH_Msk (0x800UL) /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_EDGE_LOW_Pos (10UL) /*!< GPIO_QSPI_SD0_EDGE_LOW (Bit 10) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_EDGE_LOW_Msk (0x400UL) /*!< GPIO_QSPI_SD0_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_LEVEL_HIGH_Pos (9UL) /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bit 9) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_LEVEL_HIGH_Msk (0x200UL) /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_LEVEL_LOW_Pos (8UL) /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bit 8) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_LEVEL_LOW_Msk (0x100UL) /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_EDGE_HIGH_Pos (7UL)  /*!< GPIO_QSPI_SS_EDGE_HIGH (Bit 7) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_EDGE_HIGH_Msk (0x80UL) /*!< GPIO_QSPI_SS_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_EDGE_LOW_Pos (6UL)   /*!< GPIO_QSPI_SS_EDGE_LOW (Bit 6) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_EDGE_LOW_Msk (0x40UL) /*!< GPIO_QSPI_SS_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_LEVEL_HIGH_Pos (5UL) /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bit 5) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_LEVEL_HIGH_Msk (0x20UL) /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_LEVEL_LOW_Pos (4UL)  /*!< GPIO_QSPI_SS_LEVEL_LOW (Bit 4) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_LEVEL_LOW_Msk (0x10UL) /*!< GPIO_QSPI_SS_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_EDGE_HIGH_Pos (3UL) /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bit 3) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_EDGE_HIGH_Msk (0x8UL) /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_EDGE_LOW_Pos (2UL) /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bit 2) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_EDGE_LOW_Msk (0x4UL) /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_LEVEL_HIGH_Pos (1UL) /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bit 1) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_LEVEL_HIGH_Msk (0x2UL) /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_LEVEL_LOW_Pos (0UL) /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bit 0) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_LEVEL_LOW_Msk (0x1UL) /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ===================================================  DORMANT_WAKE_INTF  =================================================== */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_EDGE_HIGH_Pos (23UL) /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bit 23) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_EDGE_LOW_Pos (22UL) /*!< GPIO_QSPI_SD3_EDGE_LOW (Bit 22) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_EDGE_LOW_Msk (0x400000UL) /*!< GPIO_QSPI_SD3_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_LEVEL_HIGH_Pos (21UL) /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bit 21) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_LEVEL_LOW_Pos (20UL) /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bit 20) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_EDGE_HIGH_Pos (19UL) /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bit 19) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_EDGE_HIGH_Msk (0x80000UL) /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_EDGE_LOW_Pos (18UL) /*!< GPIO_QSPI_SD2_EDGE_LOW (Bit 18) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_EDGE_LOW_Msk (0x40000UL) /*!< GPIO_QSPI_SD2_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_LEVEL_HIGH_Pos (17UL) /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bit 17) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_LEVEL_LOW_Pos (16UL) /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bit 16) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_LEVEL_LOW_Msk (0x10000UL) /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_EDGE_HIGH_Pos (15UL) /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bit 15) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_EDGE_HIGH_Msk (0x8000UL) /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_EDGE_LOW_Pos (14UL) /*!< GPIO_QSPI_SD1_EDGE_LOW (Bit 14) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_EDGE_LOW_Msk (0x4000UL) /*!< GPIO_QSPI_SD1_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_LEVEL_HIGH_Pos (13UL) /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bit 13) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_LEVEL_HIGH_Msk (0x2000UL) /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_LEVEL_LOW_Pos (12UL) /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bit 12) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_LEVEL_LOW_Msk (0x1000UL) /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_EDGE_HIGH_Pos (11UL) /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bit 11) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_EDGE_HIGH_Msk (0x800UL) /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_EDGE_LOW_Pos (10UL) /*!< GPIO_QSPI_SD0_EDGE_LOW (Bit 10) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_EDGE_LOW_Msk (0x400UL) /*!< GPIO_QSPI_SD0_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_LEVEL_HIGH_Pos (9UL) /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bit 9) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_LEVEL_HIGH_Msk (0x200UL) /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_LEVEL_LOW_Pos (8UL) /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bit 8) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_LEVEL_LOW_Msk (0x100UL) /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_EDGE_HIGH_Pos (7UL)  /*!< GPIO_QSPI_SS_EDGE_HIGH (Bit 7) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_EDGE_HIGH_Msk (0x80UL) /*!< GPIO_QSPI_SS_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_EDGE_LOW_Pos (6UL)   /*!< GPIO_QSPI_SS_EDGE_LOW (Bit 6) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_EDGE_LOW_Msk (0x40UL) /*!< GPIO_QSPI_SS_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_LEVEL_HIGH_Pos (5UL) /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bit 5) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_LEVEL_HIGH_Msk (0x20UL) /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_LEVEL_LOW_Pos (4UL)  /*!< GPIO_QSPI_SS_LEVEL_LOW (Bit 4) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_LEVEL_LOW_Msk (0x10UL) /*!< GPIO_QSPI_SS_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_EDGE_HIGH_Pos (3UL) /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bit 3) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_EDGE_HIGH_Msk (0x8UL) /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_EDGE_LOW_Pos (2UL) /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bit 2) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_EDGE_LOW_Msk (0x4UL) /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_LEVEL_HIGH_Pos (1UL) /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bit 1) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_LEVEL_HIGH_Msk (0x2UL) /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_LEVEL_LOW_Pos (0UL) /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bit 0) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_LEVEL_LOW_Msk (0x1UL) /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bitfield-Mask: 0x01) */
/* ===================================================  DORMANT_WAKE_INTS  =================================================== */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_EDGE_HIGH_Pos (23UL) /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bit 23) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_EDGE_LOW_Pos (22UL) /*!< GPIO_QSPI_SD3_EDGE_LOW (Bit 22) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_EDGE_LOW_Msk (0x400000UL) /*!< GPIO_QSPI_SD3_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_LEVEL_HIGH_Pos (21UL) /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bit 21) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_LEVEL_LOW_Pos (20UL) /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bit 20) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_EDGE_HIGH_Pos (19UL) /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bit 19) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_EDGE_HIGH_Msk (0x80000UL) /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_EDGE_LOW_Pos (18UL) /*!< GPIO_QSPI_SD2_EDGE_LOW (Bit 18) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_EDGE_LOW_Msk (0x40000UL) /*!< GPIO_QSPI_SD2_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_LEVEL_HIGH_Pos (17UL) /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bit 17) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_LEVEL_LOW_Pos (16UL) /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bit 16) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_LEVEL_LOW_Msk (0x10000UL) /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_EDGE_HIGH_Pos (15UL) /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bit 15) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_EDGE_HIGH_Msk (0x8000UL) /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_EDGE_LOW_Pos (14UL) /*!< GPIO_QSPI_SD1_EDGE_LOW (Bit 14) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_EDGE_LOW_Msk (0x4000UL) /*!< GPIO_QSPI_SD1_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_LEVEL_HIGH_Pos (13UL) /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bit 13) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_LEVEL_HIGH_Msk (0x2000UL) /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_LEVEL_LOW_Pos (12UL) /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bit 12) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_LEVEL_LOW_Msk (0x1000UL) /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_EDGE_HIGH_Pos (11UL) /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bit 11) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_EDGE_HIGH_Msk (0x800UL) /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_EDGE_LOW_Pos (10UL) /*!< GPIO_QSPI_SD0_EDGE_LOW (Bit 10) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_EDGE_LOW_Msk (0x400UL) /*!< GPIO_QSPI_SD0_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_LEVEL_HIGH_Pos (9UL) /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bit 9) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_LEVEL_HIGH_Msk (0x200UL) /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_LEVEL_LOW_Pos (8UL) /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bit 8) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_LEVEL_LOW_Msk (0x100UL) /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_EDGE_HIGH_Pos (7UL)  /*!< GPIO_QSPI_SS_EDGE_HIGH (Bit 7) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_EDGE_HIGH_Msk (0x80UL) /*!< GPIO_QSPI_SS_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_EDGE_LOW_Pos (6UL)   /*!< GPIO_QSPI_SS_EDGE_LOW (Bit 6) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_EDGE_LOW_Msk (0x40UL) /*!< GPIO_QSPI_SS_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_LEVEL_HIGH_Pos (5UL) /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bit 5) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_LEVEL_HIGH_Msk (0x20UL) /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_LEVEL_LOW_Pos (4UL)  /*!< GPIO_QSPI_SS_LEVEL_LOW (Bit 4) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_LEVEL_LOW_Msk (0x10UL) /*!< GPIO_QSPI_SS_LEVEL_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_EDGE_HIGH_Pos (3UL) /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bit 3) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_EDGE_HIGH_Msk (0x8UL) /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_EDGE_LOW_Pos (2UL) /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bit 2) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_EDGE_LOW_Msk (0x4UL) /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_LEVEL_HIGH_Pos (1UL) /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bit 1) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_LEVEL_HIGH_Msk (0x2UL) /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_LEVEL_LOW_Pos (0UL) /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bit 0) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_LEVEL_LOW_Msk (0x1UL) /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                        PADS_BANK0                                         ================ */
/* =========================================================================================================================== */

/* ====================================================  VOLTAGE_SELECT  ===================================================== */
#define PADS_BANK0_VOLTAGE_SELECT_VOLTAGE_SELECT_Pos (0UL)          /*!< VOLTAGE_SELECT (Bit 0) */
#define PADS_BANK0_VOLTAGE_SELECT_VOLTAGE_SELECT_Msk (0x1UL)        /*!< VOLTAGE_SELECT (Bitfield-Mask: 0x01) */
/* =========================================================  GPIO0  ========================================================= */
#define PADS_BANK0_GPIO0_OD_Pos           (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_GPIO0_OD_Msk           (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO0_IE_Pos           (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_GPIO0_IE_Msk           (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO0_DRIVE_Pos        (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_GPIO0_DRIVE_Msk        (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_GPIO0_PUE_Pos          (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_GPIO0_PUE_Msk          (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO0_PDE_Pos          (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_GPIO0_PDE_Msk          (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO0_SCHMITT_Pos      (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_GPIO0_SCHMITT_Msk      (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO0_SLEWFAST_Pos     (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_GPIO0_SLEWFAST_Msk     (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* =========================================================  GPIO1  ========================================================= */
#define PADS_BANK0_GPIO1_OD_Pos           (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_GPIO1_OD_Msk           (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO1_IE_Pos           (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_GPIO1_IE_Msk           (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO1_DRIVE_Pos        (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_GPIO1_DRIVE_Msk        (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_GPIO1_PUE_Pos          (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_GPIO1_PUE_Msk          (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO1_PDE_Pos          (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_GPIO1_PDE_Msk          (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO1_SCHMITT_Pos      (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_GPIO1_SCHMITT_Msk      (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO1_SLEWFAST_Pos     (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_GPIO1_SLEWFAST_Msk     (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* =========================================================  GPIO2  ========================================================= */
#define PADS_BANK0_GPIO2_OD_Pos           (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_GPIO2_OD_Msk           (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO2_IE_Pos           (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_GPIO2_IE_Msk           (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO2_DRIVE_Pos        (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_GPIO2_DRIVE_Msk        (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_GPIO2_PUE_Pos          (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_GPIO2_PUE_Msk          (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO2_PDE_Pos          (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_GPIO2_PDE_Msk          (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO2_SCHMITT_Pos      (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_GPIO2_SCHMITT_Msk      (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO2_SLEWFAST_Pos     (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_GPIO2_SLEWFAST_Msk     (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* =========================================================  GPIO3  ========================================================= */
#define PADS_BANK0_GPIO3_OD_Pos           (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_GPIO3_OD_Msk           (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO3_IE_Pos           (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_GPIO3_IE_Msk           (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO3_DRIVE_Pos        (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_GPIO3_DRIVE_Msk        (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_GPIO3_PUE_Pos          (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_GPIO3_PUE_Msk          (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO3_PDE_Pos          (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_GPIO3_PDE_Msk          (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO3_SCHMITT_Pos      (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_GPIO3_SCHMITT_Msk      (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO3_SLEWFAST_Pos     (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_GPIO3_SLEWFAST_Msk     (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* =========================================================  GPIO4  ========================================================= */
#define PADS_BANK0_GPIO4_OD_Pos           (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_GPIO4_OD_Msk           (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO4_IE_Pos           (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_GPIO4_IE_Msk           (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO4_DRIVE_Pos        (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_GPIO4_DRIVE_Msk        (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_GPIO4_PUE_Pos          (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_GPIO4_PUE_Msk          (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO4_PDE_Pos          (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_GPIO4_PDE_Msk          (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO4_SCHMITT_Pos      (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_GPIO4_SCHMITT_Msk      (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO4_SLEWFAST_Pos     (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_GPIO4_SLEWFAST_Msk     (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* =========================================================  GPIO5  ========================================================= */
#define PADS_BANK0_GPIO5_OD_Pos           (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_GPIO5_OD_Msk           (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO5_IE_Pos           (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_GPIO5_IE_Msk           (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO5_DRIVE_Pos        (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_GPIO5_DRIVE_Msk        (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_GPIO5_PUE_Pos          (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_GPIO5_PUE_Msk          (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO5_PDE_Pos          (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_GPIO5_PDE_Msk          (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO5_SCHMITT_Pos      (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_GPIO5_SCHMITT_Msk      (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO5_SLEWFAST_Pos     (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_GPIO5_SLEWFAST_Msk     (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* =========================================================  GPIO6  ========================================================= */
#define PADS_BANK0_GPIO6_OD_Pos           (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_GPIO6_OD_Msk           (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO6_IE_Pos           (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_GPIO6_IE_Msk           (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO6_DRIVE_Pos        (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_GPIO6_DRIVE_Msk        (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_GPIO6_PUE_Pos          (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_GPIO6_PUE_Msk          (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO6_PDE_Pos          (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_GPIO6_PDE_Msk          (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO6_SCHMITT_Pos      (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_GPIO6_SCHMITT_Msk      (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO6_SLEWFAST_Pos     (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_GPIO6_SLEWFAST_Msk     (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* =========================================================  GPIO7  ========================================================= */
#define PADS_BANK0_GPIO7_OD_Pos           (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_GPIO7_OD_Msk           (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO7_IE_Pos           (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_GPIO7_IE_Msk           (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO7_DRIVE_Pos        (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_GPIO7_DRIVE_Msk        (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_GPIO7_PUE_Pos          (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_GPIO7_PUE_Msk          (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO7_PDE_Pos          (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_GPIO7_PDE_Msk          (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO7_SCHMITT_Pos      (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_GPIO7_SCHMITT_Msk      (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO7_SLEWFAST_Pos     (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_GPIO7_SLEWFAST_Msk     (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* =========================================================  GPIO8  ========================================================= */
#define PADS_BANK0_GPIO8_OD_Pos           (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_GPIO8_OD_Msk           (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO8_IE_Pos           (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_GPIO8_IE_Msk           (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO8_DRIVE_Pos        (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_GPIO8_DRIVE_Msk        (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_GPIO8_PUE_Pos          (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_GPIO8_PUE_Msk          (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO8_PDE_Pos          (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_GPIO8_PDE_Msk          (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO8_SCHMITT_Pos      (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_GPIO8_SCHMITT_Msk      (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO8_SLEWFAST_Pos     (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_GPIO8_SLEWFAST_Msk     (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* =========================================================  GPIO9  ========================================================= */
#define PADS_BANK0_GPIO9_OD_Pos           (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_GPIO9_OD_Msk           (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO9_IE_Pos           (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_GPIO9_IE_Msk           (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO9_DRIVE_Pos        (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_GPIO9_DRIVE_Msk        (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_GPIO9_PUE_Pos          (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_GPIO9_PUE_Msk          (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO9_PDE_Pos          (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_GPIO9_PDE_Msk          (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO9_SCHMITT_Pos      (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_GPIO9_SCHMITT_Msk      (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO9_SLEWFAST_Pos     (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_GPIO9_SLEWFAST_Msk     (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* ========================================================  GPIO10  ========================================================= */
#define PADS_BANK0_GPIO10_OD_Pos          (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_GPIO10_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO10_IE_Pos          (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_GPIO10_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO10_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_GPIO10_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_GPIO10_PUE_Pos         (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_GPIO10_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO10_PDE_Pos         (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_GPIO10_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO10_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_GPIO10_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO10_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_GPIO10_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* ========================================================  GPIO11  ========================================================= */
#define PADS_BANK0_GPIO11_OD_Pos          (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_GPIO11_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO11_IE_Pos          (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_GPIO11_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO11_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_GPIO11_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_GPIO11_PUE_Pos         (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_GPIO11_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO11_PDE_Pos         (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_GPIO11_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO11_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_GPIO11_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO11_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_GPIO11_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* ========================================================  GPIO12  ========================================================= */
#define PADS_BANK0_GPIO12_OD_Pos          (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_GPIO12_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO12_IE_Pos          (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_GPIO12_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO12_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_GPIO12_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_GPIO12_PUE_Pos         (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_GPIO12_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO12_PDE_Pos         (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_GPIO12_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO12_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_GPIO12_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO12_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_GPIO12_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* ========================================================  GPIO13  ========================================================= */
#define PADS_BANK0_GPIO13_OD_Pos          (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_GPIO13_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO13_IE_Pos          (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_GPIO13_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO13_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_GPIO13_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_GPIO13_PUE_Pos         (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_GPIO13_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO13_PDE_Pos         (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_GPIO13_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO13_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_GPIO13_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO13_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_GPIO13_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* ========================================================  GPIO14  ========================================================= */
#define PADS_BANK0_GPIO14_OD_Pos          (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_GPIO14_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO14_IE_Pos          (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_GPIO14_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO14_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_GPIO14_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_GPIO14_PUE_Pos         (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_GPIO14_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO14_PDE_Pos         (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_GPIO14_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO14_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_GPIO14_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO14_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_GPIO14_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* ========================================================  GPIO15  ========================================================= */
#define PADS_BANK0_GPIO15_OD_Pos          (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_GPIO15_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO15_IE_Pos          (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_GPIO15_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO15_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_GPIO15_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_GPIO15_PUE_Pos         (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_GPIO15_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO15_PDE_Pos         (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_GPIO15_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO15_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_GPIO15_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO15_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_GPIO15_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* ========================================================  GPIO16  ========================================================= */
#define PADS_BANK0_GPIO16_OD_Pos          (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_GPIO16_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO16_IE_Pos          (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_GPIO16_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO16_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_GPIO16_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_GPIO16_PUE_Pos         (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_GPIO16_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO16_PDE_Pos         (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_GPIO16_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO16_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_GPIO16_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO16_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_GPIO16_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* ========================================================  GPIO17  ========================================================= */
#define PADS_BANK0_GPIO17_OD_Pos          (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_GPIO17_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO17_IE_Pos          (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_GPIO17_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO17_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_GPIO17_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_GPIO17_PUE_Pos         (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_GPIO17_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO17_PDE_Pos         (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_GPIO17_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO17_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_GPIO17_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO17_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_GPIO17_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* ========================================================  GPIO18  ========================================================= */
#define PADS_BANK0_GPIO18_OD_Pos          (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_GPIO18_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO18_IE_Pos          (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_GPIO18_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO18_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_GPIO18_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_GPIO18_PUE_Pos         (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_GPIO18_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO18_PDE_Pos         (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_GPIO18_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO18_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_GPIO18_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO18_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_GPIO18_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* ========================================================  GPIO19  ========================================================= */
#define PADS_BANK0_GPIO19_OD_Pos          (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_GPIO19_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO19_IE_Pos          (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_GPIO19_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO19_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_GPIO19_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_GPIO19_PUE_Pos         (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_GPIO19_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO19_PDE_Pos         (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_GPIO19_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO19_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_GPIO19_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO19_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_GPIO19_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* ========================================================  GPIO20  ========================================================= */
#define PADS_BANK0_GPIO20_OD_Pos          (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_GPIO20_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO20_IE_Pos          (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_GPIO20_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO20_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_GPIO20_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_GPIO20_PUE_Pos         (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_GPIO20_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO20_PDE_Pos         (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_GPIO20_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO20_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_GPIO20_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO20_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_GPIO20_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* ========================================================  GPIO21  ========================================================= */
#define PADS_BANK0_GPIO21_OD_Pos          (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_GPIO21_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO21_IE_Pos          (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_GPIO21_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO21_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_GPIO21_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_GPIO21_PUE_Pos         (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_GPIO21_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO21_PDE_Pos         (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_GPIO21_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO21_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_GPIO21_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO21_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_GPIO21_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* ========================================================  GPIO22  ========================================================= */
#define PADS_BANK0_GPIO22_OD_Pos          (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_GPIO22_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO22_IE_Pos          (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_GPIO22_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO22_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_GPIO22_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_GPIO22_PUE_Pos         (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_GPIO22_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO22_PDE_Pos         (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_GPIO22_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO22_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_GPIO22_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO22_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_GPIO22_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* ========================================================  GPIO23  ========================================================= */
#define PADS_BANK0_GPIO23_OD_Pos          (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_GPIO23_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO23_IE_Pos          (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_GPIO23_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO23_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_GPIO23_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_GPIO23_PUE_Pos         (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_GPIO23_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO23_PDE_Pos         (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_GPIO23_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO23_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_GPIO23_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO23_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_GPIO23_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* ========================================================  GPIO24  ========================================================= */
#define PADS_BANK0_GPIO24_OD_Pos          (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_GPIO24_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO24_IE_Pos          (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_GPIO24_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO24_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_GPIO24_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_GPIO24_PUE_Pos         (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_GPIO24_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO24_PDE_Pos         (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_GPIO24_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO24_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_GPIO24_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO24_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_GPIO24_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* ========================================================  GPIO25  ========================================================= */
#define PADS_BANK0_GPIO25_OD_Pos          (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_GPIO25_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO25_IE_Pos          (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_GPIO25_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO25_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_GPIO25_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_GPIO25_PUE_Pos         (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_GPIO25_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO25_PDE_Pos         (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_GPIO25_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO25_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_GPIO25_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO25_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_GPIO25_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* ========================================================  GPIO26  ========================================================= */
#define PADS_BANK0_GPIO26_OD_Pos          (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_GPIO26_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO26_IE_Pos          (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_GPIO26_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO26_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_GPIO26_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_GPIO26_PUE_Pos         (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_GPIO26_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO26_PDE_Pos         (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_GPIO26_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO26_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_GPIO26_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO26_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_GPIO26_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* ========================================================  GPIO27  ========================================================= */
#define PADS_BANK0_GPIO27_OD_Pos          (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_GPIO27_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO27_IE_Pos          (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_GPIO27_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO27_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_GPIO27_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_GPIO27_PUE_Pos         (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_GPIO27_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO27_PDE_Pos         (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_GPIO27_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO27_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_GPIO27_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO27_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_GPIO27_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* ========================================================  GPIO28  ========================================================= */
#define PADS_BANK0_GPIO28_OD_Pos          (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_GPIO28_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO28_IE_Pos          (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_GPIO28_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO28_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_GPIO28_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_GPIO28_PUE_Pos         (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_GPIO28_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO28_PDE_Pos         (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_GPIO28_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO28_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_GPIO28_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO28_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_GPIO28_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* ========================================================  GPIO29  ========================================================= */
#define PADS_BANK0_GPIO29_OD_Pos          (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_GPIO29_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO29_IE_Pos          (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_GPIO29_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO29_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_GPIO29_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_GPIO29_PUE_Pos         (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_GPIO29_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO29_PDE_Pos         (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_GPIO29_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO29_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_GPIO29_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_GPIO29_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_GPIO29_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* =========================================================  SWCLK  ========================================================= */
#define PADS_BANK0_SWCLK_OD_Pos           (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_SWCLK_OD_Msk           (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_SWCLK_IE_Pos           (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_SWCLK_IE_Msk           (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_SWCLK_DRIVE_Pos        (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_SWCLK_DRIVE_Msk        (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_SWCLK_PUE_Pos          (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_SWCLK_PUE_Msk          (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_SWCLK_PDE_Pos          (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_SWCLK_PDE_Msk          (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_SWCLK_SCHMITT_Pos      (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_SWCLK_SCHMITT_Msk      (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_SWCLK_SLEWFAST_Pos     (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_SWCLK_SLEWFAST_Msk     (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* ==========================================================  SWD  ========================================================== */
#define PADS_BANK0_SWD_OD_Pos             (7UL)                     /*!< OD (Bit 7) */
#define PADS_BANK0_SWD_OD_Msk             (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_BANK0_SWD_IE_Pos             (6UL)                     /*!< IE (Bit 6) */
#define PADS_BANK0_SWD_IE_Msk             (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_SWD_DRIVE_Pos          (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_BANK0_SWD_DRIVE_Msk          (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_BANK0_SWD_PUE_Pos            (3UL)                     /*!< PUE (Bit 3) */
#define PADS_BANK0_SWD_PUE_Msk            (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_SWD_PDE_Pos            (2UL)                     /*!< PDE (Bit 2) */
#define PADS_BANK0_SWD_PDE_Msk            (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_BANK0_SWD_SCHMITT_Pos        (1UL)                     /*!< SCHMITT (Bit 1) */
#define PADS_BANK0_SWD_SCHMITT_Msk        (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_BANK0_SWD_SLEWFAST_Pos       (0UL)                     /*!< SLEWFAST (Bit 0) */
#define PADS_BANK0_SWD_SLEWFAST_Msk       (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                         PADS_QSPI                                         ================ */
/* =========================================================================================================================== */

/* ====================================================  VOLTAGE_SELECT  ===================================================== */
#define PADS_QSPI_VOLTAGE_SELECT_VOLTAGE_SELECT_Pos (0UL)           /*!< VOLTAGE_SELECT (Bit 0) */
#define PADS_QSPI_VOLTAGE_SELECT_VOLTAGE_SELECT_Msk (0x1UL)         /*!< VOLTAGE_SELECT (Bitfield-Mask: 0x01) */
/* ====================================================  GPIO_QSPI_SCLK  ===================================================== */
#define PADS_QSPI_GPIO_QSPI_SCLK_OD_Pos   (7UL)                     /*!< OD (Bit 7) */
#define PADS_QSPI_GPIO_QSPI_SCLK_OD_Msk   (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_QSPI_GPIO_QSPI_SCLK_IE_Pos   (6UL)                     /*!< IE (Bit 6) */
#define PADS_QSPI_GPIO_QSPI_SCLK_IE_Msk   (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_QSPI_GPIO_QSPI_SCLK_DRIVE_Pos (4UL)                    /*!< DRIVE (Bit 4) */
#define PADS_QSPI_GPIO_QSPI_SCLK_DRIVE_Msk (0x30UL)                 /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_QSPI_GPIO_QSPI_SCLK_PUE_Pos  (3UL)                     /*!< PUE (Bit 3) */
#define PADS_QSPI_GPIO_QSPI_SCLK_PUE_Msk  (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_QSPI_GPIO_QSPI_SCLK_PDE_Pos  (2UL)                     /*!< PDE (Bit 2) */
#define PADS_QSPI_GPIO_QSPI_SCLK_PDE_Msk  (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_QSPI_GPIO_QSPI_SCLK_SCHMITT_Pos (1UL)                  /*!< SCHMITT (Bit 1) */
#define PADS_QSPI_GPIO_QSPI_SCLK_SCHMITT_Msk (0x2UL)                /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_QSPI_GPIO_QSPI_SCLK_SLEWFAST_Pos (0UL)                 /*!< SLEWFAST (Bit 0) */
#define PADS_QSPI_GPIO_QSPI_SCLK_SLEWFAST_Msk (0x1UL)               /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* =====================================================  GPIO_QSPI_SD0  ===================================================== */
#define PADS_QSPI_GPIO_QSPI_SD0_OD_Pos    (7UL)                     /*!< OD (Bit 7) */
#define PADS_QSPI_GPIO_QSPI_SD0_OD_Msk    (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_QSPI_GPIO_QSPI_SD0_IE_Pos    (6UL)                     /*!< IE (Bit 6) */
#define PADS_QSPI_GPIO_QSPI_SD0_IE_Msk    (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_QSPI_GPIO_QSPI_SD0_DRIVE_Pos (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_QSPI_GPIO_QSPI_SD0_DRIVE_Msk (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_QSPI_GPIO_QSPI_SD0_PUE_Pos   (3UL)                     /*!< PUE (Bit 3) */
#define PADS_QSPI_GPIO_QSPI_SD0_PUE_Msk   (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_QSPI_GPIO_QSPI_SD0_PDE_Pos   (2UL)                     /*!< PDE (Bit 2) */
#define PADS_QSPI_GPIO_QSPI_SD0_PDE_Msk   (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_QSPI_GPIO_QSPI_SD0_SCHMITT_Pos (1UL)                   /*!< SCHMITT (Bit 1) */
#define PADS_QSPI_GPIO_QSPI_SD0_SCHMITT_Msk (0x2UL)                 /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_QSPI_GPIO_QSPI_SD0_SLEWFAST_Pos (0UL)                  /*!< SLEWFAST (Bit 0) */
#define PADS_QSPI_GPIO_QSPI_SD0_SLEWFAST_Msk (0x1UL)                /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* =====================================================  GPIO_QSPI_SD1  ===================================================== */
#define PADS_QSPI_GPIO_QSPI_SD1_OD_Pos    (7UL)                     /*!< OD (Bit 7) */
#define PADS_QSPI_GPIO_QSPI_SD1_OD_Msk    (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_QSPI_GPIO_QSPI_SD1_IE_Pos    (6UL)                     /*!< IE (Bit 6) */
#define PADS_QSPI_GPIO_QSPI_SD1_IE_Msk    (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_QSPI_GPIO_QSPI_SD1_DRIVE_Pos (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_QSPI_GPIO_QSPI_SD1_DRIVE_Msk (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_QSPI_GPIO_QSPI_SD1_PUE_Pos   (3UL)                     /*!< PUE (Bit 3) */
#define PADS_QSPI_GPIO_QSPI_SD1_PUE_Msk   (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_QSPI_GPIO_QSPI_SD1_PDE_Pos   (2UL)                     /*!< PDE (Bit 2) */
#define PADS_QSPI_GPIO_QSPI_SD1_PDE_Msk   (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_QSPI_GPIO_QSPI_SD1_SCHMITT_Pos (1UL)                   /*!< SCHMITT (Bit 1) */
#define PADS_QSPI_GPIO_QSPI_SD1_SCHMITT_Msk (0x2UL)                 /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_QSPI_GPIO_QSPI_SD1_SLEWFAST_Pos (0UL)                  /*!< SLEWFAST (Bit 0) */
#define PADS_QSPI_GPIO_QSPI_SD1_SLEWFAST_Msk (0x1UL)                /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* =====================================================  GPIO_QSPI_SD2  ===================================================== */
#define PADS_QSPI_GPIO_QSPI_SD2_OD_Pos    (7UL)                     /*!< OD (Bit 7) */
#define PADS_QSPI_GPIO_QSPI_SD2_OD_Msk    (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_QSPI_GPIO_QSPI_SD2_IE_Pos    (6UL)                     /*!< IE (Bit 6) */
#define PADS_QSPI_GPIO_QSPI_SD2_IE_Msk    (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_QSPI_GPIO_QSPI_SD2_DRIVE_Pos (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_QSPI_GPIO_QSPI_SD2_DRIVE_Msk (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_QSPI_GPIO_QSPI_SD2_PUE_Pos   (3UL)                     /*!< PUE (Bit 3) */
#define PADS_QSPI_GPIO_QSPI_SD2_PUE_Msk   (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_QSPI_GPIO_QSPI_SD2_PDE_Pos   (2UL)                     /*!< PDE (Bit 2) */
#define PADS_QSPI_GPIO_QSPI_SD2_PDE_Msk   (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_QSPI_GPIO_QSPI_SD2_SCHMITT_Pos (1UL)                   /*!< SCHMITT (Bit 1) */
#define PADS_QSPI_GPIO_QSPI_SD2_SCHMITT_Msk (0x2UL)                 /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_QSPI_GPIO_QSPI_SD2_SLEWFAST_Pos (0UL)                  /*!< SLEWFAST (Bit 0) */
#define PADS_QSPI_GPIO_QSPI_SD2_SLEWFAST_Msk (0x1UL)                /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* =====================================================  GPIO_QSPI_SD3  ===================================================== */
#define PADS_QSPI_GPIO_QSPI_SD3_OD_Pos    (7UL)                     /*!< OD (Bit 7) */
#define PADS_QSPI_GPIO_QSPI_SD3_OD_Msk    (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_QSPI_GPIO_QSPI_SD3_IE_Pos    (6UL)                     /*!< IE (Bit 6) */
#define PADS_QSPI_GPIO_QSPI_SD3_IE_Msk    (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_QSPI_GPIO_QSPI_SD3_DRIVE_Pos (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_QSPI_GPIO_QSPI_SD3_DRIVE_Msk (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_QSPI_GPIO_QSPI_SD3_PUE_Pos   (3UL)                     /*!< PUE (Bit 3) */
#define PADS_QSPI_GPIO_QSPI_SD3_PUE_Msk   (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_QSPI_GPIO_QSPI_SD3_PDE_Pos   (2UL)                     /*!< PDE (Bit 2) */
#define PADS_QSPI_GPIO_QSPI_SD3_PDE_Msk   (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_QSPI_GPIO_QSPI_SD3_SCHMITT_Pos (1UL)                   /*!< SCHMITT (Bit 1) */
#define PADS_QSPI_GPIO_QSPI_SD3_SCHMITT_Msk (0x2UL)                 /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_QSPI_GPIO_QSPI_SD3_SLEWFAST_Pos (0UL)                  /*!< SLEWFAST (Bit 0) */
#define PADS_QSPI_GPIO_QSPI_SD3_SLEWFAST_Msk (0x1UL)                /*!< SLEWFAST (Bitfield-Mask: 0x01) */
/* =====================================================  GPIO_QSPI_SS  ====================================================== */
#define PADS_QSPI_GPIO_QSPI_SS_OD_Pos     (7UL)                     /*!< OD (Bit 7) */
#define PADS_QSPI_GPIO_QSPI_SS_OD_Msk     (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01) */
#define PADS_QSPI_GPIO_QSPI_SS_IE_Pos     (6UL)                     /*!< IE (Bit 6) */
#define PADS_QSPI_GPIO_QSPI_SS_IE_Msk     (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01) */
#define PADS_QSPI_GPIO_QSPI_SS_DRIVE_Pos  (4UL)                     /*!< DRIVE (Bit 4) */
#define PADS_QSPI_GPIO_QSPI_SS_DRIVE_Msk  (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03) */
#define PADS_QSPI_GPIO_QSPI_SS_PUE_Pos    (3UL)                     /*!< PUE (Bit 3) */
#define PADS_QSPI_GPIO_QSPI_SS_PUE_Msk    (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01) */
#define PADS_QSPI_GPIO_QSPI_SS_PDE_Pos    (2UL)                     /*!< PDE (Bit 2) */
#define PADS_QSPI_GPIO_QSPI_SS_PDE_Msk    (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01) */
#define PADS_QSPI_GPIO_QSPI_SS_SCHMITT_Pos (1UL)                    /*!< SCHMITT (Bit 1) */
#define PADS_QSPI_GPIO_QSPI_SS_SCHMITT_Msk (0x2UL)                  /*!< SCHMITT (Bitfield-Mask: 0x01) */
#define PADS_QSPI_GPIO_QSPI_SS_SLEWFAST_Pos (0UL)                   /*!< SLEWFAST (Bit 0) */
#define PADS_QSPI_GPIO_QSPI_SS_SLEWFAST_Msk (0x1UL)                 /*!< SLEWFAST (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                           XOSC                                            ================ */
/* =========================================================================================================================== */

/* =========================================================  CTRL  ========================================================== */
#define XOSC_CTRL_ENABLE_Pos              (12UL)                    /*!< ENABLE (Bit 12) */
#define XOSC_CTRL_ENABLE_Msk              (0xfff000UL)              /*!< ENABLE (Bitfield-Mask: 0xfff) */
#define XOSC_CTRL_FREQ_RANGE_Pos          (0UL)                     /*!< FREQ_RANGE (Bit 0) */
#define XOSC_CTRL_FREQ_RANGE_Msk          (0xfffUL)                 /*!< FREQ_RANGE (Bitfield-Mask: 0xfff) */
/* ========================================================  STATUS  ========================================================= */
#define XOSC_STATUS_STABLE_Pos            (31UL)                    /*!< STABLE (Bit 31) */
#define XOSC_STATUS_STABLE_Msk            (0x80000000UL)            /*!< STABLE (Bitfield-Mask: 0x01) */
#define XOSC_STATUS_BADWRITE_Pos          (24UL)                    /*!< BADWRITE (Bit 24) */
#define XOSC_STATUS_BADWRITE_Msk          (0x1000000UL)             /*!< BADWRITE (Bitfield-Mask: 0x01) */
#define XOSC_STATUS_ENABLED_Pos           (12UL)                    /*!< ENABLED (Bit 12) */
#define XOSC_STATUS_ENABLED_Msk           (0x1000UL)                /*!< ENABLED (Bitfield-Mask: 0x01) */
#define XOSC_STATUS_FREQ_RANGE_Pos        (0UL)                     /*!< FREQ_RANGE (Bit 0) */
#define XOSC_STATUS_FREQ_RANGE_Msk        (0x3UL)                   /*!< FREQ_RANGE (Bitfield-Mask: 0x03) */
/* ========================================================  DORMANT  ======================================================== */
/* ========================================================  STARTUP  ======================================================== */
#define XOSC_STARTUP_X4_Pos               (20UL)                    /*!< X4 (Bit 20) */
#define XOSC_STARTUP_X4_Msk               (0x100000UL)              /*!< X4 (Bitfield-Mask: 0x01) */
#define XOSC_STARTUP_DELAY_Pos            (0UL)                     /*!< DELAY (Bit 0) */
#define XOSC_STARTUP_DELAY_Msk            (0x3fffUL)                /*!< DELAY (Bitfield-Mask: 0x3fff) */
/* =========================================================  COUNT  ========================================================= */
#define XOSC_COUNT_COUNT_Pos              (0UL)                     /*!< COUNT (Bit 0) */
#define XOSC_COUNT_COUNT_Msk              (0xffUL)                  /*!< COUNT (Bitfield-Mask: 0xff) */


/* =========================================================================================================================== */
/* ================                                          PLL_SYS                                          ================ */
/* =========================================================================================================================== */

/* ==========================================================  CS  =========================================================== */
#define PLL_SYS_CS_LOCK_Pos               (31UL)                    /*!< LOCK (Bit 31) */
#define PLL_SYS_CS_LOCK_Msk               (0x80000000UL)            /*!< LOCK (Bitfield-Mask: 0x01) */
#define PLL_SYS_CS_BYPASS_Pos             (8UL)                     /*!< BYPASS (Bit 8) */
#define PLL_SYS_CS_BYPASS_Msk             (0x100UL)                 /*!< BYPASS (Bitfield-Mask: 0x01) */
#define PLL_SYS_CS_REFDIV_Pos             (0UL)                     /*!< REFDIV (Bit 0) */
#define PLL_SYS_CS_REFDIV_Msk             (0x3fUL)                  /*!< REFDIV (Bitfield-Mask: 0x3f) */
/* ==========================================================  PWR  ========================================================== */
#define PLL_SYS_PWR_VCOPD_Pos             (5UL)                     /*!< VCOPD (Bit 5) */
#define PLL_SYS_PWR_VCOPD_Msk             (0x20UL)                  /*!< VCOPD (Bitfield-Mask: 0x01) */
#define PLL_SYS_PWR_POSTDIVPD_Pos         (3UL)                     /*!< POSTDIVPD (Bit 3) */
#define PLL_SYS_PWR_POSTDIVPD_Msk         (0x8UL)                   /*!< POSTDIVPD (Bitfield-Mask: 0x01) */
#define PLL_SYS_PWR_DSMPD_Pos             (2UL)                     /*!< DSMPD (Bit 2) */
#define PLL_SYS_PWR_DSMPD_Msk             (0x4UL)                   /*!< DSMPD (Bitfield-Mask: 0x01) */
#define PLL_SYS_PWR_PD_Pos                (0UL)                     /*!< PD (Bit 0) */
#define PLL_SYS_PWR_PD_Msk                (0x1UL)                   /*!< PD (Bitfield-Mask: 0x01) */
/* =======================================================  FBDIV_INT  ======================================================= */
#define PLL_SYS_FBDIV_INT_FBDIV_INT_Pos   (0UL)                     /*!< FBDIV_INT (Bit 0) */
#define PLL_SYS_FBDIV_INT_FBDIV_INT_Msk   (0xfffUL)                 /*!< FBDIV_INT (Bitfield-Mask: 0xfff) */
/* =========================================================  PRIM  ========================================================== */
#define PLL_SYS_PRIM_POSTDIV1_Pos         (16UL)                    /*!< POSTDIV1 (Bit 16) */
#define PLL_SYS_PRIM_POSTDIV1_Msk         (0x70000UL)               /*!< POSTDIV1 (Bitfield-Mask: 0x07) */
#define PLL_SYS_PRIM_POSTDIV2_Pos         (12UL)                    /*!< POSTDIV2 (Bit 12) */
#define PLL_SYS_PRIM_POSTDIV2_Msk         (0x7000UL)                /*!< POSTDIV2 (Bitfield-Mask: 0x07) */


/* =========================================================================================================================== */
/* ================                                          BUSCTRL                                          ================ */
/* =========================================================================================================================== */

/* =====================================================  BUS_PRIORITY  ====================================================== */
#define BUSCTRL_BUS_PRIORITY_DMA_W_Pos    (12UL)                    /*!< DMA_W (Bit 12) */
#define BUSCTRL_BUS_PRIORITY_DMA_W_Msk    (0x1000UL)                /*!< DMA_W (Bitfield-Mask: 0x01) */
#define BUSCTRL_BUS_PRIORITY_DMA_R_Pos    (8UL)                     /*!< DMA_R (Bit 8) */
#define BUSCTRL_BUS_PRIORITY_DMA_R_Msk    (0x100UL)                 /*!< DMA_R (Bitfield-Mask: 0x01) */
#define BUSCTRL_BUS_PRIORITY_PROC1_Pos    (4UL)                     /*!< PROC1 (Bit 4) */
#define BUSCTRL_BUS_PRIORITY_PROC1_Msk    (0x10UL)                  /*!< PROC1 (Bitfield-Mask: 0x01) */
#define BUSCTRL_BUS_PRIORITY_PROC0_Pos    (0UL)                     /*!< PROC0 (Bit 0) */
#define BUSCTRL_BUS_PRIORITY_PROC0_Msk    (0x1UL)                   /*!< PROC0 (Bitfield-Mask: 0x01) */
/* ===================================================  BUS_PRIORITY_ACK  ==================================================== */
#define BUSCTRL_BUS_PRIORITY_ACK_BUS_PRIORITY_ACK_Pos (0UL)         /*!< BUS_PRIORITY_ACK (Bit 0) */
#define BUSCTRL_BUS_PRIORITY_ACK_BUS_PRIORITY_ACK_Msk (0x1UL)       /*!< BUS_PRIORITY_ACK (Bitfield-Mask: 0x01) */
/* =======================================================  PERFCTR0  ======================================================== */
#define BUSCTRL_PERFCTR0_PERFCTR0_Pos     (0UL)                     /*!< PERFCTR0 (Bit 0) */
#define BUSCTRL_PERFCTR0_PERFCTR0_Msk     (0xffffffUL)              /*!< PERFCTR0 (Bitfield-Mask: 0xffffff) */
/* =======================================================  PERFSEL0  ======================================================== */
#define BUSCTRL_PERFSEL0_PERFSEL0_Pos     (0UL)                     /*!< PERFSEL0 (Bit 0) */
#define BUSCTRL_PERFSEL0_PERFSEL0_Msk     (0x1fUL)                  /*!< PERFSEL0 (Bitfield-Mask: 0x1f) */
/* =======================================================  PERFCTR1  ======================================================== */
#define BUSCTRL_PERFCTR1_PERFCTR1_Pos     (0UL)                     /*!< PERFCTR1 (Bit 0) */
#define BUSCTRL_PERFCTR1_PERFCTR1_Msk     (0xffffffUL)              /*!< PERFCTR1 (Bitfield-Mask: 0xffffff) */
/* =======================================================  PERFSEL1  ======================================================== */
#define BUSCTRL_PERFSEL1_PERFSEL1_Pos     (0UL)                     /*!< PERFSEL1 (Bit 0) */
#define BUSCTRL_PERFSEL1_PERFSEL1_Msk     (0x1fUL)                  /*!< PERFSEL1 (Bitfield-Mask: 0x1f) */
/* =======================================================  PERFCTR2  ======================================================== */
#define BUSCTRL_PERFCTR2_PERFCTR2_Pos     (0UL)                     /*!< PERFCTR2 (Bit 0) */
#define BUSCTRL_PERFCTR2_PERFCTR2_Msk     (0xffffffUL)              /*!< PERFCTR2 (Bitfield-Mask: 0xffffff) */
/* =======================================================  PERFSEL2  ======================================================== */
#define BUSCTRL_PERFSEL2_PERFSEL2_Pos     (0UL)                     /*!< PERFSEL2 (Bit 0) */
#define BUSCTRL_PERFSEL2_PERFSEL2_Msk     (0x1fUL)                  /*!< PERFSEL2 (Bitfield-Mask: 0x1f) */
/* =======================================================  PERFCTR3  ======================================================== */
#define BUSCTRL_PERFCTR3_PERFCTR3_Pos     (0UL)                     /*!< PERFCTR3 (Bit 0) */
#define BUSCTRL_PERFCTR3_PERFCTR3_Msk     (0xffffffUL)              /*!< PERFCTR3 (Bitfield-Mask: 0xffffff) */
/* =======================================================  PERFSEL3  ======================================================== */
#define BUSCTRL_PERFSEL3_PERFSEL3_Pos     (0UL)                     /*!< PERFSEL3 (Bit 0) */
#define BUSCTRL_PERFSEL3_PERFSEL3_Msk     (0x1fUL)                  /*!< PERFSEL3 (Bitfield-Mask: 0x1f) */


/* =========================================================================================================================== */
/* ================                                           UART0                                           ================ */
/* =========================================================================================================================== */

/* ========================================================  UARTDR  ========================================================= */
#define UART0_UARTDR_OE_Pos               (11UL)                    /*!< OE (Bit 11) */
#define UART0_UARTDR_OE_Msk               (0x800UL)                 /*!< OE (Bitfield-Mask: 0x01) */
#define UART0_UARTDR_BE_Pos               (10UL)                    /*!< BE (Bit 10) */
#define UART0_UARTDR_BE_Msk               (0x400UL)                 /*!< BE (Bitfield-Mask: 0x01) */
#define UART0_UARTDR_PE_Pos               (9UL)                     /*!< PE (Bit 9) */
#define UART0_UARTDR_PE_Msk               (0x200UL)                 /*!< PE (Bitfield-Mask: 0x01) */
#define UART0_UARTDR_FE_Pos               (8UL)                     /*!< FE (Bit 8) */
#define UART0_UARTDR_FE_Msk               (0x100UL)                 /*!< FE (Bitfield-Mask: 0x01) */
#define UART0_UARTDR_DATA_Pos             (0UL)                     /*!< DATA (Bit 0) */
#define UART0_UARTDR_DATA_Msk             (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff) */
/* ========================================================  UARTRSR  ======================================================== */
#define UART0_UARTRSR_OE_Pos              (3UL)                     /*!< OE (Bit 3) */
#define UART0_UARTRSR_OE_Msk              (0x8UL)                   /*!< OE (Bitfield-Mask: 0x01) */
#define UART0_UARTRSR_BE_Pos              (2UL)                     /*!< BE (Bit 2) */
#define UART0_UARTRSR_BE_Msk              (0x4UL)                   /*!< BE (Bitfield-Mask: 0x01) */
#define UART0_UARTRSR_PE_Pos              (1UL)                     /*!< PE (Bit 1) */
#define UART0_UARTRSR_PE_Msk              (0x2UL)                   /*!< PE (Bitfield-Mask: 0x01) */
#define UART0_UARTRSR_FE_Pos              (0UL)                     /*!< FE (Bit 0) */
#define UART0_UARTRSR_FE_Msk              (0x1UL)                   /*!< FE (Bitfield-Mask: 0x01) */
/* ========================================================  UARTFR  ========================================================= */
#define UART0_UARTFR_RI_Pos               (8UL)                     /*!< RI (Bit 8) */
#define UART0_UARTFR_RI_Msk               (0x100UL)                 /*!< RI (Bitfield-Mask: 0x01) */
#define UART0_UARTFR_TXFE_Pos             (7UL)                     /*!< TXFE (Bit 7) */
#define UART0_UARTFR_TXFE_Msk             (0x80UL)                  /*!< TXFE (Bitfield-Mask: 0x01) */
#define UART0_UARTFR_RXFF_Pos             (6UL)                     /*!< RXFF (Bit 6) */
#define UART0_UARTFR_RXFF_Msk             (0x40UL)                  /*!< RXFF (Bitfield-Mask: 0x01) */
#define UART0_UARTFR_TXFF_Pos             (5UL)                     /*!< TXFF (Bit 5) */
#define UART0_UARTFR_TXFF_Msk             (0x20UL)                  /*!< TXFF (Bitfield-Mask: 0x01) */
#define UART0_UARTFR_RXFE_Pos             (4UL)                     /*!< RXFE (Bit 4) */
#define UART0_UARTFR_RXFE_Msk             (0x10UL)                  /*!< RXFE (Bitfield-Mask: 0x01) */
#define UART0_UARTFR_BUSY_Pos             (3UL)                     /*!< BUSY (Bit 3) */
#define UART0_UARTFR_BUSY_Msk             (0x8UL)                   /*!< BUSY (Bitfield-Mask: 0x01) */
#define UART0_UARTFR_DCD_Pos              (2UL)                     /*!< DCD (Bit 2) */
#define UART0_UARTFR_DCD_Msk              (0x4UL)                   /*!< DCD (Bitfield-Mask: 0x01) */
#define UART0_UARTFR_DSR_Pos              (1UL)                     /*!< DSR (Bit 1) */
#define UART0_UARTFR_DSR_Msk              (0x2UL)                   /*!< DSR (Bitfield-Mask: 0x01) */
#define UART0_UARTFR_CTS_Pos              (0UL)                     /*!< CTS (Bit 0) */
#define UART0_UARTFR_CTS_Msk              (0x1UL)                   /*!< CTS (Bitfield-Mask: 0x01) */
/* =======================================================  UARTILPR  ======================================================== */
#define UART0_UARTILPR_ILPDVSR_Pos        (0UL)                     /*!< ILPDVSR (Bit 0) */
#define UART0_UARTILPR_ILPDVSR_Msk        (0xffUL)                  /*!< ILPDVSR (Bitfield-Mask: 0xff) */
/* =======================================================  UARTIBRD  ======================================================== */
#define UART0_UARTIBRD_BAUD_DIVINT_Pos    (0UL)                     /*!< BAUD_DIVINT (Bit 0) */
#define UART0_UARTIBRD_BAUD_DIVINT_Msk    (0xffffUL)                /*!< BAUD_DIVINT (Bitfield-Mask: 0xffff) */
/* =======================================================  UARTFBRD  ======================================================== */
#define UART0_UARTFBRD_BAUD_DIVFRAC_Pos   (0UL)                     /*!< BAUD_DIVFRAC (Bit 0) */
#define UART0_UARTFBRD_BAUD_DIVFRAC_Msk   (0x3fUL)                  /*!< BAUD_DIVFRAC (Bitfield-Mask: 0x3f) */
/* =======================================================  UARTLCR_H  ======================================================= */
#define UART0_UARTLCR_H_SPS_Pos           (7UL)                     /*!< SPS (Bit 7) */
#define UART0_UARTLCR_H_SPS_Msk           (0x80UL)                  /*!< SPS (Bitfield-Mask: 0x01) */
#define UART0_UARTLCR_H_WLEN_Pos          (5UL)                     /*!< WLEN (Bit 5) */
#define UART0_UARTLCR_H_WLEN_Msk          (0x60UL)                  /*!< WLEN (Bitfield-Mask: 0x03) */
#define UART0_UARTLCR_H_FEN_Pos           (4UL)                     /*!< FEN (Bit 4) */
#define UART0_UARTLCR_H_FEN_Msk           (0x10UL)                  /*!< FEN (Bitfield-Mask: 0x01) */
#define UART0_UARTLCR_H_STP2_Pos          (3UL)                     /*!< STP2 (Bit 3) */
#define UART0_UARTLCR_H_STP2_Msk          (0x8UL)                   /*!< STP2 (Bitfield-Mask: 0x01) */
#define UART0_UARTLCR_H_EPS_Pos           (2UL)                     /*!< EPS (Bit 2) */
#define UART0_UARTLCR_H_EPS_Msk           (0x4UL)                   /*!< EPS (Bitfield-Mask: 0x01) */
#define UART0_UARTLCR_H_PEN_Pos           (1UL)                     /*!< PEN (Bit 1) */
#define UART0_UARTLCR_H_PEN_Msk           (0x2UL)                   /*!< PEN (Bitfield-Mask: 0x01) */
#define UART0_UARTLCR_H_BRK_Pos           (0UL)                     /*!< BRK (Bit 0) */
#define UART0_UARTLCR_H_BRK_Msk           (0x1UL)                   /*!< BRK (Bitfield-Mask: 0x01) */
/* ========================================================  UARTCR  ========================================================= */
#define UART0_UARTCR_CTSEN_Pos            (15UL)                    /*!< CTSEN (Bit 15) */
#define UART0_UARTCR_CTSEN_Msk            (0x8000UL)                /*!< CTSEN (Bitfield-Mask: 0x01) */
#define UART0_UARTCR_RTSEN_Pos            (14UL)                    /*!< RTSEN (Bit 14) */
#define UART0_UARTCR_RTSEN_Msk            (0x4000UL)                /*!< RTSEN (Bitfield-Mask: 0x01) */
#define UART0_UARTCR_OUT2_Pos             (13UL)                    /*!< OUT2 (Bit 13) */
#define UART0_UARTCR_OUT2_Msk             (0x2000UL)                /*!< OUT2 (Bitfield-Mask: 0x01) */
#define UART0_UARTCR_OUT1_Pos             (12UL)                    /*!< OUT1 (Bit 12) */
#define UART0_UARTCR_OUT1_Msk             (0x1000UL)                /*!< OUT1 (Bitfield-Mask: 0x01) */
#define UART0_UARTCR_RTS_Pos              (11UL)                    /*!< RTS (Bit 11) */
#define UART0_UARTCR_RTS_Msk              (0x800UL)                 /*!< RTS (Bitfield-Mask: 0x01) */
#define UART0_UARTCR_DTR_Pos              (10UL)                    /*!< DTR (Bit 10) */
#define UART0_UARTCR_DTR_Msk              (0x400UL)                 /*!< DTR (Bitfield-Mask: 0x01) */
#define UART0_UARTCR_RXE_Pos              (9UL)                     /*!< RXE (Bit 9) */
#define UART0_UARTCR_RXE_Msk              (0x200UL)                 /*!< RXE (Bitfield-Mask: 0x01) */
#define UART0_UARTCR_TXE_Pos              (8UL)                     /*!< TXE (Bit 8) */
#define UART0_UARTCR_TXE_Msk              (0x100UL)                 /*!< TXE (Bitfield-Mask: 0x01) */
#define UART0_UARTCR_LBE_Pos              (7UL)                     /*!< LBE (Bit 7) */
#define UART0_UARTCR_LBE_Msk              (0x80UL)                  /*!< LBE (Bitfield-Mask: 0x01) */
#define UART0_UARTCR_SIRLP_Pos            (2UL)                     /*!< SIRLP (Bit 2) */
#define UART0_UARTCR_SIRLP_Msk            (0x4UL)                   /*!< SIRLP (Bitfield-Mask: 0x01) */
#define UART0_UARTCR_SIREN_Pos            (1UL)                     /*!< SIREN (Bit 1) */
#define UART0_UARTCR_SIREN_Msk            (0x2UL)                   /*!< SIREN (Bitfield-Mask: 0x01) */
#define UART0_UARTCR_UARTEN_Pos           (0UL)                     /*!< UARTEN (Bit 0) */
#define UART0_UARTCR_UARTEN_Msk           (0x1UL)                   /*!< UARTEN (Bitfield-Mask: 0x01) */
/* =======================================================  UARTIFLS  ======================================================== */
#define UART0_UARTIFLS_RXIFLSEL_Pos       (3UL)                     /*!< RXIFLSEL (Bit 3) */
#define UART0_UARTIFLS_RXIFLSEL_Msk       (0x38UL)                  /*!< RXIFLSEL (Bitfield-Mask: 0x07) */
#define UART0_UARTIFLS_TXIFLSEL_Pos       (0UL)                     /*!< TXIFLSEL (Bit 0) */
#define UART0_UARTIFLS_TXIFLSEL_Msk       (0x7UL)                   /*!< TXIFLSEL (Bitfield-Mask: 0x07) */
/* =======================================================  UARTIMSC  ======================================================== */
#define UART0_UARTIMSC_OEIM_Pos           (10UL)                    /*!< OEIM (Bit 10) */
#define UART0_UARTIMSC_OEIM_Msk           (0x400UL)                 /*!< OEIM (Bitfield-Mask: 0x01) */
#define UART0_UARTIMSC_BEIM_Pos           (9UL)                     /*!< BEIM (Bit 9) */
#define UART0_UARTIMSC_BEIM_Msk           (0x200UL)                 /*!< BEIM (Bitfield-Mask: 0x01) */
#define UART0_UARTIMSC_PEIM_Pos           (8UL)                     /*!< PEIM (Bit 8) */
#define UART0_UARTIMSC_PEIM_Msk           (0x100UL)                 /*!< PEIM (Bitfield-Mask: 0x01) */
#define UART0_UARTIMSC_FEIM_Pos           (7UL)                     /*!< FEIM (Bit 7) */
#define UART0_UARTIMSC_FEIM_Msk           (0x80UL)                  /*!< FEIM (Bitfield-Mask: 0x01) */
#define UART0_UARTIMSC_RTIM_Pos           (6UL)                     /*!< RTIM (Bit 6) */
#define UART0_UARTIMSC_RTIM_Msk           (0x40UL)                  /*!< RTIM (Bitfield-Mask: 0x01) */
#define UART0_UARTIMSC_TXIM_Pos           (5UL)                     /*!< TXIM (Bit 5) */
#define UART0_UARTIMSC_TXIM_Msk           (0x20UL)                  /*!< TXIM (Bitfield-Mask: 0x01) */
#define UART0_UARTIMSC_RXIM_Pos           (4UL)                     /*!< RXIM (Bit 4) */
#define UART0_UARTIMSC_RXIM_Msk           (0x10UL)                  /*!< RXIM (Bitfield-Mask: 0x01) */
#define UART0_UARTIMSC_DSRMIM_Pos         (3UL)                     /*!< DSRMIM (Bit 3) */
#define UART0_UARTIMSC_DSRMIM_Msk         (0x8UL)                   /*!< DSRMIM (Bitfield-Mask: 0x01) */
#define UART0_UARTIMSC_DCDMIM_Pos         (2UL)                     /*!< DCDMIM (Bit 2) */
#define UART0_UARTIMSC_DCDMIM_Msk         (0x4UL)                   /*!< DCDMIM (Bitfield-Mask: 0x01) */
#define UART0_UARTIMSC_CTSMIM_Pos         (1UL)                     /*!< CTSMIM (Bit 1) */
#define UART0_UARTIMSC_CTSMIM_Msk         (0x2UL)                   /*!< CTSMIM (Bitfield-Mask: 0x01) */
#define UART0_UARTIMSC_RIMIM_Pos          (0UL)                     /*!< RIMIM (Bit 0) */
#define UART0_UARTIMSC_RIMIM_Msk          (0x1UL)                   /*!< RIMIM (Bitfield-Mask: 0x01) */
/* ========================================================  UARTRIS  ======================================================== */
#define UART0_UARTRIS_OERIS_Pos           (10UL)                    /*!< OERIS (Bit 10) */
#define UART0_UARTRIS_OERIS_Msk           (0x400UL)                 /*!< OERIS (Bitfield-Mask: 0x01) */
#define UART0_UARTRIS_BERIS_Pos           (9UL)                     /*!< BERIS (Bit 9) */
#define UART0_UARTRIS_BERIS_Msk           (0x200UL)                 /*!< BERIS (Bitfield-Mask: 0x01) */
#define UART0_UARTRIS_PERIS_Pos           (8UL)                     /*!< PERIS (Bit 8) */
#define UART0_UARTRIS_PERIS_Msk           (0x100UL)                 /*!< PERIS (Bitfield-Mask: 0x01) */
#define UART0_UARTRIS_FERIS_Pos           (7UL)                     /*!< FERIS (Bit 7) */
#define UART0_UARTRIS_FERIS_Msk           (0x80UL)                  /*!< FERIS (Bitfield-Mask: 0x01) */
#define UART0_UARTRIS_RTRIS_Pos           (6UL)                     /*!< RTRIS (Bit 6) */
#define UART0_UARTRIS_RTRIS_Msk           (0x40UL)                  /*!< RTRIS (Bitfield-Mask: 0x01) */
#define UART0_UARTRIS_TXRIS_Pos           (5UL)                     /*!< TXRIS (Bit 5) */
#define UART0_UARTRIS_TXRIS_Msk           (0x20UL)                  /*!< TXRIS (Bitfield-Mask: 0x01) */
#define UART0_UARTRIS_RXRIS_Pos           (4UL)                     /*!< RXRIS (Bit 4) */
#define UART0_UARTRIS_RXRIS_Msk           (0x10UL)                  /*!< RXRIS (Bitfield-Mask: 0x01) */
#define UART0_UARTRIS_DSRRMIS_Pos         (3UL)                     /*!< DSRRMIS (Bit 3) */
#define UART0_UARTRIS_DSRRMIS_Msk         (0x8UL)                   /*!< DSRRMIS (Bitfield-Mask: 0x01) */
#define UART0_UARTRIS_DCDRMIS_Pos         (2UL)                     /*!< DCDRMIS (Bit 2) */
#define UART0_UARTRIS_DCDRMIS_Msk         (0x4UL)                   /*!< DCDRMIS (Bitfield-Mask: 0x01) */
#define UART0_UARTRIS_CTSRMIS_Pos         (1UL)                     /*!< CTSRMIS (Bit 1) */
#define UART0_UARTRIS_CTSRMIS_Msk         (0x2UL)                   /*!< CTSRMIS (Bitfield-Mask: 0x01) */
#define UART0_UARTRIS_RIRMIS_Pos          (0UL)                     /*!< RIRMIS (Bit 0) */
#define UART0_UARTRIS_RIRMIS_Msk          (0x1UL)                   /*!< RIRMIS (Bitfield-Mask: 0x01) */
/* ========================================================  UARTMIS  ======================================================== */
#define UART0_UARTMIS_OEMIS_Pos           (10UL)                    /*!< OEMIS (Bit 10) */
#define UART0_UARTMIS_OEMIS_Msk           (0x400UL)                 /*!< OEMIS (Bitfield-Mask: 0x01) */
#define UART0_UARTMIS_BEMIS_Pos           (9UL)                     /*!< BEMIS (Bit 9) */
#define UART0_UARTMIS_BEMIS_Msk           (0x200UL)                 /*!< BEMIS (Bitfield-Mask: 0x01) */
#define UART0_UARTMIS_PEMIS_Pos           (8UL)                     /*!< PEMIS (Bit 8) */
#define UART0_UARTMIS_PEMIS_Msk           (0x100UL)                 /*!< PEMIS (Bitfield-Mask: 0x01) */
#define UART0_UARTMIS_FEMIS_Pos           (7UL)                     /*!< FEMIS (Bit 7) */
#define UART0_UARTMIS_FEMIS_Msk           (0x80UL)                  /*!< FEMIS (Bitfield-Mask: 0x01) */
#define UART0_UARTMIS_RTMIS_Pos           (6UL)                     /*!< RTMIS (Bit 6) */
#define UART0_UARTMIS_RTMIS_Msk           (0x40UL)                  /*!< RTMIS (Bitfield-Mask: 0x01) */
#define UART0_UARTMIS_TXMIS_Pos           (5UL)                     /*!< TXMIS (Bit 5) */
#define UART0_UARTMIS_TXMIS_Msk           (0x20UL)                  /*!< TXMIS (Bitfield-Mask: 0x01) */
#define UART0_UARTMIS_RXMIS_Pos           (4UL)                     /*!< RXMIS (Bit 4) */
#define UART0_UARTMIS_RXMIS_Msk           (0x10UL)                  /*!< RXMIS (Bitfield-Mask: 0x01) */
#define UART0_UARTMIS_DSRMMIS_Pos         (3UL)                     /*!< DSRMMIS (Bit 3) */
#define UART0_UARTMIS_DSRMMIS_Msk         (0x8UL)                   /*!< DSRMMIS (Bitfield-Mask: 0x01) */
#define UART0_UARTMIS_DCDMMIS_Pos         (2UL)                     /*!< DCDMMIS (Bit 2) */
#define UART0_UARTMIS_DCDMMIS_Msk         (0x4UL)                   /*!< DCDMMIS (Bitfield-Mask: 0x01) */
#define UART0_UARTMIS_CTSMMIS_Pos         (1UL)                     /*!< CTSMMIS (Bit 1) */
#define UART0_UARTMIS_CTSMMIS_Msk         (0x2UL)                   /*!< CTSMMIS (Bitfield-Mask: 0x01) */
#define UART0_UARTMIS_RIMMIS_Pos          (0UL)                     /*!< RIMMIS (Bit 0) */
#define UART0_UARTMIS_RIMMIS_Msk          (0x1UL)                   /*!< RIMMIS (Bitfield-Mask: 0x01) */
/* ========================================================  UARTICR  ======================================================== */
#define UART0_UARTICR_OEIC_Pos            (10UL)                    /*!< OEIC (Bit 10) */
#define UART0_UARTICR_OEIC_Msk            (0x400UL)                 /*!< OEIC (Bitfield-Mask: 0x01) */
#define UART0_UARTICR_BEIC_Pos            (9UL)                     /*!< BEIC (Bit 9) */
#define UART0_UARTICR_BEIC_Msk            (0x200UL)                 /*!< BEIC (Bitfield-Mask: 0x01) */
#define UART0_UARTICR_PEIC_Pos            (8UL)                     /*!< PEIC (Bit 8) */
#define UART0_UARTICR_PEIC_Msk            (0x100UL)                 /*!< PEIC (Bitfield-Mask: 0x01) */
#define UART0_UARTICR_FEIC_Pos            (7UL)                     /*!< FEIC (Bit 7) */
#define UART0_UARTICR_FEIC_Msk            (0x80UL)                  /*!< FEIC (Bitfield-Mask: 0x01) */
#define UART0_UARTICR_RTIC_Pos            (6UL)                     /*!< RTIC (Bit 6) */
#define UART0_UARTICR_RTIC_Msk            (0x40UL)                  /*!< RTIC (Bitfield-Mask: 0x01) */
#define UART0_UARTICR_TXIC_Pos            (5UL)                     /*!< TXIC (Bit 5) */
#define UART0_UARTICR_TXIC_Msk            (0x20UL)                  /*!< TXIC (Bitfield-Mask: 0x01) */
#define UART0_UARTICR_RXIC_Pos            (4UL)                     /*!< RXIC (Bit 4) */
#define UART0_UARTICR_RXIC_Msk            (0x10UL)                  /*!< RXIC (Bitfield-Mask: 0x01) */
#define UART0_UARTICR_DSRMIC_Pos          (3UL)                     /*!< DSRMIC (Bit 3) */
#define UART0_UARTICR_DSRMIC_Msk          (0x8UL)                   /*!< DSRMIC (Bitfield-Mask: 0x01) */
#define UART0_UARTICR_DCDMIC_Pos          (2UL)                     /*!< DCDMIC (Bit 2) */
#define UART0_UARTICR_DCDMIC_Msk          (0x4UL)                   /*!< DCDMIC (Bitfield-Mask: 0x01) */
#define UART0_UARTICR_CTSMIC_Pos          (1UL)                     /*!< CTSMIC (Bit 1) */
#define UART0_UARTICR_CTSMIC_Msk          (0x2UL)                   /*!< CTSMIC (Bitfield-Mask: 0x01) */
#define UART0_UARTICR_RIMIC_Pos           (0UL)                     /*!< RIMIC (Bit 0) */
#define UART0_UARTICR_RIMIC_Msk           (0x1UL)                   /*!< RIMIC (Bitfield-Mask: 0x01) */
/* =======================================================  UARTDMACR  ======================================================= */
#define UART0_UARTDMACR_DMAONERR_Pos      (2UL)                     /*!< DMAONERR (Bit 2) */
#define UART0_UARTDMACR_DMAONERR_Msk      (0x4UL)                   /*!< DMAONERR (Bitfield-Mask: 0x01) */
#define UART0_UARTDMACR_TXDMAE_Pos        (1UL)                     /*!< TXDMAE (Bit 1) */
#define UART0_UARTDMACR_TXDMAE_Msk        (0x2UL)                   /*!< TXDMAE (Bitfield-Mask: 0x01) */
#define UART0_UARTDMACR_RXDMAE_Pos        (0UL)                     /*!< RXDMAE (Bit 0) */
#define UART0_UARTDMACR_RXDMAE_Msk        (0x1UL)                   /*!< RXDMAE (Bitfield-Mask: 0x01) */
/* =====================================================  UARTPERIPHID0  ===================================================== */
#define UART0_UARTPERIPHID0_PARTNUMBER0_Pos (0UL)                   /*!< PARTNUMBER0 (Bit 0) */
#define UART0_UARTPERIPHID0_PARTNUMBER0_Msk (0xffUL)                /*!< PARTNUMBER0 (Bitfield-Mask: 0xff) */
/* =====================================================  UARTPERIPHID1  ===================================================== */
#define UART0_UARTPERIPHID1_DESIGNER0_Pos (4UL)                     /*!< DESIGNER0 (Bit 4) */
#define UART0_UARTPERIPHID1_DESIGNER0_Msk (0xf0UL)                  /*!< DESIGNER0 (Bitfield-Mask: 0x0f) */
#define UART0_UARTPERIPHID1_PARTNUMBER1_Pos (0UL)                   /*!< PARTNUMBER1 (Bit 0) */
#define UART0_UARTPERIPHID1_PARTNUMBER1_Msk (0xfUL)                 /*!< PARTNUMBER1 (Bitfield-Mask: 0x0f) */
/* =====================================================  UARTPERIPHID2  ===================================================== */
#define UART0_UARTPERIPHID2_REVISION_Pos  (4UL)                     /*!< REVISION (Bit 4) */
#define UART0_UARTPERIPHID2_REVISION_Msk  (0xf0UL)                  /*!< REVISION (Bitfield-Mask: 0x0f) */
#define UART0_UARTPERIPHID2_DESIGNER1_Pos (0UL)                     /*!< DESIGNER1 (Bit 0) */
#define UART0_UARTPERIPHID2_DESIGNER1_Msk (0xfUL)                   /*!< DESIGNER1 (Bitfield-Mask: 0x0f) */
/* =====================================================  UARTPERIPHID3  ===================================================== */
#define UART0_UARTPERIPHID3_CONFIGURATION_Pos (0UL)                 /*!< CONFIGURATION (Bit 0) */
#define UART0_UARTPERIPHID3_CONFIGURATION_Msk (0xffUL)              /*!< CONFIGURATION (Bitfield-Mask: 0xff) */
/* =====================================================  UARTPCELLID0  ====================================================== */
#define UART0_UARTPCELLID0_UARTPCELLID0_Pos (0UL)                   /*!< UARTPCELLID0 (Bit 0) */
#define UART0_UARTPCELLID0_UARTPCELLID0_Msk (0xffUL)                /*!< UARTPCELLID0 (Bitfield-Mask: 0xff) */
/* =====================================================  UARTPCELLID1  ====================================================== */
#define UART0_UARTPCELLID1_UARTPCELLID1_Pos (0UL)                   /*!< UARTPCELLID1 (Bit 0) */
#define UART0_UARTPCELLID1_UARTPCELLID1_Msk (0xffUL)                /*!< UARTPCELLID1 (Bitfield-Mask: 0xff) */
/* =====================================================  UARTPCELLID2  ====================================================== */
#define UART0_UARTPCELLID2_UARTPCELLID2_Pos (0UL)                   /*!< UARTPCELLID2 (Bit 0) */
#define UART0_UARTPCELLID2_UARTPCELLID2_Msk (0xffUL)                /*!< UARTPCELLID2 (Bitfield-Mask: 0xff) */
/* =====================================================  UARTPCELLID3  ====================================================== */
#define UART0_UARTPCELLID3_UARTPCELLID3_Pos (0UL)                   /*!< UARTPCELLID3 (Bit 0) */
#define UART0_UARTPCELLID3_UARTPCELLID3_Msk (0xffUL)                /*!< UARTPCELLID3 (Bitfield-Mask: 0xff) */


/* =========================================================================================================================== */
/* ================                                           SPI0                                            ================ */
/* =========================================================================================================================== */

/* ========================================================  SSPCR0  ========================================================= */
#define SPI0_SSPCR0_SCR_Pos               (8UL)                     /*!< SCR (Bit 8) */
#define SPI0_SSPCR0_SCR_Msk               (0xff00UL)                /*!< SCR (Bitfield-Mask: 0xff) */
#define SPI0_SSPCR0_SPH_Pos               (7UL)                     /*!< SPH (Bit 7) */
#define SPI0_SSPCR0_SPH_Msk               (0x80UL)                  /*!< SPH (Bitfield-Mask: 0x01) */
#define SPI0_SSPCR0_SPO_Pos               (6UL)                     /*!< SPO (Bit 6) */
#define SPI0_SSPCR0_SPO_Msk               (0x40UL)                  /*!< SPO (Bitfield-Mask: 0x01) */
#define SPI0_SSPCR0_FRF_Pos               (4UL)                     /*!< FRF (Bit 4) */
#define SPI0_SSPCR0_FRF_Msk               (0x30UL)                  /*!< FRF (Bitfield-Mask: 0x03) */
#define SPI0_SSPCR0_DSS_Pos               (0UL)                     /*!< DSS (Bit 0) */
#define SPI0_SSPCR0_DSS_Msk               (0xfUL)                   /*!< DSS (Bitfield-Mask: 0x0f) */
/* ========================================================  SSPCR1  ========================================================= */
#define SPI0_SSPCR1_SOD_Pos               (3UL)                     /*!< SOD (Bit 3) */
#define SPI0_SSPCR1_SOD_Msk               (0x8UL)                   /*!< SOD (Bitfield-Mask: 0x01) */
#define SPI0_SSPCR1_MS_Pos                (2UL)                     /*!< MS (Bit 2) */
#define SPI0_SSPCR1_MS_Msk                (0x4UL)                   /*!< MS (Bitfield-Mask: 0x01) */
#define SPI0_SSPCR1_SSE_Pos               (1UL)                     /*!< SSE (Bit 1) */
#define SPI0_SSPCR1_SSE_Msk               (0x2UL)                   /*!< SSE (Bitfield-Mask: 0x01) */
#define SPI0_SSPCR1_LBM_Pos               (0UL)                     /*!< LBM (Bit 0) */
#define SPI0_SSPCR1_LBM_Msk               (0x1UL)                   /*!< LBM (Bitfield-Mask: 0x01) */
/* =========================================================  SSPDR  ========================================================= */
#define SPI0_SSPDR_DATA_Pos               (0UL)                     /*!< DATA (Bit 0) */
#define SPI0_SSPDR_DATA_Msk               (0xffffUL)                /*!< DATA (Bitfield-Mask: 0xffff) */
/* =========================================================  SSPSR  ========================================================= */
#define SPI0_SSPSR_BSY_Pos                (4UL)                     /*!< BSY (Bit 4) */
#define SPI0_SSPSR_BSY_Msk                (0x10UL)                  /*!< BSY (Bitfield-Mask: 0x01) */
#define SPI0_SSPSR_RFF_Pos                (3UL)                     /*!< RFF (Bit 3) */
#define SPI0_SSPSR_RFF_Msk                (0x8UL)                   /*!< RFF (Bitfield-Mask: 0x01) */
#define SPI0_SSPSR_RNE_Pos                (2UL)                     /*!< RNE (Bit 2) */
#define SPI0_SSPSR_RNE_Msk                (0x4UL)                   /*!< RNE (Bitfield-Mask: 0x01) */
#define SPI0_SSPSR_TNF_Pos                (1UL)                     /*!< TNF (Bit 1) */
#define SPI0_SSPSR_TNF_Msk                (0x2UL)                   /*!< TNF (Bitfield-Mask: 0x01) */
#define SPI0_SSPSR_TFE_Pos                (0UL)                     /*!< TFE (Bit 0) */
#define SPI0_SSPSR_TFE_Msk                (0x1UL)                   /*!< TFE (Bitfield-Mask: 0x01) */
/* ========================================================  SSPCPSR  ======================================================== */
#define SPI0_SSPCPSR_CPSDVSR_Pos          (0UL)                     /*!< CPSDVSR (Bit 0) */
#define SPI0_SSPCPSR_CPSDVSR_Msk          (0xffUL)                  /*!< CPSDVSR (Bitfield-Mask: 0xff) */
/* ========================================================  SSPIMSC  ======================================================== */
#define SPI0_SSPIMSC_TXIM_Pos             (3UL)                     /*!< TXIM (Bit 3) */
#define SPI0_SSPIMSC_TXIM_Msk             (0x8UL)                   /*!< TXIM (Bitfield-Mask: 0x01) */
#define SPI0_SSPIMSC_RXIM_Pos             (2UL)                     /*!< RXIM (Bit 2) */
#define SPI0_SSPIMSC_RXIM_Msk             (0x4UL)                   /*!< RXIM (Bitfield-Mask: 0x01) */
#define SPI0_SSPIMSC_RTIM_Pos             (1UL)                     /*!< RTIM (Bit 1) */
#define SPI0_SSPIMSC_RTIM_Msk             (0x2UL)                   /*!< RTIM (Bitfield-Mask: 0x01) */
#define SPI0_SSPIMSC_RORIM_Pos            (0UL)                     /*!< RORIM (Bit 0) */
#define SPI0_SSPIMSC_RORIM_Msk            (0x1UL)                   /*!< RORIM (Bitfield-Mask: 0x01) */
/* ========================================================  SSPRIS  ========================================================= */
#define SPI0_SSPRIS_TXRIS_Pos             (3UL)                     /*!< TXRIS (Bit 3) */
#define SPI0_SSPRIS_TXRIS_Msk             (0x8UL)                   /*!< TXRIS (Bitfield-Mask: 0x01) */
#define SPI0_SSPRIS_RXRIS_Pos             (2UL)                     /*!< RXRIS (Bit 2) */
#define SPI0_SSPRIS_RXRIS_Msk             (0x4UL)                   /*!< RXRIS (Bitfield-Mask: 0x01) */
#define SPI0_SSPRIS_RTRIS_Pos             (1UL)                     /*!< RTRIS (Bit 1) */
#define SPI0_SSPRIS_RTRIS_Msk             (0x2UL)                   /*!< RTRIS (Bitfield-Mask: 0x01) */
#define SPI0_SSPRIS_RORRIS_Pos            (0UL)                     /*!< RORRIS (Bit 0) */
#define SPI0_SSPRIS_RORRIS_Msk            (0x1UL)                   /*!< RORRIS (Bitfield-Mask: 0x01) */
/* ========================================================  SSPMIS  ========================================================= */
#define SPI0_SSPMIS_TXMIS_Pos             (3UL)                     /*!< TXMIS (Bit 3) */
#define SPI0_SSPMIS_TXMIS_Msk             (0x8UL)                   /*!< TXMIS (Bitfield-Mask: 0x01) */
#define SPI0_SSPMIS_RXMIS_Pos             (2UL)                     /*!< RXMIS (Bit 2) */
#define SPI0_SSPMIS_RXMIS_Msk             (0x4UL)                   /*!< RXMIS (Bitfield-Mask: 0x01) */
#define SPI0_SSPMIS_RTMIS_Pos             (1UL)                     /*!< RTMIS (Bit 1) */
#define SPI0_SSPMIS_RTMIS_Msk             (0x2UL)                   /*!< RTMIS (Bitfield-Mask: 0x01) */
#define SPI0_SSPMIS_RORMIS_Pos            (0UL)                     /*!< RORMIS (Bit 0) */
#define SPI0_SSPMIS_RORMIS_Msk            (0x1UL)                   /*!< RORMIS (Bitfield-Mask: 0x01) */
/* ========================================================  SSPICR  ========================================================= */
#define SPI0_SSPICR_RTIC_Pos              (1UL)                     /*!< RTIC (Bit 1) */
#define SPI0_SSPICR_RTIC_Msk              (0x2UL)                   /*!< RTIC (Bitfield-Mask: 0x01) */
#define SPI0_SSPICR_RORIC_Pos             (0UL)                     /*!< RORIC (Bit 0) */
#define SPI0_SSPICR_RORIC_Msk             (0x1UL)                   /*!< RORIC (Bitfield-Mask: 0x01) */
/* =======================================================  SSPDMACR  ======================================================== */
#define SPI0_SSPDMACR_TXDMAE_Pos          (1UL)                     /*!< TXDMAE (Bit 1) */
#define SPI0_SSPDMACR_TXDMAE_Msk          (0x2UL)                   /*!< TXDMAE (Bitfield-Mask: 0x01) */
#define SPI0_SSPDMACR_RXDMAE_Pos          (0UL)                     /*!< RXDMAE (Bit 0) */
#define SPI0_SSPDMACR_RXDMAE_Msk          (0x1UL)                   /*!< RXDMAE (Bitfield-Mask: 0x01) */
/* =====================================================  SSPPERIPHID0  ====================================================== */
#define SPI0_SSPPERIPHID0_PARTNUMBER0_Pos (0UL)                     /*!< PARTNUMBER0 (Bit 0) */
#define SPI0_SSPPERIPHID0_PARTNUMBER0_Msk (0xffUL)                  /*!< PARTNUMBER0 (Bitfield-Mask: 0xff) */
/* =====================================================  SSPPERIPHID1  ====================================================== */
#define SPI0_SSPPERIPHID1_DESIGNER0_Pos   (4UL)                     /*!< DESIGNER0 (Bit 4) */
#define SPI0_SSPPERIPHID1_DESIGNER0_Msk   (0xf0UL)                  /*!< DESIGNER0 (Bitfield-Mask: 0x0f) */
#define SPI0_SSPPERIPHID1_PARTNUMBER1_Pos (0UL)                     /*!< PARTNUMBER1 (Bit 0) */
#define SPI0_SSPPERIPHID1_PARTNUMBER1_Msk (0xfUL)                   /*!< PARTNUMBER1 (Bitfield-Mask: 0x0f) */
/* =====================================================  SSPPERIPHID2  ====================================================== */
#define SPI0_SSPPERIPHID2_REVISION_Pos    (4UL)                     /*!< REVISION (Bit 4) */
#define SPI0_SSPPERIPHID2_REVISION_Msk    (0xf0UL)                  /*!< REVISION (Bitfield-Mask: 0x0f) */
#define SPI0_SSPPERIPHID2_DESIGNER1_Pos   (0UL)                     /*!< DESIGNER1 (Bit 0) */
#define SPI0_SSPPERIPHID2_DESIGNER1_Msk   (0xfUL)                   /*!< DESIGNER1 (Bitfield-Mask: 0x0f) */
/* =====================================================  SSPPERIPHID3  ====================================================== */
#define SPI0_SSPPERIPHID3_CONFIGURATION_Pos (0UL)                   /*!< CONFIGURATION (Bit 0) */
#define SPI0_SSPPERIPHID3_CONFIGURATION_Msk (0xffUL)                /*!< CONFIGURATION (Bitfield-Mask: 0xff) */
/* ======================================================  SSPPCELLID0  ====================================================== */
#define SPI0_SSPPCELLID0_SSPPCELLID0_Pos  (0UL)                     /*!< SSPPCELLID0 (Bit 0) */
#define SPI0_SSPPCELLID0_SSPPCELLID0_Msk  (0xffUL)                  /*!< SSPPCELLID0 (Bitfield-Mask: 0xff) */
/* ======================================================  SSPPCELLID1  ====================================================== */
#define SPI0_SSPPCELLID1_SSPPCELLID1_Pos  (0UL)                     /*!< SSPPCELLID1 (Bit 0) */
#define SPI0_SSPPCELLID1_SSPPCELLID1_Msk  (0xffUL)                  /*!< SSPPCELLID1 (Bitfield-Mask: 0xff) */
/* ======================================================  SSPPCELLID2  ====================================================== */
#define SPI0_SSPPCELLID2_SSPPCELLID2_Pos  (0UL)                     /*!< SSPPCELLID2 (Bit 0) */
#define SPI0_SSPPCELLID2_SSPPCELLID2_Msk  (0xffUL)                  /*!< SSPPCELLID2 (Bitfield-Mask: 0xff) */
/* ======================================================  SSPPCELLID3  ====================================================== */
#define SPI0_SSPPCELLID3_SSPPCELLID3_Pos  (0UL)                     /*!< SSPPCELLID3 (Bit 0) */
#define SPI0_SSPPCELLID3_SSPPCELLID3_Msk  (0xffUL)                  /*!< SSPPCELLID3 (Bitfield-Mask: 0xff) */


/* =========================================================================================================================== */
/* ================                                           I2C0                                            ================ */
/* =========================================================================================================================== */

/* ========================================================  IC_CON  ========================================================= */
#define I2C0_IC_CON_STOP_DET_IF_MASTER_ACTIVE_Pos (10UL)            /*!< STOP_DET_IF_MASTER_ACTIVE (Bit 10) */
#define I2C0_IC_CON_STOP_DET_IF_MASTER_ACTIVE_Msk (0x400UL)         /*!< STOP_DET_IF_MASTER_ACTIVE (Bitfield-Mask: 0x01) */
#define I2C0_IC_CON_RX_FIFO_FULL_HLD_CTRL_Pos (9UL)                 /*!< RX_FIFO_FULL_HLD_CTRL (Bit 9) */
#define I2C0_IC_CON_RX_FIFO_FULL_HLD_CTRL_Msk (0x200UL)             /*!< RX_FIFO_FULL_HLD_CTRL (Bitfield-Mask: 0x01) */
#define I2C0_IC_CON_TX_EMPTY_CTRL_Pos     (8UL)                     /*!< TX_EMPTY_CTRL (Bit 8) */
#define I2C0_IC_CON_TX_EMPTY_CTRL_Msk     (0x100UL)                 /*!< TX_EMPTY_CTRL (Bitfield-Mask: 0x01) */
#define I2C0_IC_CON_STOP_DET_IFADDRESSED_Pos (7UL)                  /*!< STOP_DET_IFADDRESSED (Bit 7) */
#define I2C0_IC_CON_STOP_DET_IFADDRESSED_Msk (0x80UL)               /*!< STOP_DET_IFADDRESSED (Bitfield-Mask: 0x01) */
#define I2C0_IC_CON_IC_SLAVE_DISABLE_Pos  (6UL)                     /*!< IC_SLAVE_DISABLE (Bit 6) */
#define I2C0_IC_CON_IC_SLAVE_DISABLE_Msk  (0x40UL)                  /*!< IC_SLAVE_DISABLE (Bitfield-Mask: 0x01) */
#define I2C0_IC_CON_IC_RESTART_EN_Pos     (5UL)                     /*!< IC_RESTART_EN (Bit 5) */
#define I2C0_IC_CON_IC_RESTART_EN_Msk     (0x20UL)                  /*!< IC_RESTART_EN (Bitfield-Mask: 0x01) */
#define I2C0_IC_CON_IC_10BITADDR_MASTER_Pos (4UL)                   /*!< IC_10BITADDR_MASTER (Bit 4) */
#define I2C0_IC_CON_IC_10BITADDR_MASTER_Msk (0x10UL)                /*!< IC_10BITADDR_MASTER (Bitfield-Mask: 0x01) */
#define I2C0_IC_CON_IC_10BITADDR_SLAVE_Pos (3UL)                    /*!< IC_10BITADDR_SLAVE (Bit 3) */
#define I2C0_IC_CON_IC_10BITADDR_SLAVE_Msk (0x8UL)                  /*!< IC_10BITADDR_SLAVE (Bitfield-Mask: 0x01) */
#define I2C0_IC_CON_SPEED_Pos             (1UL)                     /*!< SPEED (Bit 1) */
#define I2C0_IC_CON_SPEED_Msk             (0x6UL)                   /*!< SPEED (Bitfield-Mask: 0x03) */
#define I2C0_IC_CON_MASTER_MODE_Pos       (0UL)                     /*!< MASTER_MODE (Bit 0) */
#define I2C0_IC_CON_MASTER_MODE_Msk       (0x1UL)                   /*!< MASTER_MODE (Bitfield-Mask: 0x01) */
/* ========================================================  IC_TAR  ========================================================= */
#define I2C0_IC_TAR_SPECIAL_Pos           (11UL)                    /*!< SPECIAL (Bit 11) */
#define I2C0_IC_TAR_SPECIAL_Msk           (0x800UL)                 /*!< SPECIAL (Bitfield-Mask: 0x01) */
#define I2C0_IC_TAR_GC_OR_START_Pos       (10UL)                    /*!< GC_OR_START (Bit 10) */
#define I2C0_IC_TAR_GC_OR_START_Msk       (0x400UL)                 /*!< GC_OR_START (Bitfield-Mask: 0x01) */
#define I2C0_IC_TAR_IC_TAR_Pos            (0UL)                     /*!< IC_TAR (Bit 0) */
#define I2C0_IC_TAR_IC_TAR_Msk            (0x3ffUL)                 /*!< IC_TAR (Bitfield-Mask: 0x3ff) */
/* ========================================================  IC_SAR  ========================================================= */
#define I2C0_IC_SAR_IC_SAR_Pos            (0UL)                     /*!< IC_SAR (Bit 0) */
#define I2C0_IC_SAR_IC_SAR_Msk            (0x3ffUL)                 /*!< IC_SAR (Bitfield-Mask: 0x3ff) */
/* ======================================================  IC_DATA_CMD  ====================================================== */
#define I2C0_IC_DATA_CMD_FIRST_DATA_BYTE_Pos (11UL)                 /*!< FIRST_DATA_BYTE (Bit 11) */
#define I2C0_IC_DATA_CMD_FIRST_DATA_BYTE_Msk (0x800UL)              /*!< FIRST_DATA_BYTE (Bitfield-Mask: 0x01) */
#define I2C0_IC_DATA_CMD_RESTART_Pos      (10UL)                    /*!< RESTART (Bit 10) */
#define I2C0_IC_DATA_CMD_RESTART_Msk      (0x400UL)                 /*!< RESTART (Bitfield-Mask: 0x01) */
#define I2C0_IC_DATA_CMD_STOP_Pos         (9UL)                     /*!< STOP (Bit 9) */
#define I2C0_IC_DATA_CMD_STOP_Msk         (0x200UL)                 /*!< STOP (Bitfield-Mask: 0x01) */
#define I2C0_IC_DATA_CMD_CMD_Pos          (8UL)                     /*!< CMD (Bit 8) */
#define I2C0_IC_DATA_CMD_CMD_Msk          (0x100UL)                 /*!< CMD (Bitfield-Mask: 0x01) */
#define I2C0_IC_DATA_CMD_DAT_Pos          (0UL)                     /*!< DAT (Bit 0) */
#define I2C0_IC_DATA_CMD_DAT_Msk          (0xffUL)                  /*!< DAT (Bitfield-Mask: 0xff) */
/* ====================================================  IC_SS_SCL_HCNT  ===================================================== */
#define I2C0_IC_SS_SCL_HCNT_IC_SS_SCL_HCNT_Pos (0UL)                /*!< IC_SS_SCL_HCNT (Bit 0) */
#define I2C0_IC_SS_SCL_HCNT_IC_SS_SCL_HCNT_Msk (0xffffUL)           /*!< IC_SS_SCL_HCNT (Bitfield-Mask: 0xffff) */
/* ====================================================  IC_SS_SCL_LCNT  ===================================================== */
#define I2C0_IC_SS_SCL_LCNT_IC_SS_SCL_LCNT_Pos (0UL)                /*!< IC_SS_SCL_LCNT (Bit 0) */
#define I2C0_IC_SS_SCL_LCNT_IC_SS_SCL_LCNT_Msk (0xffffUL)           /*!< IC_SS_SCL_LCNT (Bitfield-Mask: 0xffff) */
/* ====================================================  IC_FS_SCL_HCNT  ===================================================== */
#define I2C0_IC_FS_SCL_HCNT_IC_FS_SCL_HCNT_Pos (0UL)                /*!< IC_FS_SCL_HCNT (Bit 0) */
#define I2C0_IC_FS_SCL_HCNT_IC_FS_SCL_HCNT_Msk (0xffffUL)           /*!< IC_FS_SCL_HCNT (Bitfield-Mask: 0xffff) */
/* ====================================================  IC_FS_SCL_LCNT  ===================================================== */
#define I2C0_IC_FS_SCL_LCNT_IC_FS_SCL_LCNT_Pos (0UL)                /*!< IC_FS_SCL_LCNT (Bit 0) */
#define I2C0_IC_FS_SCL_LCNT_IC_FS_SCL_LCNT_Msk (0xffffUL)           /*!< IC_FS_SCL_LCNT (Bitfield-Mask: 0xffff) */
/* =====================================================  IC_INTR_STAT  ====================================================== */
#define I2C0_IC_INTR_STAT_R_RESTART_DET_Pos (12UL)                  /*!< R_RESTART_DET (Bit 12) */
#define I2C0_IC_INTR_STAT_R_RESTART_DET_Msk (0x1000UL)              /*!< R_RESTART_DET (Bitfield-Mask: 0x01) */
#define I2C0_IC_INTR_STAT_R_GEN_CALL_Pos  (11UL)                    /*!< R_GEN_CALL (Bit 11) */
#define I2C0_IC_INTR_STAT_R_GEN_CALL_Msk  (0x800UL)                 /*!< R_GEN_CALL (Bitfield-Mask: 0x01) */
#define I2C0_IC_INTR_STAT_R_START_DET_Pos (10UL)                    /*!< R_START_DET (Bit 10) */
#define I2C0_IC_INTR_STAT_R_START_DET_Msk (0x400UL)                 /*!< R_START_DET (Bitfield-Mask: 0x01) */
#define I2C0_IC_INTR_STAT_R_STOP_DET_Pos  (9UL)                     /*!< R_STOP_DET (Bit 9) */
#define I2C0_IC_INTR_STAT_R_STOP_DET_Msk  (0x200UL)                 /*!< R_STOP_DET (Bitfield-Mask: 0x01) */
#define I2C0_IC_INTR_STAT_R_ACTIVITY_Pos  (8UL)                     /*!< R_ACTIVITY (Bit 8) */
#define I2C0_IC_INTR_STAT_R_ACTIVITY_Msk  (0x100UL)                 /*!< R_ACTIVITY (Bitfield-Mask: 0x01) */
#define I2C0_IC_INTR_STAT_R_RX_DONE_Pos   (7UL)                     /*!< R_RX_DONE (Bit 7) */
#define I2C0_IC_INTR_STAT_R_RX_DONE_Msk   (0x80UL)                  /*!< R_RX_DONE (Bitfield-Mask: 0x01) */
#define I2C0_IC_INTR_STAT_R_TX_ABRT_Pos   (6UL)                     /*!< R_TX_ABRT (Bit 6) */
#define I2C0_IC_INTR_STAT_R_TX_ABRT_Msk   (0x40UL)                  /*!< R_TX_ABRT (Bitfield-Mask: 0x01) */
#define I2C0_IC_INTR_STAT_R_RD_REQ_Pos    (5UL)                     /*!< R_RD_REQ (Bit 5) */
#define I2C0_IC_INTR_STAT_R_RD_REQ_Msk    (0x20UL)                  /*!< R_RD_REQ (Bitfield-Mask: 0x01) */
#define I2C0_IC_INTR_STAT_R_TX_EMPTY_Pos  (4UL)                     /*!< R_TX_EMPTY (Bit 4) */
#define I2C0_IC_INTR_STAT_R_TX_EMPTY_Msk  (0x10UL)                  /*!< R_TX_EMPTY (Bitfield-Mask: 0x01) */
#define I2C0_IC_INTR_STAT_R_TX_OVER_Pos   (3UL)                     /*!< R_TX_OVER (Bit 3) */
#define I2C0_IC_INTR_STAT_R_TX_OVER_Msk   (0x8UL)                   /*!< R_TX_OVER (Bitfield-Mask: 0x01) */
#define I2C0_IC_INTR_STAT_R_RX_FULL_Pos   (2UL)                     /*!< R_RX_FULL (Bit 2) */
#define I2C0_IC_INTR_STAT_R_RX_FULL_Msk   (0x4UL)                   /*!< R_RX_FULL (Bitfield-Mask: 0x01) */
#define I2C0_IC_INTR_STAT_R_RX_OVER_Pos   (1UL)                     /*!< R_RX_OVER (Bit 1) */
#define I2C0_IC_INTR_STAT_R_RX_OVER_Msk   (0x2UL)                   /*!< R_RX_OVER (Bitfield-Mask: 0x01) */
#define I2C0_IC_INTR_STAT_R_RX_UNDER_Pos  (0UL)                     /*!< R_RX_UNDER (Bit 0) */
#define I2C0_IC_INTR_STAT_R_RX_UNDER_Msk  (0x1UL)                   /*!< R_RX_UNDER (Bitfield-Mask: 0x01) */
/* =====================================================  IC_INTR_MASK  ====================================================== */
#define I2C0_IC_INTR_MASK_M_RESTART_DET_Pos (12UL)                  /*!< M_RESTART_DET (Bit 12) */
#define I2C0_IC_INTR_MASK_M_RESTART_DET_Msk (0x1000UL)              /*!< M_RESTART_DET (Bitfield-Mask: 0x01) */
#define I2C0_IC_INTR_MASK_M_GEN_CALL_Pos  (11UL)                    /*!< M_GEN_CALL (Bit 11) */
#define I2C0_IC_INTR_MASK_M_GEN_CALL_Msk  (0x800UL)                 /*!< M_GEN_CALL (Bitfield-Mask: 0x01) */
#define I2C0_IC_INTR_MASK_M_START_DET_Pos (10UL)                    /*!< M_START_DET (Bit 10) */
#define I2C0_IC_INTR_MASK_M_START_DET_Msk (0x400UL)                 /*!< M_START_DET (Bitfield-Mask: 0x01) */
#define I2C0_IC_INTR_MASK_M_STOP_DET_Pos  (9UL)                     /*!< M_STOP_DET (Bit 9) */
#define I2C0_IC_INTR_MASK_M_STOP_DET_Msk  (0x200UL)                 /*!< M_STOP_DET (Bitfield-Mask: 0x01) */
#define I2C0_IC_INTR_MASK_M_ACTIVITY_Pos  (8UL)                     /*!< M_ACTIVITY (Bit 8) */
#define I2C0_IC_INTR_MASK_M_ACTIVITY_Msk  (0x100UL)                 /*!< M_ACTIVITY (Bitfield-Mask: 0x01) */
#define I2C0_IC_INTR_MASK_M_RX_DONE_Pos   (7UL)                     /*!< M_RX_DONE (Bit 7) */
#define I2C0_IC_INTR_MASK_M_RX_DONE_Msk   (0x80UL)                  /*!< M_RX_DONE (Bitfield-Mask: 0x01) */
#define I2C0_IC_INTR_MASK_M_TX_ABRT_Pos   (6UL)                     /*!< M_TX_ABRT (Bit 6) */
#define I2C0_IC_INTR_MASK_M_TX_ABRT_Msk   (0x40UL)                  /*!< M_TX_ABRT (Bitfield-Mask: 0x01) */
#define I2C0_IC_INTR_MASK_M_RD_REQ_Pos    (5UL)                     /*!< M_RD_REQ (Bit 5) */
#define I2C0_IC_INTR_MASK_M_RD_REQ_Msk    (0x20UL)                  /*!< M_RD_REQ (Bitfield-Mask: 0x01) */
#define I2C0_IC_INTR_MASK_M_TX_EMPTY_Pos  (4UL)                     /*!< M_TX_EMPTY (Bit 4) */
#define I2C0_IC_INTR_MASK_M_TX_EMPTY_Msk  (0x10UL)                  /*!< M_TX_EMPTY (Bitfield-Mask: 0x01) */
#define I2C0_IC_INTR_MASK_M_TX_OVER_Pos   (3UL)                     /*!< M_TX_OVER (Bit 3) */
#define I2C0_IC_INTR_MASK_M_TX_OVER_Msk   (0x8UL)                   /*!< M_TX_OVER (Bitfield-Mask: 0x01) */
#define I2C0_IC_INTR_MASK_M_RX_FULL_Pos   (2UL)                     /*!< M_RX_FULL (Bit 2) */
#define I2C0_IC_INTR_MASK_M_RX_FULL_Msk   (0x4UL)                   /*!< M_RX_FULL (Bitfield-Mask: 0x01) */
#define I2C0_IC_INTR_MASK_M_RX_OVER_Pos   (1UL)                     /*!< M_RX_OVER (Bit 1) */
#define I2C0_IC_INTR_MASK_M_RX_OVER_Msk   (0x2UL)                   /*!< M_RX_OVER (Bitfield-Mask: 0x01) */
#define I2C0_IC_INTR_MASK_M_RX_UNDER_Pos  (0UL)                     /*!< M_RX_UNDER (Bit 0) */
#define I2C0_IC_INTR_MASK_M_RX_UNDER_Msk  (0x1UL)                   /*!< M_RX_UNDER (Bitfield-Mask: 0x01) */
/* ===================================================  IC_RAW_INTR_STAT  ==================================================== */
#define I2C0_IC_RAW_INTR_STAT_RESTART_DET_Pos (12UL)                /*!< RESTART_DET (Bit 12) */
#define I2C0_IC_RAW_INTR_STAT_RESTART_DET_Msk (0x1000UL)            /*!< RESTART_DET (Bitfield-Mask: 0x01) */
#define I2C0_IC_RAW_INTR_STAT_GEN_CALL_Pos (11UL)                   /*!< GEN_CALL (Bit 11) */
#define I2C0_IC_RAW_INTR_STAT_GEN_CALL_Msk (0x800UL)                /*!< GEN_CALL (Bitfield-Mask: 0x01) */
#define I2C0_IC_RAW_INTR_STAT_START_DET_Pos (10UL)                  /*!< START_DET (Bit 10) */
#define I2C0_IC_RAW_INTR_STAT_START_DET_Msk (0x400UL)               /*!< START_DET (Bitfield-Mask: 0x01) */
#define I2C0_IC_RAW_INTR_STAT_STOP_DET_Pos (9UL)                    /*!< STOP_DET (Bit 9) */
#define I2C0_IC_RAW_INTR_STAT_STOP_DET_Msk (0x200UL)                /*!< STOP_DET (Bitfield-Mask: 0x01) */
#define I2C0_IC_RAW_INTR_STAT_ACTIVITY_Pos (8UL)                    /*!< ACTIVITY (Bit 8) */
#define I2C0_IC_RAW_INTR_STAT_ACTIVITY_Msk (0x100UL)                /*!< ACTIVITY (Bitfield-Mask: 0x01) */
#define I2C0_IC_RAW_INTR_STAT_RX_DONE_Pos (7UL)                     /*!< RX_DONE (Bit 7) */
#define I2C0_IC_RAW_INTR_STAT_RX_DONE_Msk (0x80UL)                  /*!< RX_DONE (Bitfield-Mask: 0x01) */
#define I2C0_IC_RAW_INTR_STAT_TX_ABRT_Pos (6UL)                     /*!< TX_ABRT (Bit 6) */
#define I2C0_IC_RAW_INTR_STAT_TX_ABRT_Msk (0x40UL)                  /*!< TX_ABRT (Bitfield-Mask: 0x01) */
#define I2C0_IC_RAW_INTR_STAT_RD_REQ_Pos  (5UL)                     /*!< RD_REQ (Bit 5) */
#define I2C0_IC_RAW_INTR_STAT_RD_REQ_Msk  (0x20UL)                  /*!< RD_REQ (Bitfield-Mask: 0x01) */
#define I2C0_IC_RAW_INTR_STAT_TX_EMPTY_Pos (4UL)                    /*!< TX_EMPTY (Bit 4) */
#define I2C0_IC_RAW_INTR_STAT_TX_EMPTY_Msk (0x10UL)                 /*!< TX_EMPTY (Bitfield-Mask: 0x01) */
#define I2C0_IC_RAW_INTR_STAT_TX_OVER_Pos (3UL)                     /*!< TX_OVER (Bit 3) */
#define I2C0_IC_RAW_INTR_STAT_TX_OVER_Msk (0x8UL)                   /*!< TX_OVER (Bitfield-Mask: 0x01) */
#define I2C0_IC_RAW_INTR_STAT_RX_FULL_Pos (2UL)                     /*!< RX_FULL (Bit 2) */
#define I2C0_IC_RAW_INTR_STAT_RX_FULL_Msk (0x4UL)                   /*!< RX_FULL (Bitfield-Mask: 0x01) */
#define I2C0_IC_RAW_INTR_STAT_RX_OVER_Pos (1UL)                     /*!< RX_OVER (Bit 1) */
#define I2C0_IC_RAW_INTR_STAT_RX_OVER_Msk (0x2UL)                   /*!< RX_OVER (Bitfield-Mask: 0x01) */
#define I2C0_IC_RAW_INTR_STAT_RX_UNDER_Pos (0UL)                    /*!< RX_UNDER (Bit 0) */
#define I2C0_IC_RAW_INTR_STAT_RX_UNDER_Msk (0x1UL)                  /*!< RX_UNDER (Bitfield-Mask: 0x01) */
/* =======================================================  IC_RX_TL  ======================================================== */
#define I2C0_IC_RX_TL_RX_TL_Pos           (0UL)                     /*!< RX_TL (Bit 0) */
#define I2C0_IC_RX_TL_RX_TL_Msk           (0xffUL)                  /*!< RX_TL (Bitfield-Mask: 0xff) */
/* =======================================================  IC_TX_TL  ======================================================== */
#define I2C0_IC_TX_TL_TX_TL_Pos           (0UL)                     /*!< TX_TL (Bit 0) */
#define I2C0_IC_TX_TL_TX_TL_Msk           (0xffUL)                  /*!< TX_TL (Bitfield-Mask: 0xff) */
/* ======================================================  IC_CLR_INTR  ====================================================== */
#define I2C0_IC_CLR_INTR_CLR_INTR_Pos     (0UL)                     /*!< CLR_INTR (Bit 0) */
#define I2C0_IC_CLR_INTR_CLR_INTR_Msk     (0x1UL)                   /*!< CLR_INTR (Bitfield-Mask: 0x01) */
/* ====================================================  IC_CLR_RX_UNDER  ==================================================== */
#define I2C0_IC_CLR_RX_UNDER_CLR_RX_UNDER_Pos (0UL)                 /*!< CLR_RX_UNDER (Bit 0) */
#define I2C0_IC_CLR_RX_UNDER_CLR_RX_UNDER_Msk (0x1UL)               /*!< CLR_RX_UNDER (Bitfield-Mask: 0x01) */
/* ====================================================  IC_CLR_RX_OVER  ===================================================== */
#define I2C0_IC_CLR_RX_OVER_CLR_RX_OVER_Pos (0UL)                   /*!< CLR_RX_OVER (Bit 0) */
#define I2C0_IC_CLR_RX_OVER_CLR_RX_OVER_Msk (0x1UL)                 /*!< CLR_RX_OVER (Bitfield-Mask: 0x01) */
/* ====================================================  IC_CLR_TX_OVER  ===================================================== */
#define I2C0_IC_CLR_TX_OVER_CLR_TX_OVER_Pos (0UL)                   /*!< CLR_TX_OVER (Bit 0) */
#define I2C0_IC_CLR_TX_OVER_CLR_TX_OVER_Msk (0x1UL)                 /*!< CLR_TX_OVER (Bitfield-Mask: 0x01) */
/* =====================================================  IC_CLR_RD_REQ  ===================================================== */
#define I2C0_IC_CLR_RD_REQ_CLR_RD_REQ_Pos (0UL)                     /*!< CLR_RD_REQ (Bit 0) */
#define I2C0_IC_CLR_RD_REQ_CLR_RD_REQ_Msk (0x1UL)                   /*!< CLR_RD_REQ (Bitfield-Mask: 0x01) */
/* ====================================================  IC_CLR_TX_ABRT  ===================================================== */
#define I2C0_IC_CLR_TX_ABRT_CLR_TX_ABRT_Pos (0UL)                   /*!< CLR_TX_ABRT (Bit 0) */
#define I2C0_IC_CLR_TX_ABRT_CLR_TX_ABRT_Msk (0x1UL)                 /*!< CLR_TX_ABRT (Bitfield-Mask: 0x01) */
/* ====================================================  IC_CLR_RX_DONE  ===================================================== */
#define I2C0_IC_CLR_RX_DONE_CLR_RX_DONE_Pos (0UL)                   /*!< CLR_RX_DONE (Bit 0) */
#define I2C0_IC_CLR_RX_DONE_CLR_RX_DONE_Msk (0x1UL)                 /*!< CLR_RX_DONE (Bitfield-Mask: 0x01) */
/* ====================================================  IC_CLR_ACTIVITY  ==================================================== */
#define I2C0_IC_CLR_ACTIVITY_CLR_ACTIVITY_Pos (0UL)                 /*!< CLR_ACTIVITY (Bit 0) */
#define I2C0_IC_CLR_ACTIVITY_CLR_ACTIVITY_Msk (0x1UL)               /*!< CLR_ACTIVITY (Bitfield-Mask: 0x01) */
/* ====================================================  IC_CLR_STOP_DET  ==================================================== */
#define I2C0_IC_CLR_STOP_DET_CLR_STOP_DET_Pos (0UL)                 /*!< CLR_STOP_DET (Bit 0) */
#define I2C0_IC_CLR_STOP_DET_CLR_STOP_DET_Msk (0x1UL)               /*!< CLR_STOP_DET (Bitfield-Mask: 0x01) */
/* ===================================================  IC_CLR_START_DET  ==================================================== */
#define I2C0_IC_CLR_START_DET_CLR_START_DET_Pos (0UL)               /*!< CLR_START_DET (Bit 0) */
#define I2C0_IC_CLR_START_DET_CLR_START_DET_Msk (0x1UL)             /*!< CLR_START_DET (Bitfield-Mask: 0x01) */
/* ====================================================  IC_CLR_GEN_CALL  ==================================================== */
#define I2C0_IC_CLR_GEN_CALL_CLR_GEN_CALL_Pos (0UL)                 /*!< CLR_GEN_CALL (Bit 0) */
#define I2C0_IC_CLR_GEN_CALL_CLR_GEN_CALL_Msk (0x1UL)               /*!< CLR_GEN_CALL (Bitfield-Mask: 0x01) */
/* =======================================================  IC_ENABLE  ======================================================= */
#define I2C0_IC_ENABLE_TX_CMD_BLOCK_Pos   (2UL)                     /*!< TX_CMD_BLOCK (Bit 2) */
#define I2C0_IC_ENABLE_TX_CMD_BLOCK_Msk   (0x4UL)                   /*!< TX_CMD_BLOCK (Bitfield-Mask: 0x01) */
#define I2C0_IC_ENABLE_ABORT_Pos          (1UL)                     /*!< ABORT (Bit 1) */
#define I2C0_IC_ENABLE_ABORT_Msk          (0x2UL)                   /*!< ABORT (Bitfield-Mask: 0x01) */
#define I2C0_IC_ENABLE_ENABLE_Pos         (0UL)                     /*!< ENABLE (Bit 0) */
#define I2C0_IC_ENABLE_ENABLE_Msk         (0x1UL)                   /*!< ENABLE (Bitfield-Mask: 0x01) */
/* =======================================================  IC_STATUS  ======================================================= */
#define I2C0_IC_STATUS_SLV_ACTIVITY_Pos   (6UL)                     /*!< SLV_ACTIVITY (Bit 6) */
#define I2C0_IC_STATUS_SLV_ACTIVITY_Msk   (0x40UL)                  /*!< SLV_ACTIVITY (Bitfield-Mask: 0x01) */
#define I2C0_IC_STATUS_MST_ACTIVITY_Pos   (5UL)                     /*!< MST_ACTIVITY (Bit 5) */
#define I2C0_IC_STATUS_MST_ACTIVITY_Msk   (0x20UL)                  /*!< MST_ACTIVITY (Bitfield-Mask: 0x01) */
#define I2C0_IC_STATUS_RFF_Pos            (4UL)                     /*!< RFF (Bit 4) */
#define I2C0_IC_STATUS_RFF_Msk            (0x10UL)                  /*!< RFF (Bitfield-Mask: 0x01) */
#define I2C0_IC_STATUS_RFNE_Pos           (3UL)                     /*!< RFNE (Bit 3) */
#define I2C0_IC_STATUS_RFNE_Msk           (0x8UL)                   /*!< RFNE (Bitfield-Mask: 0x01) */
#define I2C0_IC_STATUS_TFE_Pos            (2UL)                     /*!< TFE (Bit 2) */
#define I2C0_IC_STATUS_TFE_Msk            (0x4UL)                   /*!< TFE (Bitfield-Mask: 0x01) */
#define I2C0_IC_STATUS_TFNF_Pos           (1UL)                     /*!< TFNF (Bit 1) */
#define I2C0_IC_STATUS_TFNF_Msk           (0x2UL)                   /*!< TFNF (Bitfield-Mask: 0x01) */
#define I2C0_IC_STATUS_ACTIVITY_Pos       (0UL)                     /*!< ACTIVITY (Bit 0) */
#define I2C0_IC_STATUS_ACTIVITY_Msk       (0x1UL)                   /*!< ACTIVITY (Bitfield-Mask: 0x01) */
/* =======================================================  IC_TXFLR  ======================================================== */
#define I2C0_IC_TXFLR_TXFLR_Pos           (0UL)                     /*!< TXFLR (Bit 0) */
#define I2C0_IC_TXFLR_TXFLR_Msk           (0x1fUL)                  /*!< TXFLR (Bitfield-Mask: 0x1f) */
/* =======================================================  IC_RXFLR  ======================================================== */
#define I2C0_IC_RXFLR_RXFLR_Pos           (0UL)                     /*!< RXFLR (Bit 0) */
#define I2C0_IC_RXFLR_RXFLR_Msk           (0x1fUL)                  /*!< RXFLR (Bitfield-Mask: 0x1f) */
/* ======================================================  IC_SDA_HOLD  ====================================================== */
#define I2C0_IC_SDA_HOLD_IC_SDA_RX_HOLD_Pos (16UL)                  /*!< IC_SDA_RX_HOLD (Bit 16) */
#define I2C0_IC_SDA_HOLD_IC_SDA_RX_HOLD_Msk (0xff0000UL)            /*!< IC_SDA_RX_HOLD (Bitfield-Mask: 0xff) */
#define I2C0_IC_SDA_HOLD_IC_SDA_TX_HOLD_Pos (0UL)                   /*!< IC_SDA_TX_HOLD (Bit 0) */
#define I2C0_IC_SDA_HOLD_IC_SDA_TX_HOLD_Msk (0xffffUL)              /*!< IC_SDA_TX_HOLD (Bitfield-Mask: 0xffff) */
/* ===================================================  IC_TX_ABRT_SOURCE  =================================================== */
#define I2C0_IC_TX_ABRT_SOURCE_TX_FLUSH_CNT_Pos (23UL)              /*!< TX_FLUSH_CNT (Bit 23) */
#define I2C0_IC_TX_ABRT_SOURCE_TX_FLUSH_CNT_Msk (0xff800000UL)      /*!< TX_FLUSH_CNT (Bitfield-Mask: 0x1ff) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT_Pos (16UL)            /*!< ABRT_USER_ABRT (Bit 16) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT_Msk (0x10000UL)       /*!< ABRT_USER_ABRT (Bitfield-Mask: 0x01) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX_Pos (15UL)           /*!< ABRT_SLVRD_INTX (Bit 15) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX_Msk (0x8000UL)       /*!< ABRT_SLVRD_INTX (Bitfield-Mask: 0x01) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST_Pos (14UL)          /*!< ABRT_SLV_ARBLOST (Bit 14) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST_Msk (0x4000UL)      /*!< ABRT_SLV_ARBLOST (Bitfield-Mask: 0x01) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO_Pos (13UL)      /*!< ABRT_SLVFLUSH_TXFIFO (Bit 13) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO_Msk (0x2000UL)  /*!< ABRT_SLVFLUSH_TXFIFO (Bitfield-Mask: 0x01) */
#define I2C0_IC_TX_ABRT_SOURCE_ARB_LOST_Pos (12UL)                  /*!< ARB_LOST (Bit 12) */
#define I2C0_IC_TX_ABRT_SOURCE_ARB_LOST_Msk (0x1000UL)              /*!< ARB_LOST (Bitfield-Mask: 0x01) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS_Pos (11UL)           /*!< ABRT_MASTER_DIS (Bit 11) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS_Msk (0x800UL)        /*!< ABRT_MASTER_DIS (Bitfield-Mask: 0x01) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT_Pos (10UL)       /*!< ABRT_10B_RD_NORSTRT (Bit 10) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT_Msk (0x400UL)    /*!< ABRT_10B_RD_NORSTRT (Bitfield-Mask: 0x01) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT_Pos (9UL)         /*!< ABRT_SBYTE_NORSTRT (Bit 9) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT_Msk (0x200UL)     /*!< ABRT_SBYTE_NORSTRT (Bitfield-Mask: 0x01) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT_Pos (8UL)            /*!< ABRT_HS_NORSTRT (Bit 8) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT_Msk (0x100UL)        /*!< ABRT_HS_NORSTRT (Bitfield-Mask: 0x01) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET_Pos (7UL)          /*!< ABRT_SBYTE_ACKDET (Bit 7) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET_Msk (0x80UL)       /*!< ABRT_SBYTE_ACKDET (Bitfield-Mask: 0x01) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET_Pos (6UL)             /*!< ABRT_HS_ACKDET (Bit 6) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET_Msk (0x40UL)          /*!< ABRT_HS_ACKDET (Bitfield-Mask: 0x01) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ_Pos (5UL)            /*!< ABRT_GCALL_READ (Bit 5) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ_Msk (0x20UL)         /*!< ABRT_GCALL_READ (Bitfield-Mask: 0x01) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK_Pos (4UL)           /*!< ABRT_GCALL_NOACK (Bit 4) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK_Msk (0x10UL)        /*!< ABRT_GCALL_NOACK (Bitfield-Mask: 0x01) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK_Pos (3UL)          /*!< ABRT_TXDATA_NOACK (Bit 3) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK_Msk (0x8UL)        /*!< ABRT_TXDATA_NOACK (Bitfield-Mask: 0x01) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK_Pos (2UL)         /*!< ABRT_10ADDR2_NOACK (Bit 2) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK_Msk (0x4UL)       /*!< ABRT_10ADDR2_NOACK (Bitfield-Mask: 0x01) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK_Pos (1UL)         /*!< ABRT_10ADDR1_NOACK (Bit 1) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK_Msk (0x2UL)       /*!< ABRT_10ADDR1_NOACK (Bitfield-Mask: 0x01) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK_Pos (0UL)         /*!< ABRT_7B_ADDR_NOACK (Bit 0) */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK_Msk (0x1UL)       /*!< ABRT_7B_ADDR_NOACK (Bitfield-Mask: 0x01) */
/* =================================================  IC_SLV_DATA_NACK_ONLY  ================================================= */
#define I2C0_IC_SLV_DATA_NACK_ONLY_NACK_Pos (0UL)                   /*!< NACK (Bit 0) */
#define I2C0_IC_SLV_DATA_NACK_ONLY_NACK_Msk (0x1UL)                 /*!< NACK (Bitfield-Mask: 0x01) */
/* =======================================================  IC_DMA_CR  ======================================================= */
#define I2C0_IC_DMA_CR_TDMAE_Pos          (1UL)                     /*!< TDMAE (Bit 1) */
#define I2C0_IC_DMA_CR_TDMAE_Msk          (0x2UL)                   /*!< TDMAE (Bitfield-Mask: 0x01) */
#define I2C0_IC_DMA_CR_RDMAE_Pos          (0UL)                     /*!< RDMAE (Bit 0) */
#define I2C0_IC_DMA_CR_RDMAE_Msk          (0x1UL)                   /*!< RDMAE (Bitfield-Mask: 0x01) */
/* ======================================================  IC_DMA_TDLR  ====================================================== */
#define I2C0_IC_DMA_TDLR_DMATDL_Pos       (0UL)                     /*!< DMATDL (Bit 0) */
#define I2C0_IC_DMA_TDLR_DMATDL_Msk       (0xfUL)                   /*!< DMATDL (Bitfield-Mask: 0x0f) */
/* ======================================================  IC_DMA_RDLR  ====================================================== */
#define I2C0_IC_DMA_RDLR_DMARDL_Pos       (0UL)                     /*!< DMARDL (Bit 0) */
#define I2C0_IC_DMA_RDLR_DMARDL_Msk       (0xfUL)                   /*!< DMARDL (Bitfield-Mask: 0x0f) */
/* =====================================================  IC_SDA_SETUP  ====================================================== */
#define I2C0_IC_SDA_SETUP_SDA_SETUP_Pos   (0UL)                     /*!< SDA_SETUP (Bit 0) */
#define I2C0_IC_SDA_SETUP_SDA_SETUP_Msk   (0xffUL)                  /*!< SDA_SETUP (Bitfield-Mask: 0xff) */
/* ==================================================  IC_ACK_GENERAL_CALL  ================================================== */
#define I2C0_IC_ACK_GENERAL_CALL_ACK_GEN_CALL_Pos (0UL)             /*!< ACK_GEN_CALL (Bit 0) */
#define I2C0_IC_ACK_GENERAL_CALL_ACK_GEN_CALL_Msk (0x1UL)           /*!< ACK_GEN_CALL (Bitfield-Mask: 0x01) */
/* ===================================================  IC_ENABLE_STATUS  ==================================================== */
#define I2C0_IC_ENABLE_STATUS_SLV_RX_DATA_LOST_Pos (2UL)            /*!< SLV_RX_DATA_LOST (Bit 2) */
#define I2C0_IC_ENABLE_STATUS_SLV_RX_DATA_LOST_Msk (0x4UL)          /*!< SLV_RX_DATA_LOST (Bitfield-Mask: 0x01) */
#define I2C0_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY_Pos (1UL)     /*!< SLV_DISABLED_WHILE_BUSY (Bit 1) */
#define I2C0_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY_Msk (0x2UL)   /*!< SLV_DISABLED_WHILE_BUSY (Bitfield-Mask: 0x01) */
#define I2C0_IC_ENABLE_STATUS_IC_EN_Pos   (0UL)                     /*!< IC_EN (Bit 0) */
#define I2C0_IC_ENABLE_STATUS_IC_EN_Msk   (0x1UL)                   /*!< IC_EN (Bitfield-Mask: 0x01) */
/* =====================================================  IC_FS_SPKLEN  ====================================================== */
#define I2C0_IC_FS_SPKLEN_IC_FS_SPKLEN_Pos (0UL)                    /*!< IC_FS_SPKLEN (Bit 0) */
#define I2C0_IC_FS_SPKLEN_IC_FS_SPKLEN_Msk (0xffUL)                 /*!< IC_FS_SPKLEN (Bitfield-Mask: 0xff) */
/* ==================================================  IC_CLR_RESTART_DET  =================================================== */
#define I2C0_IC_CLR_RESTART_DET_CLR_RESTART_DET_Pos (0UL)           /*!< CLR_RESTART_DET (Bit 0) */
#define I2C0_IC_CLR_RESTART_DET_CLR_RESTART_DET_Msk (0x1UL)         /*!< CLR_RESTART_DET (Bitfield-Mask: 0x01) */
/* ====================================================  IC_COMP_PARAM_1  ==================================================== */
#define I2C0_IC_COMP_PARAM_1_TX_BUFFER_DEPTH_Pos (16UL)             /*!< TX_BUFFER_DEPTH (Bit 16) */
#define I2C0_IC_COMP_PARAM_1_TX_BUFFER_DEPTH_Msk (0xff0000UL)       /*!< TX_BUFFER_DEPTH (Bitfield-Mask: 0xff) */
#define I2C0_IC_COMP_PARAM_1_RX_BUFFER_DEPTH_Pos (8UL)              /*!< RX_BUFFER_DEPTH (Bit 8) */
#define I2C0_IC_COMP_PARAM_1_RX_BUFFER_DEPTH_Msk (0xff00UL)         /*!< RX_BUFFER_DEPTH (Bitfield-Mask: 0xff) */
#define I2C0_IC_COMP_PARAM_1_ADD_ENCODED_PARAMS_Pos (7UL)           /*!< ADD_ENCODED_PARAMS (Bit 7) */
#define I2C0_IC_COMP_PARAM_1_ADD_ENCODED_PARAMS_Msk (0x80UL)        /*!< ADD_ENCODED_PARAMS (Bitfield-Mask: 0x01) */
#define I2C0_IC_COMP_PARAM_1_HAS_DMA_Pos  (6UL)                     /*!< HAS_DMA (Bit 6) */
#define I2C0_IC_COMP_PARAM_1_HAS_DMA_Msk  (0x40UL)                  /*!< HAS_DMA (Bitfield-Mask: 0x01) */
#define I2C0_IC_COMP_PARAM_1_INTR_IO_Pos  (5UL)                     /*!< INTR_IO (Bit 5) */
#define I2C0_IC_COMP_PARAM_1_INTR_IO_Msk  (0x20UL)                  /*!< INTR_IO (Bitfield-Mask: 0x01) */
#define I2C0_IC_COMP_PARAM_1_HC_COUNT_VALUES_Pos (4UL)              /*!< HC_COUNT_VALUES (Bit 4) */
#define I2C0_IC_COMP_PARAM_1_HC_COUNT_VALUES_Msk (0x10UL)           /*!< HC_COUNT_VALUES (Bitfield-Mask: 0x01) */
#define I2C0_IC_COMP_PARAM_1_MAX_SPEED_MODE_Pos (2UL)               /*!< MAX_SPEED_MODE (Bit 2) */
#define I2C0_IC_COMP_PARAM_1_MAX_SPEED_MODE_Msk (0xcUL)             /*!< MAX_SPEED_MODE (Bitfield-Mask: 0x03) */
#define I2C0_IC_COMP_PARAM_1_APB_DATA_WIDTH_Pos (0UL)               /*!< APB_DATA_WIDTH (Bit 0) */
#define I2C0_IC_COMP_PARAM_1_APB_DATA_WIDTH_Msk (0x3UL)             /*!< APB_DATA_WIDTH (Bitfield-Mask: 0x03) */
/* ====================================================  IC_COMP_VERSION  ==================================================== */
#define I2C0_IC_COMP_VERSION_IC_COMP_VERSION_Pos (0UL)              /*!< IC_COMP_VERSION (Bit 0) */
#define I2C0_IC_COMP_VERSION_IC_COMP_VERSION_Msk (0xffffffffUL)     /*!< IC_COMP_VERSION (Bitfield-Mask: 0xffffffff) */
/* =====================================================  IC_COMP_TYPE  ====================================================== */
#define I2C0_IC_COMP_TYPE_IC_COMP_TYPE_Pos (0UL)                    /*!< IC_COMP_TYPE (Bit 0) */
#define I2C0_IC_COMP_TYPE_IC_COMP_TYPE_Msk (0xffffffffUL)           /*!< IC_COMP_TYPE (Bitfield-Mask: 0xffffffff) */


/* =========================================================================================================================== */
/* ================                                            ADC                                            ================ */
/* =========================================================================================================================== */

/* ==========================================================  CS  =========================================================== */
#define ADC_CS_RROBIN_Pos                 (16UL)                    /*!< RROBIN (Bit 16) */
#define ADC_CS_RROBIN_Msk                 (0x1f0000UL)              /*!< RROBIN (Bitfield-Mask: 0x1f) */
#define ADC_CS_AINSEL_Pos                 (12UL)                    /*!< AINSEL (Bit 12) */
#define ADC_CS_AINSEL_Msk                 (0x7000UL)                /*!< AINSEL (Bitfield-Mask: 0x07) */
#define ADC_CS_ERR_STICKY_Pos             (10UL)                    /*!< ERR_STICKY (Bit 10) */
#define ADC_CS_ERR_STICKY_Msk             (0x400UL)                 /*!< ERR_STICKY (Bitfield-Mask: 0x01) */
#define ADC_CS_ERR_Pos                    (9UL)                     /*!< ERR (Bit 9) */
#define ADC_CS_ERR_Msk                    (0x200UL)                 /*!< ERR (Bitfield-Mask: 0x01) */
#define ADC_CS_READY_Pos                  (8UL)                     /*!< READY (Bit 8) */
#define ADC_CS_READY_Msk                  (0x100UL)                 /*!< READY (Bitfield-Mask: 0x01) */
#define ADC_CS_START_MANY_Pos             (3UL)                     /*!< START_MANY (Bit 3) */
#define ADC_CS_START_MANY_Msk             (0x8UL)                   /*!< START_MANY (Bitfield-Mask: 0x01) */
#define ADC_CS_START_ONCE_Pos             (2UL)                     /*!< START_ONCE (Bit 2) */
#define ADC_CS_START_ONCE_Msk             (0x4UL)                   /*!< START_ONCE (Bitfield-Mask: 0x01) */
#define ADC_CS_TS_EN_Pos                  (1UL)                     /*!< TS_EN (Bit 1) */
#define ADC_CS_TS_EN_Msk                  (0x2UL)                   /*!< TS_EN (Bitfield-Mask: 0x01) */
#define ADC_CS_EN_Pos                     (0UL)                     /*!< EN (Bit 0) */
#define ADC_CS_EN_Msk                     (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01) */
/* ========================================================  RESULT  ========================================================= */
#define ADC_RESULT_RESULT_Pos             (0UL)                     /*!< RESULT (Bit 0) */
#define ADC_RESULT_RESULT_Msk             (0xfffUL)                 /*!< RESULT (Bitfield-Mask: 0xfff) */
/* ==========================================================  FCS  ========================================================== */
#define ADC_FCS_THRESH_Pos                (24UL)                    /*!< THRESH (Bit 24) */
#define ADC_FCS_THRESH_Msk                (0xf000000UL)             /*!< THRESH (Bitfield-Mask: 0x0f) */
#define ADC_FCS_LEVEL_Pos                 (16UL)                    /*!< LEVEL (Bit 16) */
#define ADC_FCS_LEVEL_Msk                 (0xf0000UL)               /*!< LEVEL (Bitfield-Mask: 0x0f) */
#define ADC_FCS_OVER_Pos                  (11UL)                    /*!< OVER (Bit 11) */
#define ADC_FCS_OVER_Msk                  (0x800UL)                 /*!< OVER (Bitfield-Mask: 0x01) */
#define ADC_FCS_UNDER_Pos                 (10UL)                    /*!< UNDER (Bit 10) */
#define ADC_FCS_UNDER_Msk                 (0x400UL)                 /*!< UNDER (Bitfield-Mask: 0x01) */
#define ADC_FCS_FULL_Pos                  (9UL)                     /*!< FULL (Bit 9) */
#define ADC_FCS_FULL_Msk                  (0x200UL)                 /*!< FULL (Bitfield-Mask: 0x01) */
#define ADC_FCS_EMPTY_Pos                 (8UL)                     /*!< EMPTY (Bit 8) */
#define ADC_FCS_EMPTY_Msk                 (0x100UL)                 /*!< EMPTY (Bitfield-Mask: 0x01) */
#define ADC_FCS_DREQ_EN_Pos               (3UL)                     /*!< DREQ_EN (Bit 3) */
#define ADC_FCS_DREQ_EN_Msk               (0x8UL)                   /*!< DREQ_EN (Bitfield-Mask: 0x01) */
#define ADC_FCS_ERR_Pos                   (2UL)                     /*!< ERR (Bit 2) */
#define ADC_FCS_ERR_Msk                   (0x4UL)                   /*!< ERR (Bitfield-Mask: 0x01) */
#define ADC_FCS_SHIFT_Pos                 (1UL)                     /*!< SHIFT (Bit 1) */
#define ADC_FCS_SHIFT_Msk                 (0x2UL)                   /*!< SHIFT (Bitfield-Mask: 0x01) */
#define ADC_FCS_EN_Pos                    (0UL)                     /*!< EN (Bit 0) */
#define ADC_FCS_EN_Msk                    (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01) */
/* =========================================================  FIFO  ========================================================== */
#define ADC_FIFO_ERR_Pos                  (15UL)                    /*!< ERR (Bit 15) */
#define ADC_FIFO_ERR_Msk                  (0x8000UL)                /*!< ERR (Bitfield-Mask: 0x01) */
#define ADC_FIFO_VAL_Pos                  (0UL)                     /*!< VAL (Bit 0) */
#define ADC_FIFO_VAL_Msk                  (0xfffUL)                 /*!< VAL (Bitfield-Mask: 0xfff) */
/* ==========================================================  DIV  ========================================================== */
#define ADC_DIV_INT_Pos                   (8UL)                     /*!< INT (Bit 8) */
#define ADC_DIV_INT_Msk                   (0xffff00UL)              /*!< INT (Bitfield-Mask: 0xffff) */
#define ADC_DIV_FRAC_Pos                  (0UL)                     /*!< FRAC (Bit 0) */
#define ADC_DIV_FRAC_Msk                  (0xffUL)                  /*!< FRAC (Bitfield-Mask: 0xff) */
/* =========================================================  INTR  ========================================================== */
#define ADC_INTR_FIFO_Pos                 (0UL)                     /*!< FIFO (Bit 0) */
#define ADC_INTR_FIFO_Msk                 (0x1UL)                   /*!< FIFO (Bitfield-Mask: 0x01) */
/* =========================================================  INTE  ========================================================== */
#define ADC_INTE_FIFO_Pos                 (0UL)                     /*!< FIFO (Bit 0) */
#define ADC_INTE_FIFO_Msk                 (0x1UL)                   /*!< FIFO (Bitfield-Mask: 0x01) */
/* =========================================================  INTF  ========================================================== */
#define ADC_INTF_FIFO_Pos                 (0UL)                     /*!< FIFO (Bit 0) */
#define ADC_INTF_FIFO_Msk                 (0x1UL)                   /*!< FIFO (Bitfield-Mask: 0x01) */
/* =========================================================  INTS  ========================================================== */
#define ADC_INTS_FIFO_Pos                 (0UL)                     /*!< FIFO (Bit 0) */
#define ADC_INTS_FIFO_Msk                 (0x1UL)                   /*!< FIFO (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                            PWM                                            ================ */
/* =========================================================================================================================== */

/* ========================================================  CH0_CSR  ======================================================== */
#define PWM_CH0_CSR_PH_ADV_Pos            (7UL)                     /*!< PH_ADV (Bit 7) */
#define PWM_CH0_CSR_PH_ADV_Msk            (0x80UL)                  /*!< PH_ADV (Bitfield-Mask: 0x01) */
#define PWM_CH0_CSR_PH_RET_Pos            (6UL)                     /*!< PH_RET (Bit 6) */
#define PWM_CH0_CSR_PH_RET_Msk            (0x40UL)                  /*!< PH_RET (Bitfield-Mask: 0x01) */
#define PWM_CH0_CSR_DIVMODE_Pos           (4UL)                     /*!< DIVMODE (Bit 4) */
#define PWM_CH0_CSR_DIVMODE_Msk           (0x30UL)                  /*!< DIVMODE (Bitfield-Mask: 0x03) */
#define PWM_CH0_CSR_B_INV_Pos             (3UL)                     /*!< B_INV (Bit 3) */
#define PWM_CH0_CSR_B_INV_Msk             (0x8UL)                   /*!< B_INV (Bitfield-Mask: 0x01) */
#define PWM_CH0_CSR_A_INV_Pos             (2UL)                     /*!< A_INV (Bit 2) */
#define PWM_CH0_CSR_A_INV_Msk             (0x4UL)                   /*!< A_INV (Bitfield-Mask: 0x01) */
#define PWM_CH0_CSR_PH_CORRECT_Pos        (1UL)                     /*!< PH_CORRECT (Bit 1) */
#define PWM_CH0_CSR_PH_CORRECT_Msk        (0x2UL)                   /*!< PH_CORRECT (Bitfield-Mask: 0x01) */
#define PWM_CH0_CSR_EN_Pos                (0UL)                     /*!< EN (Bit 0) */
#define PWM_CH0_CSR_EN_Msk                (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01) */
/* ========================================================  CH0_DIV  ======================================================== */
#define PWM_CH0_DIV_INT_Pos               (4UL)                     /*!< INT (Bit 4) */
#define PWM_CH0_DIV_INT_Msk               (0xff0UL)                 /*!< INT (Bitfield-Mask: 0xff) */
#define PWM_CH0_DIV_FRAC_Pos              (0UL)                     /*!< FRAC (Bit 0) */
#define PWM_CH0_DIV_FRAC_Msk              (0xfUL)                   /*!< FRAC (Bitfield-Mask: 0x0f) */
/* ========================================================  CH0_CTR  ======================================================== */
#define PWM_CH0_CTR_CH0_CTR_Pos           (0UL)                     /*!< CH0_CTR (Bit 0) */
#define PWM_CH0_CTR_CH0_CTR_Msk           (0xffffUL)                /*!< CH0_CTR (Bitfield-Mask: 0xffff) */
/* ========================================================  CH0_CC  ========================================================= */
#define PWM_CH0_CC_B_Pos                  (16UL)                    /*!< B (Bit 16) */
#define PWM_CH0_CC_B_Msk                  (0xffff0000UL)            /*!< B (Bitfield-Mask: 0xffff) */
#define PWM_CH0_CC_A_Pos                  (0UL)                     /*!< A (Bit 0) */
#define PWM_CH0_CC_A_Msk                  (0xffffUL)                /*!< A (Bitfield-Mask: 0xffff) */
/* ========================================================  CH0_TOP  ======================================================== */
#define PWM_CH0_TOP_CH0_TOP_Pos           (0UL)                     /*!< CH0_TOP (Bit 0) */
#define PWM_CH0_TOP_CH0_TOP_Msk           (0xffffUL)                /*!< CH0_TOP (Bitfield-Mask: 0xffff) */
/* ========================================================  CH1_CSR  ======================================================== */
#define PWM_CH1_CSR_PH_ADV_Pos            (7UL)                     /*!< PH_ADV (Bit 7) */
#define PWM_CH1_CSR_PH_ADV_Msk            (0x80UL)                  /*!< PH_ADV (Bitfield-Mask: 0x01) */
#define PWM_CH1_CSR_PH_RET_Pos            (6UL)                     /*!< PH_RET (Bit 6) */
#define PWM_CH1_CSR_PH_RET_Msk            (0x40UL)                  /*!< PH_RET (Bitfield-Mask: 0x01) */
#define PWM_CH1_CSR_DIVMODE_Pos           (4UL)                     /*!< DIVMODE (Bit 4) */
#define PWM_CH1_CSR_DIVMODE_Msk           (0x30UL)                  /*!< DIVMODE (Bitfield-Mask: 0x03) */
#define PWM_CH1_CSR_B_INV_Pos             (3UL)                     /*!< B_INV (Bit 3) */
#define PWM_CH1_CSR_B_INV_Msk             (0x8UL)                   /*!< B_INV (Bitfield-Mask: 0x01) */
#define PWM_CH1_CSR_A_INV_Pos             (2UL)                     /*!< A_INV (Bit 2) */
#define PWM_CH1_CSR_A_INV_Msk             (0x4UL)                   /*!< A_INV (Bitfield-Mask: 0x01) */
#define PWM_CH1_CSR_PH_CORRECT_Pos        (1UL)                     /*!< PH_CORRECT (Bit 1) */
#define PWM_CH1_CSR_PH_CORRECT_Msk        (0x2UL)                   /*!< PH_CORRECT (Bitfield-Mask: 0x01) */
#define PWM_CH1_CSR_EN_Pos                (0UL)                     /*!< EN (Bit 0) */
#define PWM_CH1_CSR_EN_Msk                (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01) */
/* ========================================================  CH1_DIV  ======================================================== */
#define PWM_CH1_DIV_INT_Pos               (4UL)                     /*!< INT (Bit 4) */
#define PWM_CH1_DIV_INT_Msk               (0xff0UL)                 /*!< INT (Bitfield-Mask: 0xff) */
#define PWM_CH1_DIV_FRAC_Pos              (0UL)                     /*!< FRAC (Bit 0) */
#define PWM_CH1_DIV_FRAC_Msk              (0xfUL)                   /*!< FRAC (Bitfield-Mask: 0x0f) */
/* ========================================================  CH1_CTR  ======================================================== */
#define PWM_CH1_CTR_CH1_CTR_Pos           (0UL)                     /*!< CH1_CTR (Bit 0) */
#define PWM_CH1_CTR_CH1_CTR_Msk           (0xffffUL)                /*!< CH1_CTR (Bitfield-Mask: 0xffff) */
/* ========================================================  CH1_CC  ========================================================= */
#define PWM_CH1_CC_B_Pos                  (16UL)                    /*!< B (Bit 16) */
#define PWM_CH1_CC_B_Msk                  (0xffff0000UL)            /*!< B (Bitfield-Mask: 0xffff) */
#define PWM_CH1_CC_A_Pos                  (0UL)                     /*!< A (Bit 0) */
#define PWM_CH1_CC_A_Msk                  (0xffffUL)                /*!< A (Bitfield-Mask: 0xffff) */
/* ========================================================  CH1_TOP  ======================================================== */
#define PWM_CH1_TOP_CH1_TOP_Pos           (0UL)                     /*!< CH1_TOP (Bit 0) */
#define PWM_CH1_TOP_CH1_TOP_Msk           (0xffffUL)                /*!< CH1_TOP (Bitfield-Mask: 0xffff) */
/* ========================================================  CH2_CSR  ======================================================== */
#define PWM_CH2_CSR_PH_ADV_Pos            (7UL)                     /*!< PH_ADV (Bit 7) */
#define PWM_CH2_CSR_PH_ADV_Msk            (0x80UL)                  /*!< PH_ADV (Bitfield-Mask: 0x01) */
#define PWM_CH2_CSR_PH_RET_Pos            (6UL)                     /*!< PH_RET (Bit 6) */
#define PWM_CH2_CSR_PH_RET_Msk            (0x40UL)                  /*!< PH_RET (Bitfield-Mask: 0x01) */
#define PWM_CH2_CSR_DIVMODE_Pos           (4UL)                     /*!< DIVMODE (Bit 4) */
#define PWM_CH2_CSR_DIVMODE_Msk           (0x30UL)                  /*!< DIVMODE (Bitfield-Mask: 0x03) */
#define PWM_CH2_CSR_B_INV_Pos             (3UL)                     /*!< B_INV (Bit 3) */
#define PWM_CH2_CSR_B_INV_Msk             (0x8UL)                   /*!< B_INV (Bitfield-Mask: 0x01) */
#define PWM_CH2_CSR_A_INV_Pos             (2UL)                     /*!< A_INV (Bit 2) */
#define PWM_CH2_CSR_A_INV_Msk             (0x4UL)                   /*!< A_INV (Bitfield-Mask: 0x01) */
#define PWM_CH2_CSR_PH_CORRECT_Pos        (1UL)                     /*!< PH_CORRECT (Bit 1) */
#define PWM_CH2_CSR_PH_CORRECT_Msk        (0x2UL)                   /*!< PH_CORRECT (Bitfield-Mask: 0x01) */
#define PWM_CH2_CSR_EN_Pos                (0UL)                     /*!< EN (Bit 0) */
#define PWM_CH2_CSR_EN_Msk                (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01) */
/* ========================================================  CH2_DIV  ======================================================== */
#define PWM_CH2_DIV_INT_Pos               (4UL)                     /*!< INT (Bit 4) */
#define PWM_CH2_DIV_INT_Msk               (0xff0UL)                 /*!< INT (Bitfield-Mask: 0xff) */
#define PWM_CH2_DIV_FRAC_Pos              (0UL)                     /*!< FRAC (Bit 0) */
#define PWM_CH2_DIV_FRAC_Msk              (0xfUL)                   /*!< FRAC (Bitfield-Mask: 0x0f) */
/* ========================================================  CH2_CTR  ======================================================== */
#define PWM_CH2_CTR_CH2_CTR_Pos           (0UL)                     /*!< CH2_CTR (Bit 0) */
#define PWM_CH2_CTR_CH2_CTR_Msk           (0xffffUL)                /*!< CH2_CTR (Bitfield-Mask: 0xffff) */
/* ========================================================  CH2_CC  ========================================================= */
#define PWM_CH2_CC_B_Pos                  (16UL)                    /*!< B (Bit 16) */
#define PWM_CH2_CC_B_Msk                  (0xffff0000UL)            /*!< B (Bitfield-Mask: 0xffff) */
#define PWM_CH2_CC_A_Pos                  (0UL)                     /*!< A (Bit 0) */
#define PWM_CH2_CC_A_Msk                  (0xffffUL)                /*!< A (Bitfield-Mask: 0xffff) */
/* ========================================================  CH2_TOP  ======================================================== */
#define PWM_CH2_TOP_CH2_TOP_Pos           (0UL)                     /*!< CH2_TOP (Bit 0) */
#define PWM_CH2_TOP_CH2_TOP_Msk           (0xffffUL)                /*!< CH2_TOP (Bitfield-Mask: 0xffff) */
/* ========================================================  CH3_CSR  ======================================================== */
#define PWM_CH3_CSR_PH_ADV_Pos            (7UL)                     /*!< PH_ADV (Bit 7) */
#define PWM_CH3_CSR_PH_ADV_Msk            (0x80UL)                  /*!< PH_ADV (Bitfield-Mask: 0x01) */
#define PWM_CH3_CSR_PH_RET_Pos            (6UL)                     /*!< PH_RET (Bit 6) */
#define PWM_CH3_CSR_PH_RET_Msk            (0x40UL)                  /*!< PH_RET (Bitfield-Mask: 0x01) */
#define PWM_CH3_CSR_DIVMODE_Pos           (4UL)                     /*!< DIVMODE (Bit 4) */
#define PWM_CH3_CSR_DIVMODE_Msk           (0x30UL)                  /*!< DIVMODE (Bitfield-Mask: 0x03) */
#define PWM_CH3_CSR_B_INV_Pos             (3UL)                     /*!< B_INV (Bit 3) */
#define PWM_CH3_CSR_B_INV_Msk             (0x8UL)                   /*!< B_INV (Bitfield-Mask: 0x01) */
#define PWM_CH3_CSR_A_INV_Pos             (2UL)                     /*!< A_INV (Bit 2) */
#define PWM_CH3_CSR_A_INV_Msk             (0x4UL)                   /*!< A_INV (Bitfield-Mask: 0x01) */
#define PWM_CH3_CSR_PH_CORRECT_Pos        (1UL)                     /*!< PH_CORRECT (Bit 1) */
#define PWM_CH3_CSR_PH_CORRECT_Msk        (0x2UL)                   /*!< PH_CORRECT (Bitfield-Mask: 0x01) */
#define PWM_CH3_CSR_EN_Pos                (0UL)                     /*!< EN (Bit 0) */
#define PWM_CH3_CSR_EN_Msk                (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01) */
/* ========================================================  CH3_DIV  ======================================================== */
#define PWM_CH3_DIV_INT_Pos               (4UL)                     /*!< INT (Bit 4) */
#define PWM_CH3_DIV_INT_Msk               (0xff0UL)                 /*!< INT (Bitfield-Mask: 0xff) */
#define PWM_CH3_DIV_FRAC_Pos              (0UL)                     /*!< FRAC (Bit 0) */
#define PWM_CH3_DIV_FRAC_Msk              (0xfUL)                   /*!< FRAC (Bitfield-Mask: 0x0f) */
/* ========================================================  CH3_CTR  ======================================================== */
#define PWM_CH3_CTR_CH3_CTR_Pos           (0UL)                     /*!< CH3_CTR (Bit 0) */
#define PWM_CH3_CTR_CH3_CTR_Msk           (0xffffUL)                /*!< CH3_CTR (Bitfield-Mask: 0xffff) */
/* ========================================================  CH3_CC  ========================================================= */
#define PWM_CH3_CC_B_Pos                  (16UL)                    /*!< B (Bit 16) */
#define PWM_CH3_CC_B_Msk                  (0xffff0000UL)            /*!< B (Bitfield-Mask: 0xffff) */
#define PWM_CH3_CC_A_Pos                  (0UL)                     /*!< A (Bit 0) */
#define PWM_CH3_CC_A_Msk                  (0xffffUL)                /*!< A (Bitfield-Mask: 0xffff) */
/* ========================================================  CH3_TOP  ======================================================== */
#define PWM_CH3_TOP_CH3_TOP_Pos           (0UL)                     /*!< CH3_TOP (Bit 0) */
#define PWM_CH3_TOP_CH3_TOP_Msk           (0xffffUL)                /*!< CH3_TOP (Bitfield-Mask: 0xffff) */
/* ========================================================  CH4_CSR  ======================================================== */
#define PWM_CH4_CSR_PH_ADV_Pos            (7UL)                     /*!< PH_ADV (Bit 7) */
#define PWM_CH4_CSR_PH_ADV_Msk            (0x80UL)                  /*!< PH_ADV (Bitfield-Mask: 0x01) */
#define PWM_CH4_CSR_PH_RET_Pos            (6UL)                     /*!< PH_RET (Bit 6) */
#define PWM_CH4_CSR_PH_RET_Msk            (0x40UL)                  /*!< PH_RET (Bitfield-Mask: 0x01) */
#define PWM_CH4_CSR_DIVMODE_Pos           (4UL)                     /*!< DIVMODE (Bit 4) */
#define PWM_CH4_CSR_DIVMODE_Msk           (0x30UL)                  /*!< DIVMODE (Bitfield-Mask: 0x03) */
#define PWM_CH4_CSR_B_INV_Pos             (3UL)                     /*!< B_INV (Bit 3) */
#define PWM_CH4_CSR_B_INV_Msk             (0x8UL)                   /*!< B_INV (Bitfield-Mask: 0x01) */
#define PWM_CH4_CSR_A_INV_Pos             (2UL)                     /*!< A_INV (Bit 2) */
#define PWM_CH4_CSR_A_INV_Msk             (0x4UL)                   /*!< A_INV (Bitfield-Mask: 0x01) */
#define PWM_CH4_CSR_PH_CORRECT_Pos        (1UL)                     /*!< PH_CORRECT (Bit 1) */
#define PWM_CH4_CSR_PH_CORRECT_Msk        (0x2UL)                   /*!< PH_CORRECT (Bitfield-Mask: 0x01) */
#define PWM_CH4_CSR_EN_Pos                (0UL)                     /*!< EN (Bit 0) */
#define PWM_CH4_CSR_EN_Msk                (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01) */
/* ========================================================  CH4_DIV  ======================================================== */
#define PWM_CH4_DIV_INT_Pos               (4UL)                     /*!< INT (Bit 4) */
#define PWM_CH4_DIV_INT_Msk               (0xff0UL)                 /*!< INT (Bitfield-Mask: 0xff) */
#define PWM_CH4_DIV_FRAC_Pos              (0UL)                     /*!< FRAC (Bit 0) */
#define PWM_CH4_DIV_FRAC_Msk              (0xfUL)                   /*!< FRAC (Bitfield-Mask: 0x0f) */
/* ========================================================  CH4_CTR  ======================================================== */
#define PWM_CH4_CTR_CH4_CTR_Pos           (0UL)                     /*!< CH4_CTR (Bit 0) */
#define PWM_CH4_CTR_CH4_CTR_Msk           (0xffffUL)                /*!< CH4_CTR (Bitfield-Mask: 0xffff) */
/* ========================================================  CH4_CC  ========================================================= */
#define PWM_CH4_CC_B_Pos                  (16UL)                    /*!< B (Bit 16) */
#define PWM_CH4_CC_B_Msk                  (0xffff0000UL)            /*!< B (Bitfield-Mask: 0xffff) */
#define PWM_CH4_CC_A_Pos                  (0UL)                     /*!< A (Bit 0) */
#define PWM_CH4_CC_A_Msk                  (0xffffUL)                /*!< A (Bitfield-Mask: 0xffff) */
/* ========================================================  CH4_TOP  ======================================================== */
#define PWM_CH4_TOP_CH4_TOP_Pos           (0UL)                     /*!< CH4_TOP (Bit 0) */
#define PWM_CH4_TOP_CH4_TOP_Msk           (0xffffUL)                /*!< CH4_TOP (Bitfield-Mask: 0xffff) */
/* ========================================================  CH5_CSR  ======================================================== */
#define PWM_CH5_CSR_PH_ADV_Pos            (7UL)                     /*!< PH_ADV (Bit 7) */
#define PWM_CH5_CSR_PH_ADV_Msk            (0x80UL)                  /*!< PH_ADV (Bitfield-Mask: 0x01) */
#define PWM_CH5_CSR_PH_RET_Pos            (6UL)                     /*!< PH_RET (Bit 6) */
#define PWM_CH5_CSR_PH_RET_Msk            (0x40UL)                  /*!< PH_RET (Bitfield-Mask: 0x01) */
#define PWM_CH5_CSR_DIVMODE_Pos           (4UL)                     /*!< DIVMODE (Bit 4) */
#define PWM_CH5_CSR_DIVMODE_Msk           (0x30UL)                  /*!< DIVMODE (Bitfield-Mask: 0x03) */
#define PWM_CH5_CSR_B_INV_Pos             (3UL)                     /*!< B_INV (Bit 3) */
#define PWM_CH5_CSR_B_INV_Msk             (0x8UL)                   /*!< B_INV (Bitfield-Mask: 0x01) */
#define PWM_CH5_CSR_A_INV_Pos             (2UL)                     /*!< A_INV (Bit 2) */
#define PWM_CH5_CSR_A_INV_Msk             (0x4UL)                   /*!< A_INV (Bitfield-Mask: 0x01) */
#define PWM_CH5_CSR_PH_CORRECT_Pos        (1UL)                     /*!< PH_CORRECT (Bit 1) */
#define PWM_CH5_CSR_PH_CORRECT_Msk        (0x2UL)                   /*!< PH_CORRECT (Bitfield-Mask: 0x01) */
#define PWM_CH5_CSR_EN_Pos                (0UL)                     /*!< EN (Bit 0) */
#define PWM_CH5_CSR_EN_Msk                (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01) */
/* ========================================================  CH5_DIV  ======================================================== */
#define PWM_CH5_DIV_INT_Pos               (4UL)                     /*!< INT (Bit 4) */
#define PWM_CH5_DIV_INT_Msk               (0xff0UL)                 /*!< INT (Bitfield-Mask: 0xff) */
#define PWM_CH5_DIV_FRAC_Pos              (0UL)                     /*!< FRAC (Bit 0) */
#define PWM_CH5_DIV_FRAC_Msk              (0xfUL)                   /*!< FRAC (Bitfield-Mask: 0x0f) */
/* ========================================================  CH5_CTR  ======================================================== */
#define PWM_CH5_CTR_CH5_CTR_Pos           (0UL)                     /*!< CH5_CTR (Bit 0) */
#define PWM_CH5_CTR_CH5_CTR_Msk           (0xffffUL)                /*!< CH5_CTR (Bitfield-Mask: 0xffff) */
/* ========================================================  CH5_CC  ========================================================= */
#define PWM_CH5_CC_B_Pos                  (16UL)                    /*!< B (Bit 16) */
#define PWM_CH5_CC_B_Msk                  (0xffff0000UL)            /*!< B (Bitfield-Mask: 0xffff) */
#define PWM_CH5_CC_A_Pos                  (0UL)                     /*!< A (Bit 0) */
#define PWM_CH5_CC_A_Msk                  (0xffffUL)                /*!< A (Bitfield-Mask: 0xffff) */
/* ========================================================  CH5_TOP  ======================================================== */
#define PWM_CH5_TOP_CH5_TOP_Pos           (0UL)                     /*!< CH5_TOP (Bit 0) */
#define PWM_CH5_TOP_CH5_TOP_Msk           (0xffffUL)                /*!< CH5_TOP (Bitfield-Mask: 0xffff) */
/* ========================================================  CH6_CSR  ======================================================== */
#define PWM_CH6_CSR_PH_ADV_Pos            (7UL)                     /*!< PH_ADV (Bit 7) */
#define PWM_CH6_CSR_PH_ADV_Msk            (0x80UL)                  /*!< PH_ADV (Bitfield-Mask: 0x01) */
#define PWM_CH6_CSR_PH_RET_Pos            (6UL)                     /*!< PH_RET (Bit 6) */
#define PWM_CH6_CSR_PH_RET_Msk            (0x40UL)                  /*!< PH_RET (Bitfield-Mask: 0x01) */
#define PWM_CH6_CSR_DIVMODE_Pos           (4UL)                     /*!< DIVMODE (Bit 4) */
#define PWM_CH6_CSR_DIVMODE_Msk           (0x30UL)                  /*!< DIVMODE (Bitfield-Mask: 0x03) */
#define PWM_CH6_CSR_B_INV_Pos             (3UL)                     /*!< B_INV (Bit 3) */
#define PWM_CH6_CSR_B_INV_Msk             (0x8UL)                   /*!< B_INV (Bitfield-Mask: 0x01) */
#define PWM_CH6_CSR_A_INV_Pos             (2UL)                     /*!< A_INV (Bit 2) */
#define PWM_CH6_CSR_A_INV_Msk             (0x4UL)                   /*!< A_INV (Bitfield-Mask: 0x01) */
#define PWM_CH6_CSR_PH_CORRECT_Pos        (1UL)                     /*!< PH_CORRECT (Bit 1) */
#define PWM_CH6_CSR_PH_CORRECT_Msk        (0x2UL)                   /*!< PH_CORRECT (Bitfield-Mask: 0x01) */
#define PWM_CH6_CSR_EN_Pos                (0UL)                     /*!< EN (Bit 0) */
#define PWM_CH6_CSR_EN_Msk                (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01) */
/* ========================================================  CH6_DIV  ======================================================== */
#define PWM_CH6_DIV_INT_Pos               (4UL)                     /*!< INT (Bit 4) */
#define PWM_CH6_DIV_INT_Msk               (0xff0UL)                 /*!< INT (Bitfield-Mask: 0xff) */
#define PWM_CH6_DIV_FRAC_Pos              (0UL)                     /*!< FRAC (Bit 0) */
#define PWM_CH6_DIV_FRAC_Msk              (0xfUL)                   /*!< FRAC (Bitfield-Mask: 0x0f) */
/* ========================================================  CH6_CTR  ======================================================== */
#define PWM_CH6_CTR_CH6_CTR_Pos           (0UL)                     /*!< CH6_CTR (Bit 0) */
#define PWM_CH6_CTR_CH6_CTR_Msk           (0xffffUL)                /*!< CH6_CTR (Bitfield-Mask: 0xffff) */
/* ========================================================  CH6_CC  ========================================================= */
#define PWM_CH6_CC_B_Pos                  (16UL)                    /*!< B (Bit 16) */
#define PWM_CH6_CC_B_Msk                  (0xffff0000UL)            /*!< B (Bitfield-Mask: 0xffff) */
#define PWM_CH6_CC_A_Pos                  (0UL)                     /*!< A (Bit 0) */
#define PWM_CH6_CC_A_Msk                  (0xffffUL)                /*!< A (Bitfield-Mask: 0xffff) */
/* ========================================================  CH6_TOP  ======================================================== */
#define PWM_CH6_TOP_CH6_TOP_Pos           (0UL)                     /*!< CH6_TOP (Bit 0) */
#define PWM_CH6_TOP_CH6_TOP_Msk           (0xffffUL)                /*!< CH6_TOP (Bitfield-Mask: 0xffff) */
/* ========================================================  CH7_CSR  ======================================================== */
#define PWM_CH7_CSR_PH_ADV_Pos            (7UL)                     /*!< PH_ADV (Bit 7) */
#define PWM_CH7_CSR_PH_ADV_Msk            (0x80UL)                  /*!< PH_ADV (Bitfield-Mask: 0x01) */
#define PWM_CH7_CSR_PH_RET_Pos            (6UL)                     /*!< PH_RET (Bit 6) */
#define PWM_CH7_CSR_PH_RET_Msk            (0x40UL)                  /*!< PH_RET (Bitfield-Mask: 0x01) */
#define PWM_CH7_CSR_DIVMODE_Pos           (4UL)                     /*!< DIVMODE (Bit 4) */
#define PWM_CH7_CSR_DIVMODE_Msk           (0x30UL)                  /*!< DIVMODE (Bitfield-Mask: 0x03) */
#define PWM_CH7_CSR_B_INV_Pos             (3UL)                     /*!< B_INV (Bit 3) */
#define PWM_CH7_CSR_B_INV_Msk             (0x8UL)                   /*!< B_INV (Bitfield-Mask: 0x01) */
#define PWM_CH7_CSR_A_INV_Pos             (2UL)                     /*!< A_INV (Bit 2) */
#define PWM_CH7_CSR_A_INV_Msk             (0x4UL)                   /*!< A_INV (Bitfield-Mask: 0x01) */
#define PWM_CH7_CSR_PH_CORRECT_Pos        (1UL)                     /*!< PH_CORRECT (Bit 1) */
#define PWM_CH7_CSR_PH_CORRECT_Msk        (0x2UL)                   /*!< PH_CORRECT (Bitfield-Mask: 0x01) */
#define PWM_CH7_CSR_EN_Pos                (0UL)                     /*!< EN (Bit 0) */
#define PWM_CH7_CSR_EN_Msk                (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01) */
/* ========================================================  CH7_DIV  ======================================================== */
#define PWM_CH7_DIV_INT_Pos               (4UL)                     /*!< INT (Bit 4) */
#define PWM_CH7_DIV_INT_Msk               (0xff0UL)                 /*!< INT (Bitfield-Mask: 0xff) */
#define PWM_CH7_DIV_FRAC_Pos              (0UL)                     /*!< FRAC (Bit 0) */
#define PWM_CH7_DIV_FRAC_Msk              (0xfUL)                   /*!< FRAC (Bitfield-Mask: 0x0f) */
/* ========================================================  CH7_CTR  ======================================================== */
#define PWM_CH7_CTR_CH7_CTR_Pos           (0UL)                     /*!< CH7_CTR (Bit 0) */
#define PWM_CH7_CTR_CH7_CTR_Msk           (0xffffUL)                /*!< CH7_CTR (Bitfield-Mask: 0xffff) */
/* ========================================================  CH7_CC  ========================================================= */
#define PWM_CH7_CC_B_Pos                  (16UL)                    /*!< B (Bit 16) */
#define PWM_CH7_CC_B_Msk                  (0xffff0000UL)            /*!< B (Bitfield-Mask: 0xffff) */
#define PWM_CH7_CC_A_Pos                  (0UL)                     /*!< A (Bit 0) */
#define PWM_CH7_CC_A_Msk                  (0xffffUL)                /*!< A (Bitfield-Mask: 0xffff) */
/* ========================================================  CH7_TOP  ======================================================== */
#define PWM_CH7_TOP_CH7_TOP_Pos           (0UL)                     /*!< CH7_TOP (Bit 0) */
#define PWM_CH7_TOP_CH7_TOP_Msk           (0xffffUL)                /*!< CH7_TOP (Bitfield-Mask: 0xffff) */
/* ==========================================================  EN  =========================================================== */
#define PWM_EN_CH7_Pos                    (7UL)                     /*!< CH7 (Bit 7) */
#define PWM_EN_CH7_Msk                    (0x80UL)                  /*!< CH7 (Bitfield-Mask: 0x01) */
#define PWM_EN_CH6_Pos                    (6UL)                     /*!< CH6 (Bit 6) */
#define PWM_EN_CH6_Msk                    (0x40UL)                  /*!< CH6 (Bitfield-Mask: 0x01) */
#define PWM_EN_CH5_Pos                    (5UL)                     /*!< CH5 (Bit 5) */
#define PWM_EN_CH5_Msk                    (0x20UL)                  /*!< CH5 (Bitfield-Mask: 0x01) */
#define PWM_EN_CH4_Pos                    (4UL)                     /*!< CH4 (Bit 4) */
#define PWM_EN_CH4_Msk                    (0x10UL)                  /*!< CH4 (Bitfield-Mask: 0x01) */
#define PWM_EN_CH3_Pos                    (3UL)                     /*!< CH3 (Bit 3) */
#define PWM_EN_CH3_Msk                    (0x8UL)                   /*!< CH3 (Bitfield-Mask: 0x01) */
#define PWM_EN_CH2_Pos                    (2UL)                     /*!< CH2 (Bit 2) */
#define PWM_EN_CH2_Msk                    (0x4UL)                   /*!< CH2 (Bitfield-Mask: 0x01) */
#define PWM_EN_CH1_Pos                    (1UL)                     /*!< CH1 (Bit 1) */
#define PWM_EN_CH1_Msk                    (0x2UL)                   /*!< CH1 (Bitfield-Mask: 0x01) */
#define PWM_EN_CH0_Pos                    (0UL)                     /*!< CH0 (Bit 0) */
#define PWM_EN_CH0_Msk                    (0x1UL)                   /*!< CH0 (Bitfield-Mask: 0x01) */
/* =========================================================  INTR  ========================================================== */
#define PWM_INTR_CH7_Pos                  (7UL)                     /*!< CH7 (Bit 7) */
#define PWM_INTR_CH7_Msk                  (0x80UL)                  /*!< CH7 (Bitfield-Mask: 0x01) */
#define PWM_INTR_CH6_Pos                  (6UL)                     /*!< CH6 (Bit 6) */
#define PWM_INTR_CH6_Msk                  (0x40UL)                  /*!< CH6 (Bitfield-Mask: 0x01) */
#define PWM_INTR_CH5_Pos                  (5UL)                     /*!< CH5 (Bit 5) */
#define PWM_INTR_CH5_Msk                  (0x20UL)                  /*!< CH5 (Bitfield-Mask: 0x01) */
#define PWM_INTR_CH4_Pos                  (4UL)                     /*!< CH4 (Bit 4) */
#define PWM_INTR_CH4_Msk                  (0x10UL)                  /*!< CH4 (Bitfield-Mask: 0x01) */
#define PWM_INTR_CH3_Pos                  (3UL)                     /*!< CH3 (Bit 3) */
#define PWM_INTR_CH3_Msk                  (0x8UL)                   /*!< CH3 (Bitfield-Mask: 0x01) */
#define PWM_INTR_CH2_Pos                  (2UL)                     /*!< CH2 (Bit 2) */
#define PWM_INTR_CH2_Msk                  (0x4UL)                   /*!< CH2 (Bitfield-Mask: 0x01) */
#define PWM_INTR_CH1_Pos                  (1UL)                     /*!< CH1 (Bit 1) */
#define PWM_INTR_CH1_Msk                  (0x2UL)                   /*!< CH1 (Bitfield-Mask: 0x01) */
#define PWM_INTR_CH0_Pos                  (0UL)                     /*!< CH0 (Bit 0) */
#define PWM_INTR_CH0_Msk                  (0x1UL)                   /*!< CH0 (Bitfield-Mask: 0x01) */
/* =========================================================  INTE  ========================================================== */
#define PWM_INTE_CH7_Pos                  (7UL)                     /*!< CH7 (Bit 7) */
#define PWM_INTE_CH7_Msk                  (0x80UL)                  /*!< CH7 (Bitfield-Mask: 0x01) */
#define PWM_INTE_CH6_Pos                  (6UL)                     /*!< CH6 (Bit 6) */
#define PWM_INTE_CH6_Msk                  (0x40UL)                  /*!< CH6 (Bitfield-Mask: 0x01) */
#define PWM_INTE_CH5_Pos                  (5UL)                     /*!< CH5 (Bit 5) */
#define PWM_INTE_CH5_Msk                  (0x20UL)                  /*!< CH5 (Bitfield-Mask: 0x01) */
#define PWM_INTE_CH4_Pos                  (4UL)                     /*!< CH4 (Bit 4) */
#define PWM_INTE_CH4_Msk                  (0x10UL)                  /*!< CH4 (Bitfield-Mask: 0x01) */
#define PWM_INTE_CH3_Pos                  (3UL)                     /*!< CH3 (Bit 3) */
#define PWM_INTE_CH3_Msk                  (0x8UL)                   /*!< CH3 (Bitfield-Mask: 0x01) */
#define PWM_INTE_CH2_Pos                  (2UL)                     /*!< CH2 (Bit 2) */
#define PWM_INTE_CH2_Msk                  (0x4UL)                   /*!< CH2 (Bitfield-Mask: 0x01) */
#define PWM_INTE_CH1_Pos                  (1UL)                     /*!< CH1 (Bit 1) */
#define PWM_INTE_CH1_Msk                  (0x2UL)                   /*!< CH1 (Bitfield-Mask: 0x01) */
#define PWM_INTE_CH0_Pos                  (0UL)                     /*!< CH0 (Bit 0) */
#define PWM_INTE_CH0_Msk                  (0x1UL)                   /*!< CH0 (Bitfield-Mask: 0x01) */
/* =========================================================  INTF  ========================================================== */
#define PWM_INTF_CH7_Pos                  (7UL)                     /*!< CH7 (Bit 7) */
#define PWM_INTF_CH7_Msk                  (0x80UL)                  /*!< CH7 (Bitfield-Mask: 0x01) */
#define PWM_INTF_CH6_Pos                  (6UL)                     /*!< CH6 (Bit 6) */
#define PWM_INTF_CH6_Msk                  (0x40UL)                  /*!< CH6 (Bitfield-Mask: 0x01) */
#define PWM_INTF_CH5_Pos                  (5UL)                     /*!< CH5 (Bit 5) */
#define PWM_INTF_CH5_Msk                  (0x20UL)                  /*!< CH5 (Bitfield-Mask: 0x01) */
#define PWM_INTF_CH4_Pos                  (4UL)                     /*!< CH4 (Bit 4) */
#define PWM_INTF_CH4_Msk                  (0x10UL)                  /*!< CH4 (Bitfield-Mask: 0x01) */
#define PWM_INTF_CH3_Pos                  (3UL)                     /*!< CH3 (Bit 3) */
#define PWM_INTF_CH3_Msk                  (0x8UL)                   /*!< CH3 (Bitfield-Mask: 0x01) */
#define PWM_INTF_CH2_Pos                  (2UL)                     /*!< CH2 (Bit 2) */
#define PWM_INTF_CH2_Msk                  (0x4UL)                   /*!< CH2 (Bitfield-Mask: 0x01) */
#define PWM_INTF_CH1_Pos                  (1UL)                     /*!< CH1 (Bit 1) */
#define PWM_INTF_CH1_Msk                  (0x2UL)                   /*!< CH1 (Bitfield-Mask: 0x01) */
#define PWM_INTF_CH0_Pos                  (0UL)                     /*!< CH0 (Bit 0) */
#define PWM_INTF_CH0_Msk                  (0x1UL)                   /*!< CH0 (Bitfield-Mask: 0x01) */
/* =========================================================  INTS  ========================================================== */
#define PWM_INTS_CH7_Pos                  (7UL)                     /*!< CH7 (Bit 7) */
#define PWM_INTS_CH7_Msk                  (0x80UL)                  /*!< CH7 (Bitfield-Mask: 0x01) */
#define PWM_INTS_CH6_Pos                  (6UL)                     /*!< CH6 (Bit 6) */
#define PWM_INTS_CH6_Msk                  (0x40UL)                  /*!< CH6 (Bitfield-Mask: 0x01) */
#define PWM_INTS_CH5_Pos                  (5UL)                     /*!< CH5 (Bit 5) */
#define PWM_INTS_CH5_Msk                  (0x20UL)                  /*!< CH5 (Bitfield-Mask: 0x01) */
#define PWM_INTS_CH4_Pos                  (4UL)                     /*!< CH4 (Bit 4) */
#define PWM_INTS_CH4_Msk                  (0x10UL)                  /*!< CH4 (Bitfield-Mask: 0x01) */
#define PWM_INTS_CH3_Pos                  (3UL)                     /*!< CH3 (Bit 3) */
#define PWM_INTS_CH3_Msk                  (0x8UL)                   /*!< CH3 (Bitfield-Mask: 0x01) */
#define PWM_INTS_CH2_Pos                  (2UL)                     /*!< CH2 (Bit 2) */
#define PWM_INTS_CH2_Msk                  (0x4UL)                   /*!< CH2 (Bitfield-Mask: 0x01) */
#define PWM_INTS_CH1_Pos                  (1UL)                     /*!< CH1 (Bit 1) */
#define PWM_INTS_CH1_Msk                  (0x2UL)                   /*!< CH1 (Bitfield-Mask: 0x01) */
#define PWM_INTS_CH0_Pos                  (0UL)                     /*!< CH0 (Bit 0) */
#define PWM_INTS_CH0_Msk                  (0x1UL)                   /*!< CH0 (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                           TIMER                                           ================ */
/* =========================================================================================================================== */

/* ========================================================  TIMEHW  ========================================================= */
/* ========================================================  TIMELW  ========================================================= */
/* ========================================================  TIMEHR  ========================================================= */
/* ========================================================  TIMELR  ========================================================= */
/* ========================================================  ALARM0  ========================================================= */
/* ========================================================  ALARM1  ========================================================= */
/* ========================================================  ALARM2  ========================================================= */
/* ========================================================  ALARM3  ========================================================= */
/* =========================================================  ARMED  ========================================================= */
#define TIMER_ARMED_ARMED_Pos             (0UL)                     /*!< ARMED (Bit 0) */
#define TIMER_ARMED_ARMED_Msk             (0xfUL)                   /*!< ARMED (Bitfield-Mask: 0x0f) */
/* =======================================================  TIMERAWH  ======================================================== */
/* =======================================================  TIMERAWL  ======================================================== */
/* =======================================================  DBGPAUSE  ======================================================== */
#define TIMER_DBGPAUSE_DBG1_Pos           (2UL)                     /*!< DBG1 (Bit 2) */
#define TIMER_DBGPAUSE_DBG1_Msk           (0x4UL)                   /*!< DBG1 (Bitfield-Mask: 0x01) */
#define TIMER_DBGPAUSE_DBG0_Pos           (1UL)                     /*!< DBG0 (Bit 1) */
#define TIMER_DBGPAUSE_DBG0_Msk           (0x2UL)                   /*!< DBG0 (Bitfield-Mask: 0x01) */
/* =========================================================  PAUSE  ========================================================= */
#define TIMER_PAUSE_PAUSE_Pos             (0UL)                     /*!< PAUSE (Bit 0) */
#define TIMER_PAUSE_PAUSE_Msk             (0x1UL)                   /*!< PAUSE (Bitfield-Mask: 0x01) */
/* =========================================================  INTR  ========================================================== */
#define TIMER_INTR_ALARM_3_Pos            (3UL)                     /*!< ALARM_3 (Bit 3) */
#define TIMER_INTR_ALARM_3_Msk            (0x8UL)                   /*!< ALARM_3 (Bitfield-Mask: 0x01) */
#define TIMER_INTR_ALARM_2_Pos            (2UL)                     /*!< ALARM_2 (Bit 2) */
#define TIMER_INTR_ALARM_2_Msk            (0x4UL)                   /*!< ALARM_2 (Bitfield-Mask: 0x01) */
#define TIMER_INTR_ALARM_1_Pos            (1UL)                     /*!< ALARM_1 (Bit 1) */
#define TIMER_INTR_ALARM_1_Msk            (0x2UL)                   /*!< ALARM_1 (Bitfield-Mask: 0x01) */
#define TIMER_INTR_ALARM_0_Pos            (0UL)                     /*!< ALARM_0 (Bit 0) */
#define TIMER_INTR_ALARM_0_Msk            (0x1UL)                   /*!< ALARM_0 (Bitfield-Mask: 0x01) */
/* =========================================================  INTE  ========================================================== */
#define TIMER_INTE_ALARM_3_Pos            (3UL)                     /*!< ALARM_3 (Bit 3) */
#define TIMER_INTE_ALARM_3_Msk            (0x8UL)                   /*!< ALARM_3 (Bitfield-Mask: 0x01) */
#define TIMER_INTE_ALARM_2_Pos            (2UL)                     /*!< ALARM_2 (Bit 2) */
#define TIMER_INTE_ALARM_2_Msk            (0x4UL)                   /*!< ALARM_2 (Bitfield-Mask: 0x01) */
#define TIMER_INTE_ALARM_1_Pos            (1UL)                     /*!< ALARM_1 (Bit 1) */
#define TIMER_INTE_ALARM_1_Msk            (0x2UL)                   /*!< ALARM_1 (Bitfield-Mask: 0x01) */
#define TIMER_INTE_ALARM_0_Pos            (0UL)                     /*!< ALARM_0 (Bit 0) */
#define TIMER_INTE_ALARM_0_Msk            (0x1UL)                   /*!< ALARM_0 (Bitfield-Mask: 0x01) */
/* =========================================================  INTF  ========================================================== */
#define TIMER_INTF_ALARM_3_Pos            (3UL)                     /*!< ALARM_3 (Bit 3) */
#define TIMER_INTF_ALARM_3_Msk            (0x8UL)                   /*!< ALARM_3 (Bitfield-Mask: 0x01) */
#define TIMER_INTF_ALARM_2_Pos            (2UL)                     /*!< ALARM_2 (Bit 2) */
#define TIMER_INTF_ALARM_2_Msk            (0x4UL)                   /*!< ALARM_2 (Bitfield-Mask: 0x01) */
#define TIMER_INTF_ALARM_1_Pos            (1UL)                     /*!< ALARM_1 (Bit 1) */
#define TIMER_INTF_ALARM_1_Msk            (0x2UL)                   /*!< ALARM_1 (Bitfield-Mask: 0x01) */
#define TIMER_INTF_ALARM_0_Pos            (0UL)                     /*!< ALARM_0 (Bit 0) */
#define TIMER_INTF_ALARM_0_Msk            (0x1UL)                   /*!< ALARM_0 (Bitfield-Mask: 0x01) */
/* =========================================================  INTS  ========================================================== */
#define TIMER_INTS_ALARM_3_Pos            (3UL)                     /*!< ALARM_3 (Bit 3) */
#define TIMER_INTS_ALARM_3_Msk            (0x8UL)                   /*!< ALARM_3 (Bitfield-Mask: 0x01) */
#define TIMER_INTS_ALARM_2_Pos            (2UL)                     /*!< ALARM_2 (Bit 2) */
#define TIMER_INTS_ALARM_2_Msk            (0x4UL)                   /*!< ALARM_2 (Bitfield-Mask: 0x01) */
#define TIMER_INTS_ALARM_1_Pos            (1UL)                     /*!< ALARM_1 (Bit 1) */
#define TIMER_INTS_ALARM_1_Msk            (0x2UL)                   /*!< ALARM_1 (Bitfield-Mask: 0x01) */
#define TIMER_INTS_ALARM_0_Pos            (0UL)                     /*!< ALARM_0 (Bit 0) */
#define TIMER_INTS_ALARM_0_Msk            (0x1UL)                   /*!< ALARM_0 (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                         WATCHDOG                                          ================ */
/* =========================================================================================================================== */

/* =========================================================  CTRL  ========================================================== */
#define WATCHDOG_CTRL_TRIGGER_Pos         (31UL)                    /*!< TRIGGER (Bit 31) */
#define WATCHDOG_CTRL_TRIGGER_Msk         (0x80000000UL)            /*!< TRIGGER (Bitfield-Mask: 0x01) */
#define WATCHDOG_CTRL_ENABLE_Pos          (30UL)                    /*!< ENABLE (Bit 30) */
#define WATCHDOG_CTRL_ENABLE_Msk          (0x40000000UL)            /*!< ENABLE (Bitfield-Mask: 0x01) */
#define WATCHDOG_CTRL_PAUSE_DBG1_Pos      (26UL)                    /*!< PAUSE_DBG1 (Bit 26) */
#define WATCHDOG_CTRL_PAUSE_DBG1_Msk      (0x4000000UL)             /*!< PAUSE_DBG1 (Bitfield-Mask: 0x01) */
#define WATCHDOG_CTRL_PAUSE_DBG0_Pos      (25UL)                    /*!< PAUSE_DBG0 (Bit 25) */
#define WATCHDOG_CTRL_PAUSE_DBG0_Msk      (0x2000000UL)             /*!< PAUSE_DBG0 (Bitfield-Mask: 0x01) */
#define WATCHDOG_CTRL_PAUSE_JTAG_Pos      (24UL)                    /*!< PAUSE_JTAG (Bit 24) */
#define WATCHDOG_CTRL_PAUSE_JTAG_Msk      (0x1000000UL)             /*!< PAUSE_JTAG (Bitfield-Mask: 0x01) */
#define WATCHDOG_CTRL_TIME_Pos            (0UL)                     /*!< TIME (Bit 0) */
#define WATCHDOG_CTRL_TIME_Msk            (0xffffffUL)              /*!< TIME (Bitfield-Mask: 0xffffff) */
/* =========================================================  LOAD  ========================================================== */
#define WATCHDOG_LOAD_LOAD_Pos            (0UL)                     /*!< LOAD (Bit 0) */
#define WATCHDOG_LOAD_LOAD_Msk            (0xffffffUL)              /*!< LOAD (Bitfield-Mask: 0xffffff) */
/* ========================================================  REASON  ========================================================= */
#define WATCHDOG_REASON_FORCE_Pos         (1UL)                     /*!< FORCE (Bit 1) */
#define WATCHDOG_REASON_FORCE_Msk         (0x2UL)                   /*!< FORCE (Bitfield-Mask: 0x01) */
#define WATCHDOG_REASON_TIMER_Pos         (0UL)                     /*!< TIMER (Bit 0) */
#define WATCHDOG_REASON_TIMER_Msk         (0x1UL)                   /*!< TIMER (Bitfield-Mask: 0x01) */
/* =======================================================  SCRATCH0  ======================================================== */
/* =======================================================  SCRATCH1  ======================================================== */
/* =======================================================  SCRATCH2  ======================================================== */
/* =======================================================  SCRATCH3  ======================================================== */
/* =======================================================  SCRATCH4  ======================================================== */
/* =======================================================  SCRATCH5  ======================================================== */
/* =======================================================  SCRATCH6  ======================================================== */
/* =======================================================  SCRATCH7  ======================================================== */
/* =========================================================  TICK  ========================================================== */
#define WATCHDOG_TICK_COUNT_Pos           (11UL)                    /*!< COUNT (Bit 11) */
#define WATCHDOG_TICK_COUNT_Msk           (0xff800UL)               /*!< COUNT (Bitfield-Mask: 0x1ff) */
#define WATCHDOG_TICK_RUNNING_Pos         (10UL)                    /*!< RUNNING (Bit 10) */
#define WATCHDOG_TICK_RUNNING_Msk         (0x400UL)                 /*!< RUNNING (Bitfield-Mask: 0x01) */
#define WATCHDOG_TICK_ENABLE_Pos          (9UL)                     /*!< ENABLE (Bit 9) */
#define WATCHDOG_TICK_ENABLE_Msk          (0x200UL)                 /*!< ENABLE (Bitfield-Mask: 0x01) */
#define WATCHDOG_TICK_CYCLES_Pos          (0UL)                     /*!< CYCLES (Bit 0) */
#define WATCHDOG_TICK_CYCLES_Msk          (0x1ffUL)                 /*!< CYCLES (Bitfield-Mask: 0x1ff) */


/* =========================================================================================================================== */
/* ================                                            RTC                                            ================ */
/* =========================================================================================================================== */

/* =======================================================  CLKDIV_M1  ======================================================= */
#define RTC_CLKDIV_M1_CLKDIV_M1_Pos       (0UL)                     /*!< CLKDIV_M1 (Bit 0) */
#define RTC_CLKDIV_M1_CLKDIV_M1_Msk       (0xffffUL)                /*!< CLKDIV_M1 (Bitfield-Mask: 0xffff) */
/* ========================================================  SETUP_0  ======================================================== */
#define RTC_SETUP_0_YEAR_Pos              (12UL)                    /*!< YEAR (Bit 12) */
#define RTC_SETUP_0_YEAR_Msk              (0xfff000UL)              /*!< YEAR (Bitfield-Mask: 0xfff) */
#define RTC_SETUP_0_MONTH_Pos             (8UL)                     /*!< MONTH (Bit 8) */
#define RTC_SETUP_0_MONTH_Msk             (0xf00UL)                 /*!< MONTH (Bitfield-Mask: 0x0f) */
#define RTC_SETUP_0_DAY_Pos               (0UL)                     /*!< DAY (Bit 0) */
#define RTC_SETUP_0_DAY_Msk               (0x1fUL)                  /*!< DAY (Bitfield-Mask: 0x1f) */
/* ========================================================  SETUP_1  ======================================================== */
#define RTC_SETUP_1_DOTW_Pos              (24UL)                    /*!< DOTW (Bit 24) */
#define RTC_SETUP_1_DOTW_Msk              (0x7000000UL)             /*!< DOTW (Bitfield-Mask: 0x07) */
#define RTC_SETUP_1_HOUR_Pos              (16UL)                    /*!< HOUR (Bit 16) */
#define RTC_SETUP_1_HOUR_Msk              (0x1f0000UL)              /*!< HOUR (Bitfield-Mask: 0x1f) */
#define RTC_SETUP_1_MIN_Pos               (8UL)                     /*!< MIN (Bit 8) */
#define RTC_SETUP_1_MIN_Msk               (0x3f00UL)                /*!< MIN (Bitfield-Mask: 0x3f) */
#define RTC_SETUP_1_SEC_Pos               (0UL)                     /*!< SEC (Bit 0) */
#define RTC_SETUP_1_SEC_Msk               (0x3fUL)                  /*!< SEC (Bitfield-Mask: 0x3f) */
/* =========================================================  CTRL  ========================================================== */
#define RTC_CTRL_FORCE_NOTLEAPYEAR_Pos    (8UL)                     /*!< FORCE_NOTLEAPYEAR (Bit 8) */
#define RTC_CTRL_FORCE_NOTLEAPYEAR_Msk    (0x100UL)                 /*!< FORCE_NOTLEAPYEAR (Bitfield-Mask: 0x01) */
#define RTC_CTRL_LOAD_Pos                 (4UL)                     /*!< LOAD (Bit 4) */
#define RTC_CTRL_LOAD_Msk                 (0x10UL)                  /*!< LOAD (Bitfield-Mask: 0x01) */
#define RTC_CTRL_RTC_ACTIVE_Pos           (1UL)                     /*!< RTC_ACTIVE (Bit 1) */
#define RTC_CTRL_RTC_ACTIVE_Msk           (0x2UL)                   /*!< RTC_ACTIVE (Bitfield-Mask: 0x01) */
#define RTC_CTRL_RTC_ENABLE_Pos           (0UL)                     /*!< RTC_ENABLE (Bit 0) */
#define RTC_CTRL_RTC_ENABLE_Msk           (0x1UL)                   /*!< RTC_ENABLE (Bitfield-Mask: 0x01) */
/* ======================================================  IRQ_SETUP_0  ====================================================== */
#define RTC_IRQ_SETUP_0_MATCH_ACTIVE_Pos  (29UL)                    /*!< MATCH_ACTIVE (Bit 29) */
#define RTC_IRQ_SETUP_0_MATCH_ACTIVE_Msk  (0x20000000UL)            /*!< MATCH_ACTIVE (Bitfield-Mask: 0x01) */
#define RTC_IRQ_SETUP_0_MATCH_ENA_Pos     (28UL)                    /*!< MATCH_ENA (Bit 28) */
#define RTC_IRQ_SETUP_0_MATCH_ENA_Msk     (0x10000000UL)            /*!< MATCH_ENA (Bitfield-Mask: 0x01) */
#define RTC_IRQ_SETUP_0_YEAR_ENA_Pos      (26UL)                    /*!< YEAR_ENA (Bit 26) */
#define RTC_IRQ_SETUP_0_YEAR_ENA_Msk      (0x4000000UL)             /*!< YEAR_ENA (Bitfield-Mask: 0x01) */
#define RTC_IRQ_SETUP_0_MONTH_ENA_Pos     (25UL)                    /*!< MONTH_ENA (Bit 25) */
#define RTC_IRQ_SETUP_0_MONTH_ENA_Msk     (0x2000000UL)             /*!< MONTH_ENA (Bitfield-Mask: 0x01) */
#define RTC_IRQ_SETUP_0_DAY_ENA_Pos       (24UL)                    /*!< DAY_ENA (Bit 24) */
#define RTC_IRQ_SETUP_0_DAY_ENA_Msk       (0x1000000UL)             /*!< DAY_ENA (Bitfield-Mask: 0x01) */
#define RTC_IRQ_SETUP_0_YEAR_Pos          (12UL)                    /*!< YEAR (Bit 12) */
#define RTC_IRQ_SETUP_0_YEAR_Msk          (0xfff000UL)              /*!< YEAR (Bitfield-Mask: 0xfff) */
#define RTC_IRQ_SETUP_0_MONTH_Pos         (8UL)                     /*!< MONTH (Bit 8) */
#define RTC_IRQ_SETUP_0_MONTH_Msk         (0xf00UL)                 /*!< MONTH (Bitfield-Mask: 0x0f) */
#define RTC_IRQ_SETUP_0_DAY_Pos           (0UL)                     /*!< DAY (Bit 0) */
#define RTC_IRQ_SETUP_0_DAY_Msk           (0x1fUL)                  /*!< DAY (Bitfield-Mask: 0x1f) */
/* ======================================================  IRQ_SETUP_1  ====================================================== */
#define RTC_IRQ_SETUP_1_DOTW_ENA_Pos      (31UL)                    /*!< DOTW_ENA (Bit 31) */
#define RTC_IRQ_SETUP_1_DOTW_ENA_Msk      (0x80000000UL)            /*!< DOTW_ENA (Bitfield-Mask: 0x01) */
#define RTC_IRQ_SETUP_1_HOUR_ENA_Pos      (30UL)                    /*!< HOUR_ENA (Bit 30) */
#define RTC_IRQ_SETUP_1_HOUR_ENA_Msk      (0x40000000UL)            /*!< HOUR_ENA (Bitfield-Mask: 0x01) */
#define RTC_IRQ_SETUP_1_MIN_ENA_Pos       (29UL)                    /*!< MIN_ENA (Bit 29) */
#define RTC_IRQ_SETUP_1_MIN_ENA_Msk       (0x20000000UL)            /*!< MIN_ENA (Bitfield-Mask: 0x01) */
#define RTC_IRQ_SETUP_1_SEC_ENA_Pos       (28UL)                    /*!< SEC_ENA (Bit 28) */
#define RTC_IRQ_SETUP_1_SEC_ENA_Msk       (0x10000000UL)            /*!< SEC_ENA (Bitfield-Mask: 0x01) */
#define RTC_IRQ_SETUP_1_DOTW_Pos          (24UL)                    /*!< DOTW (Bit 24) */
#define RTC_IRQ_SETUP_1_DOTW_Msk          (0x7000000UL)             /*!< DOTW (Bitfield-Mask: 0x07) */
#define RTC_IRQ_SETUP_1_HOUR_Pos          (16UL)                    /*!< HOUR (Bit 16) */
#define RTC_IRQ_SETUP_1_HOUR_Msk          (0x1f0000UL)              /*!< HOUR (Bitfield-Mask: 0x1f) */
#define RTC_IRQ_SETUP_1_MIN_Pos           (8UL)                     /*!< MIN (Bit 8) */
#define RTC_IRQ_SETUP_1_MIN_Msk           (0x3f00UL)                /*!< MIN (Bitfield-Mask: 0x3f) */
#define RTC_IRQ_SETUP_1_SEC_Pos           (0UL)                     /*!< SEC (Bit 0) */
#define RTC_IRQ_SETUP_1_SEC_Msk           (0x3fUL)                  /*!< SEC (Bitfield-Mask: 0x3f) */
/* =========================================================  RTC_1  ========================================================= */
#define RTC_RTC_1_YEAR_Pos                (12UL)                    /*!< YEAR (Bit 12) */
#define RTC_RTC_1_YEAR_Msk                (0xfff000UL)              /*!< YEAR (Bitfield-Mask: 0xfff) */
#define RTC_RTC_1_MONTH_Pos               (8UL)                     /*!< MONTH (Bit 8) */
#define RTC_RTC_1_MONTH_Msk               (0xf00UL)                 /*!< MONTH (Bitfield-Mask: 0x0f) */
#define RTC_RTC_1_DAY_Pos                 (0UL)                     /*!< DAY (Bit 0) */
#define RTC_RTC_1_DAY_Msk                 (0x1fUL)                  /*!< DAY (Bitfield-Mask: 0x1f) */
/* =========================================================  RTC_0  ========================================================= */
#define RTC_RTC_0_DOTW_Pos                (24UL)                    /*!< DOTW (Bit 24) */
#define RTC_RTC_0_DOTW_Msk                (0x7000000UL)             /*!< DOTW (Bitfield-Mask: 0x07) */
#define RTC_RTC_0_HOUR_Pos                (16UL)                    /*!< HOUR (Bit 16) */
#define RTC_RTC_0_HOUR_Msk                (0x1f0000UL)              /*!< HOUR (Bitfield-Mask: 0x1f) */
#define RTC_RTC_0_MIN_Pos                 (8UL)                     /*!< MIN (Bit 8) */
#define RTC_RTC_0_MIN_Msk                 (0x3f00UL)                /*!< MIN (Bitfield-Mask: 0x3f) */
#define RTC_RTC_0_SEC_Pos                 (0UL)                     /*!< SEC (Bit 0) */
#define RTC_RTC_0_SEC_Msk                 (0x3fUL)                  /*!< SEC (Bitfield-Mask: 0x3f) */
/* =========================================================  INTR  ========================================================== */
#define RTC_INTR_RTC_Pos                  (0UL)                     /*!< RTC (Bit 0) */
#define RTC_INTR_RTC_Msk                  (0x1UL)                   /*!< RTC (Bitfield-Mask: 0x01) */
/* =========================================================  INTE  ========================================================== */
#define RTC_INTE_RTC_Pos                  (0UL)                     /*!< RTC (Bit 0) */
#define RTC_INTE_RTC_Msk                  (0x1UL)                   /*!< RTC (Bitfield-Mask: 0x01) */
/* =========================================================  INTF  ========================================================== */
#define RTC_INTF_RTC_Pos                  (0UL)                     /*!< RTC (Bit 0) */
#define RTC_INTF_RTC_Msk                  (0x1UL)                   /*!< RTC (Bitfield-Mask: 0x01) */
/* =========================================================  INTS  ========================================================== */
#define RTC_INTS_RTC_Pos                  (0UL)                     /*!< RTC (Bit 0) */
#define RTC_INTS_RTC_Msk                  (0x1UL)                   /*!< RTC (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                           ROSC                                            ================ */
/* =========================================================================================================================== */

/* =========================================================  CTRL  ========================================================== */
#define ROSC_CTRL_ENABLE_Pos              (12UL)                    /*!< ENABLE (Bit 12) */
#define ROSC_CTRL_ENABLE_Msk              (0xfff000UL)              /*!< ENABLE (Bitfield-Mask: 0xfff) */
#define ROSC_CTRL_FREQ_RANGE_Pos          (0UL)                     /*!< FREQ_RANGE (Bit 0) */
#define ROSC_CTRL_FREQ_RANGE_Msk          (0xfffUL)                 /*!< FREQ_RANGE (Bitfield-Mask: 0xfff) */
/* =========================================================  FREQA  ========================================================= */
#define ROSC_FREQA_PASSWD_Pos             (16UL)                    /*!< PASSWD (Bit 16) */
#define ROSC_FREQA_PASSWD_Msk             (0xffff0000UL)            /*!< PASSWD (Bitfield-Mask: 0xffff) */
#define ROSC_FREQA_DS3_Pos                (12UL)                    /*!< DS3 (Bit 12) */
#define ROSC_FREQA_DS3_Msk                (0x7000UL)                /*!< DS3 (Bitfield-Mask: 0x07) */
#define ROSC_FREQA_DS2_Pos                (8UL)                     /*!< DS2 (Bit 8) */
#define ROSC_FREQA_DS2_Msk                (0x700UL)                 /*!< DS2 (Bitfield-Mask: 0x07) */
#define ROSC_FREQA_DS1_Pos                (4UL)                     /*!< DS1 (Bit 4) */
#define ROSC_FREQA_DS1_Msk                (0x70UL)                  /*!< DS1 (Bitfield-Mask: 0x07) */
#define ROSC_FREQA_DS0_Pos                (0UL)                     /*!< DS0 (Bit 0) */
#define ROSC_FREQA_DS0_Msk                (0x7UL)                   /*!< DS0 (Bitfield-Mask: 0x07) */
/* =========================================================  FREQB  ========================================================= */
#define ROSC_FREQB_PASSWD_Pos             (16UL)                    /*!< PASSWD (Bit 16) */
#define ROSC_FREQB_PASSWD_Msk             (0xffff0000UL)            /*!< PASSWD (Bitfield-Mask: 0xffff) */
#define ROSC_FREQB_DS7_Pos                (12UL)                    /*!< DS7 (Bit 12) */
#define ROSC_FREQB_DS7_Msk                (0x7000UL)                /*!< DS7 (Bitfield-Mask: 0x07) */
#define ROSC_FREQB_DS6_Pos                (8UL)                     /*!< DS6 (Bit 8) */
#define ROSC_FREQB_DS6_Msk                (0x700UL)                 /*!< DS6 (Bitfield-Mask: 0x07) */
#define ROSC_FREQB_DS5_Pos                (4UL)                     /*!< DS5 (Bit 4) */
#define ROSC_FREQB_DS5_Msk                (0x70UL)                  /*!< DS5 (Bitfield-Mask: 0x07) */
#define ROSC_FREQB_DS4_Pos                (0UL)                     /*!< DS4 (Bit 0) */
#define ROSC_FREQB_DS4_Msk                (0x7UL)                   /*!< DS4 (Bitfield-Mask: 0x07) */
/* ========================================================  DORMANT  ======================================================== */
/* ==========================================================  DIV  ========================================================== */
#define ROSC_DIV_DIV_Pos                  (0UL)                     /*!< DIV (Bit 0) */
#define ROSC_DIV_DIV_Msk                  (0xfffUL)                 /*!< DIV (Bitfield-Mask: 0xfff) */
/* =========================================================  PHASE  ========================================================= */
#define ROSC_PHASE_PASSWD_Pos             (4UL)                     /*!< PASSWD (Bit 4) */
#define ROSC_PHASE_PASSWD_Msk             (0xff0UL)                 /*!< PASSWD (Bitfield-Mask: 0xff) */
#define ROSC_PHASE_ENABLE_Pos             (3UL)                     /*!< ENABLE (Bit 3) */
#define ROSC_PHASE_ENABLE_Msk             (0x8UL)                   /*!< ENABLE (Bitfield-Mask: 0x01) */
#define ROSC_PHASE_FLIP_Pos               (2UL)                     /*!< FLIP (Bit 2) */
#define ROSC_PHASE_FLIP_Msk               (0x4UL)                   /*!< FLIP (Bitfield-Mask: 0x01) */
#define ROSC_PHASE_SHIFT_Pos              (0UL)                     /*!< SHIFT (Bit 0) */
#define ROSC_PHASE_SHIFT_Msk              (0x3UL)                   /*!< SHIFT (Bitfield-Mask: 0x03) */
/* ========================================================  STATUS  ========================================================= */
#define ROSC_STATUS_STABLE_Pos            (31UL)                    /*!< STABLE (Bit 31) */
#define ROSC_STATUS_STABLE_Msk            (0x80000000UL)            /*!< STABLE (Bitfield-Mask: 0x01) */
#define ROSC_STATUS_BADWRITE_Pos          (24UL)                    /*!< BADWRITE (Bit 24) */
#define ROSC_STATUS_BADWRITE_Msk          (0x1000000UL)             /*!< BADWRITE (Bitfield-Mask: 0x01) */
#define ROSC_STATUS_DIV_RUNNING_Pos       (16UL)                    /*!< DIV_RUNNING (Bit 16) */
#define ROSC_STATUS_DIV_RUNNING_Msk       (0x10000UL)               /*!< DIV_RUNNING (Bitfield-Mask: 0x01) */
#define ROSC_STATUS_ENABLED_Pos           (12UL)                    /*!< ENABLED (Bit 12) */
#define ROSC_STATUS_ENABLED_Msk           (0x1000UL)                /*!< ENABLED (Bitfield-Mask: 0x01) */
/* =======================================================  RANDOMBIT  ======================================================= */
#define ROSC_RANDOMBIT_RANDOMBIT_Pos      (0UL)                     /*!< RANDOMBIT (Bit 0) */
#define ROSC_RANDOMBIT_RANDOMBIT_Msk      (0x1UL)                   /*!< RANDOMBIT (Bitfield-Mask: 0x01) */
/* =========================================================  COUNT  ========================================================= */
#define ROSC_COUNT_COUNT_Pos              (0UL)                     /*!< COUNT (Bit 0) */
#define ROSC_COUNT_COUNT_Msk              (0xffUL)                  /*!< COUNT (Bitfield-Mask: 0xff) */


/* =========================================================================================================================== */
/* ================                                    VREG_AND_CHIP_RESET                                    ================ */
/* =========================================================================================================================== */

/* =========================================================  VREG  ========================================================== */
#define VREG_AND_CHIP_RESET_VREG_ROK_Pos  (12UL)                    /*!< ROK (Bit 12) */
#define VREG_AND_CHIP_RESET_VREG_ROK_Msk  (0x1000UL)                /*!< ROK (Bitfield-Mask: 0x01) */
#define VREG_AND_CHIP_RESET_VREG_VSEL_Pos (4UL)                     /*!< VSEL (Bit 4) */
#define VREG_AND_CHIP_RESET_VREG_VSEL_Msk (0xf0UL)                  /*!< VSEL (Bitfield-Mask: 0x0f) */
#define VREG_AND_CHIP_RESET_VREG_HIZ_Pos  (1UL)                     /*!< HIZ (Bit 1) */
#define VREG_AND_CHIP_RESET_VREG_HIZ_Msk  (0x2UL)                   /*!< HIZ (Bitfield-Mask: 0x01) */
#define VREG_AND_CHIP_RESET_VREG_EN_Pos   (0UL)                     /*!< EN (Bit 0) */
#define VREG_AND_CHIP_RESET_VREG_EN_Msk   (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01) */
/* ==========================================================  BOD  ========================================================== */
#define VREG_AND_CHIP_RESET_BOD_VSEL_Pos  (4UL)                     /*!< VSEL (Bit 4) */
#define VREG_AND_CHIP_RESET_BOD_VSEL_Msk  (0xf0UL)                  /*!< VSEL (Bitfield-Mask: 0x0f) */
#define VREG_AND_CHIP_RESET_BOD_EN_Pos    (0UL)                     /*!< EN (Bit 0) */
#define VREG_AND_CHIP_RESET_BOD_EN_Msk    (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01) */
/* ======================================================  CHIP_RESET  ======================================================= */
#define VREG_AND_CHIP_RESET_CHIP_RESET_PSM_RESTART_FLAG_Pos (24UL)  /*!< PSM_RESTART_FLAG (Bit 24) */
#define VREG_AND_CHIP_RESET_CHIP_RESET_PSM_RESTART_FLAG_Msk (0x1000000UL) /*!< PSM_RESTART_FLAG (Bitfield-Mask: 0x01) */
#define VREG_AND_CHIP_RESET_CHIP_RESET_HAD_PSM_RESTART_Pos (20UL)   /*!< HAD_PSM_RESTART (Bit 20) */
#define VREG_AND_CHIP_RESET_CHIP_RESET_HAD_PSM_RESTART_Msk (0x100000UL) /*!< HAD_PSM_RESTART (Bitfield-Mask: 0x01) */
#define VREG_AND_CHIP_RESET_CHIP_RESET_HAD_RUN_Pos (16UL)           /*!< HAD_RUN (Bit 16) */
#define VREG_AND_CHIP_RESET_CHIP_RESET_HAD_RUN_Msk (0x10000UL)      /*!< HAD_RUN (Bitfield-Mask: 0x01) */
#define VREG_AND_CHIP_RESET_CHIP_RESET_HAD_POR_Pos (8UL)            /*!< HAD_POR (Bit 8) */
#define VREG_AND_CHIP_RESET_CHIP_RESET_HAD_POR_Msk (0x100UL)        /*!< HAD_POR (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                           TBMAN                                           ================ */
/* =========================================================================================================================== */

/* =======================================================  PLATFORM  ======================================================== */
#define TBMAN_PLATFORM_FPGA_Pos           (1UL)                     /*!< FPGA (Bit 1) */
#define TBMAN_PLATFORM_FPGA_Msk           (0x2UL)                   /*!< FPGA (Bitfield-Mask: 0x01) */
#define TBMAN_PLATFORM_ASIC_Pos           (0UL)                     /*!< ASIC (Bit 0) */
#define TBMAN_PLATFORM_ASIC_Msk           (0x1UL)                   /*!< ASIC (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                            DMA                                            ================ */
/* =========================================================================================================================== */

/* =====================================================  CH0_READ_ADDR  ===================================================== */
/* ====================================================  CH0_WRITE_ADDR  ===================================================== */
/* ====================================================  CH0_TRANS_COUNT  ==================================================== */
/* =====================================================  CH0_CTRL_TRIG  ===================================================== */
#define DMA_CH0_CTRL_TRIG_AHB_ERROR_Pos   (31UL)                    /*!< AHB_ERROR (Bit 31) */
#define DMA_CH0_CTRL_TRIG_AHB_ERROR_Msk   (0x80000000UL)            /*!< AHB_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH0_CTRL_TRIG_READ_ERROR_Pos  (30UL)                    /*!< READ_ERROR (Bit 30) */
#define DMA_CH0_CTRL_TRIG_READ_ERROR_Msk  (0x40000000UL)            /*!< READ_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH0_CTRL_TRIG_WRITE_ERROR_Pos (29UL)                    /*!< WRITE_ERROR (Bit 29) */
#define DMA_CH0_CTRL_TRIG_WRITE_ERROR_Msk (0x20000000UL)            /*!< WRITE_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH0_CTRL_TRIG_BUSY_Pos        (24UL)                    /*!< BUSY (Bit 24) */
#define DMA_CH0_CTRL_TRIG_BUSY_Msk        (0x1000000UL)             /*!< BUSY (Bitfield-Mask: 0x01) */
#define DMA_CH0_CTRL_TRIG_SNIFF_EN_Pos    (23UL)                    /*!< SNIFF_EN (Bit 23) */
#define DMA_CH0_CTRL_TRIG_SNIFF_EN_Msk    (0x800000UL)              /*!< SNIFF_EN (Bitfield-Mask: 0x01) */
#define DMA_CH0_CTRL_TRIG_BSWAP_Pos       (22UL)                    /*!< BSWAP (Bit 22) */
#define DMA_CH0_CTRL_TRIG_BSWAP_Msk       (0x400000UL)              /*!< BSWAP (Bitfield-Mask: 0x01) */
#define DMA_CH0_CTRL_TRIG_IRQ_QUIET_Pos   (21UL)                    /*!< IRQ_QUIET (Bit 21) */
#define DMA_CH0_CTRL_TRIG_IRQ_QUIET_Msk   (0x200000UL)              /*!< IRQ_QUIET (Bitfield-Mask: 0x01) */
#define DMA_CH0_CTRL_TRIG_TREQ_SEL_Pos    (15UL)                    /*!< TREQ_SEL (Bit 15) */
#define DMA_CH0_CTRL_TRIG_TREQ_SEL_Msk    (0x1f8000UL)              /*!< TREQ_SEL (Bitfield-Mask: 0x3f) */
#define DMA_CH0_CTRL_TRIG_CHAIN_TO_Pos    (11UL)                    /*!< CHAIN_TO (Bit 11) */
#define DMA_CH0_CTRL_TRIG_CHAIN_TO_Msk    (0x7800UL)                /*!< CHAIN_TO (Bitfield-Mask: 0x0f) */
#define DMA_CH0_CTRL_TRIG_RING_SEL_Pos    (10UL)                    /*!< RING_SEL (Bit 10) */
#define DMA_CH0_CTRL_TRIG_RING_SEL_Msk    (0x400UL)                 /*!< RING_SEL (Bitfield-Mask: 0x01) */
#define DMA_CH0_CTRL_TRIG_RING_SIZE_Pos   (6UL)                     /*!< RING_SIZE (Bit 6) */
#define DMA_CH0_CTRL_TRIG_RING_SIZE_Msk   (0x3c0UL)                 /*!< RING_SIZE (Bitfield-Mask: 0x0f) */
#define DMA_CH0_CTRL_TRIG_INCR_WRITE_Pos  (5UL)                     /*!< INCR_WRITE (Bit 5) */
#define DMA_CH0_CTRL_TRIG_INCR_WRITE_Msk  (0x20UL)                  /*!< INCR_WRITE (Bitfield-Mask: 0x01) */
#define DMA_CH0_CTRL_TRIG_INCR_READ_Pos   (4UL)                     /*!< INCR_READ (Bit 4) */
#define DMA_CH0_CTRL_TRIG_INCR_READ_Msk   (0x10UL)                  /*!< INCR_READ (Bitfield-Mask: 0x01) */
#define DMA_CH0_CTRL_TRIG_DATA_SIZE_Pos   (2UL)                     /*!< DATA_SIZE (Bit 2) */
#define DMA_CH0_CTRL_TRIG_DATA_SIZE_Msk   (0xcUL)                   /*!< DATA_SIZE (Bitfield-Mask: 0x03) */
#define DMA_CH0_CTRL_TRIG_HIGH_PRIORITY_Pos (1UL)                   /*!< HIGH_PRIORITY (Bit 1) */
#define DMA_CH0_CTRL_TRIG_HIGH_PRIORITY_Msk (0x2UL)                 /*!< HIGH_PRIORITY (Bitfield-Mask: 0x01) */
#define DMA_CH0_CTRL_TRIG_EN_Pos          (0UL)                     /*!< EN (Bit 0) */
#define DMA_CH0_CTRL_TRIG_EN_Msk          (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01) */
/* =====================================================  CH0_AL1_CTRL  ====================================================== */
/* ===================================================  CH0_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH0_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH0_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH0_AL2_CTRL  ====================================================== */
/* ==================================================  CH0_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH0_AL2_READ_ADDR  =================================================== */
/* ================================================  CH0_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH0_AL3_CTRL  ====================================================== */
/* ==================================================  CH0_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH0_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH0_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH1_READ_ADDR  ===================================================== */
/* ====================================================  CH1_WRITE_ADDR  ===================================================== */
/* ====================================================  CH1_TRANS_COUNT  ==================================================== */
/* =====================================================  CH1_CTRL_TRIG  ===================================================== */
#define DMA_CH1_CTRL_TRIG_AHB_ERROR_Pos   (31UL)                    /*!< AHB_ERROR (Bit 31) */
#define DMA_CH1_CTRL_TRIG_AHB_ERROR_Msk   (0x80000000UL)            /*!< AHB_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH1_CTRL_TRIG_READ_ERROR_Pos  (30UL)                    /*!< READ_ERROR (Bit 30) */
#define DMA_CH1_CTRL_TRIG_READ_ERROR_Msk  (0x40000000UL)            /*!< READ_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH1_CTRL_TRIG_WRITE_ERROR_Pos (29UL)                    /*!< WRITE_ERROR (Bit 29) */
#define DMA_CH1_CTRL_TRIG_WRITE_ERROR_Msk (0x20000000UL)            /*!< WRITE_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH1_CTRL_TRIG_BUSY_Pos        (24UL)                    /*!< BUSY (Bit 24) */
#define DMA_CH1_CTRL_TRIG_BUSY_Msk        (0x1000000UL)             /*!< BUSY (Bitfield-Mask: 0x01) */
#define DMA_CH1_CTRL_TRIG_SNIFF_EN_Pos    (23UL)                    /*!< SNIFF_EN (Bit 23) */
#define DMA_CH1_CTRL_TRIG_SNIFF_EN_Msk    (0x800000UL)              /*!< SNIFF_EN (Bitfield-Mask: 0x01) */
#define DMA_CH1_CTRL_TRIG_BSWAP_Pos       (22UL)                    /*!< BSWAP (Bit 22) */
#define DMA_CH1_CTRL_TRIG_BSWAP_Msk       (0x400000UL)              /*!< BSWAP (Bitfield-Mask: 0x01) */
#define DMA_CH1_CTRL_TRIG_IRQ_QUIET_Pos   (21UL)                    /*!< IRQ_QUIET (Bit 21) */
#define DMA_CH1_CTRL_TRIG_IRQ_QUIET_Msk   (0x200000UL)              /*!< IRQ_QUIET (Bitfield-Mask: 0x01) */
#define DMA_CH1_CTRL_TRIG_TREQ_SEL_Pos    (15UL)                    /*!< TREQ_SEL (Bit 15) */
#define DMA_CH1_CTRL_TRIG_TREQ_SEL_Msk    (0x1f8000UL)              /*!< TREQ_SEL (Bitfield-Mask: 0x3f) */
#define DMA_CH1_CTRL_TRIG_CHAIN_TO_Pos    (11UL)                    /*!< CHAIN_TO (Bit 11) */
#define DMA_CH1_CTRL_TRIG_CHAIN_TO_Msk    (0x7800UL)                /*!< CHAIN_TO (Bitfield-Mask: 0x0f) */
#define DMA_CH1_CTRL_TRIG_RING_SEL_Pos    (10UL)                    /*!< RING_SEL (Bit 10) */
#define DMA_CH1_CTRL_TRIG_RING_SEL_Msk    (0x400UL)                 /*!< RING_SEL (Bitfield-Mask: 0x01) */
#define DMA_CH1_CTRL_TRIG_RING_SIZE_Pos   (6UL)                     /*!< RING_SIZE (Bit 6) */
#define DMA_CH1_CTRL_TRIG_RING_SIZE_Msk   (0x3c0UL)                 /*!< RING_SIZE (Bitfield-Mask: 0x0f) */
#define DMA_CH1_CTRL_TRIG_INCR_WRITE_Pos  (5UL)                     /*!< INCR_WRITE (Bit 5) */
#define DMA_CH1_CTRL_TRIG_INCR_WRITE_Msk  (0x20UL)                  /*!< INCR_WRITE (Bitfield-Mask: 0x01) */
#define DMA_CH1_CTRL_TRIG_INCR_READ_Pos   (4UL)                     /*!< INCR_READ (Bit 4) */
#define DMA_CH1_CTRL_TRIG_INCR_READ_Msk   (0x10UL)                  /*!< INCR_READ (Bitfield-Mask: 0x01) */
#define DMA_CH1_CTRL_TRIG_DATA_SIZE_Pos   (2UL)                     /*!< DATA_SIZE (Bit 2) */
#define DMA_CH1_CTRL_TRIG_DATA_SIZE_Msk   (0xcUL)                   /*!< DATA_SIZE (Bitfield-Mask: 0x03) */
#define DMA_CH1_CTRL_TRIG_HIGH_PRIORITY_Pos (1UL)                   /*!< HIGH_PRIORITY (Bit 1) */
#define DMA_CH1_CTRL_TRIG_HIGH_PRIORITY_Msk (0x2UL)                 /*!< HIGH_PRIORITY (Bitfield-Mask: 0x01) */
#define DMA_CH1_CTRL_TRIG_EN_Pos          (0UL)                     /*!< EN (Bit 0) */
#define DMA_CH1_CTRL_TRIG_EN_Msk          (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01) */
/* =====================================================  CH1_AL1_CTRL  ====================================================== */
/* ===================================================  CH1_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH1_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH1_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH1_AL2_CTRL  ====================================================== */
/* ==================================================  CH1_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH1_AL2_READ_ADDR  =================================================== */
/* ================================================  CH1_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH1_AL3_CTRL  ====================================================== */
/* ==================================================  CH1_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH1_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH1_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH2_READ_ADDR  ===================================================== */
/* ====================================================  CH2_WRITE_ADDR  ===================================================== */
/* ====================================================  CH2_TRANS_COUNT  ==================================================== */
/* =====================================================  CH2_CTRL_TRIG  ===================================================== */
#define DMA_CH2_CTRL_TRIG_AHB_ERROR_Pos   (31UL)                    /*!< AHB_ERROR (Bit 31) */
#define DMA_CH2_CTRL_TRIG_AHB_ERROR_Msk   (0x80000000UL)            /*!< AHB_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH2_CTRL_TRIG_READ_ERROR_Pos  (30UL)                    /*!< READ_ERROR (Bit 30) */
#define DMA_CH2_CTRL_TRIG_READ_ERROR_Msk  (0x40000000UL)            /*!< READ_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH2_CTRL_TRIG_WRITE_ERROR_Pos (29UL)                    /*!< WRITE_ERROR (Bit 29) */
#define DMA_CH2_CTRL_TRIG_WRITE_ERROR_Msk (0x20000000UL)            /*!< WRITE_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH2_CTRL_TRIG_BUSY_Pos        (24UL)                    /*!< BUSY (Bit 24) */
#define DMA_CH2_CTRL_TRIG_BUSY_Msk        (0x1000000UL)             /*!< BUSY (Bitfield-Mask: 0x01) */
#define DMA_CH2_CTRL_TRIG_SNIFF_EN_Pos    (23UL)                    /*!< SNIFF_EN (Bit 23) */
#define DMA_CH2_CTRL_TRIG_SNIFF_EN_Msk    (0x800000UL)              /*!< SNIFF_EN (Bitfield-Mask: 0x01) */
#define DMA_CH2_CTRL_TRIG_BSWAP_Pos       (22UL)                    /*!< BSWAP (Bit 22) */
#define DMA_CH2_CTRL_TRIG_BSWAP_Msk       (0x400000UL)              /*!< BSWAP (Bitfield-Mask: 0x01) */
#define DMA_CH2_CTRL_TRIG_IRQ_QUIET_Pos   (21UL)                    /*!< IRQ_QUIET (Bit 21) */
#define DMA_CH2_CTRL_TRIG_IRQ_QUIET_Msk   (0x200000UL)              /*!< IRQ_QUIET (Bitfield-Mask: 0x01) */
#define DMA_CH2_CTRL_TRIG_TREQ_SEL_Pos    (15UL)                    /*!< TREQ_SEL (Bit 15) */
#define DMA_CH2_CTRL_TRIG_TREQ_SEL_Msk    (0x1f8000UL)              /*!< TREQ_SEL (Bitfield-Mask: 0x3f) */
#define DMA_CH2_CTRL_TRIG_CHAIN_TO_Pos    (11UL)                    /*!< CHAIN_TO (Bit 11) */
#define DMA_CH2_CTRL_TRIG_CHAIN_TO_Msk    (0x7800UL)                /*!< CHAIN_TO (Bitfield-Mask: 0x0f) */
#define DMA_CH2_CTRL_TRIG_RING_SEL_Pos    (10UL)                    /*!< RING_SEL (Bit 10) */
#define DMA_CH2_CTRL_TRIG_RING_SEL_Msk    (0x400UL)                 /*!< RING_SEL (Bitfield-Mask: 0x01) */
#define DMA_CH2_CTRL_TRIG_RING_SIZE_Pos   (6UL)                     /*!< RING_SIZE (Bit 6) */
#define DMA_CH2_CTRL_TRIG_RING_SIZE_Msk   (0x3c0UL)                 /*!< RING_SIZE (Bitfield-Mask: 0x0f) */
#define DMA_CH2_CTRL_TRIG_INCR_WRITE_Pos  (5UL)                     /*!< INCR_WRITE (Bit 5) */
#define DMA_CH2_CTRL_TRIG_INCR_WRITE_Msk  (0x20UL)                  /*!< INCR_WRITE (Bitfield-Mask: 0x01) */
#define DMA_CH2_CTRL_TRIG_INCR_READ_Pos   (4UL)                     /*!< INCR_READ (Bit 4) */
#define DMA_CH2_CTRL_TRIG_INCR_READ_Msk   (0x10UL)                  /*!< INCR_READ (Bitfield-Mask: 0x01) */
#define DMA_CH2_CTRL_TRIG_DATA_SIZE_Pos   (2UL)                     /*!< DATA_SIZE (Bit 2) */
#define DMA_CH2_CTRL_TRIG_DATA_SIZE_Msk   (0xcUL)                   /*!< DATA_SIZE (Bitfield-Mask: 0x03) */
#define DMA_CH2_CTRL_TRIG_HIGH_PRIORITY_Pos (1UL)                   /*!< HIGH_PRIORITY (Bit 1) */
#define DMA_CH2_CTRL_TRIG_HIGH_PRIORITY_Msk (0x2UL)                 /*!< HIGH_PRIORITY (Bitfield-Mask: 0x01) */
#define DMA_CH2_CTRL_TRIG_EN_Pos          (0UL)                     /*!< EN (Bit 0) */
#define DMA_CH2_CTRL_TRIG_EN_Msk          (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01) */
/* =====================================================  CH2_AL1_CTRL  ====================================================== */
/* ===================================================  CH2_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH2_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH2_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH2_AL2_CTRL  ====================================================== */
/* ==================================================  CH2_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH2_AL2_READ_ADDR  =================================================== */
/* ================================================  CH2_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH2_AL3_CTRL  ====================================================== */
/* ==================================================  CH2_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH2_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH2_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH3_READ_ADDR  ===================================================== */
/* ====================================================  CH3_WRITE_ADDR  ===================================================== */
/* ====================================================  CH3_TRANS_COUNT  ==================================================== */
/* =====================================================  CH3_CTRL_TRIG  ===================================================== */
#define DMA_CH3_CTRL_TRIG_AHB_ERROR_Pos   (31UL)                    /*!< AHB_ERROR (Bit 31) */
#define DMA_CH3_CTRL_TRIG_AHB_ERROR_Msk   (0x80000000UL)            /*!< AHB_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH3_CTRL_TRIG_READ_ERROR_Pos  (30UL)                    /*!< READ_ERROR (Bit 30) */
#define DMA_CH3_CTRL_TRIG_READ_ERROR_Msk  (0x40000000UL)            /*!< READ_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH3_CTRL_TRIG_WRITE_ERROR_Pos (29UL)                    /*!< WRITE_ERROR (Bit 29) */
#define DMA_CH3_CTRL_TRIG_WRITE_ERROR_Msk (0x20000000UL)            /*!< WRITE_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH3_CTRL_TRIG_BUSY_Pos        (24UL)                    /*!< BUSY (Bit 24) */
#define DMA_CH3_CTRL_TRIG_BUSY_Msk        (0x1000000UL)             /*!< BUSY (Bitfield-Mask: 0x01) */
#define DMA_CH3_CTRL_TRIG_SNIFF_EN_Pos    (23UL)                    /*!< SNIFF_EN (Bit 23) */
#define DMA_CH3_CTRL_TRIG_SNIFF_EN_Msk    (0x800000UL)              /*!< SNIFF_EN (Bitfield-Mask: 0x01) */
#define DMA_CH3_CTRL_TRIG_BSWAP_Pos       (22UL)                    /*!< BSWAP (Bit 22) */
#define DMA_CH3_CTRL_TRIG_BSWAP_Msk       (0x400000UL)              /*!< BSWAP (Bitfield-Mask: 0x01) */
#define DMA_CH3_CTRL_TRIG_IRQ_QUIET_Pos   (21UL)                    /*!< IRQ_QUIET (Bit 21) */
#define DMA_CH3_CTRL_TRIG_IRQ_QUIET_Msk   (0x200000UL)              /*!< IRQ_QUIET (Bitfield-Mask: 0x01) */
#define DMA_CH3_CTRL_TRIG_TREQ_SEL_Pos    (15UL)                    /*!< TREQ_SEL (Bit 15) */
#define DMA_CH3_CTRL_TRIG_TREQ_SEL_Msk    (0x1f8000UL)              /*!< TREQ_SEL (Bitfield-Mask: 0x3f) */
#define DMA_CH3_CTRL_TRIG_CHAIN_TO_Pos    (11UL)                    /*!< CHAIN_TO (Bit 11) */
#define DMA_CH3_CTRL_TRIG_CHAIN_TO_Msk    (0x7800UL)                /*!< CHAIN_TO (Bitfield-Mask: 0x0f) */
#define DMA_CH3_CTRL_TRIG_RING_SEL_Pos    (10UL)                    /*!< RING_SEL (Bit 10) */
#define DMA_CH3_CTRL_TRIG_RING_SEL_Msk    (0x400UL)                 /*!< RING_SEL (Bitfield-Mask: 0x01) */
#define DMA_CH3_CTRL_TRIG_RING_SIZE_Pos   (6UL)                     /*!< RING_SIZE (Bit 6) */
#define DMA_CH3_CTRL_TRIG_RING_SIZE_Msk   (0x3c0UL)                 /*!< RING_SIZE (Bitfield-Mask: 0x0f) */
#define DMA_CH3_CTRL_TRIG_INCR_WRITE_Pos  (5UL)                     /*!< INCR_WRITE (Bit 5) */
#define DMA_CH3_CTRL_TRIG_INCR_WRITE_Msk  (0x20UL)                  /*!< INCR_WRITE (Bitfield-Mask: 0x01) */
#define DMA_CH3_CTRL_TRIG_INCR_READ_Pos   (4UL)                     /*!< INCR_READ (Bit 4) */
#define DMA_CH3_CTRL_TRIG_INCR_READ_Msk   (0x10UL)                  /*!< INCR_READ (Bitfield-Mask: 0x01) */
#define DMA_CH3_CTRL_TRIG_DATA_SIZE_Pos   (2UL)                     /*!< DATA_SIZE (Bit 2) */
#define DMA_CH3_CTRL_TRIG_DATA_SIZE_Msk   (0xcUL)                   /*!< DATA_SIZE (Bitfield-Mask: 0x03) */
#define DMA_CH3_CTRL_TRIG_HIGH_PRIORITY_Pos (1UL)                   /*!< HIGH_PRIORITY (Bit 1) */
#define DMA_CH3_CTRL_TRIG_HIGH_PRIORITY_Msk (0x2UL)                 /*!< HIGH_PRIORITY (Bitfield-Mask: 0x01) */
#define DMA_CH3_CTRL_TRIG_EN_Pos          (0UL)                     /*!< EN (Bit 0) */
#define DMA_CH3_CTRL_TRIG_EN_Msk          (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01) */
/* =====================================================  CH3_AL1_CTRL  ====================================================== */
/* ===================================================  CH3_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH3_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH3_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH3_AL2_CTRL  ====================================================== */
/* ==================================================  CH3_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH3_AL2_READ_ADDR  =================================================== */
/* ================================================  CH3_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH3_AL3_CTRL  ====================================================== */
/* ==================================================  CH3_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH3_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH3_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH4_READ_ADDR  ===================================================== */
/* ====================================================  CH4_WRITE_ADDR  ===================================================== */
/* ====================================================  CH4_TRANS_COUNT  ==================================================== */
/* =====================================================  CH4_CTRL_TRIG  ===================================================== */
#define DMA_CH4_CTRL_TRIG_AHB_ERROR_Pos   (31UL)                    /*!< AHB_ERROR (Bit 31) */
#define DMA_CH4_CTRL_TRIG_AHB_ERROR_Msk   (0x80000000UL)            /*!< AHB_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH4_CTRL_TRIG_READ_ERROR_Pos  (30UL)                    /*!< READ_ERROR (Bit 30) */
#define DMA_CH4_CTRL_TRIG_READ_ERROR_Msk  (0x40000000UL)            /*!< READ_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH4_CTRL_TRIG_WRITE_ERROR_Pos (29UL)                    /*!< WRITE_ERROR (Bit 29) */
#define DMA_CH4_CTRL_TRIG_WRITE_ERROR_Msk (0x20000000UL)            /*!< WRITE_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH4_CTRL_TRIG_BUSY_Pos        (24UL)                    /*!< BUSY (Bit 24) */
#define DMA_CH4_CTRL_TRIG_BUSY_Msk        (0x1000000UL)             /*!< BUSY (Bitfield-Mask: 0x01) */
#define DMA_CH4_CTRL_TRIG_SNIFF_EN_Pos    (23UL)                    /*!< SNIFF_EN (Bit 23) */
#define DMA_CH4_CTRL_TRIG_SNIFF_EN_Msk    (0x800000UL)              /*!< SNIFF_EN (Bitfield-Mask: 0x01) */
#define DMA_CH4_CTRL_TRIG_BSWAP_Pos       (22UL)                    /*!< BSWAP (Bit 22) */
#define DMA_CH4_CTRL_TRIG_BSWAP_Msk       (0x400000UL)              /*!< BSWAP (Bitfield-Mask: 0x01) */
#define DMA_CH4_CTRL_TRIG_IRQ_QUIET_Pos   (21UL)                    /*!< IRQ_QUIET (Bit 21) */
#define DMA_CH4_CTRL_TRIG_IRQ_QUIET_Msk   (0x200000UL)              /*!< IRQ_QUIET (Bitfield-Mask: 0x01) */
#define DMA_CH4_CTRL_TRIG_TREQ_SEL_Pos    (15UL)                    /*!< TREQ_SEL (Bit 15) */
#define DMA_CH4_CTRL_TRIG_TREQ_SEL_Msk    (0x1f8000UL)              /*!< TREQ_SEL (Bitfield-Mask: 0x3f) */
#define DMA_CH4_CTRL_TRIG_CHAIN_TO_Pos    (11UL)                    /*!< CHAIN_TO (Bit 11) */
#define DMA_CH4_CTRL_TRIG_CHAIN_TO_Msk    (0x7800UL)                /*!< CHAIN_TO (Bitfield-Mask: 0x0f) */
#define DMA_CH4_CTRL_TRIG_RING_SEL_Pos    (10UL)                    /*!< RING_SEL (Bit 10) */
#define DMA_CH4_CTRL_TRIG_RING_SEL_Msk    (0x400UL)                 /*!< RING_SEL (Bitfield-Mask: 0x01) */
#define DMA_CH4_CTRL_TRIG_RING_SIZE_Pos   (6UL)                     /*!< RING_SIZE (Bit 6) */
#define DMA_CH4_CTRL_TRIG_RING_SIZE_Msk   (0x3c0UL)                 /*!< RING_SIZE (Bitfield-Mask: 0x0f) */
#define DMA_CH4_CTRL_TRIG_INCR_WRITE_Pos  (5UL)                     /*!< INCR_WRITE (Bit 5) */
#define DMA_CH4_CTRL_TRIG_INCR_WRITE_Msk  (0x20UL)                  /*!< INCR_WRITE (Bitfield-Mask: 0x01) */
#define DMA_CH4_CTRL_TRIG_INCR_READ_Pos   (4UL)                     /*!< INCR_READ (Bit 4) */
#define DMA_CH4_CTRL_TRIG_INCR_READ_Msk   (0x10UL)                  /*!< INCR_READ (Bitfield-Mask: 0x01) */
#define DMA_CH4_CTRL_TRIG_DATA_SIZE_Pos   (2UL)                     /*!< DATA_SIZE (Bit 2) */
#define DMA_CH4_CTRL_TRIG_DATA_SIZE_Msk   (0xcUL)                   /*!< DATA_SIZE (Bitfield-Mask: 0x03) */
#define DMA_CH4_CTRL_TRIG_HIGH_PRIORITY_Pos (1UL)                   /*!< HIGH_PRIORITY (Bit 1) */
#define DMA_CH4_CTRL_TRIG_HIGH_PRIORITY_Msk (0x2UL)                 /*!< HIGH_PRIORITY (Bitfield-Mask: 0x01) */
#define DMA_CH4_CTRL_TRIG_EN_Pos          (0UL)                     /*!< EN (Bit 0) */
#define DMA_CH4_CTRL_TRIG_EN_Msk          (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01) */
/* =====================================================  CH4_AL1_CTRL  ====================================================== */
/* ===================================================  CH4_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH4_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH4_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH4_AL2_CTRL  ====================================================== */
/* ==================================================  CH4_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH4_AL2_READ_ADDR  =================================================== */
/* ================================================  CH4_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH4_AL3_CTRL  ====================================================== */
/* ==================================================  CH4_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH4_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH4_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH5_READ_ADDR  ===================================================== */
/* ====================================================  CH5_WRITE_ADDR  ===================================================== */
/* ====================================================  CH5_TRANS_COUNT  ==================================================== */
/* =====================================================  CH5_CTRL_TRIG  ===================================================== */
#define DMA_CH5_CTRL_TRIG_AHB_ERROR_Pos   (31UL)                    /*!< AHB_ERROR (Bit 31) */
#define DMA_CH5_CTRL_TRIG_AHB_ERROR_Msk   (0x80000000UL)            /*!< AHB_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH5_CTRL_TRIG_READ_ERROR_Pos  (30UL)                    /*!< READ_ERROR (Bit 30) */
#define DMA_CH5_CTRL_TRIG_READ_ERROR_Msk  (0x40000000UL)            /*!< READ_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH5_CTRL_TRIG_WRITE_ERROR_Pos (29UL)                    /*!< WRITE_ERROR (Bit 29) */
#define DMA_CH5_CTRL_TRIG_WRITE_ERROR_Msk (0x20000000UL)            /*!< WRITE_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH5_CTRL_TRIG_BUSY_Pos        (24UL)                    /*!< BUSY (Bit 24) */
#define DMA_CH5_CTRL_TRIG_BUSY_Msk        (0x1000000UL)             /*!< BUSY (Bitfield-Mask: 0x01) */
#define DMA_CH5_CTRL_TRIG_SNIFF_EN_Pos    (23UL)                    /*!< SNIFF_EN (Bit 23) */
#define DMA_CH5_CTRL_TRIG_SNIFF_EN_Msk    (0x800000UL)              /*!< SNIFF_EN (Bitfield-Mask: 0x01) */
#define DMA_CH5_CTRL_TRIG_BSWAP_Pos       (22UL)                    /*!< BSWAP (Bit 22) */
#define DMA_CH5_CTRL_TRIG_BSWAP_Msk       (0x400000UL)              /*!< BSWAP (Bitfield-Mask: 0x01) */
#define DMA_CH5_CTRL_TRIG_IRQ_QUIET_Pos   (21UL)                    /*!< IRQ_QUIET (Bit 21) */
#define DMA_CH5_CTRL_TRIG_IRQ_QUIET_Msk   (0x200000UL)              /*!< IRQ_QUIET (Bitfield-Mask: 0x01) */
#define DMA_CH5_CTRL_TRIG_TREQ_SEL_Pos    (15UL)                    /*!< TREQ_SEL (Bit 15) */
#define DMA_CH5_CTRL_TRIG_TREQ_SEL_Msk    (0x1f8000UL)              /*!< TREQ_SEL (Bitfield-Mask: 0x3f) */
#define DMA_CH5_CTRL_TRIG_CHAIN_TO_Pos    (11UL)                    /*!< CHAIN_TO (Bit 11) */
#define DMA_CH5_CTRL_TRIG_CHAIN_TO_Msk    (0x7800UL)                /*!< CHAIN_TO (Bitfield-Mask: 0x0f) */
#define DMA_CH5_CTRL_TRIG_RING_SEL_Pos    (10UL)                    /*!< RING_SEL (Bit 10) */
#define DMA_CH5_CTRL_TRIG_RING_SEL_Msk    (0x400UL)                 /*!< RING_SEL (Bitfield-Mask: 0x01) */
#define DMA_CH5_CTRL_TRIG_RING_SIZE_Pos   (6UL)                     /*!< RING_SIZE (Bit 6) */
#define DMA_CH5_CTRL_TRIG_RING_SIZE_Msk   (0x3c0UL)                 /*!< RING_SIZE (Bitfield-Mask: 0x0f) */
#define DMA_CH5_CTRL_TRIG_INCR_WRITE_Pos  (5UL)                     /*!< INCR_WRITE (Bit 5) */
#define DMA_CH5_CTRL_TRIG_INCR_WRITE_Msk  (0x20UL)                  /*!< INCR_WRITE (Bitfield-Mask: 0x01) */
#define DMA_CH5_CTRL_TRIG_INCR_READ_Pos   (4UL)                     /*!< INCR_READ (Bit 4) */
#define DMA_CH5_CTRL_TRIG_INCR_READ_Msk   (0x10UL)                  /*!< INCR_READ (Bitfield-Mask: 0x01) */
#define DMA_CH5_CTRL_TRIG_DATA_SIZE_Pos   (2UL)                     /*!< DATA_SIZE (Bit 2) */
#define DMA_CH5_CTRL_TRIG_DATA_SIZE_Msk   (0xcUL)                   /*!< DATA_SIZE (Bitfield-Mask: 0x03) */
#define DMA_CH5_CTRL_TRIG_HIGH_PRIORITY_Pos (1UL)                   /*!< HIGH_PRIORITY (Bit 1) */
#define DMA_CH5_CTRL_TRIG_HIGH_PRIORITY_Msk (0x2UL)                 /*!< HIGH_PRIORITY (Bitfield-Mask: 0x01) */
#define DMA_CH5_CTRL_TRIG_EN_Pos          (0UL)                     /*!< EN (Bit 0) */
#define DMA_CH5_CTRL_TRIG_EN_Msk          (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01) */
/* =====================================================  CH5_AL1_CTRL  ====================================================== */
/* ===================================================  CH5_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH5_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH5_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH5_AL2_CTRL  ====================================================== */
/* ==================================================  CH5_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH5_AL2_READ_ADDR  =================================================== */
/* ================================================  CH5_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH5_AL3_CTRL  ====================================================== */
/* ==================================================  CH5_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH5_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH5_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH6_READ_ADDR  ===================================================== */
/* ====================================================  CH6_WRITE_ADDR  ===================================================== */
/* ====================================================  CH6_TRANS_COUNT  ==================================================== */
/* =====================================================  CH6_CTRL_TRIG  ===================================================== */
#define DMA_CH6_CTRL_TRIG_AHB_ERROR_Pos   (31UL)                    /*!< AHB_ERROR (Bit 31) */
#define DMA_CH6_CTRL_TRIG_AHB_ERROR_Msk   (0x80000000UL)            /*!< AHB_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH6_CTRL_TRIG_READ_ERROR_Pos  (30UL)                    /*!< READ_ERROR (Bit 30) */
#define DMA_CH6_CTRL_TRIG_READ_ERROR_Msk  (0x40000000UL)            /*!< READ_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH6_CTRL_TRIG_WRITE_ERROR_Pos (29UL)                    /*!< WRITE_ERROR (Bit 29) */
#define DMA_CH6_CTRL_TRIG_WRITE_ERROR_Msk (0x20000000UL)            /*!< WRITE_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH6_CTRL_TRIG_BUSY_Pos        (24UL)                    /*!< BUSY (Bit 24) */
#define DMA_CH6_CTRL_TRIG_BUSY_Msk        (0x1000000UL)             /*!< BUSY (Bitfield-Mask: 0x01) */
#define DMA_CH6_CTRL_TRIG_SNIFF_EN_Pos    (23UL)                    /*!< SNIFF_EN (Bit 23) */
#define DMA_CH6_CTRL_TRIG_SNIFF_EN_Msk    (0x800000UL)              /*!< SNIFF_EN (Bitfield-Mask: 0x01) */
#define DMA_CH6_CTRL_TRIG_BSWAP_Pos       (22UL)                    /*!< BSWAP (Bit 22) */
#define DMA_CH6_CTRL_TRIG_BSWAP_Msk       (0x400000UL)              /*!< BSWAP (Bitfield-Mask: 0x01) */
#define DMA_CH6_CTRL_TRIG_IRQ_QUIET_Pos   (21UL)                    /*!< IRQ_QUIET (Bit 21) */
#define DMA_CH6_CTRL_TRIG_IRQ_QUIET_Msk   (0x200000UL)              /*!< IRQ_QUIET (Bitfield-Mask: 0x01) */
#define DMA_CH6_CTRL_TRIG_TREQ_SEL_Pos    (15UL)                    /*!< TREQ_SEL (Bit 15) */
#define DMA_CH6_CTRL_TRIG_TREQ_SEL_Msk    (0x1f8000UL)              /*!< TREQ_SEL (Bitfield-Mask: 0x3f) */
#define DMA_CH6_CTRL_TRIG_CHAIN_TO_Pos    (11UL)                    /*!< CHAIN_TO (Bit 11) */
#define DMA_CH6_CTRL_TRIG_CHAIN_TO_Msk    (0x7800UL)                /*!< CHAIN_TO (Bitfield-Mask: 0x0f) */
#define DMA_CH6_CTRL_TRIG_RING_SEL_Pos    (10UL)                    /*!< RING_SEL (Bit 10) */
#define DMA_CH6_CTRL_TRIG_RING_SEL_Msk    (0x400UL)                 /*!< RING_SEL (Bitfield-Mask: 0x01) */
#define DMA_CH6_CTRL_TRIG_RING_SIZE_Pos   (6UL)                     /*!< RING_SIZE (Bit 6) */
#define DMA_CH6_CTRL_TRIG_RING_SIZE_Msk   (0x3c0UL)                 /*!< RING_SIZE (Bitfield-Mask: 0x0f) */
#define DMA_CH6_CTRL_TRIG_INCR_WRITE_Pos  (5UL)                     /*!< INCR_WRITE (Bit 5) */
#define DMA_CH6_CTRL_TRIG_INCR_WRITE_Msk  (0x20UL)                  /*!< INCR_WRITE (Bitfield-Mask: 0x01) */
#define DMA_CH6_CTRL_TRIG_INCR_READ_Pos   (4UL)                     /*!< INCR_READ (Bit 4) */
#define DMA_CH6_CTRL_TRIG_INCR_READ_Msk   (0x10UL)                  /*!< INCR_READ (Bitfield-Mask: 0x01) */
#define DMA_CH6_CTRL_TRIG_DATA_SIZE_Pos   (2UL)                     /*!< DATA_SIZE (Bit 2) */
#define DMA_CH6_CTRL_TRIG_DATA_SIZE_Msk   (0xcUL)                   /*!< DATA_SIZE (Bitfield-Mask: 0x03) */
#define DMA_CH6_CTRL_TRIG_HIGH_PRIORITY_Pos (1UL)                   /*!< HIGH_PRIORITY (Bit 1) */
#define DMA_CH6_CTRL_TRIG_HIGH_PRIORITY_Msk (0x2UL)                 /*!< HIGH_PRIORITY (Bitfield-Mask: 0x01) */
#define DMA_CH6_CTRL_TRIG_EN_Pos          (0UL)                     /*!< EN (Bit 0) */
#define DMA_CH6_CTRL_TRIG_EN_Msk          (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01) */
/* =====================================================  CH6_AL1_CTRL  ====================================================== */
/* ===================================================  CH6_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH6_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH6_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH6_AL2_CTRL  ====================================================== */
/* ==================================================  CH6_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH6_AL2_READ_ADDR  =================================================== */
/* ================================================  CH6_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH6_AL3_CTRL  ====================================================== */
/* ==================================================  CH6_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH6_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH6_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH7_READ_ADDR  ===================================================== */
/* ====================================================  CH7_WRITE_ADDR  ===================================================== */
/* ====================================================  CH7_TRANS_COUNT  ==================================================== */
/* =====================================================  CH7_CTRL_TRIG  ===================================================== */
#define DMA_CH7_CTRL_TRIG_AHB_ERROR_Pos   (31UL)                    /*!< AHB_ERROR (Bit 31) */
#define DMA_CH7_CTRL_TRIG_AHB_ERROR_Msk   (0x80000000UL)            /*!< AHB_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH7_CTRL_TRIG_READ_ERROR_Pos  (30UL)                    /*!< READ_ERROR (Bit 30) */
#define DMA_CH7_CTRL_TRIG_READ_ERROR_Msk  (0x40000000UL)            /*!< READ_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH7_CTRL_TRIG_WRITE_ERROR_Pos (29UL)                    /*!< WRITE_ERROR (Bit 29) */
#define DMA_CH7_CTRL_TRIG_WRITE_ERROR_Msk (0x20000000UL)            /*!< WRITE_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH7_CTRL_TRIG_BUSY_Pos        (24UL)                    /*!< BUSY (Bit 24) */
#define DMA_CH7_CTRL_TRIG_BUSY_Msk        (0x1000000UL)             /*!< BUSY (Bitfield-Mask: 0x01) */
#define DMA_CH7_CTRL_TRIG_SNIFF_EN_Pos    (23UL)                    /*!< SNIFF_EN (Bit 23) */
#define DMA_CH7_CTRL_TRIG_SNIFF_EN_Msk    (0x800000UL)              /*!< SNIFF_EN (Bitfield-Mask: 0x01) */
#define DMA_CH7_CTRL_TRIG_BSWAP_Pos       (22UL)                    /*!< BSWAP (Bit 22) */
#define DMA_CH7_CTRL_TRIG_BSWAP_Msk       (0x400000UL)              /*!< BSWAP (Bitfield-Mask: 0x01) */
#define DMA_CH7_CTRL_TRIG_IRQ_QUIET_Pos   (21UL)                    /*!< IRQ_QUIET (Bit 21) */
#define DMA_CH7_CTRL_TRIG_IRQ_QUIET_Msk   (0x200000UL)              /*!< IRQ_QUIET (Bitfield-Mask: 0x01) */
#define DMA_CH7_CTRL_TRIG_TREQ_SEL_Pos    (15UL)                    /*!< TREQ_SEL (Bit 15) */
#define DMA_CH7_CTRL_TRIG_TREQ_SEL_Msk    (0x1f8000UL)              /*!< TREQ_SEL (Bitfield-Mask: 0x3f) */
#define DMA_CH7_CTRL_TRIG_CHAIN_TO_Pos    (11UL)                    /*!< CHAIN_TO (Bit 11) */
#define DMA_CH7_CTRL_TRIG_CHAIN_TO_Msk    (0x7800UL)                /*!< CHAIN_TO (Bitfield-Mask: 0x0f) */
#define DMA_CH7_CTRL_TRIG_RING_SEL_Pos    (10UL)                    /*!< RING_SEL (Bit 10) */
#define DMA_CH7_CTRL_TRIG_RING_SEL_Msk    (0x400UL)                 /*!< RING_SEL (Bitfield-Mask: 0x01) */
#define DMA_CH7_CTRL_TRIG_RING_SIZE_Pos   (6UL)                     /*!< RING_SIZE (Bit 6) */
#define DMA_CH7_CTRL_TRIG_RING_SIZE_Msk   (0x3c0UL)                 /*!< RING_SIZE (Bitfield-Mask: 0x0f) */
#define DMA_CH7_CTRL_TRIG_INCR_WRITE_Pos  (5UL)                     /*!< INCR_WRITE (Bit 5) */
#define DMA_CH7_CTRL_TRIG_INCR_WRITE_Msk  (0x20UL)                  /*!< INCR_WRITE (Bitfield-Mask: 0x01) */
#define DMA_CH7_CTRL_TRIG_INCR_READ_Pos   (4UL)                     /*!< INCR_READ (Bit 4) */
#define DMA_CH7_CTRL_TRIG_INCR_READ_Msk   (0x10UL)                  /*!< INCR_READ (Bitfield-Mask: 0x01) */
#define DMA_CH7_CTRL_TRIG_DATA_SIZE_Pos   (2UL)                     /*!< DATA_SIZE (Bit 2) */
#define DMA_CH7_CTRL_TRIG_DATA_SIZE_Msk   (0xcUL)                   /*!< DATA_SIZE (Bitfield-Mask: 0x03) */
#define DMA_CH7_CTRL_TRIG_HIGH_PRIORITY_Pos (1UL)                   /*!< HIGH_PRIORITY (Bit 1) */
#define DMA_CH7_CTRL_TRIG_HIGH_PRIORITY_Msk (0x2UL)                 /*!< HIGH_PRIORITY (Bitfield-Mask: 0x01) */
#define DMA_CH7_CTRL_TRIG_EN_Pos          (0UL)                     /*!< EN (Bit 0) */
#define DMA_CH7_CTRL_TRIG_EN_Msk          (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01) */
/* =====================================================  CH7_AL1_CTRL  ====================================================== */
/* ===================================================  CH7_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH7_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH7_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH7_AL2_CTRL  ====================================================== */
/* ==================================================  CH7_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH7_AL2_READ_ADDR  =================================================== */
/* ================================================  CH7_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH7_AL3_CTRL  ====================================================== */
/* ==================================================  CH7_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH7_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH7_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH8_READ_ADDR  ===================================================== */
/* ====================================================  CH8_WRITE_ADDR  ===================================================== */
/* ====================================================  CH8_TRANS_COUNT  ==================================================== */
/* =====================================================  CH8_CTRL_TRIG  ===================================================== */
#define DMA_CH8_CTRL_TRIG_AHB_ERROR_Pos   (31UL)                    /*!< AHB_ERROR (Bit 31) */
#define DMA_CH8_CTRL_TRIG_AHB_ERROR_Msk   (0x80000000UL)            /*!< AHB_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH8_CTRL_TRIG_READ_ERROR_Pos  (30UL)                    /*!< READ_ERROR (Bit 30) */
#define DMA_CH8_CTRL_TRIG_READ_ERROR_Msk  (0x40000000UL)            /*!< READ_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH8_CTRL_TRIG_WRITE_ERROR_Pos (29UL)                    /*!< WRITE_ERROR (Bit 29) */
#define DMA_CH8_CTRL_TRIG_WRITE_ERROR_Msk (0x20000000UL)            /*!< WRITE_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH8_CTRL_TRIG_BUSY_Pos        (24UL)                    /*!< BUSY (Bit 24) */
#define DMA_CH8_CTRL_TRIG_BUSY_Msk        (0x1000000UL)             /*!< BUSY (Bitfield-Mask: 0x01) */
#define DMA_CH8_CTRL_TRIG_SNIFF_EN_Pos    (23UL)                    /*!< SNIFF_EN (Bit 23) */
#define DMA_CH8_CTRL_TRIG_SNIFF_EN_Msk    (0x800000UL)              /*!< SNIFF_EN (Bitfield-Mask: 0x01) */
#define DMA_CH8_CTRL_TRIG_BSWAP_Pos       (22UL)                    /*!< BSWAP (Bit 22) */
#define DMA_CH8_CTRL_TRIG_BSWAP_Msk       (0x400000UL)              /*!< BSWAP (Bitfield-Mask: 0x01) */
#define DMA_CH8_CTRL_TRIG_IRQ_QUIET_Pos   (21UL)                    /*!< IRQ_QUIET (Bit 21) */
#define DMA_CH8_CTRL_TRIG_IRQ_QUIET_Msk   (0x200000UL)              /*!< IRQ_QUIET (Bitfield-Mask: 0x01) */
#define DMA_CH8_CTRL_TRIG_TREQ_SEL_Pos    (15UL)                    /*!< TREQ_SEL (Bit 15) */
#define DMA_CH8_CTRL_TRIG_TREQ_SEL_Msk    (0x1f8000UL)              /*!< TREQ_SEL (Bitfield-Mask: 0x3f) */
#define DMA_CH8_CTRL_TRIG_CHAIN_TO_Pos    (11UL)                    /*!< CHAIN_TO (Bit 11) */
#define DMA_CH8_CTRL_TRIG_CHAIN_TO_Msk    (0x7800UL)                /*!< CHAIN_TO (Bitfield-Mask: 0x0f) */
#define DMA_CH8_CTRL_TRIG_RING_SEL_Pos    (10UL)                    /*!< RING_SEL (Bit 10) */
#define DMA_CH8_CTRL_TRIG_RING_SEL_Msk    (0x400UL)                 /*!< RING_SEL (Bitfield-Mask: 0x01) */
#define DMA_CH8_CTRL_TRIG_RING_SIZE_Pos   (6UL)                     /*!< RING_SIZE (Bit 6) */
#define DMA_CH8_CTRL_TRIG_RING_SIZE_Msk   (0x3c0UL)                 /*!< RING_SIZE (Bitfield-Mask: 0x0f) */
#define DMA_CH8_CTRL_TRIG_INCR_WRITE_Pos  (5UL)                     /*!< INCR_WRITE (Bit 5) */
#define DMA_CH8_CTRL_TRIG_INCR_WRITE_Msk  (0x20UL)                  /*!< INCR_WRITE (Bitfield-Mask: 0x01) */
#define DMA_CH8_CTRL_TRIG_INCR_READ_Pos   (4UL)                     /*!< INCR_READ (Bit 4) */
#define DMA_CH8_CTRL_TRIG_INCR_READ_Msk   (0x10UL)                  /*!< INCR_READ (Bitfield-Mask: 0x01) */
#define DMA_CH8_CTRL_TRIG_DATA_SIZE_Pos   (2UL)                     /*!< DATA_SIZE (Bit 2) */
#define DMA_CH8_CTRL_TRIG_DATA_SIZE_Msk   (0xcUL)                   /*!< DATA_SIZE (Bitfield-Mask: 0x03) */
#define DMA_CH8_CTRL_TRIG_HIGH_PRIORITY_Pos (1UL)                   /*!< HIGH_PRIORITY (Bit 1) */
#define DMA_CH8_CTRL_TRIG_HIGH_PRIORITY_Msk (0x2UL)                 /*!< HIGH_PRIORITY (Bitfield-Mask: 0x01) */
#define DMA_CH8_CTRL_TRIG_EN_Pos          (0UL)                     /*!< EN (Bit 0) */
#define DMA_CH8_CTRL_TRIG_EN_Msk          (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01) */
/* =====================================================  CH8_AL1_CTRL  ====================================================== */
/* ===================================================  CH8_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH8_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH8_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH8_AL2_CTRL  ====================================================== */
/* ==================================================  CH8_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH8_AL2_READ_ADDR  =================================================== */
/* ================================================  CH8_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH8_AL3_CTRL  ====================================================== */
/* ==================================================  CH8_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH8_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH8_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH9_READ_ADDR  ===================================================== */
/* ====================================================  CH9_WRITE_ADDR  ===================================================== */
/* ====================================================  CH9_TRANS_COUNT  ==================================================== */
/* =====================================================  CH9_CTRL_TRIG  ===================================================== */
#define DMA_CH9_CTRL_TRIG_AHB_ERROR_Pos   (31UL)                    /*!< AHB_ERROR (Bit 31) */
#define DMA_CH9_CTRL_TRIG_AHB_ERROR_Msk   (0x80000000UL)            /*!< AHB_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH9_CTRL_TRIG_READ_ERROR_Pos  (30UL)                    /*!< READ_ERROR (Bit 30) */
#define DMA_CH9_CTRL_TRIG_READ_ERROR_Msk  (0x40000000UL)            /*!< READ_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH9_CTRL_TRIG_WRITE_ERROR_Pos (29UL)                    /*!< WRITE_ERROR (Bit 29) */
#define DMA_CH9_CTRL_TRIG_WRITE_ERROR_Msk (0x20000000UL)            /*!< WRITE_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH9_CTRL_TRIG_BUSY_Pos        (24UL)                    /*!< BUSY (Bit 24) */
#define DMA_CH9_CTRL_TRIG_BUSY_Msk        (0x1000000UL)             /*!< BUSY (Bitfield-Mask: 0x01) */
#define DMA_CH9_CTRL_TRIG_SNIFF_EN_Pos    (23UL)                    /*!< SNIFF_EN (Bit 23) */
#define DMA_CH9_CTRL_TRIG_SNIFF_EN_Msk    (0x800000UL)              /*!< SNIFF_EN (Bitfield-Mask: 0x01) */
#define DMA_CH9_CTRL_TRIG_BSWAP_Pos       (22UL)                    /*!< BSWAP (Bit 22) */
#define DMA_CH9_CTRL_TRIG_BSWAP_Msk       (0x400000UL)              /*!< BSWAP (Bitfield-Mask: 0x01) */
#define DMA_CH9_CTRL_TRIG_IRQ_QUIET_Pos   (21UL)                    /*!< IRQ_QUIET (Bit 21) */
#define DMA_CH9_CTRL_TRIG_IRQ_QUIET_Msk   (0x200000UL)              /*!< IRQ_QUIET (Bitfield-Mask: 0x01) */
#define DMA_CH9_CTRL_TRIG_TREQ_SEL_Pos    (15UL)                    /*!< TREQ_SEL (Bit 15) */
#define DMA_CH9_CTRL_TRIG_TREQ_SEL_Msk    (0x1f8000UL)              /*!< TREQ_SEL (Bitfield-Mask: 0x3f) */
#define DMA_CH9_CTRL_TRIG_CHAIN_TO_Pos    (11UL)                    /*!< CHAIN_TO (Bit 11) */
#define DMA_CH9_CTRL_TRIG_CHAIN_TO_Msk    (0x7800UL)                /*!< CHAIN_TO (Bitfield-Mask: 0x0f) */
#define DMA_CH9_CTRL_TRIG_RING_SEL_Pos    (10UL)                    /*!< RING_SEL (Bit 10) */
#define DMA_CH9_CTRL_TRIG_RING_SEL_Msk    (0x400UL)                 /*!< RING_SEL (Bitfield-Mask: 0x01) */
#define DMA_CH9_CTRL_TRIG_RING_SIZE_Pos   (6UL)                     /*!< RING_SIZE (Bit 6) */
#define DMA_CH9_CTRL_TRIG_RING_SIZE_Msk   (0x3c0UL)                 /*!< RING_SIZE (Bitfield-Mask: 0x0f) */
#define DMA_CH9_CTRL_TRIG_INCR_WRITE_Pos  (5UL)                     /*!< INCR_WRITE (Bit 5) */
#define DMA_CH9_CTRL_TRIG_INCR_WRITE_Msk  (0x20UL)                  /*!< INCR_WRITE (Bitfield-Mask: 0x01) */
#define DMA_CH9_CTRL_TRIG_INCR_READ_Pos   (4UL)                     /*!< INCR_READ (Bit 4) */
#define DMA_CH9_CTRL_TRIG_INCR_READ_Msk   (0x10UL)                  /*!< INCR_READ (Bitfield-Mask: 0x01) */
#define DMA_CH9_CTRL_TRIG_DATA_SIZE_Pos   (2UL)                     /*!< DATA_SIZE (Bit 2) */
#define DMA_CH9_CTRL_TRIG_DATA_SIZE_Msk   (0xcUL)                   /*!< DATA_SIZE (Bitfield-Mask: 0x03) */
#define DMA_CH9_CTRL_TRIG_HIGH_PRIORITY_Pos (1UL)                   /*!< HIGH_PRIORITY (Bit 1) */
#define DMA_CH9_CTRL_TRIG_HIGH_PRIORITY_Msk (0x2UL)                 /*!< HIGH_PRIORITY (Bitfield-Mask: 0x01) */
#define DMA_CH9_CTRL_TRIG_EN_Pos          (0UL)                     /*!< EN (Bit 0) */
#define DMA_CH9_CTRL_TRIG_EN_Msk          (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01) */
/* =====================================================  CH9_AL1_CTRL  ====================================================== */
/* ===================================================  CH9_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH9_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH9_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH9_AL2_CTRL  ====================================================== */
/* ==================================================  CH9_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH9_AL2_READ_ADDR  =================================================== */
/* ================================================  CH9_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH9_AL3_CTRL  ====================================================== */
/* ==================================================  CH9_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH9_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH9_AL3_READ_ADDR_TRIG  ================================================= */
/* ====================================================  CH10_READ_ADDR  ===================================================== */
/* ====================================================  CH10_WRITE_ADDR  ==================================================== */
/* ===================================================  CH10_TRANS_COUNT  ==================================================== */
/* ====================================================  CH10_CTRL_TRIG  ===================================================== */
#define DMA_CH10_CTRL_TRIG_AHB_ERROR_Pos  (31UL)                    /*!< AHB_ERROR (Bit 31) */
#define DMA_CH10_CTRL_TRIG_AHB_ERROR_Msk  (0x80000000UL)            /*!< AHB_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH10_CTRL_TRIG_READ_ERROR_Pos (30UL)                    /*!< READ_ERROR (Bit 30) */
#define DMA_CH10_CTRL_TRIG_READ_ERROR_Msk (0x40000000UL)            /*!< READ_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH10_CTRL_TRIG_WRITE_ERROR_Pos (29UL)                   /*!< WRITE_ERROR (Bit 29) */
#define DMA_CH10_CTRL_TRIG_WRITE_ERROR_Msk (0x20000000UL)           /*!< WRITE_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH10_CTRL_TRIG_BUSY_Pos       (24UL)                    /*!< BUSY (Bit 24) */
#define DMA_CH10_CTRL_TRIG_BUSY_Msk       (0x1000000UL)             /*!< BUSY (Bitfield-Mask: 0x01) */
#define DMA_CH10_CTRL_TRIG_SNIFF_EN_Pos   (23UL)                    /*!< SNIFF_EN (Bit 23) */
#define DMA_CH10_CTRL_TRIG_SNIFF_EN_Msk   (0x800000UL)              /*!< SNIFF_EN (Bitfield-Mask: 0x01) */
#define DMA_CH10_CTRL_TRIG_BSWAP_Pos      (22UL)                    /*!< BSWAP (Bit 22) */
#define DMA_CH10_CTRL_TRIG_BSWAP_Msk      (0x400000UL)              /*!< BSWAP (Bitfield-Mask: 0x01) */
#define DMA_CH10_CTRL_TRIG_IRQ_QUIET_Pos  (21UL)                    /*!< IRQ_QUIET (Bit 21) */
#define DMA_CH10_CTRL_TRIG_IRQ_QUIET_Msk  (0x200000UL)              /*!< IRQ_QUIET (Bitfield-Mask: 0x01) */
#define DMA_CH10_CTRL_TRIG_TREQ_SEL_Pos   (15UL)                    /*!< TREQ_SEL (Bit 15) */
#define DMA_CH10_CTRL_TRIG_TREQ_SEL_Msk   (0x1f8000UL)              /*!< TREQ_SEL (Bitfield-Mask: 0x3f) */
#define DMA_CH10_CTRL_TRIG_CHAIN_TO_Pos   (11UL)                    /*!< CHAIN_TO (Bit 11) */
#define DMA_CH10_CTRL_TRIG_CHAIN_TO_Msk   (0x7800UL)                /*!< CHAIN_TO (Bitfield-Mask: 0x0f) */
#define DMA_CH10_CTRL_TRIG_RING_SEL_Pos   (10UL)                    /*!< RING_SEL (Bit 10) */
#define DMA_CH10_CTRL_TRIG_RING_SEL_Msk   (0x400UL)                 /*!< RING_SEL (Bitfield-Mask: 0x01) */
#define DMA_CH10_CTRL_TRIG_RING_SIZE_Pos  (6UL)                     /*!< RING_SIZE (Bit 6) */
#define DMA_CH10_CTRL_TRIG_RING_SIZE_Msk  (0x3c0UL)                 /*!< RING_SIZE (Bitfield-Mask: 0x0f) */
#define DMA_CH10_CTRL_TRIG_INCR_WRITE_Pos (5UL)                     /*!< INCR_WRITE (Bit 5) */
#define DMA_CH10_CTRL_TRIG_INCR_WRITE_Msk (0x20UL)                  /*!< INCR_WRITE (Bitfield-Mask: 0x01) */
#define DMA_CH10_CTRL_TRIG_INCR_READ_Pos  (4UL)                     /*!< INCR_READ (Bit 4) */
#define DMA_CH10_CTRL_TRIG_INCR_READ_Msk  (0x10UL)                  /*!< INCR_READ (Bitfield-Mask: 0x01) */
#define DMA_CH10_CTRL_TRIG_DATA_SIZE_Pos  (2UL)                     /*!< DATA_SIZE (Bit 2) */
#define DMA_CH10_CTRL_TRIG_DATA_SIZE_Msk  (0xcUL)                   /*!< DATA_SIZE (Bitfield-Mask: 0x03) */
#define DMA_CH10_CTRL_TRIG_HIGH_PRIORITY_Pos (1UL)                  /*!< HIGH_PRIORITY (Bit 1) */
#define DMA_CH10_CTRL_TRIG_HIGH_PRIORITY_Msk (0x2UL)                /*!< HIGH_PRIORITY (Bitfield-Mask: 0x01) */
#define DMA_CH10_CTRL_TRIG_EN_Pos         (0UL)                     /*!< EN (Bit 0) */
#define DMA_CH10_CTRL_TRIG_EN_Msk         (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01) */
/* =====================================================  CH10_AL1_CTRL  ===================================================== */
/* ==================================================  CH10_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH10_AL1_WRITE_ADDR  ================================================== */
/* ===============================================  CH10_AL1_TRANS_COUNT_TRIG  =============================================== */
/* =====================================================  CH10_AL2_CTRL  ===================================================== */
/* =================================================  CH10_AL2_TRANS_COUNT  ================================================== */
/* ==================================================  CH10_AL2_READ_ADDR  =================================================== */
/* ===============================================  CH10_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH10_AL3_CTRL  ===================================================== */
/* ==================================================  CH10_AL3_WRITE_ADDR  ================================================== */
/* =================================================  CH10_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH10_AL3_READ_ADDR_TRIG  ================================================ */
/* ====================================================  CH11_READ_ADDR  ===================================================== */
/* ====================================================  CH11_WRITE_ADDR  ==================================================== */
/* ===================================================  CH11_TRANS_COUNT  ==================================================== */
/* ====================================================  CH11_CTRL_TRIG  ===================================================== */
#define DMA_CH11_CTRL_TRIG_AHB_ERROR_Pos  (31UL)                    /*!< AHB_ERROR (Bit 31) */
#define DMA_CH11_CTRL_TRIG_AHB_ERROR_Msk  (0x80000000UL)            /*!< AHB_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH11_CTRL_TRIG_READ_ERROR_Pos (30UL)                    /*!< READ_ERROR (Bit 30) */
#define DMA_CH11_CTRL_TRIG_READ_ERROR_Msk (0x40000000UL)            /*!< READ_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH11_CTRL_TRIG_WRITE_ERROR_Pos (29UL)                   /*!< WRITE_ERROR (Bit 29) */
#define DMA_CH11_CTRL_TRIG_WRITE_ERROR_Msk (0x20000000UL)           /*!< WRITE_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CH11_CTRL_TRIG_BUSY_Pos       (24UL)                    /*!< BUSY (Bit 24) */
#define DMA_CH11_CTRL_TRIG_BUSY_Msk       (0x1000000UL)             /*!< BUSY (Bitfield-Mask: 0x01) */
#define DMA_CH11_CTRL_TRIG_SNIFF_EN_Pos   (23UL)                    /*!< SNIFF_EN (Bit 23) */
#define DMA_CH11_CTRL_TRIG_SNIFF_EN_Msk   (0x800000UL)              /*!< SNIFF_EN (Bitfield-Mask: 0x01) */
#define DMA_CH11_CTRL_TRIG_BSWAP_Pos      (22UL)                    /*!< BSWAP (Bit 22) */
#define DMA_CH11_CTRL_TRIG_BSWAP_Msk      (0x400000UL)              /*!< BSWAP (Bitfield-Mask: 0x01) */
#define DMA_CH11_CTRL_TRIG_IRQ_QUIET_Pos  (21UL)                    /*!< IRQ_QUIET (Bit 21) */
#define DMA_CH11_CTRL_TRIG_IRQ_QUIET_Msk  (0x200000UL)              /*!< IRQ_QUIET (Bitfield-Mask: 0x01) */
#define DMA_CH11_CTRL_TRIG_TREQ_SEL_Pos   (15UL)                    /*!< TREQ_SEL (Bit 15) */
#define DMA_CH11_CTRL_TRIG_TREQ_SEL_Msk   (0x1f8000UL)              /*!< TREQ_SEL (Bitfield-Mask: 0x3f) */
#define DMA_CH11_CTRL_TRIG_CHAIN_TO_Pos   (11UL)                    /*!< CHAIN_TO (Bit 11) */
#define DMA_CH11_CTRL_TRIG_CHAIN_TO_Msk   (0x7800UL)                /*!< CHAIN_TO (Bitfield-Mask: 0x0f) */
#define DMA_CH11_CTRL_TRIG_RING_SEL_Pos   (10UL)                    /*!< RING_SEL (Bit 10) */
#define DMA_CH11_CTRL_TRIG_RING_SEL_Msk   (0x400UL)                 /*!< RING_SEL (Bitfield-Mask: 0x01) */
#define DMA_CH11_CTRL_TRIG_RING_SIZE_Pos  (6UL)                     /*!< RING_SIZE (Bit 6) */
#define DMA_CH11_CTRL_TRIG_RING_SIZE_Msk  (0x3c0UL)                 /*!< RING_SIZE (Bitfield-Mask: 0x0f) */
#define DMA_CH11_CTRL_TRIG_INCR_WRITE_Pos (5UL)                     /*!< INCR_WRITE (Bit 5) */
#define DMA_CH11_CTRL_TRIG_INCR_WRITE_Msk (0x20UL)                  /*!< INCR_WRITE (Bitfield-Mask: 0x01) */
#define DMA_CH11_CTRL_TRIG_INCR_READ_Pos  (4UL)                     /*!< INCR_READ (Bit 4) */
#define DMA_CH11_CTRL_TRIG_INCR_READ_Msk  (0x10UL)                  /*!< INCR_READ (Bitfield-Mask: 0x01) */
#define DMA_CH11_CTRL_TRIG_DATA_SIZE_Pos  (2UL)                     /*!< DATA_SIZE (Bit 2) */
#define DMA_CH11_CTRL_TRIG_DATA_SIZE_Msk  (0xcUL)                   /*!< DATA_SIZE (Bitfield-Mask: 0x03) */
#define DMA_CH11_CTRL_TRIG_HIGH_PRIORITY_Pos (1UL)                  /*!< HIGH_PRIORITY (Bit 1) */
#define DMA_CH11_CTRL_TRIG_HIGH_PRIORITY_Msk (0x2UL)                /*!< HIGH_PRIORITY (Bitfield-Mask: 0x01) */
#define DMA_CH11_CTRL_TRIG_EN_Pos         (0UL)                     /*!< EN (Bit 0) */
#define DMA_CH11_CTRL_TRIG_EN_Msk         (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01) */
/* =====================================================  CH11_AL1_CTRL  ===================================================== */
/* ==================================================  CH11_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH11_AL1_WRITE_ADDR  ================================================== */
/* ===============================================  CH11_AL1_TRANS_COUNT_TRIG  =============================================== */
/* =====================================================  CH11_AL2_CTRL  ===================================================== */
/* =================================================  CH11_AL2_TRANS_COUNT  ================================================== */
/* ==================================================  CH11_AL2_READ_ADDR  =================================================== */
/* ===============================================  CH11_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH11_AL3_CTRL  ===================================================== */
/* ==================================================  CH11_AL3_WRITE_ADDR  ================================================== */
/* =================================================  CH11_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH11_AL3_READ_ADDR_TRIG  ================================================ */
/* =========================================================  INTR  ========================================================== */
#define DMA_INTR_INTR_Pos                 (0UL)                     /*!< INTR (Bit 0) */
#define DMA_INTR_INTR_Msk                 (0xffffUL)                /*!< INTR (Bitfield-Mask: 0xffff) */
/* =========================================================  INTE0  ========================================================= */
#define DMA_INTE0_INTE0_Pos               (0UL)                     /*!< INTE0 (Bit 0) */
#define DMA_INTE0_INTE0_Msk               (0xffffUL)                /*!< INTE0 (Bitfield-Mask: 0xffff) */
/* =========================================================  INTF0  ========================================================= */
#define DMA_INTF0_INTF0_Pos               (0UL)                     /*!< INTF0 (Bit 0) */
#define DMA_INTF0_INTF0_Msk               (0xffffUL)                /*!< INTF0 (Bitfield-Mask: 0xffff) */
/* =========================================================  INTS0  ========================================================= */
#define DMA_INTS0_INTS0_Pos               (0UL)                     /*!< INTS0 (Bit 0) */
#define DMA_INTS0_INTS0_Msk               (0xffffUL)                /*!< INTS0 (Bitfield-Mask: 0xffff) */
/* =========================================================  INTE1  ========================================================= */
#define DMA_INTE1_INTE1_Pos               (0UL)                     /*!< INTE1 (Bit 0) */
#define DMA_INTE1_INTE1_Msk               (0xffffUL)                /*!< INTE1 (Bitfield-Mask: 0xffff) */
/* =========================================================  INTF1  ========================================================= */
#define DMA_INTF1_INTF1_Pos               (0UL)                     /*!< INTF1 (Bit 0) */
#define DMA_INTF1_INTF1_Msk               (0xffffUL)                /*!< INTF1 (Bitfield-Mask: 0xffff) */
/* =========================================================  INTS1  ========================================================= */
#define DMA_INTS1_INTS1_Pos               (0UL)                     /*!< INTS1 (Bit 0) */
#define DMA_INTS1_INTS1_Msk               (0xffffUL)                /*!< INTS1 (Bitfield-Mask: 0xffff) */
/* ========================================================  TIMER0  ========================================================= */
#define DMA_TIMER0_X_Pos                  (16UL)                    /*!< X (Bit 16) */
#define DMA_TIMER0_X_Msk                  (0xffff0000UL)            /*!< X (Bitfield-Mask: 0xffff) */
#define DMA_TIMER0_Y_Pos                  (0UL)                     /*!< Y (Bit 0) */
#define DMA_TIMER0_Y_Msk                  (0xffffUL)                /*!< Y (Bitfield-Mask: 0xffff) */
/* ========================================================  TIMER1  ========================================================= */
#define DMA_TIMER1_X_Pos                  (16UL)                    /*!< X (Bit 16) */
#define DMA_TIMER1_X_Msk                  (0xffff0000UL)            /*!< X (Bitfield-Mask: 0xffff) */
#define DMA_TIMER1_Y_Pos                  (0UL)                     /*!< Y (Bit 0) */
#define DMA_TIMER1_Y_Msk                  (0xffffUL)                /*!< Y (Bitfield-Mask: 0xffff) */
/* ========================================================  TIMER2  ========================================================= */
#define DMA_TIMER2_X_Pos                  (16UL)                    /*!< X (Bit 16) */
#define DMA_TIMER2_X_Msk                  (0xffff0000UL)            /*!< X (Bitfield-Mask: 0xffff) */
#define DMA_TIMER2_Y_Pos                  (0UL)                     /*!< Y (Bit 0) */
#define DMA_TIMER2_Y_Msk                  (0xffffUL)                /*!< Y (Bitfield-Mask: 0xffff) */
/* ========================================================  TIMER3  ========================================================= */
#define DMA_TIMER3_X_Pos                  (16UL)                    /*!< X (Bit 16) */
#define DMA_TIMER3_X_Msk                  (0xffff0000UL)            /*!< X (Bitfield-Mask: 0xffff) */
#define DMA_TIMER3_Y_Pos                  (0UL)                     /*!< Y (Bit 0) */
#define DMA_TIMER3_Y_Msk                  (0xffffUL)                /*!< Y (Bitfield-Mask: 0xffff) */
/* ==================================================  MULTI_CHAN_TRIGGER  =================================================== */
#define DMA_MULTI_CHAN_TRIGGER_MULTI_CHAN_TRIGGER_Pos (0UL)         /*!< MULTI_CHAN_TRIGGER (Bit 0) */
#define DMA_MULTI_CHAN_TRIGGER_MULTI_CHAN_TRIGGER_Msk (0xffffUL)    /*!< MULTI_CHAN_TRIGGER (Bitfield-Mask: 0xffff) */
/* ======================================================  SNIFF_CTRL  ======================================================= */
#define DMA_SNIFF_CTRL_OUT_INV_Pos        (11UL)                    /*!< OUT_INV (Bit 11) */
#define DMA_SNIFF_CTRL_OUT_INV_Msk        (0x800UL)                 /*!< OUT_INV (Bitfield-Mask: 0x01) */
#define DMA_SNIFF_CTRL_OUT_REV_Pos        (10UL)                    /*!< OUT_REV (Bit 10) */
#define DMA_SNIFF_CTRL_OUT_REV_Msk        (0x400UL)                 /*!< OUT_REV (Bitfield-Mask: 0x01) */
#define DMA_SNIFF_CTRL_BSWAP_Pos          (9UL)                     /*!< BSWAP (Bit 9) */
#define DMA_SNIFF_CTRL_BSWAP_Msk          (0x200UL)                 /*!< BSWAP (Bitfield-Mask: 0x01) */
#define DMA_SNIFF_CTRL_CALC_Pos           (5UL)                     /*!< CALC (Bit 5) */
#define DMA_SNIFF_CTRL_CALC_Msk           (0x1e0UL)                 /*!< CALC (Bitfield-Mask: 0x0f) */
#define DMA_SNIFF_CTRL_DMACH_Pos          (1UL)                     /*!< DMACH (Bit 1) */
#define DMA_SNIFF_CTRL_DMACH_Msk          (0x1eUL)                  /*!< DMACH (Bitfield-Mask: 0x0f) */
#define DMA_SNIFF_CTRL_EN_Pos             (0UL)                     /*!< EN (Bit 0) */
#define DMA_SNIFF_CTRL_EN_Msk             (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01) */
/* ======================================================  SNIFF_DATA  ======================================================= */
/* ======================================================  FIFO_LEVELS  ====================================================== */
#define DMA_FIFO_LEVELS_RAF_LVL_Pos       (16UL)                    /*!< RAF_LVL (Bit 16) */
#define DMA_FIFO_LEVELS_RAF_LVL_Msk       (0xff0000UL)              /*!< RAF_LVL (Bitfield-Mask: 0xff) */
#define DMA_FIFO_LEVELS_WAF_LVL_Pos       (8UL)                     /*!< WAF_LVL (Bit 8) */
#define DMA_FIFO_LEVELS_WAF_LVL_Msk       (0xff00UL)                /*!< WAF_LVL (Bitfield-Mask: 0xff) */
#define DMA_FIFO_LEVELS_TDF_LVL_Pos       (0UL)                     /*!< TDF_LVL (Bit 0) */
#define DMA_FIFO_LEVELS_TDF_LVL_Msk       (0xffUL)                  /*!< TDF_LVL (Bitfield-Mask: 0xff) */
/* ======================================================  CHAN_ABORT  ======================================================= */
#define DMA_CHAN_ABORT_CHAN_ABORT_Pos     (0UL)                     /*!< CHAN_ABORT (Bit 0) */
#define DMA_CHAN_ABORT_CHAN_ABORT_Msk     (0xffffUL)                /*!< CHAN_ABORT (Bitfield-Mask: 0xffff) */
/* ======================================================  N_CHANNELS  ======================================================= */
#define DMA_N_CHANNELS_N_CHANNELS_Pos     (0UL)                     /*!< N_CHANNELS (Bit 0) */
#define DMA_N_CHANNELS_N_CHANNELS_Msk     (0x1fUL)                  /*!< N_CHANNELS (Bitfield-Mask: 0x1f) */
/* ====================================================  CH0_DBG_CTDREQ  ===================================================== */
#define DMA_CH0_DBG_CTDREQ_CH0_DBG_CTDREQ_Pos (0UL)                 /*!< CH0_DBG_CTDREQ (Bit 0) */
#define DMA_CH0_DBG_CTDREQ_CH0_DBG_CTDREQ_Msk (0x3fUL)              /*!< CH0_DBG_CTDREQ (Bitfield-Mask: 0x3f) */
/* ======================================================  CH0_DBG_TCR  ====================================================== */
/* ====================================================  CH1_DBG_CTDREQ  ===================================================== */
#define DMA_CH1_DBG_CTDREQ_CH1_DBG_CTDREQ_Pos (0UL)                 /*!< CH1_DBG_CTDREQ (Bit 0) */
#define DMA_CH1_DBG_CTDREQ_CH1_DBG_CTDREQ_Msk (0x3fUL)              /*!< CH1_DBG_CTDREQ (Bitfield-Mask: 0x3f) */
/* ======================================================  CH1_DBG_TCR  ====================================================== */
/* ====================================================  CH2_DBG_CTDREQ  ===================================================== */
#define DMA_CH2_DBG_CTDREQ_CH2_DBG_CTDREQ_Pos (0UL)                 /*!< CH2_DBG_CTDREQ (Bit 0) */
#define DMA_CH2_DBG_CTDREQ_CH2_DBG_CTDREQ_Msk (0x3fUL)              /*!< CH2_DBG_CTDREQ (Bitfield-Mask: 0x3f) */
/* ======================================================  CH2_DBG_TCR  ====================================================== */
/* ====================================================  CH3_DBG_CTDREQ  ===================================================== */
#define DMA_CH3_DBG_CTDREQ_CH3_DBG_CTDREQ_Pos (0UL)                 /*!< CH3_DBG_CTDREQ (Bit 0) */
#define DMA_CH3_DBG_CTDREQ_CH3_DBG_CTDREQ_Msk (0x3fUL)              /*!< CH3_DBG_CTDREQ (Bitfield-Mask: 0x3f) */
/* ======================================================  CH3_DBG_TCR  ====================================================== */
/* ====================================================  CH4_DBG_CTDREQ  ===================================================== */
#define DMA_CH4_DBG_CTDREQ_CH4_DBG_CTDREQ_Pos (0UL)                 /*!< CH4_DBG_CTDREQ (Bit 0) */
#define DMA_CH4_DBG_CTDREQ_CH4_DBG_CTDREQ_Msk (0x3fUL)              /*!< CH4_DBG_CTDREQ (Bitfield-Mask: 0x3f) */
/* ======================================================  CH4_DBG_TCR  ====================================================== */
/* ====================================================  CH5_DBG_CTDREQ  ===================================================== */
#define DMA_CH5_DBG_CTDREQ_CH5_DBG_CTDREQ_Pos (0UL)                 /*!< CH5_DBG_CTDREQ (Bit 0) */
#define DMA_CH5_DBG_CTDREQ_CH5_DBG_CTDREQ_Msk (0x3fUL)              /*!< CH5_DBG_CTDREQ (Bitfield-Mask: 0x3f) */
/* ======================================================  CH5_DBG_TCR  ====================================================== */
/* ====================================================  CH6_DBG_CTDREQ  ===================================================== */
#define DMA_CH6_DBG_CTDREQ_CH6_DBG_CTDREQ_Pos (0UL)                 /*!< CH6_DBG_CTDREQ (Bit 0) */
#define DMA_CH6_DBG_CTDREQ_CH6_DBG_CTDREQ_Msk (0x3fUL)              /*!< CH6_DBG_CTDREQ (Bitfield-Mask: 0x3f) */
/* ======================================================  CH6_DBG_TCR  ====================================================== */
/* ====================================================  CH7_DBG_CTDREQ  ===================================================== */
#define DMA_CH7_DBG_CTDREQ_CH7_DBG_CTDREQ_Pos (0UL)                 /*!< CH7_DBG_CTDREQ (Bit 0) */
#define DMA_CH7_DBG_CTDREQ_CH7_DBG_CTDREQ_Msk (0x3fUL)              /*!< CH7_DBG_CTDREQ (Bitfield-Mask: 0x3f) */
/* ======================================================  CH7_DBG_TCR  ====================================================== */
/* ====================================================  CH8_DBG_CTDREQ  ===================================================== */
#define DMA_CH8_DBG_CTDREQ_CH8_DBG_CTDREQ_Pos (0UL)                 /*!< CH8_DBG_CTDREQ (Bit 0) */
#define DMA_CH8_DBG_CTDREQ_CH8_DBG_CTDREQ_Msk (0x3fUL)              /*!< CH8_DBG_CTDREQ (Bitfield-Mask: 0x3f) */
/* ======================================================  CH8_DBG_TCR  ====================================================== */
/* ====================================================  CH9_DBG_CTDREQ  ===================================================== */
#define DMA_CH9_DBG_CTDREQ_CH9_DBG_CTDREQ_Pos (0UL)                 /*!< CH9_DBG_CTDREQ (Bit 0) */
#define DMA_CH9_DBG_CTDREQ_CH9_DBG_CTDREQ_Msk (0x3fUL)              /*!< CH9_DBG_CTDREQ (Bitfield-Mask: 0x3f) */
/* ======================================================  CH9_DBG_TCR  ====================================================== */
/* ====================================================  CH10_DBG_CTDREQ  ==================================================== */
#define DMA_CH10_DBG_CTDREQ_CH10_DBG_CTDREQ_Pos (0UL)               /*!< CH10_DBG_CTDREQ (Bit 0) */
#define DMA_CH10_DBG_CTDREQ_CH10_DBG_CTDREQ_Msk (0x3fUL)            /*!< CH10_DBG_CTDREQ (Bitfield-Mask: 0x3f) */
/* =====================================================  CH10_DBG_TCR  ====================================================== */
/* ====================================================  CH11_DBG_CTDREQ  ==================================================== */
#define DMA_CH11_DBG_CTDREQ_CH11_DBG_CTDREQ_Pos (0UL)               /*!< CH11_DBG_CTDREQ (Bit 0) */
#define DMA_CH11_DBG_CTDREQ_CH11_DBG_CTDREQ_Msk (0x3fUL)            /*!< CH11_DBG_CTDREQ (Bitfield-Mask: 0x3f) */
/* =====================================================  CH11_DBG_TCR  ====================================================== */


/* =========================================================================================================================== */
/* ================                                       USBCTRL_DPRAM                                       ================ */
/* =========================================================================================================================== */

/* ===================================================  SETUP_PACKET_LOW  ==================================================== */
#define USBCTRL_DPRAM_SETUP_PACKET_LOW_WVALUE_Pos (16UL)            /*!< WVALUE (Bit 16) */
#define USBCTRL_DPRAM_SETUP_PACKET_LOW_WVALUE_Msk (0xffff0000UL)    /*!< WVALUE (Bitfield-Mask: 0xffff) */
#define USBCTRL_DPRAM_SETUP_PACKET_LOW_BREQUEST_Pos (8UL)           /*!< BREQUEST (Bit 8) */
#define USBCTRL_DPRAM_SETUP_PACKET_LOW_BREQUEST_Msk (0xff00UL)      /*!< BREQUEST (Bitfield-Mask: 0xff) */
#define USBCTRL_DPRAM_SETUP_PACKET_LOW_BMREQUESTTYPE_Pos (0UL)      /*!< BMREQUESTTYPE (Bit 0) */
#define USBCTRL_DPRAM_SETUP_PACKET_LOW_BMREQUESTTYPE_Msk (0xffUL)   /*!< BMREQUESTTYPE (Bitfield-Mask: 0xff) */
/* ===================================================  SETUP_PACKET_HIGH  =================================================== */
#define USBCTRL_DPRAM_SETUP_PACKET_HIGH_WLENGTH_Pos (16UL)          /*!< WLENGTH (Bit 16) */
#define USBCTRL_DPRAM_SETUP_PACKET_HIGH_WLENGTH_Msk (0xffff0000UL)  /*!< WLENGTH (Bitfield-Mask: 0xffff) */
#define USBCTRL_DPRAM_SETUP_PACKET_HIGH_WINDEX_Pos (0UL)            /*!< WINDEX (Bit 0) */
#define USBCTRL_DPRAM_SETUP_PACKET_HIGH_WINDEX_Msk (0xffffUL)       /*!< WINDEX (Bitfield-Mask: 0xffff) */
/* ====================================================  EP1_IN_CONTROL  ===================================================== */
#define USBCTRL_DPRAM_EP1_IN_CONTROL_ENABLE_Pos (31UL)              /*!< ENABLE (Bit 31) */
#define USBCTRL_DPRAM_EP1_IN_CONTROL_ENABLE_Msk (0x80000000UL)      /*!< ENABLE (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_IN_CONTROL_DOUBLE_BUFFERED_Pos (30UL)     /*!< DOUBLE_BUFFERED (Bit 30) */
#define USBCTRL_DPRAM_EP1_IN_CONTROL_DOUBLE_BUFFERED_Msk (0x40000000UL) /*!< DOUBLE_BUFFERED (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_IN_CONTROL_INTERRUPT_PER_BUFF_Pos (29UL)  /*!< INTERRUPT_PER_BUFF (Bit 29) */
#define USBCTRL_DPRAM_EP1_IN_CONTROL_INTERRUPT_PER_BUFF_Msk (0x20000000UL) /*!< INTERRUPT_PER_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Pos (28UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bit 28) */
#define USBCTRL_DPRAM_EP1_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Msk (0x10000000UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_IN_CONTROL_ENDPOINT_TYPE_Pos (26UL)       /*!< ENDPOINT_TYPE (Bit 26) */
#define USBCTRL_DPRAM_EP1_IN_CONTROL_ENDPOINT_TYPE_Msk (0xc000000UL) /*!< ENDPOINT_TYPE (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP1_IN_CONTROL_INTERRUPT_ON_STALL_Pos (17UL)  /*!< INTERRUPT_ON_STALL (Bit 17) */
#define USBCTRL_DPRAM_EP1_IN_CONTROL_INTERRUPT_ON_STALL_Msk (0x20000UL) /*!< INTERRUPT_ON_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_IN_CONTROL_INTERRUPT_ON_NAK_Pos (16UL)    /*!< INTERRUPT_ON_NAK (Bit 16) */
#define USBCTRL_DPRAM_EP1_IN_CONTROL_INTERRUPT_ON_NAK_Msk (0x10000UL) /*!< INTERRUPT_ON_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_IN_CONTROL_BUFFER_ADDRESS_Pos (0UL)       /*!< BUFFER_ADDRESS (Bit 0) */
#define USBCTRL_DPRAM_EP1_IN_CONTROL_BUFFER_ADDRESS_Msk (0xffffUL)  /*!< BUFFER_ADDRESS (Bitfield-Mask: 0xffff) */
/* ====================================================  EP1_OUT_CONTROL  ==================================================== */
#define USBCTRL_DPRAM_EP1_OUT_CONTROL_ENABLE_Pos (31UL)             /*!< ENABLE (Bit 31) */
#define USBCTRL_DPRAM_EP1_OUT_CONTROL_ENABLE_Msk (0x80000000UL)     /*!< ENABLE (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_OUT_CONTROL_DOUBLE_BUFFERED_Pos (30UL)    /*!< DOUBLE_BUFFERED (Bit 30) */
#define USBCTRL_DPRAM_EP1_OUT_CONTROL_DOUBLE_BUFFERED_Msk (0x40000000UL) /*!< DOUBLE_BUFFERED (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_OUT_CONTROL_INTERRUPT_PER_BUFF_Pos (29UL) /*!< INTERRUPT_PER_BUFF (Bit 29) */
#define USBCTRL_DPRAM_EP1_OUT_CONTROL_INTERRUPT_PER_BUFF_Msk (0x20000000UL) /*!< INTERRUPT_PER_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Pos (28UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bit 28) */
#define USBCTRL_DPRAM_EP1_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Msk (0x10000000UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_OUT_CONTROL_ENDPOINT_TYPE_Pos (26UL)      /*!< ENDPOINT_TYPE (Bit 26) */
#define USBCTRL_DPRAM_EP1_OUT_CONTROL_ENDPOINT_TYPE_Msk (0xc000000UL) /*!< ENDPOINT_TYPE (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP1_OUT_CONTROL_INTERRUPT_ON_STALL_Pos (17UL) /*!< INTERRUPT_ON_STALL (Bit 17) */
#define USBCTRL_DPRAM_EP1_OUT_CONTROL_INTERRUPT_ON_STALL_Msk (0x20000UL) /*!< INTERRUPT_ON_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_OUT_CONTROL_INTERRUPT_ON_NAK_Pos (16UL)   /*!< INTERRUPT_ON_NAK (Bit 16) */
#define USBCTRL_DPRAM_EP1_OUT_CONTROL_INTERRUPT_ON_NAK_Msk (0x10000UL) /*!< INTERRUPT_ON_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_OUT_CONTROL_BUFFER_ADDRESS_Pos (0UL)      /*!< BUFFER_ADDRESS (Bit 0) */
#define USBCTRL_DPRAM_EP1_OUT_CONTROL_BUFFER_ADDRESS_Msk (0xffffUL) /*!< BUFFER_ADDRESS (Bitfield-Mask: 0xffff) */
/* ====================================================  EP2_IN_CONTROL  ===================================================== */
#define USBCTRL_DPRAM_EP2_IN_CONTROL_ENABLE_Pos (31UL)              /*!< ENABLE (Bit 31) */
#define USBCTRL_DPRAM_EP2_IN_CONTROL_ENABLE_Msk (0x80000000UL)      /*!< ENABLE (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_IN_CONTROL_DOUBLE_BUFFERED_Pos (30UL)     /*!< DOUBLE_BUFFERED (Bit 30) */
#define USBCTRL_DPRAM_EP2_IN_CONTROL_DOUBLE_BUFFERED_Msk (0x40000000UL) /*!< DOUBLE_BUFFERED (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_IN_CONTROL_INTERRUPT_PER_BUFF_Pos (29UL)  /*!< INTERRUPT_PER_BUFF (Bit 29) */
#define USBCTRL_DPRAM_EP2_IN_CONTROL_INTERRUPT_PER_BUFF_Msk (0x20000000UL) /*!< INTERRUPT_PER_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Pos (28UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bit 28) */
#define USBCTRL_DPRAM_EP2_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Msk (0x10000000UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_IN_CONTROL_ENDPOINT_TYPE_Pos (26UL)       /*!< ENDPOINT_TYPE (Bit 26) */
#define USBCTRL_DPRAM_EP2_IN_CONTROL_ENDPOINT_TYPE_Msk (0xc000000UL) /*!< ENDPOINT_TYPE (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP2_IN_CONTROL_INTERRUPT_ON_STALL_Pos (17UL)  /*!< INTERRUPT_ON_STALL (Bit 17) */
#define USBCTRL_DPRAM_EP2_IN_CONTROL_INTERRUPT_ON_STALL_Msk (0x20000UL) /*!< INTERRUPT_ON_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_IN_CONTROL_INTERRUPT_ON_NAK_Pos (16UL)    /*!< INTERRUPT_ON_NAK (Bit 16) */
#define USBCTRL_DPRAM_EP2_IN_CONTROL_INTERRUPT_ON_NAK_Msk (0x10000UL) /*!< INTERRUPT_ON_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_IN_CONTROL_BUFFER_ADDRESS_Pos (0UL)       /*!< BUFFER_ADDRESS (Bit 0) */
#define USBCTRL_DPRAM_EP2_IN_CONTROL_BUFFER_ADDRESS_Msk (0xffffUL)  /*!< BUFFER_ADDRESS (Bitfield-Mask: 0xffff) */
/* ====================================================  EP2_OUT_CONTROL  ==================================================== */
#define USBCTRL_DPRAM_EP2_OUT_CONTROL_ENABLE_Pos (31UL)             /*!< ENABLE (Bit 31) */
#define USBCTRL_DPRAM_EP2_OUT_CONTROL_ENABLE_Msk (0x80000000UL)     /*!< ENABLE (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_OUT_CONTROL_DOUBLE_BUFFERED_Pos (30UL)    /*!< DOUBLE_BUFFERED (Bit 30) */
#define USBCTRL_DPRAM_EP2_OUT_CONTROL_DOUBLE_BUFFERED_Msk (0x40000000UL) /*!< DOUBLE_BUFFERED (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_OUT_CONTROL_INTERRUPT_PER_BUFF_Pos (29UL) /*!< INTERRUPT_PER_BUFF (Bit 29) */
#define USBCTRL_DPRAM_EP2_OUT_CONTROL_INTERRUPT_PER_BUFF_Msk (0x20000000UL) /*!< INTERRUPT_PER_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Pos (28UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bit 28) */
#define USBCTRL_DPRAM_EP2_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Msk (0x10000000UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_OUT_CONTROL_ENDPOINT_TYPE_Pos (26UL)      /*!< ENDPOINT_TYPE (Bit 26) */
#define USBCTRL_DPRAM_EP2_OUT_CONTROL_ENDPOINT_TYPE_Msk (0xc000000UL) /*!< ENDPOINT_TYPE (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP2_OUT_CONTROL_INTERRUPT_ON_STALL_Pos (17UL) /*!< INTERRUPT_ON_STALL (Bit 17) */
#define USBCTRL_DPRAM_EP2_OUT_CONTROL_INTERRUPT_ON_STALL_Msk (0x20000UL) /*!< INTERRUPT_ON_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_OUT_CONTROL_INTERRUPT_ON_NAK_Pos (16UL)   /*!< INTERRUPT_ON_NAK (Bit 16) */
#define USBCTRL_DPRAM_EP2_OUT_CONTROL_INTERRUPT_ON_NAK_Msk (0x10000UL) /*!< INTERRUPT_ON_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_OUT_CONTROL_BUFFER_ADDRESS_Pos (0UL)      /*!< BUFFER_ADDRESS (Bit 0) */
#define USBCTRL_DPRAM_EP2_OUT_CONTROL_BUFFER_ADDRESS_Msk (0xffffUL) /*!< BUFFER_ADDRESS (Bitfield-Mask: 0xffff) */
/* ====================================================  EP3_IN_CONTROL  ===================================================== */
#define USBCTRL_DPRAM_EP3_IN_CONTROL_ENABLE_Pos (31UL)              /*!< ENABLE (Bit 31) */
#define USBCTRL_DPRAM_EP3_IN_CONTROL_ENABLE_Msk (0x80000000UL)      /*!< ENABLE (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_IN_CONTROL_DOUBLE_BUFFERED_Pos (30UL)     /*!< DOUBLE_BUFFERED (Bit 30) */
#define USBCTRL_DPRAM_EP3_IN_CONTROL_DOUBLE_BUFFERED_Msk (0x40000000UL) /*!< DOUBLE_BUFFERED (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_IN_CONTROL_INTERRUPT_PER_BUFF_Pos (29UL)  /*!< INTERRUPT_PER_BUFF (Bit 29) */
#define USBCTRL_DPRAM_EP3_IN_CONTROL_INTERRUPT_PER_BUFF_Msk (0x20000000UL) /*!< INTERRUPT_PER_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Pos (28UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bit 28) */
#define USBCTRL_DPRAM_EP3_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Msk (0x10000000UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_IN_CONTROL_ENDPOINT_TYPE_Pos (26UL)       /*!< ENDPOINT_TYPE (Bit 26) */
#define USBCTRL_DPRAM_EP3_IN_CONTROL_ENDPOINT_TYPE_Msk (0xc000000UL) /*!< ENDPOINT_TYPE (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP3_IN_CONTROL_INTERRUPT_ON_STALL_Pos (17UL)  /*!< INTERRUPT_ON_STALL (Bit 17) */
#define USBCTRL_DPRAM_EP3_IN_CONTROL_INTERRUPT_ON_STALL_Msk (0x20000UL) /*!< INTERRUPT_ON_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_IN_CONTROL_INTERRUPT_ON_NAK_Pos (16UL)    /*!< INTERRUPT_ON_NAK (Bit 16) */
#define USBCTRL_DPRAM_EP3_IN_CONTROL_INTERRUPT_ON_NAK_Msk (0x10000UL) /*!< INTERRUPT_ON_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_IN_CONTROL_BUFFER_ADDRESS_Pos (0UL)       /*!< BUFFER_ADDRESS (Bit 0) */
#define USBCTRL_DPRAM_EP3_IN_CONTROL_BUFFER_ADDRESS_Msk (0xffffUL)  /*!< BUFFER_ADDRESS (Bitfield-Mask: 0xffff) */
/* ====================================================  EP3_OUT_CONTROL  ==================================================== */
#define USBCTRL_DPRAM_EP3_OUT_CONTROL_ENABLE_Pos (31UL)             /*!< ENABLE (Bit 31) */
#define USBCTRL_DPRAM_EP3_OUT_CONTROL_ENABLE_Msk (0x80000000UL)     /*!< ENABLE (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_OUT_CONTROL_DOUBLE_BUFFERED_Pos (30UL)    /*!< DOUBLE_BUFFERED (Bit 30) */
#define USBCTRL_DPRAM_EP3_OUT_CONTROL_DOUBLE_BUFFERED_Msk (0x40000000UL) /*!< DOUBLE_BUFFERED (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_OUT_CONTROL_INTERRUPT_PER_BUFF_Pos (29UL) /*!< INTERRUPT_PER_BUFF (Bit 29) */
#define USBCTRL_DPRAM_EP3_OUT_CONTROL_INTERRUPT_PER_BUFF_Msk (0x20000000UL) /*!< INTERRUPT_PER_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Pos (28UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bit 28) */
#define USBCTRL_DPRAM_EP3_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Msk (0x10000000UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_OUT_CONTROL_ENDPOINT_TYPE_Pos (26UL)      /*!< ENDPOINT_TYPE (Bit 26) */
#define USBCTRL_DPRAM_EP3_OUT_CONTROL_ENDPOINT_TYPE_Msk (0xc000000UL) /*!< ENDPOINT_TYPE (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP3_OUT_CONTROL_INTERRUPT_ON_STALL_Pos (17UL) /*!< INTERRUPT_ON_STALL (Bit 17) */
#define USBCTRL_DPRAM_EP3_OUT_CONTROL_INTERRUPT_ON_STALL_Msk (0x20000UL) /*!< INTERRUPT_ON_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_OUT_CONTROL_INTERRUPT_ON_NAK_Pos (16UL)   /*!< INTERRUPT_ON_NAK (Bit 16) */
#define USBCTRL_DPRAM_EP3_OUT_CONTROL_INTERRUPT_ON_NAK_Msk (0x10000UL) /*!< INTERRUPT_ON_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_OUT_CONTROL_BUFFER_ADDRESS_Pos (0UL)      /*!< BUFFER_ADDRESS (Bit 0) */
#define USBCTRL_DPRAM_EP3_OUT_CONTROL_BUFFER_ADDRESS_Msk (0xffffUL) /*!< BUFFER_ADDRESS (Bitfield-Mask: 0xffff) */
/* ====================================================  EP4_IN_CONTROL  ===================================================== */
#define USBCTRL_DPRAM_EP4_IN_CONTROL_ENABLE_Pos (31UL)              /*!< ENABLE (Bit 31) */
#define USBCTRL_DPRAM_EP4_IN_CONTROL_ENABLE_Msk (0x80000000UL)      /*!< ENABLE (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_IN_CONTROL_DOUBLE_BUFFERED_Pos (30UL)     /*!< DOUBLE_BUFFERED (Bit 30) */
#define USBCTRL_DPRAM_EP4_IN_CONTROL_DOUBLE_BUFFERED_Msk (0x40000000UL) /*!< DOUBLE_BUFFERED (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_IN_CONTROL_INTERRUPT_PER_BUFF_Pos (29UL)  /*!< INTERRUPT_PER_BUFF (Bit 29) */
#define USBCTRL_DPRAM_EP4_IN_CONTROL_INTERRUPT_PER_BUFF_Msk (0x20000000UL) /*!< INTERRUPT_PER_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Pos (28UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bit 28) */
#define USBCTRL_DPRAM_EP4_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Msk (0x10000000UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_IN_CONTROL_ENDPOINT_TYPE_Pos (26UL)       /*!< ENDPOINT_TYPE (Bit 26) */
#define USBCTRL_DPRAM_EP4_IN_CONTROL_ENDPOINT_TYPE_Msk (0xc000000UL) /*!< ENDPOINT_TYPE (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP4_IN_CONTROL_INTERRUPT_ON_STALL_Pos (17UL)  /*!< INTERRUPT_ON_STALL (Bit 17) */
#define USBCTRL_DPRAM_EP4_IN_CONTROL_INTERRUPT_ON_STALL_Msk (0x20000UL) /*!< INTERRUPT_ON_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_IN_CONTROL_INTERRUPT_ON_NAK_Pos (16UL)    /*!< INTERRUPT_ON_NAK (Bit 16) */
#define USBCTRL_DPRAM_EP4_IN_CONTROL_INTERRUPT_ON_NAK_Msk (0x10000UL) /*!< INTERRUPT_ON_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_IN_CONTROL_BUFFER_ADDRESS_Pos (0UL)       /*!< BUFFER_ADDRESS (Bit 0) */
#define USBCTRL_DPRAM_EP4_IN_CONTROL_BUFFER_ADDRESS_Msk (0xffffUL)  /*!< BUFFER_ADDRESS (Bitfield-Mask: 0xffff) */
/* ====================================================  EP4_OUT_CONTROL  ==================================================== */
#define USBCTRL_DPRAM_EP4_OUT_CONTROL_ENABLE_Pos (31UL)             /*!< ENABLE (Bit 31) */
#define USBCTRL_DPRAM_EP4_OUT_CONTROL_ENABLE_Msk (0x80000000UL)     /*!< ENABLE (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_OUT_CONTROL_DOUBLE_BUFFERED_Pos (30UL)    /*!< DOUBLE_BUFFERED (Bit 30) */
#define USBCTRL_DPRAM_EP4_OUT_CONTROL_DOUBLE_BUFFERED_Msk (0x40000000UL) /*!< DOUBLE_BUFFERED (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_OUT_CONTROL_INTERRUPT_PER_BUFF_Pos (29UL) /*!< INTERRUPT_PER_BUFF (Bit 29) */
#define USBCTRL_DPRAM_EP4_OUT_CONTROL_INTERRUPT_PER_BUFF_Msk (0x20000000UL) /*!< INTERRUPT_PER_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Pos (28UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bit 28) */
#define USBCTRL_DPRAM_EP4_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Msk (0x10000000UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_OUT_CONTROL_ENDPOINT_TYPE_Pos (26UL)      /*!< ENDPOINT_TYPE (Bit 26) */
#define USBCTRL_DPRAM_EP4_OUT_CONTROL_ENDPOINT_TYPE_Msk (0xc000000UL) /*!< ENDPOINT_TYPE (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP4_OUT_CONTROL_INTERRUPT_ON_STALL_Pos (17UL) /*!< INTERRUPT_ON_STALL (Bit 17) */
#define USBCTRL_DPRAM_EP4_OUT_CONTROL_INTERRUPT_ON_STALL_Msk (0x20000UL) /*!< INTERRUPT_ON_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_OUT_CONTROL_INTERRUPT_ON_NAK_Pos (16UL)   /*!< INTERRUPT_ON_NAK (Bit 16) */
#define USBCTRL_DPRAM_EP4_OUT_CONTROL_INTERRUPT_ON_NAK_Msk (0x10000UL) /*!< INTERRUPT_ON_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_OUT_CONTROL_BUFFER_ADDRESS_Pos (0UL)      /*!< BUFFER_ADDRESS (Bit 0) */
#define USBCTRL_DPRAM_EP4_OUT_CONTROL_BUFFER_ADDRESS_Msk (0xffffUL) /*!< BUFFER_ADDRESS (Bitfield-Mask: 0xffff) */
/* ====================================================  EP5_IN_CONTROL  ===================================================== */
#define USBCTRL_DPRAM_EP5_IN_CONTROL_ENABLE_Pos (31UL)              /*!< ENABLE (Bit 31) */
#define USBCTRL_DPRAM_EP5_IN_CONTROL_ENABLE_Msk (0x80000000UL)      /*!< ENABLE (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_IN_CONTROL_DOUBLE_BUFFERED_Pos (30UL)     /*!< DOUBLE_BUFFERED (Bit 30) */
#define USBCTRL_DPRAM_EP5_IN_CONTROL_DOUBLE_BUFFERED_Msk (0x40000000UL) /*!< DOUBLE_BUFFERED (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_IN_CONTROL_INTERRUPT_PER_BUFF_Pos (29UL)  /*!< INTERRUPT_PER_BUFF (Bit 29) */
#define USBCTRL_DPRAM_EP5_IN_CONTROL_INTERRUPT_PER_BUFF_Msk (0x20000000UL) /*!< INTERRUPT_PER_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Pos (28UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bit 28) */
#define USBCTRL_DPRAM_EP5_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Msk (0x10000000UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_IN_CONTROL_ENDPOINT_TYPE_Pos (26UL)       /*!< ENDPOINT_TYPE (Bit 26) */
#define USBCTRL_DPRAM_EP5_IN_CONTROL_ENDPOINT_TYPE_Msk (0xc000000UL) /*!< ENDPOINT_TYPE (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP5_IN_CONTROL_INTERRUPT_ON_STALL_Pos (17UL)  /*!< INTERRUPT_ON_STALL (Bit 17) */
#define USBCTRL_DPRAM_EP5_IN_CONTROL_INTERRUPT_ON_STALL_Msk (0x20000UL) /*!< INTERRUPT_ON_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_IN_CONTROL_INTERRUPT_ON_NAK_Pos (16UL)    /*!< INTERRUPT_ON_NAK (Bit 16) */
#define USBCTRL_DPRAM_EP5_IN_CONTROL_INTERRUPT_ON_NAK_Msk (0x10000UL) /*!< INTERRUPT_ON_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_IN_CONTROL_BUFFER_ADDRESS_Pos (0UL)       /*!< BUFFER_ADDRESS (Bit 0) */
#define USBCTRL_DPRAM_EP5_IN_CONTROL_BUFFER_ADDRESS_Msk (0xffffUL)  /*!< BUFFER_ADDRESS (Bitfield-Mask: 0xffff) */
/* ====================================================  EP5_OUT_CONTROL  ==================================================== */
#define USBCTRL_DPRAM_EP5_OUT_CONTROL_ENABLE_Pos (31UL)             /*!< ENABLE (Bit 31) */
#define USBCTRL_DPRAM_EP5_OUT_CONTROL_ENABLE_Msk (0x80000000UL)     /*!< ENABLE (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_OUT_CONTROL_DOUBLE_BUFFERED_Pos (30UL)    /*!< DOUBLE_BUFFERED (Bit 30) */
#define USBCTRL_DPRAM_EP5_OUT_CONTROL_DOUBLE_BUFFERED_Msk (0x40000000UL) /*!< DOUBLE_BUFFERED (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_OUT_CONTROL_INTERRUPT_PER_BUFF_Pos (29UL) /*!< INTERRUPT_PER_BUFF (Bit 29) */
#define USBCTRL_DPRAM_EP5_OUT_CONTROL_INTERRUPT_PER_BUFF_Msk (0x20000000UL) /*!< INTERRUPT_PER_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Pos (28UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bit 28) */
#define USBCTRL_DPRAM_EP5_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Msk (0x10000000UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_OUT_CONTROL_ENDPOINT_TYPE_Pos (26UL)      /*!< ENDPOINT_TYPE (Bit 26) */
#define USBCTRL_DPRAM_EP5_OUT_CONTROL_ENDPOINT_TYPE_Msk (0xc000000UL) /*!< ENDPOINT_TYPE (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP5_OUT_CONTROL_INTERRUPT_ON_STALL_Pos (17UL) /*!< INTERRUPT_ON_STALL (Bit 17) */
#define USBCTRL_DPRAM_EP5_OUT_CONTROL_INTERRUPT_ON_STALL_Msk (0x20000UL) /*!< INTERRUPT_ON_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_OUT_CONTROL_INTERRUPT_ON_NAK_Pos (16UL)   /*!< INTERRUPT_ON_NAK (Bit 16) */
#define USBCTRL_DPRAM_EP5_OUT_CONTROL_INTERRUPT_ON_NAK_Msk (0x10000UL) /*!< INTERRUPT_ON_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_OUT_CONTROL_BUFFER_ADDRESS_Pos (0UL)      /*!< BUFFER_ADDRESS (Bit 0) */
#define USBCTRL_DPRAM_EP5_OUT_CONTROL_BUFFER_ADDRESS_Msk (0xffffUL) /*!< BUFFER_ADDRESS (Bitfield-Mask: 0xffff) */
/* ====================================================  EP6_IN_CONTROL  ===================================================== */
#define USBCTRL_DPRAM_EP6_IN_CONTROL_ENABLE_Pos (31UL)              /*!< ENABLE (Bit 31) */
#define USBCTRL_DPRAM_EP6_IN_CONTROL_ENABLE_Msk (0x80000000UL)      /*!< ENABLE (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_IN_CONTROL_DOUBLE_BUFFERED_Pos (30UL)     /*!< DOUBLE_BUFFERED (Bit 30) */
#define USBCTRL_DPRAM_EP6_IN_CONTROL_DOUBLE_BUFFERED_Msk (0x40000000UL) /*!< DOUBLE_BUFFERED (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_IN_CONTROL_INTERRUPT_PER_BUFF_Pos (29UL)  /*!< INTERRUPT_PER_BUFF (Bit 29) */
#define USBCTRL_DPRAM_EP6_IN_CONTROL_INTERRUPT_PER_BUFF_Msk (0x20000000UL) /*!< INTERRUPT_PER_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Pos (28UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bit 28) */
#define USBCTRL_DPRAM_EP6_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Msk (0x10000000UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_IN_CONTROL_ENDPOINT_TYPE_Pos (26UL)       /*!< ENDPOINT_TYPE (Bit 26) */
#define USBCTRL_DPRAM_EP6_IN_CONTROL_ENDPOINT_TYPE_Msk (0xc000000UL) /*!< ENDPOINT_TYPE (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP6_IN_CONTROL_INTERRUPT_ON_STALL_Pos (17UL)  /*!< INTERRUPT_ON_STALL (Bit 17) */
#define USBCTRL_DPRAM_EP6_IN_CONTROL_INTERRUPT_ON_STALL_Msk (0x20000UL) /*!< INTERRUPT_ON_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_IN_CONTROL_INTERRUPT_ON_NAK_Pos (16UL)    /*!< INTERRUPT_ON_NAK (Bit 16) */
#define USBCTRL_DPRAM_EP6_IN_CONTROL_INTERRUPT_ON_NAK_Msk (0x10000UL) /*!< INTERRUPT_ON_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_IN_CONTROL_BUFFER_ADDRESS_Pos (0UL)       /*!< BUFFER_ADDRESS (Bit 0) */
#define USBCTRL_DPRAM_EP6_IN_CONTROL_BUFFER_ADDRESS_Msk (0xffffUL)  /*!< BUFFER_ADDRESS (Bitfield-Mask: 0xffff) */
/* ====================================================  EP6_OUT_CONTROL  ==================================================== */
#define USBCTRL_DPRAM_EP6_OUT_CONTROL_ENABLE_Pos (31UL)             /*!< ENABLE (Bit 31) */
#define USBCTRL_DPRAM_EP6_OUT_CONTROL_ENABLE_Msk (0x80000000UL)     /*!< ENABLE (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_OUT_CONTROL_DOUBLE_BUFFERED_Pos (30UL)    /*!< DOUBLE_BUFFERED (Bit 30) */
#define USBCTRL_DPRAM_EP6_OUT_CONTROL_DOUBLE_BUFFERED_Msk (0x40000000UL) /*!< DOUBLE_BUFFERED (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_OUT_CONTROL_INTERRUPT_PER_BUFF_Pos (29UL) /*!< INTERRUPT_PER_BUFF (Bit 29) */
#define USBCTRL_DPRAM_EP6_OUT_CONTROL_INTERRUPT_PER_BUFF_Msk (0x20000000UL) /*!< INTERRUPT_PER_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Pos (28UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bit 28) */
#define USBCTRL_DPRAM_EP6_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Msk (0x10000000UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_OUT_CONTROL_ENDPOINT_TYPE_Pos (26UL)      /*!< ENDPOINT_TYPE (Bit 26) */
#define USBCTRL_DPRAM_EP6_OUT_CONTROL_ENDPOINT_TYPE_Msk (0xc000000UL) /*!< ENDPOINT_TYPE (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP6_OUT_CONTROL_INTERRUPT_ON_STALL_Pos (17UL) /*!< INTERRUPT_ON_STALL (Bit 17) */
#define USBCTRL_DPRAM_EP6_OUT_CONTROL_INTERRUPT_ON_STALL_Msk (0x20000UL) /*!< INTERRUPT_ON_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_OUT_CONTROL_INTERRUPT_ON_NAK_Pos (16UL)   /*!< INTERRUPT_ON_NAK (Bit 16) */
#define USBCTRL_DPRAM_EP6_OUT_CONTROL_INTERRUPT_ON_NAK_Msk (0x10000UL) /*!< INTERRUPT_ON_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_OUT_CONTROL_BUFFER_ADDRESS_Pos (0UL)      /*!< BUFFER_ADDRESS (Bit 0) */
#define USBCTRL_DPRAM_EP6_OUT_CONTROL_BUFFER_ADDRESS_Msk (0xffffUL) /*!< BUFFER_ADDRESS (Bitfield-Mask: 0xffff) */
/* ====================================================  EP7_IN_CONTROL  ===================================================== */
#define USBCTRL_DPRAM_EP7_IN_CONTROL_ENABLE_Pos (31UL)              /*!< ENABLE (Bit 31) */
#define USBCTRL_DPRAM_EP7_IN_CONTROL_ENABLE_Msk (0x80000000UL)      /*!< ENABLE (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_IN_CONTROL_DOUBLE_BUFFERED_Pos (30UL)     /*!< DOUBLE_BUFFERED (Bit 30) */
#define USBCTRL_DPRAM_EP7_IN_CONTROL_DOUBLE_BUFFERED_Msk (0x40000000UL) /*!< DOUBLE_BUFFERED (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_IN_CONTROL_INTERRUPT_PER_BUFF_Pos (29UL)  /*!< INTERRUPT_PER_BUFF (Bit 29) */
#define USBCTRL_DPRAM_EP7_IN_CONTROL_INTERRUPT_PER_BUFF_Msk (0x20000000UL) /*!< INTERRUPT_PER_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Pos (28UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bit 28) */
#define USBCTRL_DPRAM_EP7_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Msk (0x10000000UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_IN_CONTROL_ENDPOINT_TYPE_Pos (26UL)       /*!< ENDPOINT_TYPE (Bit 26) */
#define USBCTRL_DPRAM_EP7_IN_CONTROL_ENDPOINT_TYPE_Msk (0xc000000UL) /*!< ENDPOINT_TYPE (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP7_IN_CONTROL_INTERRUPT_ON_STALL_Pos (17UL)  /*!< INTERRUPT_ON_STALL (Bit 17) */
#define USBCTRL_DPRAM_EP7_IN_CONTROL_INTERRUPT_ON_STALL_Msk (0x20000UL) /*!< INTERRUPT_ON_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_IN_CONTROL_INTERRUPT_ON_NAK_Pos (16UL)    /*!< INTERRUPT_ON_NAK (Bit 16) */
#define USBCTRL_DPRAM_EP7_IN_CONTROL_INTERRUPT_ON_NAK_Msk (0x10000UL) /*!< INTERRUPT_ON_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_IN_CONTROL_BUFFER_ADDRESS_Pos (0UL)       /*!< BUFFER_ADDRESS (Bit 0) */
#define USBCTRL_DPRAM_EP7_IN_CONTROL_BUFFER_ADDRESS_Msk (0xffffUL)  /*!< BUFFER_ADDRESS (Bitfield-Mask: 0xffff) */
/* ====================================================  EP7_OUT_CONTROL  ==================================================== */
#define USBCTRL_DPRAM_EP7_OUT_CONTROL_ENABLE_Pos (31UL)             /*!< ENABLE (Bit 31) */
#define USBCTRL_DPRAM_EP7_OUT_CONTROL_ENABLE_Msk (0x80000000UL)     /*!< ENABLE (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_OUT_CONTROL_DOUBLE_BUFFERED_Pos (30UL)    /*!< DOUBLE_BUFFERED (Bit 30) */
#define USBCTRL_DPRAM_EP7_OUT_CONTROL_DOUBLE_BUFFERED_Msk (0x40000000UL) /*!< DOUBLE_BUFFERED (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_OUT_CONTROL_INTERRUPT_PER_BUFF_Pos (29UL) /*!< INTERRUPT_PER_BUFF (Bit 29) */
#define USBCTRL_DPRAM_EP7_OUT_CONTROL_INTERRUPT_PER_BUFF_Msk (0x20000000UL) /*!< INTERRUPT_PER_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Pos (28UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bit 28) */
#define USBCTRL_DPRAM_EP7_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Msk (0x10000000UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_OUT_CONTROL_ENDPOINT_TYPE_Pos (26UL)      /*!< ENDPOINT_TYPE (Bit 26) */
#define USBCTRL_DPRAM_EP7_OUT_CONTROL_ENDPOINT_TYPE_Msk (0xc000000UL) /*!< ENDPOINT_TYPE (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP7_OUT_CONTROL_INTERRUPT_ON_STALL_Pos (17UL) /*!< INTERRUPT_ON_STALL (Bit 17) */
#define USBCTRL_DPRAM_EP7_OUT_CONTROL_INTERRUPT_ON_STALL_Msk (0x20000UL) /*!< INTERRUPT_ON_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_OUT_CONTROL_INTERRUPT_ON_NAK_Pos (16UL)   /*!< INTERRUPT_ON_NAK (Bit 16) */
#define USBCTRL_DPRAM_EP7_OUT_CONTROL_INTERRUPT_ON_NAK_Msk (0x10000UL) /*!< INTERRUPT_ON_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_OUT_CONTROL_BUFFER_ADDRESS_Pos (0UL)      /*!< BUFFER_ADDRESS (Bit 0) */
#define USBCTRL_DPRAM_EP7_OUT_CONTROL_BUFFER_ADDRESS_Msk (0xffffUL) /*!< BUFFER_ADDRESS (Bitfield-Mask: 0xffff) */
/* ====================================================  EP8_IN_CONTROL  ===================================================== */
#define USBCTRL_DPRAM_EP8_IN_CONTROL_ENABLE_Pos (31UL)              /*!< ENABLE (Bit 31) */
#define USBCTRL_DPRAM_EP8_IN_CONTROL_ENABLE_Msk (0x80000000UL)      /*!< ENABLE (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_IN_CONTROL_DOUBLE_BUFFERED_Pos (30UL)     /*!< DOUBLE_BUFFERED (Bit 30) */
#define USBCTRL_DPRAM_EP8_IN_CONTROL_DOUBLE_BUFFERED_Msk (0x40000000UL) /*!< DOUBLE_BUFFERED (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_IN_CONTROL_INTERRUPT_PER_BUFF_Pos (29UL)  /*!< INTERRUPT_PER_BUFF (Bit 29) */
#define USBCTRL_DPRAM_EP8_IN_CONTROL_INTERRUPT_PER_BUFF_Msk (0x20000000UL) /*!< INTERRUPT_PER_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Pos (28UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bit 28) */
#define USBCTRL_DPRAM_EP8_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Msk (0x10000000UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_IN_CONTROL_ENDPOINT_TYPE_Pos (26UL)       /*!< ENDPOINT_TYPE (Bit 26) */
#define USBCTRL_DPRAM_EP8_IN_CONTROL_ENDPOINT_TYPE_Msk (0xc000000UL) /*!< ENDPOINT_TYPE (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP8_IN_CONTROL_INTERRUPT_ON_STALL_Pos (17UL)  /*!< INTERRUPT_ON_STALL (Bit 17) */
#define USBCTRL_DPRAM_EP8_IN_CONTROL_INTERRUPT_ON_STALL_Msk (0x20000UL) /*!< INTERRUPT_ON_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_IN_CONTROL_INTERRUPT_ON_NAK_Pos (16UL)    /*!< INTERRUPT_ON_NAK (Bit 16) */
#define USBCTRL_DPRAM_EP8_IN_CONTROL_INTERRUPT_ON_NAK_Msk (0x10000UL) /*!< INTERRUPT_ON_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_IN_CONTROL_BUFFER_ADDRESS_Pos (0UL)       /*!< BUFFER_ADDRESS (Bit 0) */
#define USBCTRL_DPRAM_EP8_IN_CONTROL_BUFFER_ADDRESS_Msk (0xffffUL)  /*!< BUFFER_ADDRESS (Bitfield-Mask: 0xffff) */
/* ====================================================  EP8_OUT_CONTROL  ==================================================== */
#define USBCTRL_DPRAM_EP8_OUT_CONTROL_ENABLE_Pos (31UL)             /*!< ENABLE (Bit 31) */
#define USBCTRL_DPRAM_EP8_OUT_CONTROL_ENABLE_Msk (0x80000000UL)     /*!< ENABLE (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_OUT_CONTROL_DOUBLE_BUFFERED_Pos (30UL)    /*!< DOUBLE_BUFFERED (Bit 30) */
#define USBCTRL_DPRAM_EP8_OUT_CONTROL_DOUBLE_BUFFERED_Msk (0x40000000UL) /*!< DOUBLE_BUFFERED (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_OUT_CONTROL_INTERRUPT_PER_BUFF_Pos (29UL) /*!< INTERRUPT_PER_BUFF (Bit 29) */
#define USBCTRL_DPRAM_EP8_OUT_CONTROL_INTERRUPT_PER_BUFF_Msk (0x20000000UL) /*!< INTERRUPT_PER_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Pos (28UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bit 28) */
#define USBCTRL_DPRAM_EP8_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Msk (0x10000000UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_OUT_CONTROL_ENDPOINT_TYPE_Pos (26UL)      /*!< ENDPOINT_TYPE (Bit 26) */
#define USBCTRL_DPRAM_EP8_OUT_CONTROL_ENDPOINT_TYPE_Msk (0xc000000UL) /*!< ENDPOINT_TYPE (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP8_OUT_CONTROL_INTERRUPT_ON_STALL_Pos (17UL) /*!< INTERRUPT_ON_STALL (Bit 17) */
#define USBCTRL_DPRAM_EP8_OUT_CONTROL_INTERRUPT_ON_STALL_Msk (0x20000UL) /*!< INTERRUPT_ON_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_OUT_CONTROL_INTERRUPT_ON_NAK_Pos (16UL)   /*!< INTERRUPT_ON_NAK (Bit 16) */
#define USBCTRL_DPRAM_EP8_OUT_CONTROL_INTERRUPT_ON_NAK_Msk (0x10000UL) /*!< INTERRUPT_ON_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_OUT_CONTROL_BUFFER_ADDRESS_Pos (0UL)      /*!< BUFFER_ADDRESS (Bit 0) */
#define USBCTRL_DPRAM_EP8_OUT_CONTROL_BUFFER_ADDRESS_Msk (0xffffUL) /*!< BUFFER_ADDRESS (Bitfield-Mask: 0xffff) */
/* ====================================================  EP9_IN_CONTROL  ===================================================== */
#define USBCTRL_DPRAM_EP9_IN_CONTROL_ENABLE_Pos (31UL)              /*!< ENABLE (Bit 31) */
#define USBCTRL_DPRAM_EP9_IN_CONTROL_ENABLE_Msk (0x80000000UL)      /*!< ENABLE (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_IN_CONTROL_DOUBLE_BUFFERED_Pos (30UL)     /*!< DOUBLE_BUFFERED (Bit 30) */
#define USBCTRL_DPRAM_EP9_IN_CONTROL_DOUBLE_BUFFERED_Msk (0x40000000UL) /*!< DOUBLE_BUFFERED (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_IN_CONTROL_INTERRUPT_PER_BUFF_Pos (29UL)  /*!< INTERRUPT_PER_BUFF (Bit 29) */
#define USBCTRL_DPRAM_EP9_IN_CONTROL_INTERRUPT_PER_BUFF_Msk (0x20000000UL) /*!< INTERRUPT_PER_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Pos (28UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bit 28) */
#define USBCTRL_DPRAM_EP9_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Msk (0x10000000UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_IN_CONTROL_ENDPOINT_TYPE_Pos (26UL)       /*!< ENDPOINT_TYPE (Bit 26) */
#define USBCTRL_DPRAM_EP9_IN_CONTROL_ENDPOINT_TYPE_Msk (0xc000000UL) /*!< ENDPOINT_TYPE (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP9_IN_CONTROL_INTERRUPT_ON_STALL_Pos (17UL)  /*!< INTERRUPT_ON_STALL (Bit 17) */
#define USBCTRL_DPRAM_EP9_IN_CONTROL_INTERRUPT_ON_STALL_Msk (0x20000UL) /*!< INTERRUPT_ON_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_IN_CONTROL_INTERRUPT_ON_NAK_Pos (16UL)    /*!< INTERRUPT_ON_NAK (Bit 16) */
#define USBCTRL_DPRAM_EP9_IN_CONTROL_INTERRUPT_ON_NAK_Msk (0x10000UL) /*!< INTERRUPT_ON_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_IN_CONTROL_BUFFER_ADDRESS_Pos (0UL)       /*!< BUFFER_ADDRESS (Bit 0) */
#define USBCTRL_DPRAM_EP9_IN_CONTROL_BUFFER_ADDRESS_Msk (0xffffUL)  /*!< BUFFER_ADDRESS (Bitfield-Mask: 0xffff) */
/* ====================================================  EP9_OUT_CONTROL  ==================================================== */
#define USBCTRL_DPRAM_EP9_OUT_CONTROL_ENABLE_Pos (31UL)             /*!< ENABLE (Bit 31) */
#define USBCTRL_DPRAM_EP9_OUT_CONTROL_ENABLE_Msk (0x80000000UL)     /*!< ENABLE (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_OUT_CONTROL_DOUBLE_BUFFERED_Pos (30UL)    /*!< DOUBLE_BUFFERED (Bit 30) */
#define USBCTRL_DPRAM_EP9_OUT_CONTROL_DOUBLE_BUFFERED_Msk (0x40000000UL) /*!< DOUBLE_BUFFERED (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_OUT_CONTROL_INTERRUPT_PER_BUFF_Pos (29UL) /*!< INTERRUPT_PER_BUFF (Bit 29) */
#define USBCTRL_DPRAM_EP9_OUT_CONTROL_INTERRUPT_PER_BUFF_Msk (0x20000000UL) /*!< INTERRUPT_PER_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Pos (28UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bit 28) */
#define USBCTRL_DPRAM_EP9_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Msk (0x10000000UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_OUT_CONTROL_ENDPOINT_TYPE_Pos (26UL)      /*!< ENDPOINT_TYPE (Bit 26) */
#define USBCTRL_DPRAM_EP9_OUT_CONTROL_ENDPOINT_TYPE_Msk (0xc000000UL) /*!< ENDPOINT_TYPE (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP9_OUT_CONTROL_INTERRUPT_ON_STALL_Pos (17UL) /*!< INTERRUPT_ON_STALL (Bit 17) */
#define USBCTRL_DPRAM_EP9_OUT_CONTROL_INTERRUPT_ON_STALL_Msk (0x20000UL) /*!< INTERRUPT_ON_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_OUT_CONTROL_INTERRUPT_ON_NAK_Pos (16UL)   /*!< INTERRUPT_ON_NAK (Bit 16) */
#define USBCTRL_DPRAM_EP9_OUT_CONTROL_INTERRUPT_ON_NAK_Msk (0x10000UL) /*!< INTERRUPT_ON_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_OUT_CONTROL_BUFFER_ADDRESS_Pos (0UL)      /*!< BUFFER_ADDRESS (Bit 0) */
#define USBCTRL_DPRAM_EP9_OUT_CONTROL_BUFFER_ADDRESS_Msk (0xffffUL) /*!< BUFFER_ADDRESS (Bitfield-Mask: 0xffff) */
/* ====================================================  EP10_IN_CONTROL  ==================================================== */
#define USBCTRL_DPRAM_EP10_IN_CONTROL_ENABLE_Pos (31UL)             /*!< ENABLE (Bit 31) */
#define USBCTRL_DPRAM_EP10_IN_CONTROL_ENABLE_Msk (0x80000000UL)     /*!< ENABLE (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_IN_CONTROL_DOUBLE_BUFFERED_Pos (30UL)    /*!< DOUBLE_BUFFERED (Bit 30) */
#define USBCTRL_DPRAM_EP10_IN_CONTROL_DOUBLE_BUFFERED_Msk (0x40000000UL) /*!< DOUBLE_BUFFERED (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_IN_CONTROL_INTERRUPT_PER_BUFF_Pos (29UL) /*!< INTERRUPT_PER_BUFF (Bit 29) */
#define USBCTRL_DPRAM_EP10_IN_CONTROL_INTERRUPT_PER_BUFF_Msk (0x20000000UL) /*!< INTERRUPT_PER_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Pos (28UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bit 28) */
#define USBCTRL_DPRAM_EP10_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Msk (0x10000000UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_IN_CONTROL_ENDPOINT_TYPE_Pos (26UL)      /*!< ENDPOINT_TYPE (Bit 26) */
#define USBCTRL_DPRAM_EP10_IN_CONTROL_ENDPOINT_TYPE_Msk (0xc000000UL) /*!< ENDPOINT_TYPE (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP10_IN_CONTROL_INTERRUPT_ON_STALL_Pos (17UL) /*!< INTERRUPT_ON_STALL (Bit 17) */
#define USBCTRL_DPRAM_EP10_IN_CONTROL_INTERRUPT_ON_STALL_Msk (0x20000UL) /*!< INTERRUPT_ON_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_IN_CONTROL_INTERRUPT_ON_NAK_Pos (16UL)   /*!< INTERRUPT_ON_NAK (Bit 16) */
#define USBCTRL_DPRAM_EP10_IN_CONTROL_INTERRUPT_ON_NAK_Msk (0x10000UL) /*!< INTERRUPT_ON_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_IN_CONTROL_BUFFER_ADDRESS_Pos (0UL)      /*!< BUFFER_ADDRESS (Bit 0) */
#define USBCTRL_DPRAM_EP10_IN_CONTROL_BUFFER_ADDRESS_Msk (0xffffUL) /*!< BUFFER_ADDRESS (Bitfield-Mask: 0xffff) */
/* ===================================================  EP10_OUT_CONTROL  ==================================================== */
#define USBCTRL_DPRAM_EP10_OUT_CONTROL_ENABLE_Pos (31UL)            /*!< ENABLE (Bit 31) */
#define USBCTRL_DPRAM_EP10_OUT_CONTROL_ENABLE_Msk (0x80000000UL)    /*!< ENABLE (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_OUT_CONTROL_DOUBLE_BUFFERED_Pos (30UL)   /*!< DOUBLE_BUFFERED (Bit 30) */
#define USBCTRL_DPRAM_EP10_OUT_CONTROL_DOUBLE_BUFFERED_Msk (0x40000000UL) /*!< DOUBLE_BUFFERED (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_OUT_CONTROL_INTERRUPT_PER_BUFF_Pos (29UL) /*!< INTERRUPT_PER_BUFF (Bit 29) */
#define USBCTRL_DPRAM_EP10_OUT_CONTROL_INTERRUPT_PER_BUFF_Msk (0x20000000UL) /*!< INTERRUPT_PER_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Pos (28UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bit 28) */
#define USBCTRL_DPRAM_EP10_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Msk (0x10000000UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_OUT_CONTROL_ENDPOINT_TYPE_Pos (26UL)     /*!< ENDPOINT_TYPE (Bit 26) */
#define USBCTRL_DPRAM_EP10_OUT_CONTROL_ENDPOINT_TYPE_Msk (0xc000000UL) /*!< ENDPOINT_TYPE (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP10_OUT_CONTROL_INTERRUPT_ON_STALL_Pos (17UL) /*!< INTERRUPT_ON_STALL (Bit 17) */
#define USBCTRL_DPRAM_EP10_OUT_CONTROL_INTERRUPT_ON_STALL_Msk (0x20000UL) /*!< INTERRUPT_ON_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_OUT_CONTROL_INTERRUPT_ON_NAK_Pos (16UL)  /*!< INTERRUPT_ON_NAK (Bit 16) */
#define USBCTRL_DPRAM_EP10_OUT_CONTROL_INTERRUPT_ON_NAK_Msk (0x10000UL) /*!< INTERRUPT_ON_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_OUT_CONTROL_BUFFER_ADDRESS_Pos (0UL)     /*!< BUFFER_ADDRESS (Bit 0) */
#define USBCTRL_DPRAM_EP10_OUT_CONTROL_BUFFER_ADDRESS_Msk (0xffffUL) /*!< BUFFER_ADDRESS (Bitfield-Mask: 0xffff) */
/* ====================================================  EP11_IN_CONTROL  ==================================================== */
#define USBCTRL_DPRAM_EP11_IN_CONTROL_ENABLE_Pos (31UL)             /*!< ENABLE (Bit 31) */
#define USBCTRL_DPRAM_EP11_IN_CONTROL_ENABLE_Msk (0x80000000UL)     /*!< ENABLE (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_IN_CONTROL_DOUBLE_BUFFERED_Pos (30UL)    /*!< DOUBLE_BUFFERED (Bit 30) */
#define USBCTRL_DPRAM_EP11_IN_CONTROL_DOUBLE_BUFFERED_Msk (0x40000000UL) /*!< DOUBLE_BUFFERED (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_IN_CONTROL_INTERRUPT_PER_BUFF_Pos (29UL) /*!< INTERRUPT_PER_BUFF (Bit 29) */
#define USBCTRL_DPRAM_EP11_IN_CONTROL_INTERRUPT_PER_BUFF_Msk (0x20000000UL) /*!< INTERRUPT_PER_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Pos (28UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bit 28) */
#define USBCTRL_DPRAM_EP11_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Msk (0x10000000UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_IN_CONTROL_ENDPOINT_TYPE_Pos (26UL)      /*!< ENDPOINT_TYPE (Bit 26) */
#define USBCTRL_DPRAM_EP11_IN_CONTROL_ENDPOINT_TYPE_Msk (0xc000000UL) /*!< ENDPOINT_TYPE (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP11_IN_CONTROL_INTERRUPT_ON_STALL_Pos (17UL) /*!< INTERRUPT_ON_STALL (Bit 17) */
#define USBCTRL_DPRAM_EP11_IN_CONTROL_INTERRUPT_ON_STALL_Msk (0x20000UL) /*!< INTERRUPT_ON_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_IN_CONTROL_INTERRUPT_ON_NAK_Pos (16UL)   /*!< INTERRUPT_ON_NAK (Bit 16) */
#define USBCTRL_DPRAM_EP11_IN_CONTROL_INTERRUPT_ON_NAK_Msk (0x10000UL) /*!< INTERRUPT_ON_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_IN_CONTROL_BUFFER_ADDRESS_Pos (0UL)      /*!< BUFFER_ADDRESS (Bit 0) */
#define USBCTRL_DPRAM_EP11_IN_CONTROL_BUFFER_ADDRESS_Msk (0xffffUL) /*!< BUFFER_ADDRESS (Bitfield-Mask: 0xffff) */
/* ===================================================  EP11_OUT_CONTROL  ==================================================== */
#define USBCTRL_DPRAM_EP11_OUT_CONTROL_ENABLE_Pos (31UL)            /*!< ENABLE (Bit 31) */
#define USBCTRL_DPRAM_EP11_OUT_CONTROL_ENABLE_Msk (0x80000000UL)    /*!< ENABLE (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_OUT_CONTROL_DOUBLE_BUFFERED_Pos (30UL)   /*!< DOUBLE_BUFFERED (Bit 30) */
#define USBCTRL_DPRAM_EP11_OUT_CONTROL_DOUBLE_BUFFERED_Msk (0x40000000UL) /*!< DOUBLE_BUFFERED (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_OUT_CONTROL_INTERRUPT_PER_BUFF_Pos (29UL) /*!< INTERRUPT_PER_BUFF (Bit 29) */
#define USBCTRL_DPRAM_EP11_OUT_CONTROL_INTERRUPT_PER_BUFF_Msk (0x20000000UL) /*!< INTERRUPT_PER_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Pos (28UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bit 28) */
#define USBCTRL_DPRAM_EP11_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Msk (0x10000000UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_OUT_CONTROL_ENDPOINT_TYPE_Pos (26UL)     /*!< ENDPOINT_TYPE (Bit 26) */
#define USBCTRL_DPRAM_EP11_OUT_CONTROL_ENDPOINT_TYPE_Msk (0xc000000UL) /*!< ENDPOINT_TYPE (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP11_OUT_CONTROL_INTERRUPT_ON_STALL_Pos (17UL) /*!< INTERRUPT_ON_STALL (Bit 17) */
#define USBCTRL_DPRAM_EP11_OUT_CONTROL_INTERRUPT_ON_STALL_Msk (0x20000UL) /*!< INTERRUPT_ON_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_OUT_CONTROL_INTERRUPT_ON_NAK_Pos (16UL)  /*!< INTERRUPT_ON_NAK (Bit 16) */
#define USBCTRL_DPRAM_EP11_OUT_CONTROL_INTERRUPT_ON_NAK_Msk (0x10000UL) /*!< INTERRUPT_ON_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_OUT_CONTROL_BUFFER_ADDRESS_Pos (0UL)     /*!< BUFFER_ADDRESS (Bit 0) */
#define USBCTRL_DPRAM_EP11_OUT_CONTROL_BUFFER_ADDRESS_Msk (0xffffUL) /*!< BUFFER_ADDRESS (Bitfield-Mask: 0xffff) */
/* ====================================================  EP12_IN_CONTROL  ==================================================== */
#define USBCTRL_DPRAM_EP12_IN_CONTROL_ENABLE_Pos (31UL)             /*!< ENABLE (Bit 31) */
#define USBCTRL_DPRAM_EP12_IN_CONTROL_ENABLE_Msk (0x80000000UL)     /*!< ENABLE (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_IN_CONTROL_DOUBLE_BUFFERED_Pos (30UL)    /*!< DOUBLE_BUFFERED (Bit 30) */
#define USBCTRL_DPRAM_EP12_IN_CONTROL_DOUBLE_BUFFERED_Msk (0x40000000UL) /*!< DOUBLE_BUFFERED (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_IN_CONTROL_INTERRUPT_PER_BUFF_Pos (29UL) /*!< INTERRUPT_PER_BUFF (Bit 29) */
#define USBCTRL_DPRAM_EP12_IN_CONTROL_INTERRUPT_PER_BUFF_Msk (0x20000000UL) /*!< INTERRUPT_PER_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Pos (28UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bit 28) */
#define USBCTRL_DPRAM_EP12_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Msk (0x10000000UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_IN_CONTROL_ENDPOINT_TYPE_Pos (26UL)      /*!< ENDPOINT_TYPE (Bit 26) */
#define USBCTRL_DPRAM_EP12_IN_CONTROL_ENDPOINT_TYPE_Msk (0xc000000UL) /*!< ENDPOINT_TYPE (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP12_IN_CONTROL_INTERRUPT_ON_STALL_Pos (17UL) /*!< INTERRUPT_ON_STALL (Bit 17) */
#define USBCTRL_DPRAM_EP12_IN_CONTROL_INTERRUPT_ON_STALL_Msk (0x20000UL) /*!< INTERRUPT_ON_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_IN_CONTROL_INTERRUPT_ON_NAK_Pos (16UL)   /*!< INTERRUPT_ON_NAK (Bit 16) */
#define USBCTRL_DPRAM_EP12_IN_CONTROL_INTERRUPT_ON_NAK_Msk (0x10000UL) /*!< INTERRUPT_ON_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_IN_CONTROL_BUFFER_ADDRESS_Pos (0UL)      /*!< BUFFER_ADDRESS (Bit 0) */
#define USBCTRL_DPRAM_EP12_IN_CONTROL_BUFFER_ADDRESS_Msk (0xffffUL) /*!< BUFFER_ADDRESS (Bitfield-Mask: 0xffff) */
/* ===================================================  EP12_OUT_CONTROL  ==================================================== */
#define USBCTRL_DPRAM_EP12_OUT_CONTROL_ENABLE_Pos (31UL)            /*!< ENABLE (Bit 31) */
#define USBCTRL_DPRAM_EP12_OUT_CONTROL_ENABLE_Msk (0x80000000UL)    /*!< ENABLE (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_OUT_CONTROL_DOUBLE_BUFFERED_Pos (30UL)   /*!< DOUBLE_BUFFERED (Bit 30) */
#define USBCTRL_DPRAM_EP12_OUT_CONTROL_DOUBLE_BUFFERED_Msk (0x40000000UL) /*!< DOUBLE_BUFFERED (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_OUT_CONTROL_INTERRUPT_PER_BUFF_Pos (29UL) /*!< INTERRUPT_PER_BUFF (Bit 29) */
#define USBCTRL_DPRAM_EP12_OUT_CONTROL_INTERRUPT_PER_BUFF_Msk (0x20000000UL) /*!< INTERRUPT_PER_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Pos (28UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bit 28) */
#define USBCTRL_DPRAM_EP12_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Msk (0x10000000UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_OUT_CONTROL_ENDPOINT_TYPE_Pos (26UL)     /*!< ENDPOINT_TYPE (Bit 26) */
#define USBCTRL_DPRAM_EP12_OUT_CONTROL_ENDPOINT_TYPE_Msk (0xc000000UL) /*!< ENDPOINT_TYPE (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP12_OUT_CONTROL_INTERRUPT_ON_STALL_Pos (17UL) /*!< INTERRUPT_ON_STALL (Bit 17) */
#define USBCTRL_DPRAM_EP12_OUT_CONTROL_INTERRUPT_ON_STALL_Msk (0x20000UL) /*!< INTERRUPT_ON_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_OUT_CONTROL_INTERRUPT_ON_NAK_Pos (16UL)  /*!< INTERRUPT_ON_NAK (Bit 16) */
#define USBCTRL_DPRAM_EP12_OUT_CONTROL_INTERRUPT_ON_NAK_Msk (0x10000UL) /*!< INTERRUPT_ON_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_OUT_CONTROL_BUFFER_ADDRESS_Pos (0UL)     /*!< BUFFER_ADDRESS (Bit 0) */
#define USBCTRL_DPRAM_EP12_OUT_CONTROL_BUFFER_ADDRESS_Msk (0xffffUL) /*!< BUFFER_ADDRESS (Bitfield-Mask: 0xffff) */
/* ====================================================  EP13_IN_CONTROL  ==================================================== */
#define USBCTRL_DPRAM_EP13_IN_CONTROL_ENABLE_Pos (31UL)             /*!< ENABLE (Bit 31) */
#define USBCTRL_DPRAM_EP13_IN_CONTROL_ENABLE_Msk (0x80000000UL)     /*!< ENABLE (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_IN_CONTROL_DOUBLE_BUFFERED_Pos (30UL)    /*!< DOUBLE_BUFFERED (Bit 30) */
#define USBCTRL_DPRAM_EP13_IN_CONTROL_DOUBLE_BUFFERED_Msk (0x40000000UL) /*!< DOUBLE_BUFFERED (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_IN_CONTROL_INTERRUPT_PER_BUFF_Pos (29UL) /*!< INTERRUPT_PER_BUFF (Bit 29) */
#define USBCTRL_DPRAM_EP13_IN_CONTROL_INTERRUPT_PER_BUFF_Msk (0x20000000UL) /*!< INTERRUPT_PER_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Pos (28UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bit 28) */
#define USBCTRL_DPRAM_EP13_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Msk (0x10000000UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_IN_CONTROL_ENDPOINT_TYPE_Pos (26UL)      /*!< ENDPOINT_TYPE (Bit 26) */
#define USBCTRL_DPRAM_EP13_IN_CONTROL_ENDPOINT_TYPE_Msk (0xc000000UL) /*!< ENDPOINT_TYPE (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP13_IN_CONTROL_INTERRUPT_ON_STALL_Pos (17UL) /*!< INTERRUPT_ON_STALL (Bit 17) */
#define USBCTRL_DPRAM_EP13_IN_CONTROL_INTERRUPT_ON_STALL_Msk (0x20000UL) /*!< INTERRUPT_ON_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_IN_CONTROL_INTERRUPT_ON_NAK_Pos (16UL)   /*!< INTERRUPT_ON_NAK (Bit 16) */
#define USBCTRL_DPRAM_EP13_IN_CONTROL_INTERRUPT_ON_NAK_Msk (0x10000UL) /*!< INTERRUPT_ON_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_IN_CONTROL_BUFFER_ADDRESS_Pos (0UL)      /*!< BUFFER_ADDRESS (Bit 0) */
#define USBCTRL_DPRAM_EP13_IN_CONTROL_BUFFER_ADDRESS_Msk (0xffffUL) /*!< BUFFER_ADDRESS (Bitfield-Mask: 0xffff) */
/* ===================================================  EP13_OUT_CONTROL  ==================================================== */
#define USBCTRL_DPRAM_EP13_OUT_CONTROL_ENABLE_Pos (31UL)            /*!< ENABLE (Bit 31) */
#define USBCTRL_DPRAM_EP13_OUT_CONTROL_ENABLE_Msk (0x80000000UL)    /*!< ENABLE (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_OUT_CONTROL_DOUBLE_BUFFERED_Pos (30UL)   /*!< DOUBLE_BUFFERED (Bit 30) */
#define USBCTRL_DPRAM_EP13_OUT_CONTROL_DOUBLE_BUFFERED_Msk (0x40000000UL) /*!< DOUBLE_BUFFERED (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_OUT_CONTROL_INTERRUPT_PER_BUFF_Pos (29UL) /*!< INTERRUPT_PER_BUFF (Bit 29) */
#define USBCTRL_DPRAM_EP13_OUT_CONTROL_INTERRUPT_PER_BUFF_Msk (0x20000000UL) /*!< INTERRUPT_PER_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Pos (28UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bit 28) */
#define USBCTRL_DPRAM_EP13_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Msk (0x10000000UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_OUT_CONTROL_ENDPOINT_TYPE_Pos (26UL)     /*!< ENDPOINT_TYPE (Bit 26) */
#define USBCTRL_DPRAM_EP13_OUT_CONTROL_ENDPOINT_TYPE_Msk (0xc000000UL) /*!< ENDPOINT_TYPE (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP13_OUT_CONTROL_INTERRUPT_ON_STALL_Pos (17UL) /*!< INTERRUPT_ON_STALL (Bit 17) */
#define USBCTRL_DPRAM_EP13_OUT_CONTROL_INTERRUPT_ON_STALL_Msk (0x20000UL) /*!< INTERRUPT_ON_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_OUT_CONTROL_INTERRUPT_ON_NAK_Pos (16UL)  /*!< INTERRUPT_ON_NAK (Bit 16) */
#define USBCTRL_DPRAM_EP13_OUT_CONTROL_INTERRUPT_ON_NAK_Msk (0x10000UL) /*!< INTERRUPT_ON_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_OUT_CONTROL_BUFFER_ADDRESS_Pos (0UL)     /*!< BUFFER_ADDRESS (Bit 0) */
#define USBCTRL_DPRAM_EP13_OUT_CONTROL_BUFFER_ADDRESS_Msk (0xffffUL) /*!< BUFFER_ADDRESS (Bitfield-Mask: 0xffff) */
/* ====================================================  EP14_IN_CONTROL  ==================================================== */
#define USBCTRL_DPRAM_EP14_IN_CONTROL_ENABLE_Pos (31UL)             /*!< ENABLE (Bit 31) */
#define USBCTRL_DPRAM_EP14_IN_CONTROL_ENABLE_Msk (0x80000000UL)     /*!< ENABLE (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_IN_CONTROL_DOUBLE_BUFFERED_Pos (30UL)    /*!< DOUBLE_BUFFERED (Bit 30) */
#define USBCTRL_DPRAM_EP14_IN_CONTROL_DOUBLE_BUFFERED_Msk (0x40000000UL) /*!< DOUBLE_BUFFERED (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_IN_CONTROL_INTERRUPT_PER_BUFF_Pos (29UL) /*!< INTERRUPT_PER_BUFF (Bit 29) */
#define USBCTRL_DPRAM_EP14_IN_CONTROL_INTERRUPT_PER_BUFF_Msk (0x20000000UL) /*!< INTERRUPT_PER_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Pos (28UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bit 28) */
#define USBCTRL_DPRAM_EP14_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Msk (0x10000000UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_IN_CONTROL_ENDPOINT_TYPE_Pos (26UL)      /*!< ENDPOINT_TYPE (Bit 26) */
#define USBCTRL_DPRAM_EP14_IN_CONTROL_ENDPOINT_TYPE_Msk (0xc000000UL) /*!< ENDPOINT_TYPE (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP14_IN_CONTROL_INTERRUPT_ON_STALL_Pos (17UL) /*!< INTERRUPT_ON_STALL (Bit 17) */
#define USBCTRL_DPRAM_EP14_IN_CONTROL_INTERRUPT_ON_STALL_Msk (0x20000UL) /*!< INTERRUPT_ON_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_IN_CONTROL_INTERRUPT_ON_NAK_Pos (16UL)   /*!< INTERRUPT_ON_NAK (Bit 16) */
#define USBCTRL_DPRAM_EP14_IN_CONTROL_INTERRUPT_ON_NAK_Msk (0x10000UL) /*!< INTERRUPT_ON_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_IN_CONTROL_BUFFER_ADDRESS_Pos (0UL)      /*!< BUFFER_ADDRESS (Bit 0) */
#define USBCTRL_DPRAM_EP14_IN_CONTROL_BUFFER_ADDRESS_Msk (0xffffUL) /*!< BUFFER_ADDRESS (Bitfield-Mask: 0xffff) */
/* ===================================================  EP14_OUT_CONTROL  ==================================================== */
#define USBCTRL_DPRAM_EP14_OUT_CONTROL_ENABLE_Pos (31UL)            /*!< ENABLE (Bit 31) */
#define USBCTRL_DPRAM_EP14_OUT_CONTROL_ENABLE_Msk (0x80000000UL)    /*!< ENABLE (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_OUT_CONTROL_DOUBLE_BUFFERED_Pos (30UL)   /*!< DOUBLE_BUFFERED (Bit 30) */
#define USBCTRL_DPRAM_EP14_OUT_CONTROL_DOUBLE_BUFFERED_Msk (0x40000000UL) /*!< DOUBLE_BUFFERED (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_OUT_CONTROL_INTERRUPT_PER_BUFF_Pos (29UL) /*!< INTERRUPT_PER_BUFF (Bit 29) */
#define USBCTRL_DPRAM_EP14_OUT_CONTROL_INTERRUPT_PER_BUFF_Msk (0x20000000UL) /*!< INTERRUPT_PER_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Pos (28UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bit 28) */
#define USBCTRL_DPRAM_EP14_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Msk (0x10000000UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_OUT_CONTROL_ENDPOINT_TYPE_Pos (26UL)     /*!< ENDPOINT_TYPE (Bit 26) */
#define USBCTRL_DPRAM_EP14_OUT_CONTROL_ENDPOINT_TYPE_Msk (0xc000000UL) /*!< ENDPOINT_TYPE (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP14_OUT_CONTROL_INTERRUPT_ON_STALL_Pos (17UL) /*!< INTERRUPT_ON_STALL (Bit 17) */
#define USBCTRL_DPRAM_EP14_OUT_CONTROL_INTERRUPT_ON_STALL_Msk (0x20000UL) /*!< INTERRUPT_ON_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_OUT_CONTROL_INTERRUPT_ON_NAK_Pos (16UL)  /*!< INTERRUPT_ON_NAK (Bit 16) */
#define USBCTRL_DPRAM_EP14_OUT_CONTROL_INTERRUPT_ON_NAK_Msk (0x10000UL) /*!< INTERRUPT_ON_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_OUT_CONTROL_BUFFER_ADDRESS_Pos (0UL)     /*!< BUFFER_ADDRESS (Bit 0) */
#define USBCTRL_DPRAM_EP14_OUT_CONTROL_BUFFER_ADDRESS_Msk (0xffffUL) /*!< BUFFER_ADDRESS (Bitfield-Mask: 0xffff) */
/* ====================================================  EP15_IN_CONTROL  ==================================================== */
#define USBCTRL_DPRAM_EP15_IN_CONTROL_ENABLE_Pos (31UL)             /*!< ENABLE (Bit 31) */
#define USBCTRL_DPRAM_EP15_IN_CONTROL_ENABLE_Msk (0x80000000UL)     /*!< ENABLE (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_IN_CONTROL_DOUBLE_BUFFERED_Pos (30UL)    /*!< DOUBLE_BUFFERED (Bit 30) */
#define USBCTRL_DPRAM_EP15_IN_CONTROL_DOUBLE_BUFFERED_Msk (0x40000000UL) /*!< DOUBLE_BUFFERED (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_IN_CONTROL_INTERRUPT_PER_BUFF_Pos (29UL) /*!< INTERRUPT_PER_BUFF (Bit 29) */
#define USBCTRL_DPRAM_EP15_IN_CONTROL_INTERRUPT_PER_BUFF_Msk (0x20000000UL) /*!< INTERRUPT_PER_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Pos (28UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bit 28) */
#define USBCTRL_DPRAM_EP15_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Msk (0x10000000UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_IN_CONTROL_ENDPOINT_TYPE_Pos (26UL)      /*!< ENDPOINT_TYPE (Bit 26) */
#define USBCTRL_DPRAM_EP15_IN_CONTROL_ENDPOINT_TYPE_Msk (0xc000000UL) /*!< ENDPOINT_TYPE (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP15_IN_CONTROL_INTERRUPT_ON_STALL_Pos (17UL) /*!< INTERRUPT_ON_STALL (Bit 17) */
#define USBCTRL_DPRAM_EP15_IN_CONTROL_INTERRUPT_ON_STALL_Msk (0x20000UL) /*!< INTERRUPT_ON_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_IN_CONTROL_INTERRUPT_ON_NAK_Pos (16UL)   /*!< INTERRUPT_ON_NAK (Bit 16) */
#define USBCTRL_DPRAM_EP15_IN_CONTROL_INTERRUPT_ON_NAK_Msk (0x10000UL) /*!< INTERRUPT_ON_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_IN_CONTROL_BUFFER_ADDRESS_Pos (0UL)      /*!< BUFFER_ADDRESS (Bit 0) */
#define USBCTRL_DPRAM_EP15_IN_CONTROL_BUFFER_ADDRESS_Msk (0xffffUL) /*!< BUFFER_ADDRESS (Bitfield-Mask: 0xffff) */
/* ===================================================  EP15_OUT_CONTROL  ==================================================== */
#define USBCTRL_DPRAM_EP15_OUT_CONTROL_ENABLE_Pos (31UL)            /*!< ENABLE (Bit 31) */
#define USBCTRL_DPRAM_EP15_OUT_CONTROL_ENABLE_Msk (0x80000000UL)    /*!< ENABLE (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_OUT_CONTROL_DOUBLE_BUFFERED_Pos (30UL)   /*!< DOUBLE_BUFFERED (Bit 30) */
#define USBCTRL_DPRAM_EP15_OUT_CONTROL_DOUBLE_BUFFERED_Msk (0x40000000UL) /*!< DOUBLE_BUFFERED (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_OUT_CONTROL_INTERRUPT_PER_BUFF_Pos (29UL) /*!< INTERRUPT_PER_BUFF (Bit 29) */
#define USBCTRL_DPRAM_EP15_OUT_CONTROL_INTERRUPT_PER_BUFF_Msk (0x20000000UL) /*!< INTERRUPT_PER_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Pos (28UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bit 28) */
#define USBCTRL_DPRAM_EP15_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF_Msk (0x10000000UL) /*!< INTERRUPT_PER_DOUBLE_BUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_OUT_CONTROL_ENDPOINT_TYPE_Pos (26UL)     /*!< ENDPOINT_TYPE (Bit 26) */
#define USBCTRL_DPRAM_EP15_OUT_CONTROL_ENDPOINT_TYPE_Msk (0xc000000UL) /*!< ENDPOINT_TYPE (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP15_OUT_CONTROL_INTERRUPT_ON_STALL_Pos (17UL) /*!< INTERRUPT_ON_STALL (Bit 17) */
#define USBCTRL_DPRAM_EP15_OUT_CONTROL_INTERRUPT_ON_STALL_Msk (0x20000UL) /*!< INTERRUPT_ON_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_OUT_CONTROL_INTERRUPT_ON_NAK_Pos (16UL)  /*!< INTERRUPT_ON_NAK (Bit 16) */
#define USBCTRL_DPRAM_EP15_OUT_CONTROL_INTERRUPT_ON_NAK_Msk (0x10000UL) /*!< INTERRUPT_ON_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_OUT_CONTROL_BUFFER_ADDRESS_Pos (0UL)     /*!< BUFFER_ADDRESS (Bit 0) */
#define USBCTRL_DPRAM_EP15_OUT_CONTROL_BUFFER_ADDRESS_Msk (0xffffUL) /*!< BUFFER_ADDRESS (Bitfield-Mask: 0xffff) */
/* =================================================  EP0_IN_BUFFER_CONTROL  ================================================= */
#define USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_FULL_1_Pos (31UL)       /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_LAST_1_Pos (30UL)       /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_PID_1_Pos (29UL)        /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL)  /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_LENGTH_1_Pos (16UL)     /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_FULL_0_Pos (15UL)       /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_FULL_0_Msk (0x8000UL)   /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_LAST_0_Pos (14UL)       /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_LAST_0_Msk (0x4000UL)   /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_PID_0_Pos (13UL)        /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_PID_0_Msk (0x2000UL)    /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_RESET_Pos (12UL)        /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_RESET_Msk (0x1000UL)    /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_STALL_Pos (11UL)        /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_STALL_Msk (0x800UL)     /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL)  /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_LENGTH_0_Pos (0UL)      /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL)  /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* ================================================  EP0_OUT_BUFFER_CONTROL  ================================================= */
#define USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_FULL_1_Pos (31UL)      /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_LAST_1_Pos (30UL)      /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_PID_1_Pos (29UL)       /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL) /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_LENGTH_1_Pos (16UL)    /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_FULL_0_Pos (15UL)      /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_FULL_0_Msk (0x8000UL)  /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_LAST_0_Pos (14UL)      /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_LAST_0_Msk (0x4000UL)  /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_PID_0_Pos (13UL)       /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_PID_0_Msk (0x2000UL)   /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_RESET_Pos (12UL)       /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_RESET_Msk (0x1000UL)   /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_STALL_Pos (11UL)       /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_STALL_Msk (0x800UL)    /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL) /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_LENGTH_0_Pos (0UL)     /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL) /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* =================================================  EP1_IN_BUFFER_CONTROL  ================================================= */
#define USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_FULL_1_Pos (31UL)       /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_LAST_1_Pos (30UL)       /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_PID_1_Pos (29UL)        /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL)  /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_LENGTH_1_Pos (16UL)     /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_FULL_0_Pos (15UL)       /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_FULL_0_Msk (0x8000UL)   /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_LAST_0_Pos (14UL)       /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_LAST_0_Msk (0x4000UL)   /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_PID_0_Pos (13UL)        /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_PID_0_Msk (0x2000UL)    /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_RESET_Pos (12UL)        /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_RESET_Msk (0x1000UL)    /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_STALL_Pos (11UL)        /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_STALL_Msk (0x800UL)     /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL)  /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_LENGTH_0_Pos (0UL)      /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL)  /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* ================================================  EP1_OUT_BUFFER_CONTROL  ================================================= */
#define USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_FULL_1_Pos (31UL)      /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_LAST_1_Pos (30UL)      /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_PID_1_Pos (29UL)       /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL) /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_LENGTH_1_Pos (16UL)    /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_FULL_0_Pos (15UL)      /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_FULL_0_Msk (0x8000UL)  /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_LAST_0_Pos (14UL)      /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_LAST_0_Msk (0x4000UL)  /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_PID_0_Pos (13UL)       /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_PID_0_Msk (0x2000UL)   /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_RESET_Pos (12UL)       /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_RESET_Msk (0x1000UL)   /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_STALL_Pos (11UL)       /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_STALL_Msk (0x800UL)    /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL) /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_LENGTH_0_Pos (0UL)     /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL) /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* =================================================  EP2_IN_BUFFER_CONTROL  ================================================= */
#define USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_FULL_1_Pos (31UL)       /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_LAST_1_Pos (30UL)       /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_PID_1_Pos (29UL)        /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL)  /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_LENGTH_1_Pos (16UL)     /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_FULL_0_Pos (15UL)       /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_FULL_0_Msk (0x8000UL)   /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_LAST_0_Pos (14UL)       /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_LAST_0_Msk (0x4000UL)   /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_PID_0_Pos (13UL)        /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_PID_0_Msk (0x2000UL)    /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_RESET_Pos (12UL)        /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_RESET_Msk (0x1000UL)    /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_STALL_Pos (11UL)        /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_STALL_Msk (0x800UL)     /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL)  /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_LENGTH_0_Pos (0UL)      /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL)  /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* ================================================  EP2_OUT_BUFFER_CONTROL  ================================================= */
#define USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_FULL_1_Pos (31UL)      /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_LAST_1_Pos (30UL)      /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_PID_1_Pos (29UL)       /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL) /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_LENGTH_1_Pos (16UL)    /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_FULL_0_Pos (15UL)      /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_FULL_0_Msk (0x8000UL)  /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_LAST_0_Pos (14UL)      /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_LAST_0_Msk (0x4000UL)  /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_PID_0_Pos (13UL)       /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_PID_0_Msk (0x2000UL)   /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_RESET_Pos (12UL)       /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_RESET_Msk (0x1000UL)   /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_STALL_Pos (11UL)       /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_STALL_Msk (0x800UL)    /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL) /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_LENGTH_0_Pos (0UL)     /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL) /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* =================================================  EP3_IN_BUFFER_CONTROL  ================================================= */
#define USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_FULL_1_Pos (31UL)       /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_LAST_1_Pos (30UL)       /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_PID_1_Pos (29UL)        /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL)  /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_LENGTH_1_Pos (16UL)     /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_FULL_0_Pos (15UL)       /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_FULL_0_Msk (0x8000UL)   /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_LAST_0_Pos (14UL)       /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_LAST_0_Msk (0x4000UL)   /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_PID_0_Pos (13UL)        /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_PID_0_Msk (0x2000UL)    /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_RESET_Pos (12UL)        /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_RESET_Msk (0x1000UL)    /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_STALL_Pos (11UL)        /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_STALL_Msk (0x800UL)     /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL)  /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_LENGTH_0_Pos (0UL)      /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL)  /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* ================================================  EP3_OUT_BUFFER_CONTROL  ================================================= */
#define USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_FULL_1_Pos (31UL)      /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_LAST_1_Pos (30UL)      /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_PID_1_Pos (29UL)       /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL) /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_LENGTH_1_Pos (16UL)    /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_FULL_0_Pos (15UL)      /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_FULL_0_Msk (0x8000UL)  /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_LAST_0_Pos (14UL)      /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_LAST_0_Msk (0x4000UL)  /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_PID_0_Pos (13UL)       /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_PID_0_Msk (0x2000UL)   /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_RESET_Pos (12UL)       /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_RESET_Msk (0x1000UL)   /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_STALL_Pos (11UL)       /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_STALL_Msk (0x800UL)    /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL) /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_LENGTH_0_Pos (0UL)     /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL) /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* =================================================  EP4_IN_BUFFER_CONTROL  ================================================= */
#define USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_FULL_1_Pos (31UL)       /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_LAST_1_Pos (30UL)       /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_PID_1_Pos (29UL)        /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL)  /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_LENGTH_1_Pos (16UL)     /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_FULL_0_Pos (15UL)       /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_FULL_0_Msk (0x8000UL)   /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_LAST_0_Pos (14UL)       /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_LAST_0_Msk (0x4000UL)   /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_PID_0_Pos (13UL)        /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_PID_0_Msk (0x2000UL)    /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_RESET_Pos (12UL)        /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_RESET_Msk (0x1000UL)    /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_STALL_Pos (11UL)        /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_STALL_Msk (0x800UL)     /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL)  /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_LENGTH_0_Pos (0UL)      /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL)  /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* ================================================  EP4_OUT_BUFFER_CONTROL  ================================================= */
#define USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_FULL_1_Pos (31UL)      /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_LAST_1_Pos (30UL)      /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_PID_1_Pos (29UL)       /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL) /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_LENGTH_1_Pos (16UL)    /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_FULL_0_Pos (15UL)      /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_FULL_0_Msk (0x8000UL)  /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_LAST_0_Pos (14UL)      /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_LAST_0_Msk (0x4000UL)  /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_PID_0_Pos (13UL)       /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_PID_0_Msk (0x2000UL)   /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_RESET_Pos (12UL)       /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_RESET_Msk (0x1000UL)   /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_STALL_Pos (11UL)       /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_STALL_Msk (0x800UL)    /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL) /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_LENGTH_0_Pos (0UL)     /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL) /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* =================================================  EP5_IN_BUFFER_CONTROL  ================================================= */
#define USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_FULL_1_Pos (31UL)       /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_LAST_1_Pos (30UL)       /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_PID_1_Pos (29UL)        /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL)  /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_LENGTH_1_Pos (16UL)     /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_FULL_0_Pos (15UL)       /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_FULL_0_Msk (0x8000UL)   /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_LAST_0_Pos (14UL)       /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_LAST_0_Msk (0x4000UL)   /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_PID_0_Pos (13UL)        /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_PID_0_Msk (0x2000UL)    /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_RESET_Pos (12UL)        /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_RESET_Msk (0x1000UL)    /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_STALL_Pos (11UL)        /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_STALL_Msk (0x800UL)     /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL)  /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_LENGTH_0_Pos (0UL)      /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL)  /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* ================================================  EP5_OUT_BUFFER_CONTROL  ================================================= */
#define USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_FULL_1_Pos (31UL)      /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_LAST_1_Pos (30UL)      /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_PID_1_Pos (29UL)       /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL) /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_LENGTH_1_Pos (16UL)    /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_FULL_0_Pos (15UL)      /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_FULL_0_Msk (0x8000UL)  /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_LAST_0_Pos (14UL)      /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_LAST_0_Msk (0x4000UL)  /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_PID_0_Pos (13UL)       /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_PID_0_Msk (0x2000UL)   /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_RESET_Pos (12UL)       /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_RESET_Msk (0x1000UL)   /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_STALL_Pos (11UL)       /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_STALL_Msk (0x800UL)    /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL) /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_LENGTH_0_Pos (0UL)     /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL) /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* =================================================  EP6_IN_BUFFER_CONTROL  ================================================= */
#define USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_FULL_1_Pos (31UL)       /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_LAST_1_Pos (30UL)       /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_PID_1_Pos (29UL)        /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL)  /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_LENGTH_1_Pos (16UL)     /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_FULL_0_Pos (15UL)       /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_FULL_0_Msk (0x8000UL)   /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_LAST_0_Pos (14UL)       /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_LAST_0_Msk (0x4000UL)   /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_PID_0_Pos (13UL)        /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_PID_0_Msk (0x2000UL)    /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_RESET_Pos (12UL)        /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_RESET_Msk (0x1000UL)    /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_STALL_Pos (11UL)        /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_STALL_Msk (0x800UL)     /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL)  /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_LENGTH_0_Pos (0UL)      /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL)  /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* ================================================  EP6_OUT_BUFFER_CONTROL  ================================================= */
#define USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_FULL_1_Pos (31UL)      /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_LAST_1_Pos (30UL)      /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_PID_1_Pos (29UL)       /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL) /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_LENGTH_1_Pos (16UL)    /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_FULL_0_Pos (15UL)      /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_FULL_0_Msk (0x8000UL)  /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_LAST_0_Pos (14UL)      /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_LAST_0_Msk (0x4000UL)  /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_PID_0_Pos (13UL)       /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_PID_0_Msk (0x2000UL)   /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_RESET_Pos (12UL)       /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_RESET_Msk (0x1000UL)   /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_STALL_Pos (11UL)       /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_STALL_Msk (0x800UL)    /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL) /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_LENGTH_0_Pos (0UL)     /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL) /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* =================================================  EP7_IN_BUFFER_CONTROL  ================================================= */
#define USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_FULL_1_Pos (31UL)       /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_LAST_1_Pos (30UL)       /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_PID_1_Pos (29UL)        /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL)  /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_LENGTH_1_Pos (16UL)     /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_FULL_0_Pos (15UL)       /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_FULL_0_Msk (0x8000UL)   /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_LAST_0_Pos (14UL)       /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_LAST_0_Msk (0x4000UL)   /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_PID_0_Pos (13UL)        /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_PID_0_Msk (0x2000UL)    /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_RESET_Pos (12UL)        /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_RESET_Msk (0x1000UL)    /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_STALL_Pos (11UL)        /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_STALL_Msk (0x800UL)     /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL)  /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_LENGTH_0_Pos (0UL)      /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL)  /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* ================================================  EP7_OUT_BUFFER_CONTROL  ================================================= */
#define USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_FULL_1_Pos (31UL)      /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_LAST_1_Pos (30UL)      /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_PID_1_Pos (29UL)       /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL) /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_LENGTH_1_Pos (16UL)    /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_FULL_0_Pos (15UL)      /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_FULL_0_Msk (0x8000UL)  /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_LAST_0_Pos (14UL)      /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_LAST_0_Msk (0x4000UL)  /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_PID_0_Pos (13UL)       /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_PID_0_Msk (0x2000UL)   /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_RESET_Pos (12UL)       /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_RESET_Msk (0x1000UL)   /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_STALL_Pos (11UL)       /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_STALL_Msk (0x800UL)    /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL) /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_LENGTH_0_Pos (0UL)     /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL) /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* =================================================  EP8_IN_BUFFER_CONTROL  ================================================= */
#define USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_FULL_1_Pos (31UL)       /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_LAST_1_Pos (30UL)       /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_PID_1_Pos (29UL)        /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL)  /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_LENGTH_1_Pos (16UL)     /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_FULL_0_Pos (15UL)       /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_FULL_0_Msk (0x8000UL)   /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_LAST_0_Pos (14UL)       /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_LAST_0_Msk (0x4000UL)   /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_PID_0_Pos (13UL)        /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_PID_0_Msk (0x2000UL)    /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_RESET_Pos (12UL)        /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_RESET_Msk (0x1000UL)    /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_STALL_Pos (11UL)        /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_STALL_Msk (0x800UL)     /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL)  /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_LENGTH_0_Pos (0UL)      /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL)  /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* ================================================  EP8_OUT_BUFFER_CONTROL  ================================================= */
#define USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_FULL_1_Pos (31UL)      /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_LAST_1_Pos (30UL)      /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_PID_1_Pos (29UL)       /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL) /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_LENGTH_1_Pos (16UL)    /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_FULL_0_Pos (15UL)      /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_FULL_0_Msk (0x8000UL)  /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_LAST_0_Pos (14UL)      /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_LAST_0_Msk (0x4000UL)  /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_PID_0_Pos (13UL)       /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_PID_0_Msk (0x2000UL)   /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_RESET_Pos (12UL)       /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_RESET_Msk (0x1000UL)   /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_STALL_Pos (11UL)       /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_STALL_Msk (0x800UL)    /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL) /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_LENGTH_0_Pos (0UL)     /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL) /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* =================================================  EP9_IN_BUFFER_CONTROL  ================================================= */
#define USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_FULL_1_Pos (31UL)       /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_LAST_1_Pos (30UL)       /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_PID_1_Pos (29UL)        /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL)  /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_LENGTH_1_Pos (16UL)     /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_FULL_0_Pos (15UL)       /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_FULL_0_Msk (0x8000UL)   /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_LAST_0_Pos (14UL)       /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_LAST_0_Msk (0x4000UL)   /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_PID_0_Pos (13UL)        /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_PID_0_Msk (0x2000UL)    /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_RESET_Pos (12UL)        /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_RESET_Msk (0x1000UL)    /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_STALL_Pos (11UL)        /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_STALL_Msk (0x800UL)     /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL)  /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_LENGTH_0_Pos (0UL)      /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL)  /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* ================================================  EP9_OUT_BUFFER_CONTROL  ================================================= */
#define USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_FULL_1_Pos (31UL)      /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_LAST_1_Pos (30UL)      /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_PID_1_Pos (29UL)       /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL) /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_LENGTH_1_Pos (16UL)    /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_FULL_0_Pos (15UL)      /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_FULL_0_Msk (0x8000UL)  /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_LAST_0_Pos (14UL)      /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_LAST_0_Msk (0x4000UL)  /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_PID_0_Pos (13UL)       /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_PID_0_Msk (0x2000UL)   /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_RESET_Pos (12UL)       /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_RESET_Msk (0x1000UL)   /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_STALL_Pos (11UL)       /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_STALL_Msk (0x800UL)    /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL) /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_LENGTH_0_Pos (0UL)     /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL) /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* ================================================  EP10_IN_BUFFER_CONTROL  ================================================= */
#define USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_FULL_1_Pos (31UL)      /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_LAST_1_Pos (30UL)      /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_PID_1_Pos (29UL)       /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL) /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_LENGTH_1_Pos (16UL)    /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_FULL_0_Pos (15UL)      /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_FULL_0_Msk (0x8000UL)  /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_LAST_0_Pos (14UL)      /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_LAST_0_Msk (0x4000UL)  /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_PID_0_Pos (13UL)       /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_PID_0_Msk (0x2000UL)   /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_RESET_Pos (12UL)       /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_RESET_Msk (0x1000UL)   /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_STALL_Pos (11UL)       /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_STALL_Msk (0x800UL)    /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL) /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_LENGTH_0_Pos (0UL)     /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL) /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* ================================================  EP10_OUT_BUFFER_CONTROL  ================================================ */
#define USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_FULL_1_Pos (31UL)     /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_LAST_1_Pos (30UL)     /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_PID_1_Pos (29UL)      /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL) /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_LENGTH_1_Pos (16UL)   /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_FULL_0_Pos (15UL)     /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_FULL_0_Msk (0x8000UL) /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_LAST_0_Pos (14UL)     /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_LAST_0_Msk (0x4000UL) /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_PID_0_Pos (13UL)      /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_PID_0_Msk (0x2000UL)  /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_RESET_Pos (12UL)      /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_RESET_Msk (0x1000UL)  /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_STALL_Pos (11UL)      /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_STALL_Msk (0x800UL)   /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL) /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_LENGTH_0_Pos (0UL)    /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL) /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* ================================================  EP11_IN_BUFFER_CONTROL  ================================================= */
#define USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_FULL_1_Pos (31UL)      /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_LAST_1_Pos (30UL)      /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_PID_1_Pos (29UL)       /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL) /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_LENGTH_1_Pos (16UL)    /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_FULL_0_Pos (15UL)      /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_FULL_0_Msk (0x8000UL)  /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_LAST_0_Pos (14UL)      /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_LAST_0_Msk (0x4000UL)  /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_PID_0_Pos (13UL)       /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_PID_0_Msk (0x2000UL)   /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_RESET_Pos (12UL)       /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_RESET_Msk (0x1000UL)   /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_STALL_Pos (11UL)       /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_STALL_Msk (0x800UL)    /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL) /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_LENGTH_0_Pos (0UL)     /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL) /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* ================================================  EP11_OUT_BUFFER_CONTROL  ================================================ */
#define USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_FULL_1_Pos (31UL)     /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_LAST_1_Pos (30UL)     /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_PID_1_Pos (29UL)      /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL) /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_LENGTH_1_Pos (16UL)   /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_FULL_0_Pos (15UL)     /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_FULL_0_Msk (0x8000UL) /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_LAST_0_Pos (14UL)     /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_LAST_0_Msk (0x4000UL) /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_PID_0_Pos (13UL)      /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_PID_0_Msk (0x2000UL)  /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_RESET_Pos (12UL)      /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_RESET_Msk (0x1000UL)  /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_STALL_Pos (11UL)      /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_STALL_Msk (0x800UL)   /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL) /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_LENGTH_0_Pos (0UL)    /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL) /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* ================================================  EP12_IN_BUFFER_CONTROL  ================================================= */
#define USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_FULL_1_Pos (31UL)      /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_LAST_1_Pos (30UL)      /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_PID_1_Pos (29UL)       /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL) /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_LENGTH_1_Pos (16UL)    /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_FULL_0_Pos (15UL)      /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_FULL_0_Msk (0x8000UL)  /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_LAST_0_Pos (14UL)      /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_LAST_0_Msk (0x4000UL)  /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_PID_0_Pos (13UL)       /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_PID_0_Msk (0x2000UL)   /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_RESET_Pos (12UL)       /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_RESET_Msk (0x1000UL)   /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_STALL_Pos (11UL)       /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_STALL_Msk (0x800UL)    /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL) /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_LENGTH_0_Pos (0UL)     /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL) /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* ================================================  EP12_OUT_BUFFER_CONTROL  ================================================ */
#define USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_FULL_1_Pos (31UL)     /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_LAST_1_Pos (30UL)     /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_PID_1_Pos (29UL)      /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL) /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_LENGTH_1_Pos (16UL)   /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_FULL_0_Pos (15UL)     /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_FULL_0_Msk (0x8000UL) /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_LAST_0_Pos (14UL)     /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_LAST_0_Msk (0x4000UL) /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_PID_0_Pos (13UL)      /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_PID_0_Msk (0x2000UL)  /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_RESET_Pos (12UL)      /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_RESET_Msk (0x1000UL)  /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_STALL_Pos (11UL)      /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_STALL_Msk (0x800UL)   /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL) /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_LENGTH_0_Pos (0UL)    /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL) /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* ================================================  EP13_IN_BUFFER_CONTROL  ================================================= */
#define USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_FULL_1_Pos (31UL)      /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_LAST_1_Pos (30UL)      /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_PID_1_Pos (29UL)       /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL) /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_LENGTH_1_Pos (16UL)    /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_FULL_0_Pos (15UL)      /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_FULL_0_Msk (0x8000UL)  /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_LAST_0_Pos (14UL)      /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_LAST_0_Msk (0x4000UL)  /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_PID_0_Pos (13UL)       /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_PID_0_Msk (0x2000UL)   /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_RESET_Pos (12UL)       /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_RESET_Msk (0x1000UL)   /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_STALL_Pos (11UL)       /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_STALL_Msk (0x800UL)    /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL) /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_LENGTH_0_Pos (0UL)     /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL) /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* ================================================  EP13_OUT_BUFFER_CONTROL  ================================================ */
#define USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_FULL_1_Pos (31UL)     /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_LAST_1_Pos (30UL)     /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_PID_1_Pos (29UL)      /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL) /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_LENGTH_1_Pos (16UL)   /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_FULL_0_Pos (15UL)     /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_FULL_0_Msk (0x8000UL) /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_LAST_0_Pos (14UL)     /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_LAST_0_Msk (0x4000UL) /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_PID_0_Pos (13UL)      /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_PID_0_Msk (0x2000UL)  /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_RESET_Pos (12UL)      /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_RESET_Msk (0x1000UL)  /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_STALL_Pos (11UL)      /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_STALL_Msk (0x800UL)   /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL) /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_LENGTH_0_Pos (0UL)    /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL) /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* ================================================  EP14_IN_BUFFER_CONTROL  ================================================= */
#define USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_FULL_1_Pos (31UL)      /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_LAST_1_Pos (30UL)      /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_PID_1_Pos (29UL)       /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL) /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_LENGTH_1_Pos (16UL)    /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_FULL_0_Pos (15UL)      /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_FULL_0_Msk (0x8000UL)  /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_LAST_0_Pos (14UL)      /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_LAST_0_Msk (0x4000UL)  /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_PID_0_Pos (13UL)       /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_PID_0_Msk (0x2000UL)   /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_RESET_Pos (12UL)       /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_RESET_Msk (0x1000UL)   /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_STALL_Pos (11UL)       /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_STALL_Msk (0x800UL)    /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL) /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_LENGTH_0_Pos (0UL)     /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL) /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* ================================================  EP14_OUT_BUFFER_CONTROL  ================================================ */
#define USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_FULL_1_Pos (31UL)     /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_LAST_1_Pos (30UL)     /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_PID_1_Pos (29UL)      /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL) /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_LENGTH_1_Pos (16UL)   /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_FULL_0_Pos (15UL)     /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_FULL_0_Msk (0x8000UL) /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_LAST_0_Pos (14UL)     /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_LAST_0_Msk (0x4000UL) /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_PID_0_Pos (13UL)      /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_PID_0_Msk (0x2000UL)  /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_RESET_Pos (12UL)      /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_RESET_Msk (0x1000UL)  /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_STALL_Pos (11UL)      /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_STALL_Msk (0x800UL)   /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL) /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_LENGTH_0_Pos (0UL)    /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL) /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* ================================================  EP15_IN_BUFFER_CONTROL  ================================================= */
#define USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_FULL_1_Pos (31UL)      /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_LAST_1_Pos (30UL)      /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_PID_1_Pos (29UL)       /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL) /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_LENGTH_1_Pos (16UL)    /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_FULL_0_Pos (15UL)      /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_FULL_0_Msk (0x8000UL)  /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_LAST_0_Pos (14UL)      /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_LAST_0_Msk (0x4000UL)  /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_PID_0_Pos (13UL)       /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_PID_0_Msk (0x2000UL)   /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_RESET_Pos (12UL)       /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_RESET_Msk (0x1000UL)   /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_STALL_Pos (11UL)       /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_STALL_Msk (0x800UL)    /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL) /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_LENGTH_0_Pos (0UL)     /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL) /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */
/* ================================================  EP15_OUT_BUFFER_CONTROL  ================================================ */
#define USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_FULL_1_Pos (31UL)     /*!< FULL_1 (Bit 31) */
#define USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_FULL_1_Msk (0x80000000UL) /*!< FULL_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_LAST_1_Pos (30UL)     /*!< LAST_1 (Bit 30) */
#define USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_LAST_1_Msk (0x40000000UL) /*!< LAST_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_PID_1_Pos (29UL)      /*!< PID_1 (Bit 29) */
#define USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_PID_1_Msk (0x20000000UL) /*!< PID_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Pos (27UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bit 27) */
#define USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Msk (0x18000000UL) /*!< DOUBLE_BUFFER_ISO_OFFSET (Bitfield-Mask: 0x03) */
#define USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_AVAILABLE_1_Pos (26UL) /*!< AVAILABLE_1 (Bit 26) */
#define USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_AVAILABLE_1_Msk (0x4000000UL) /*!< AVAILABLE_1 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_LENGTH_1_Pos (16UL)   /*!< LENGTH_1 (Bit 16) */
#define USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_LENGTH_1_Msk (0x3ff0000UL) /*!< LENGTH_1 (Bitfield-Mask: 0x3ff) */
#define USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_FULL_0_Pos (15UL)     /*!< FULL_0 (Bit 15) */
#define USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_FULL_0_Msk (0x8000UL) /*!< FULL_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_LAST_0_Pos (14UL)     /*!< LAST_0 (Bit 14) */
#define USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_LAST_0_Msk (0x4000UL) /*!< LAST_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_PID_0_Pos (13UL)      /*!< PID_0 (Bit 13) */
#define USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_PID_0_Msk (0x2000UL)  /*!< PID_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_RESET_Pos (12UL)      /*!< RESET (Bit 12) */
#define USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_RESET_Msk (0x1000UL)  /*!< RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_STALL_Pos (11UL)      /*!< STALL (Bit 11) */
#define USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_STALL_Msk (0x800UL)   /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_AVAILABLE_0_Pos (10UL) /*!< AVAILABLE_0 (Bit 10) */
#define USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_AVAILABLE_0_Msk (0x400UL) /*!< AVAILABLE_0 (Bitfield-Mask: 0x01) */
#define USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_LENGTH_0_Pos (0UL)    /*!< LENGTH_0 (Bit 0) */
#define USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_LENGTH_0_Msk (0x3ffUL) /*!< LENGTH_0 (Bitfield-Mask: 0x3ff) */


/* =========================================================================================================================== */
/* ================                                       USBCTRL_REGS                                        ================ */
/* =========================================================================================================================== */

/* =======================================================  ADDR_ENDP  ======================================================= */
#define USBCTRL_REGS_ADDR_ENDP_ENDPOINT_Pos (16UL)                  /*!< ENDPOINT (Bit 16) */
#define USBCTRL_REGS_ADDR_ENDP_ENDPOINT_Msk (0xf0000UL)             /*!< ENDPOINT (Bitfield-Mask: 0x0f) */
#define USBCTRL_REGS_ADDR_ENDP_ADDRESS_Pos (0UL)                    /*!< ADDRESS (Bit 0) */
#define USBCTRL_REGS_ADDR_ENDP_ADDRESS_Msk (0x7fUL)                 /*!< ADDRESS (Bitfield-Mask: 0x7f) */
/* ======================================================  ADDR_ENDP1  ======================================================= */
#define USBCTRL_REGS_ADDR_ENDP1_INTEP_PREAMBLE_Pos (26UL)           /*!< INTEP_PREAMBLE (Bit 26) */
#define USBCTRL_REGS_ADDR_ENDP1_INTEP_PREAMBLE_Msk (0x4000000UL)    /*!< INTEP_PREAMBLE (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_ADDR_ENDP1_INTEP_DIR_Pos (25UL)                /*!< INTEP_DIR (Bit 25) */
#define USBCTRL_REGS_ADDR_ENDP1_INTEP_DIR_Msk (0x2000000UL)         /*!< INTEP_DIR (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_ADDR_ENDP1_ENDPOINT_Pos (16UL)                 /*!< ENDPOINT (Bit 16) */
#define USBCTRL_REGS_ADDR_ENDP1_ENDPOINT_Msk (0xf0000UL)            /*!< ENDPOINT (Bitfield-Mask: 0x0f) */
#define USBCTRL_REGS_ADDR_ENDP1_ADDRESS_Pos (0UL)                   /*!< ADDRESS (Bit 0) */
#define USBCTRL_REGS_ADDR_ENDP1_ADDRESS_Msk (0x7fUL)                /*!< ADDRESS (Bitfield-Mask: 0x7f) */
/* ======================================================  ADDR_ENDP2  ======================================================= */
#define USBCTRL_REGS_ADDR_ENDP2_INTEP_PREAMBLE_Pos (26UL)           /*!< INTEP_PREAMBLE (Bit 26) */
#define USBCTRL_REGS_ADDR_ENDP2_INTEP_PREAMBLE_Msk (0x4000000UL)    /*!< INTEP_PREAMBLE (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_ADDR_ENDP2_INTEP_DIR_Pos (25UL)                /*!< INTEP_DIR (Bit 25) */
#define USBCTRL_REGS_ADDR_ENDP2_INTEP_DIR_Msk (0x2000000UL)         /*!< INTEP_DIR (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_ADDR_ENDP2_ENDPOINT_Pos (16UL)                 /*!< ENDPOINT (Bit 16) */
#define USBCTRL_REGS_ADDR_ENDP2_ENDPOINT_Msk (0xf0000UL)            /*!< ENDPOINT (Bitfield-Mask: 0x0f) */
#define USBCTRL_REGS_ADDR_ENDP2_ADDRESS_Pos (0UL)                   /*!< ADDRESS (Bit 0) */
#define USBCTRL_REGS_ADDR_ENDP2_ADDRESS_Msk (0x7fUL)                /*!< ADDRESS (Bitfield-Mask: 0x7f) */
/* ======================================================  ADDR_ENDP3  ======================================================= */
#define USBCTRL_REGS_ADDR_ENDP3_INTEP_PREAMBLE_Pos (26UL)           /*!< INTEP_PREAMBLE (Bit 26) */
#define USBCTRL_REGS_ADDR_ENDP3_INTEP_PREAMBLE_Msk (0x4000000UL)    /*!< INTEP_PREAMBLE (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_ADDR_ENDP3_INTEP_DIR_Pos (25UL)                /*!< INTEP_DIR (Bit 25) */
#define USBCTRL_REGS_ADDR_ENDP3_INTEP_DIR_Msk (0x2000000UL)         /*!< INTEP_DIR (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_ADDR_ENDP3_ENDPOINT_Pos (16UL)                 /*!< ENDPOINT (Bit 16) */
#define USBCTRL_REGS_ADDR_ENDP3_ENDPOINT_Msk (0xf0000UL)            /*!< ENDPOINT (Bitfield-Mask: 0x0f) */
#define USBCTRL_REGS_ADDR_ENDP3_ADDRESS_Pos (0UL)                   /*!< ADDRESS (Bit 0) */
#define USBCTRL_REGS_ADDR_ENDP3_ADDRESS_Msk (0x7fUL)                /*!< ADDRESS (Bitfield-Mask: 0x7f) */
/* ======================================================  ADDR_ENDP4  ======================================================= */
#define USBCTRL_REGS_ADDR_ENDP4_INTEP_PREAMBLE_Pos (26UL)           /*!< INTEP_PREAMBLE (Bit 26) */
#define USBCTRL_REGS_ADDR_ENDP4_INTEP_PREAMBLE_Msk (0x4000000UL)    /*!< INTEP_PREAMBLE (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_ADDR_ENDP4_INTEP_DIR_Pos (25UL)                /*!< INTEP_DIR (Bit 25) */
#define USBCTRL_REGS_ADDR_ENDP4_INTEP_DIR_Msk (0x2000000UL)         /*!< INTEP_DIR (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_ADDR_ENDP4_ENDPOINT_Pos (16UL)                 /*!< ENDPOINT (Bit 16) */
#define USBCTRL_REGS_ADDR_ENDP4_ENDPOINT_Msk (0xf0000UL)            /*!< ENDPOINT (Bitfield-Mask: 0x0f) */
#define USBCTRL_REGS_ADDR_ENDP4_ADDRESS_Pos (0UL)                   /*!< ADDRESS (Bit 0) */
#define USBCTRL_REGS_ADDR_ENDP4_ADDRESS_Msk (0x7fUL)                /*!< ADDRESS (Bitfield-Mask: 0x7f) */
/* ======================================================  ADDR_ENDP5  ======================================================= */
#define USBCTRL_REGS_ADDR_ENDP5_INTEP_PREAMBLE_Pos (26UL)           /*!< INTEP_PREAMBLE (Bit 26) */
#define USBCTRL_REGS_ADDR_ENDP5_INTEP_PREAMBLE_Msk (0x4000000UL)    /*!< INTEP_PREAMBLE (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_ADDR_ENDP5_INTEP_DIR_Pos (25UL)                /*!< INTEP_DIR (Bit 25) */
#define USBCTRL_REGS_ADDR_ENDP5_INTEP_DIR_Msk (0x2000000UL)         /*!< INTEP_DIR (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_ADDR_ENDP5_ENDPOINT_Pos (16UL)                 /*!< ENDPOINT (Bit 16) */
#define USBCTRL_REGS_ADDR_ENDP5_ENDPOINT_Msk (0xf0000UL)            /*!< ENDPOINT (Bitfield-Mask: 0x0f) */
#define USBCTRL_REGS_ADDR_ENDP5_ADDRESS_Pos (0UL)                   /*!< ADDRESS (Bit 0) */
#define USBCTRL_REGS_ADDR_ENDP5_ADDRESS_Msk (0x7fUL)                /*!< ADDRESS (Bitfield-Mask: 0x7f) */
/* ======================================================  ADDR_ENDP6  ======================================================= */
#define USBCTRL_REGS_ADDR_ENDP6_INTEP_PREAMBLE_Pos (26UL)           /*!< INTEP_PREAMBLE (Bit 26) */
#define USBCTRL_REGS_ADDR_ENDP6_INTEP_PREAMBLE_Msk (0x4000000UL)    /*!< INTEP_PREAMBLE (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_ADDR_ENDP6_INTEP_DIR_Pos (25UL)                /*!< INTEP_DIR (Bit 25) */
#define USBCTRL_REGS_ADDR_ENDP6_INTEP_DIR_Msk (0x2000000UL)         /*!< INTEP_DIR (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_ADDR_ENDP6_ENDPOINT_Pos (16UL)                 /*!< ENDPOINT (Bit 16) */
#define USBCTRL_REGS_ADDR_ENDP6_ENDPOINT_Msk (0xf0000UL)            /*!< ENDPOINT (Bitfield-Mask: 0x0f) */
#define USBCTRL_REGS_ADDR_ENDP6_ADDRESS_Pos (0UL)                   /*!< ADDRESS (Bit 0) */
#define USBCTRL_REGS_ADDR_ENDP6_ADDRESS_Msk (0x7fUL)                /*!< ADDRESS (Bitfield-Mask: 0x7f) */
/* ======================================================  ADDR_ENDP7  ======================================================= */
#define USBCTRL_REGS_ADDR_ENDP7_INTEP_PREAMBLE_Pos (26UL)           /*!< INTEP_PREAMBLE (Bit 26) */
#define USBCTRL_REGS_ADDR_ENDP7_INTEP_PREAMBLE_Msk (0x4000000UL)    /*!< INTEP_PREAMBLE (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_ADDR_ENDP7_INTEP_DIR_Pos (25UL)                /*!< INTEP_DIR (Bit 25) */
#define USBCTRL_REGS_ADDR_ENDP7_INTEP_DIR_Msk (0x2000000UL)         /*!< INTEP_DIR (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_ADDR_ENDP7_ENDPOINT_Pos (16UL)                 /*!< ENDPOINT (Bit 16) */
#define USBCTRL_REGS_ADDR_ENDP7_ENDPOINT_Msk (0xf0000UL)            /*!< ENDPOINT (Bitfield-Mask: 0x0f) */
#define USBCTRL_REGS_ADDR_ENDP7_ADDRESS_Pos (0UL)                   /*!< ADDRESS (Bit 0) */
#define USBCTRL_REGS_ADDR_ENDP7_ADDRESS_Msk (0x7fUL)                /*!< ADDRESS (Bitfield-Mask: 0x7f) */
/* ======================================================  ADDR_ENDP8  ======================================================= */
#define USBCTRL_REGS_ADDR_ENDP8_INTEP_PREAMBLE_Pos (26UL)           /*!< INTEP_PREAMBLE (Bit 26) */
#define USBCTRL_REGS_ADDR_ENDP8_INTEP_PREAMBLE_Msk (0x4000000UL)    /*!< INTEP_PREAMBLE (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_ADDR_ENDP8_INTEP_DIR_Pos (25UL)                /*!< INTEP_DIR (Bit 25) */
#define USBCTRL_REGS_ADDR_ENDP8_INTEP_DIR_Msk (0x2000000UL)         /*!< INTEP_DIR (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_ADDR_ENDP8_ENDPOINT_Pos (16UL)                 /*!< ENDPOINT (Bit 16) */
#define USBCTRL_REGS_ADDR_ENDP8_ENDPOINT_Msk (0xf0000UL)            /*!< ENDPOINT (Bitfield-Mask: 0x0f) */
#define USBCTRL_REGS_ADDR_ENDP8_ADDRESS_Pos (0UL)                   /*!< ADDRESS (Bit 0) */
#define USBCTRL_REGS_ADDR_ENDP8_ADDRESS_Msk (0x7fUL)                /*!< ADDRESS (Bitfield-Mask: 0x7f) */
/* ======================================================  ADDR_ENDP9  ======================================================= */
#define USBCTRL_REGS_ADDR_ENDP9_INTEP_PREAMBLE_Pos (26UL)           /*!< INTEP_PREAMBLE (Bit 26) */
#define USBCTRL_REGS_ADDR_ENDP9_INTEP_PREAMBLE_Msk (0x4000000UL)    /*!< INTEP_PREAMBLE (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_ADDR_ENDP9_INTEP_DIR_Pos (25UL)                /*!< INTEP_DIR (Bit 25) */
#define USBCTRL_REGS_ADDR_ENDP9_INTEP_DIR_Msk (0x2000000UL)         /*!< INTEP_DIR (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_ADDR_ENDP9_ENDPOINT_Pos (16UL)                 /*!< ENDPOINT (Bit 16) */
#define USBCTRL_REGS_ADDR_ENDP9_ENDPOINT_Msk (0xf0000UL)            /*!< ENDPOINT (Bitfield-Mask: 0x0f) */
#define USBCTRL_REGS_ADDR_ENDP9_ADDRESS_Pos (0UL)                   /*!< ADDRESS (Bit 0) */
#define USBCTRL_REGS_ADDR_ENDP9_ADDRESS_Msk (0x7fUL)                /*!< ADDRESS (Bitfield-Mask: 0x7f) */
/* ======================================================  ADDR_ENDP10  ====================================================== */
#define USBCTRL_REGS_ADDR_ENDP10_INTEP_PREAMBLE_Pos (26UL)          /*!< INTEP_PREAMBLE (Bit 26) */
#define USBCTRL_REGS_ADDR_ENDP10_INTEP_PREAMBLE_Msk (0x4000000UL)   /*!< INTEP_PREAMBLE (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_ADDR_ENDP10_INTEP_DIR_Pos (25UL)               /*!< INTEP_DIR (Bit 25) */
#define USBCTRL_REGS_ADDR_ENDP10_INTEP_DIR_Msk (0x2000000UL)        /*!< INTEP_DIR (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_ADDR_ENDP10_ENDPOINT_Pos (16UL)                /*!< ENDPOINT (Bit 16) */
#define USBCTRL_REGS_ADDR_ENDP10_ENDPOINT_Msk (0xf0000UL)           /*!< ENDPOINT (Bitfield-Mask: 0x0f) */
#define USBCTRL_REGS_ADDR_ENDP10_ADDRESS_Pos (0UL)                  /*!< ADDRESS (Bit 0) */
#define USBCTRL_REGS_ADDR_ENDP10_ADDRESS_Msk (0x7fUL)               /*!< ADDRESS (Bitfield-Mask: 0x7f) */
/* ======================================================  ADDR_ENDP11  ====================================================== */
#define USBCTRL_REGS_ADDR_ENDP11_INTEP_PREAMBLE_Pos (26UL)          /*!< INTEP_PREAMBLE (Bit 26) */
#define USBCTRL_REGS_ADDR_ENDP11_INTEP_PREAMBLE_Msk (0x4000000UL)   /*!< INTEP_PREAMBLE (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_ADDR_ENDP11_INTEP_DIR_Pos (25UL)               /*!< INTEP_DIR (Bit 25) */
#define USBCTRL_REGS_ADDR_ENDP11_INTEP_DIR_Msk (0x2000000UL)        /*!< INTEP_DIR (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_ADDR_ENDP11_ENDPOINT_Pos (16UL)                /*!< ENDPOINT (Bit 16) */
#define USBCTRL_REGS_ADDR_ENDP11_ENDPOINT_Msk (0xf0000UL)           /*!< ENDPOINT (Bitfield-Mask: 0x0f) */
#define USBCTRL_REGS_ADDR_ENDP11_ADDRESS_Pos (0UL)                  /*!< ADDRESS (Bit 0) */
#define USBCTRL_REGS_ADDR_ENDP11_ADDRESS_Msk (0x7fUL)               /*!< ADDRESS (Bitfield-Mask: 0x7f) */
/* ======================================================  ADDR_ENDP12  ====================================================== */
#define USBCTRL_REGS_ADDR_ENDP12_INTEP_PREAMBLE_Pos (26UL)          /*!< INTEP_PREAMBLE (Bit 26) */
#define USBCTRL_REGS_ADDR_ENDP12_INTEP_PREAMBLE_Msk (0x4000000UL)   /*!< INTEP_PREAMBLE (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_ADDR_ENDP12_INTEP_DIR_Pos (25UL)               /*!< INTEP_DIR (Bit 25) */
#define USBCTRL_REGS_ADDR_ENDP12_INTEP_DIR_Msk (0x2000000UL)        /*!< INTEP_DIR (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_ADDR_ENDP12_ENDPOINT_Pos (16UL)                /*!< ENDPOINT (Bit 16) */
#define USBCTRL_REGS_ADDR_ENDP12_ENDPOINT_Msk (0xf0000UL)           /*!< ENDPOINT (Bitfield-Mask: 0x0f) */
#define USBCTRL_REGS_ADDR_ENDP12_ADDRESS_Pos (0UL)                  /*!< ADDRESS (Bit 0) */
#define USBCTRL_REGS_ADDR_ENDP12_ADDRESS_Msk (0x7fUL)               /*!< ADDRESS (Bitfield-Mask: 0x7f) */
/* ======================================================  ADDR_ENDP13  ====================================================== */
#define USBCTRL_REGS_ADDR_ENDP13_INTEP_PREAMBLE_Pos (26UL)          /*!< INTEP_PREAMBLE (Bit 26) */
#define USBCTRL_REGS_ADDR_ENDP13_INTEP_PREAMBLE_Msk (0x4000000UL)   /*!< INTEP_PREAMBLE (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_ADDR_ENDP13_INTEP_DIR_Pos (25UL)               /*!< INTEP_DIR (Bit 25) */
#define USBCTRL_REGS_ADDR_ENDP13_INTEP_DIR_Msk (0x2000000UL)        /*!< INTEP_DIR (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_ADDR_ENDP13_ENDPOINT_Pos (16UL)                /*!< ENDPOINT (Bit 16) */
#define USBCTRL_REGS_ADDR_ENDP13_ENDPOINT_Msk (0xf0000UL)           /*!< ENDPOINT (Bitfield-Mask: 0x0f) */
#define USBCTRL_REGS_ADDR_ENDP13_ADDRESS_Pos (0UL)                  /*!< ADDRESS (Bit 0) */
#define USBCTRL_REGS_ADDR_ENDP13_ADDRESS_Msk (0x7fUL)               /*!< ADDRESS (Bitfield-Mask: 0x7f) */
/* ======================================================  ADDR_ENDP14  ====================================================== */
#define USBCTRL_REGS_ADDR_ENDP14_INTEP_PREAMBLE_Pos (26UL)          /*!< INTEP_PREAMBLE (Bit 26) */
#define USBCTRL_REGS_ADDR_ENDP14_INTEP_PREAMBLE_Msk (0x4000000UL)   /*!< INTEP_PREAMBLE (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_ADDR_ENDP14_INTEP_DIR_Pos (25UL)               /*!< INTEP_DIR (Bit 25) */
#define USBCTRL_REGS_ADDR_ENDP14_INTEP_DIR_Msk (0x2000000UL)        /*!< INTEP_DIR (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_ADDR_ENDP14_ENDPOINT_Pos (16UL)                /*!< ENDPOINT (Bit 16) */
#define USBCTRL_REGS_ADDR_ENDP14_ENDPOINT_Msk (0xf0000UL)           /*!< ENDPOINT (Bitfield-Mask: 0x0f) */
#define USBCTRL_REGS_ADDR_ENDP14_ADDRESS_Pos (0UL)                  /*!< ADDRESS (Bit 0) */
#define USBCTRL_REGS_ADDR_ENDP14_ADDRESS_Msk (0x7fUL)               /*!< ADDRESS (Bitfield-Mask: 0x7f) */
/* ======================================================  ADDR_ENDP15  ====================================================== */
#define USBCTRL_REGS_ADDR_ENDP15_INTEP_PREAMBLE_Pos (26UL)          /*!< INTEP_PREAMBLE (Bit 26) */
#define USBCTRL_REGS_ADDR_ENDP15_INTEP_PREAMBLE_Msk (0x4000000UL)   /*!< INTEP_PREAMBLE (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_ADDR_ENDP15_INTEP_DIR_Pos (25UL)               /*!< INTEP_DIR (Bit 25) */
#define USBCTRL_REGS_ADDR_ENDP15_INTEP_DIR_Msk (0x2000000UL)        /*!< INTEP_DIR (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_ADDR_ENDP15_ENDPOINT_Pos (16UL)                /*!< ENDPOINT (Bit 16) */
#define USBCTRL_REGS_ADDR_ENDP15_ENDPOINT_Msk (0xf0000UL)           /*!< ENDPOINT (Bitfield-Mask: 0x0f) */
#define USBCTRL_REGS_ADDR_ENDP15_ADDRESS_Pos (0UL)                  /*!< ADDRESS (Bit 0) */
#define USBCTRL_REGS_ADDR_ENDP15_ADDRESS_Msk (0x7fUL)               /*!< ADDRESS (Bitfield-Mask: 0x7f) */
/* =======================================================  MAIN_CTRL  ======================================================= */
#define USBCTRL_REGS_MAIN_CTRL_SIM_TIMING_Pos (31UL)                /*!< SIM_TIMING (Bit 31) */
#define USBCTRL_REGS_MAIN_CTRL_SIM_TIMING_Msk (0x80000000UL)        /*!< SIM_TIMING (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_MAIN_CTRL_HOST_NDEVICE_Pos (1UL)               /*!< HOST_NDEVICE (Bit 1) */
#define USBCTRL_REGS_MAIN_CTRL_HOST_NDEVICE_Msk (0x2UL)             /*!< HOST_NDEVICE (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_MAIN_CTRL_CONTROLLER_EN_Pos (0UL)              /*!< CONTROLLER_EN (Bit 0) */
#define USBCTRL_REGS_MAIN_CTRL_CONTROLLER_EN_Msk (0x1UL)            /*!< CONTROLLER_EN (Bitfield-Mask: 0x01) */
/* ========================================================  SOF_WR  ========================================================= */
#define USBCTRL_REGS_SOF_WR_COUNT_Pos     (0UL)                     /*!< COUNT (Bit 0) */
#define USBCTRL_REGS_SOF_WR_COUNT_Msk     (0x7ffUL)                 /*!< COUNT (Bitfield-Mask: 0x7ff) */
/* ========================================================  SOF_RD  ========================================================= */
#define USBCTRL_REGS_SOF_RD_COUNT_Pos     (0UL)                     /*!< COUNT (Bit 0) */
#define USBCTRL_REGS_SOF_RD_COUNT_Msk     (0x7ffUL)                 /*!< COUNT (Bitfield-Mask: 0x7ff) */
/* =======================================================  SIE_CTRL  ======================================================== */
#define USBCTRL_REGS_SIE_CTRL_EP0_INT_STALL_Pos (31UL)              /*!< EP0_INT_STALL (Bit 31) */
#define USBCTRL_REGS_SIE_CTRL_EP0_INT_STALL_Msk (0x80000000UL)      /*!< EP0_INT_STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_CTRL_EP0_DOUBLE_BUF_Pos (30UL)             /*!< EP0_DOUBLE_BUF (Bit 30) */
#define USBCTRL_REGS_SIE_CTRL_EP0_DOUBLE_BUF_Msk (0x40000000UL)     /*!< EP0_DOUBLE_BUF (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_CTRL_EP0_INT_1BUF_Pos (29UL)               /*!< EP0_INT_1BUF (Bit 29) */
#define USBCTRL_REGS_SIE_CTRL_EP0_INT_1BUF_Msk (0x20000000UL)       /*!< EP0_INT_1BUF (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_CTRL_EP0_INT_2BUF_Pos (28UL)               /*!< EP0_INT_2BUF (Bit 28) */
#define USBCTRL_REGS_SIE_CTRL_EP0_INT_2BUF_Msk (0x10000000UL)       /*!< EP0_INT_2BUF (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_CTRL_EP0_INT_NAK_Pos (27UL)                /*!< EP0_INT_NAK (Bit 27) */
#define USBCTRL_REGS_SIE_CTRL_EP0_INT_NAK_Msk (0x8000000UL)         /*!< EP0_INT_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_CTRL_DIRECT_EN_Pos (26UL)                  /*!< DIRECT_EN (Bit 26) */
#define USBCTRL_REGS_SIE_CTRL_DIRECT_EN_Msk (0x4000000UL)           /*!< DIRECT_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_CTRL_DIRECT_DP_Pos (25UL)                  /*!< DIRECT_DP (Bit 25) */
#define USBCTRL_REGS_SIE_CTRL_DIRECT_DP_Msk (0x2000000UL)           /*!< DIRECT_DP (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_CTRL_DIRECT_DM_Pos (24UL)                  /*!< DIRECT_DM (Bit 24) */
#define USBCTRL_REGS_SIE_CTRL_DIRECT_DM_Msk (0x1000000UL)           /*!< DIRECT_DM (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_CTRL_TRANSCEIVER_PD_Pos (18UL)             /*!< TRANSCEIVER_PD (Bit 18) */
#define USBCTRL_REGS_SIE_CTRL_TRANSCEIVER_PD_Msk (0x40000UL)        /*!< TRANSCEIVER_PD (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_CTRL_RPU_OPT_Pos (17UL)                    /*!< RPU_OPT (Bit 17) */
#define USBCTRL_REGS_SIE_CTRL_RPU_OPT_Msk (0x20000UL)               /*!< RPU_OPT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_CTRL_PULLUP_EN_Pos (16UL)                  /*!< PULLUP_EN (Bit 16) */
#define USBCTRL_REGS_SIE_CTRL_PULLUP_EN_Msk (0x10000UL)             /*!< PULLUP_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_CTRL_PULLDOWN_EN_Pos (15UL)                /*!< PULLDOWN_EN (Bit 15) */
#define USBCTRL_REGS_SIE_CTRL_PULLDOWN_EN_Msk (0x8000UL)            /*!< PULLDOWN_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_CTRL_RESET_BUS_Pos (13UL)                  /*!< RESET_BUS (Bit 13) */
#define USBCTRL_REGS_SIE_CTRL_RESET_BUS_Msk (0x2000UL)              /*!< RESET_BUS (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_CTRL_RESUME_Pos  (12UL)                    /*!< RESUME (Bit 12) */
#define USBCTRL_REGS_SIE_CTRL_RESUME_Msk  (0x1000UL)                /*!< RESUME (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_CTRL_VBUS_EN_Pos (11UL)                    /*!< VBUS_EN (Bit 11) */
#define USBCTRL_REGS_SIE_CTRL_VBUS_EN_Msk (0x800UL)                 /*!< VBUS_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_CTRL_KEEP_ALIVE_EN_Pos (10UL)              /*!< KEEP_ALIVE_EN (Bit 10) */
#define USBCTRL_REGS_SIE_CTRL_KEEP_ALIVE_EN_Msk (0x400UL)           /*!< KEEP_ALIVE_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_CTRL_SOF_EN_Pos  (9UL)                     /*!< SOF_EN (Bit 9) */
#define USBCTRL_REGS_SIE_CTRL_SOF_EN_Msk  (0x200UL)                 /*!< SOF_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_CTRL_SOF_SYNC_Pos (8UL)                    /*!< SOF_SYNC (Bit 8) */
#define USBCTRL_REGS_SIE_CTRL_SOF_SYNC_Msk (0x100UL)                /*!< SOF_SYNC (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_CTRL_PREAMBLE_EN_Pos (6UL)                 /*!< PREAMBLE_EN (Bit 6) */
#define USBCTRL_REGS_SIE_CTRL_PREAMBLE_EN_Msk (0x40UL)              /*!< PREAMBLE_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_CTRL_STOP_TRANS_Pos (4UL)                  /*!< STOP_TRANS (Bit 4) */
#define USBCTRL_REGS_SIE_CTRL_STOP_TRANS_Msk (0x10UL)               /*!< STOP_TRANS (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_CTRL_RECEIVE_DATA_Pos (3UL)                /*!< RECEIVE_DATA (Bit 3) */
#define USBCTRL_REGS_SIE_CTRL_RECEIVE_DATA_Msk (0x8UL)              /*!< RECEIVE_DATA (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_CTRL_SEND_DATA_Pos (2UL)                   /*!< SEND_DATA (Bit 2) */
#define USBCTRL_REGS_SIE_CTRL_SEND_DATA_Msk (0x4UL)                 /*!< SEND_DATA (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_CTRL_SEND_SETUP_Pos (1UL)                  /*!< SEND_SETUP (Bit 1) */
#define USBCTRL_REGS_SIE_CTRL_SEND_SETUP_Msk (0x2UL)                /*!< SEND_SETUP (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_CTRL_START_TRANS_Pos (0UL)                 /*!< START_TRANS (Bit 0) */
#define USBCTRL_REGS_SIE_CTRL_START_TRANS_Msk (0x1UL)               /*!< START_TRANS (Bitfield-Mask: 0x01) */
/* ======================================================  SIE_STATUS  ======================================================= */
#define USBCTRL_REGS_SIE_STATUS_DATA_SEQ_ERROR_Pos (31UL)           /*!< DATA_SEQ_ERROR (Bit 31) */
#define USBCTRL_REGS_SIE_STATUS_DATA_SEQ_ERROR_Msk (0x80000000UL)   /*!< DATA_SEQ_ERROR (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_STATUS_ACK_REC_Pos (30UL)                  /*!< ACK_REC (Bit 30) */
#define USBCTRL_REGS_SIE_STATUS_ACK_REC_Msk (0x40000000UL)          /*!< ACK_REC (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_STATUS_STALL_REC_Pos (29UL)                /*!< STALL_REC (Bit 29) */
#define USBCTRL_REGS_SIE_STATUS_STALL_REC_Msk (0x20000000UL)        /*!< STALL_REC (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_STATUS_NAK_REC_Pos (28UL)                  /*!< NAK_REC (Bit 28) */
#define USBCTRL_REGS_SIE_STATUS_NAK_REC_Msk (0x10000000UL)          /*!< NAK_REC (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_STATUS_RX_TIMEOUT_Pos (27UL)               /*!< RX_TIMEOUT (Bit 27) */
#define USBCTRL_REGS_SIE_STATUS_RX_TIMEOUT_Msk (0x8000000UL)        /*!< RX_TIMEOUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_STATUS_RX_OVERFLOW_Pos (26UL)              /*!< RX_OVERFLOW (Bit 26) */
#define USBCTRL_REGS_SIE_STATUS_RX_OVERFLOW_Msk (0x4000000UL)       /*!< RX_OVERFLOW (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_STATUS_BIT_STUFF_ERROR_Pos (25UL)          /*!< BIT_STUFF_ERROR (Bit 25) */
#define USBCTRL_REGS_SIE_STATUS_BIT_STUFF_ERROR_Msk (0x2000000UL)   /*!< BIT_STUFF_ERROR (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_STATUS_CRC_ERROR_Pos (24UL)                /*!< CRC_ERROR (Bit 24) */
#define USBCTRL_REGS_SIE_STATUS_CRC_ERROR_Msk (0x1000000UL)         /*!< CRC_ERROR (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_STATUS_BUS_RESET_Pos (19UL)                /*!< BUS_RESET (Bit 19) */
#define USBCTRL_REGS_SIE_STATUS_BUS_RESET_Msk (0x80000UL)           /*!< BUS_RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_STATUS_TRANS_COMPLETE_Pos (18UL)           /*!< TRANS_COMPLETE (Bit 18) */
#define USBCTRL_REGS_SIE_STATUS_TRANS_COMPLETE_Msk (0x40000UL)      /*!< TRANS_COMPLETE (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_STATUS_SETUP_REC_Pos (17UL)                /*!< SETUP_REC (Bit 17) */
#define USBCTRL_REGS_SIE_STATUS_SETUP_REC_Msk (0x20000UL)           /*!< SETUP_REC (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_STATUS_CONNECTED_Pos (16UL)                /*!< CONNECTED (Bit 16) */
#define USBCTRL_REGS_SIE_STATUS_CONNECTED_Msk (0x10000UL)           /*!< CONNECTED (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_STATUS_RESUME_Pos (11UL)                   /*!< RESUME (Bit 11) */
#define USBCTRL_REGS_SIE_STATUS_RESUME_Msk (0x800UL)                /*!< RESUME (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_STATUS_VBUS_OVER_CURR_Pos (10UL)           /*!< VBUS_OVER_CURR (Bit 10) */
#define USBCTRL_REGS_SIE_STATUS_VBUS_OVER_CURR_Msk (0x400UL)        /*!< VBUS_OVER_CURR (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_STATUS_SPEED_Pos (8UL)                     /*!< SPEED (Bit 8) */
#define USBCTRL_REGS_SIE_STATUS_SPEED_Msk (0x300UL)                 /*!< SPEED (Bitfield-Mask: 0x03) */
#define USBCTRL_REGS_SIE_STATUS_SUSPENDED_Pos (4UL)                 /*!< SUSPENDED (Bit 4) */
#define USBCTRL_REGS_SIE_STATUS_SUSPENDED_Msk (0x10UL)              /*!< SUSPENDED (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_SIE_STATUS_LINE_STATE_Pos (2UL)                /*!< LINE_STATE (Bit 2) */
#define USBCTRL_REGS_SIE_STATUS_LINE_STATE_Msk (0xcUL)              /*!< LINE_STATE (Bitfield-Mask: 0x03) */
#define USBCTRL_REGS_SIE_STATUS_VBUS_DETECTED_Pos (0UL)             /*!< VBUS_DETECTED (Bit 0) */
#define USBCTRL_REGS_SIE_STATUS_VBUS_DETECTED_Msk (0x1UL)           /*!< VBUS_DETECTED (Bitfield-Mask: 0x01) */
/* ======================================================  INT_EP_CTRL  ====================================================== */
#define USBCTRL_REGS_INT_EP_CTRL_INT_EP_ACTIVE_Pos (1UL)            /*!< INT_EP_ACTIVE (Bit 1) */
#define USBCTRL_REGS_INT_EP_CTRL_INT_EP_ACTIVE_Msk (0xfffeUL)       /*!< INT_EP_ACTIVE (Bitfield-Mask: 0x7fff) */
/* ======================================================  BUFF_STATUS  ====================================================== */
#define USBCTRL_REGS_BUFF_STATUS_EP15_OUT_Pos (31UL)                /*!< EP15_OUT (Bit 31) */
#define USBCTRL_REGS_BUFF_STATUS_EP15_OUT_Msk (0x80000000UL)        /*!< EP15_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP15_IN_Pos (30UL)                 /*!< EP15_IN (Bit 30) */
#define USBCTRL_REGS_BUFF_STATUS_EP15_IN_Msk (0x40000000UL)         /*!< EP15_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP14_OUT_Pos (29UL)                /*!< EP14_OUT (Bit 29) */
#define USBCTRL_REGS_BUFF_STATUS_EP14_OUT_Msk (0x20000000UL)        /*!< EP14_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP14_IN_Pos (28UL)                 /*!< EP14_IN (Bit 28) */
#define USBCTRL_REGS_BUFF_STATUS_EP14_IN_Msk (0x10000000UL)         /*!< EP14_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP13_OUT_Pos (27UL)                /*!< EP13_OUT (Bit 27) */
#define USBCTRL_REGS_BUFF_STATUS_EP13_OUT_Msk (0x8000000UL)         /*!< EP13_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP13_IN_Pos (26UL)                 /*!< EP13_IN (Bit 26) */
#define USBCTRL_REGS_BUFF_STATUS_EP13_IN_Msk (0x4000000UL)          /*!< EP13_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP12_OUT_Pos (25UL)                /*!< EP12_OUT (Bit 25) */
#define USBCTRL_REGS_BUFF_STATUS_EP12_OUT_Msk (0x2000000UL)         /*!< EP12_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP12_IN_Pos (24UL)                 /*!< EP12_IN (Bit 24) */
#define USBCTRL_REGS_BUFF_STATUS_EP12_IN_Msk (0x1000000UL)          /*!< EP12_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP11_OUT_Pos (23UL)                /*!< EP11_OUT (Bit 23) */
#define USBCTRL_REGS_BUFF_STATUS_EP11_OUT_Msk (0x800000UL)          /*!< EP11_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP11_IN_Pos (22UL)                 /*!< EP11_IN (Bit 22) */
#define USBCTRL_REGS_BUFF_STATUS_EP11_IN_Msk (0x400000UL)           /*!< EP11_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP10_OUT_Pos (21UL)                /*!< EP10_OUT (Bit 21) */
#define USBCTRL_REGS_BUFF_STATUS_EP10_OUT_Msk (0x200000UL)          /*!< EP10_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP10_IN_Pos (20UL)                 /*!< EP10_IN (Bit 20) */
#define USBCTRL_REGS_BUFF_STATUS_EP10_IN_Msk (0x100000UL)           /*!< EP10_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP9_OUT_Pos (19UL)                 /*!< EP9_OUT (Bit 19) */
#define USBCTRL_REGS_BUFF_STATUS_EP9_OUT_Msk (0x80000UL)            /*!< EP9_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP9_IN_Pos (18UL)                  /*!< EP9_IN (Bit 18) */
#define USBCTRL_REGS_BUFF_STATUS_EP9_IN_Msk (0x40000UL)             /*!< EP9_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP8_OUT_Pos (17UL)                 /*!< EP8_OUT (Bit 17) */
#define USBCTRL_REGS_BUFF_STATUS_EP8_OUT_Msk (0x20000UL)            /*!< EP8_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP8_IN_Pos (16UL)                  /*!< EP8_IN (Bit 16) */
#define USBCTRL_REGS_BUFF_STATUS_EP8_IN_Msk (0x10000UL)             /*!< EP8_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP7_OUT_Pos (15UL)                 /*!< EP7_OUT (Bit 15) */
#define USBCTRL_REGS_BUFF_STATUS_EP7_OUT_Msk (0x8000UL)             /*!< EP7_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP7_IN_Pos (14UL)                  /*!< EP7_IN (Bit 14) */
#define USBCTRL_REGS_BUFF_STATUS_EP7_IN_Msk (0x4000UL)              /*!< EP7_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP6_OUT_Pos (13UL)                 /*!< EP6_OUT (Bit 13) */
#define USBCTRL_REGS_BUFF_STATUS_EP6_OUT_Msk (0x2000UL)             /*!< EP6_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP6_IN_Pos (12UL)                  /*!< EP6_IN (Bit 12) */
#define USBCTRL_REGS_BUFF_STATUS_EP6_IN_Msk (0x1000UL)              /*!< EP6_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP5_OUT_Pos (11UL)                 /*!< EP5_OUT (Bit 11) */
#define USBCTRL_REGS_BUFF_STATUS_EP5_OUT_Msk (0x800UL)              /*!< EP5_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP5_IN_Pos (10UL)                  /*!< EP5_IN (Bit 10) */
#define USBCTRL_REGS_BUFF_STATUS_EP5_IN_Msk (0x400UL)               /*!< EP5_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP4_OUT_Pos (9UL)                  /*!< EP4_OUT (Bit 9) */
#define USBCTRL_REGS_BUFF_STATUS_EP4_OUT_Msk (0x200UL)              /*!< EP4_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP4_IN_Pos (8UL)                   /*!< EP4_IN (Bit 8) */
#define USBCTRL_REGS_BUFF_STATUS_EP4_IN_Msk (0x100UL)               /*!< EP4_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP3_OUT_Pos (7UL)                  /*!< EP3_OUT (Bit 7) */
#define USBCTRL_REGS_BUFF_STATUS_EP3_OUT_Msk (0x80UL)               /*!< EP3_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP3_IN_Pos (6UL)                   /*!< EP3_IN (Bit 6) */
#define USBCTRL_REGS_BUFF_STATUS_EP3_IN_Msk (0x40UL)                /*!< EP3_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP2_OUT_Pos (5UL)                  /*!< EP2_OUT (Bit 5) */
#define USBCTRL_REGS_BUFF_STATUS_EP2_OUT_Msk (0x20UL)               /*!< EP2_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP2_IN_Pos (4UL)                   /*!< EP2_IN (Bit 4) */
#define USBCTRL_REGS_BUFF_STATUS_EP2_IN_Msk (0x10UL)                /*!< EP2_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP1_OUT_Pos (3UL)                  /*!< EP1_OUT (Bit 3) */
#define USBCTRL_REGS_BUFF_STATUS_EP1_OUT_Msk (0x8UL)                /*!< EP1_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP1_IN_Pos (2UL)                   /*!< EP1_IN (Bit 2) */
#define USBCTRL_REGS_BUFF_STATUS_EP1_IN_Msk (0x4UL)                 /*!< EP1_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP0_OUT_Pos (1UL)                  /*!< EP0_OUT (Bit 1) */
#define USBCTRL_REGS_BUFF_STATUS_EP0_OUT_Msk (0x2UL)                /*!< EP0_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_STATUS_EP0_IN_Pos (0UL)                   /*!< EP0_IN (Bit 0) */
#define USBCTRL_REGS_BUFF_STATUS_EP0_IN_Msk (0x1UL)                 /*!< EP0_IN (Bitfield-Mask: 0x01) */
/* ================================================  BUFF_CPU_SHOULD_HANDLE  ================================================= */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP15_OUT_Pos (31UL)     /*!< EP15_OUT (Bit 31) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP15_OUT_Msk (0x80000000UL) /*!< EP15_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP15_IN_Pos (30UL)      /*!< EP15_IN (Bit 30) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP15_IN_Msk (0x40000000UL) /*!< EP15_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP14_OUT_Pos (29UL)     /*!< EP14_OUT (Bit 29) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP14_OUT_Msk (0x20000000UL) /*!< EP14_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP14_IN_Pos (28UL)      /*!< EP14_IN (Bit 28) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP14_IN_Msk (0x10000000UL) /*!< EP14_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP13_OUT_Pos (27UL)     /*!< EP13_OUT (Bit 27) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP13_OUT_Msk (0x8000000UL) /*!< EP13_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP13_IN_Pos (26UL)      /*!< EP13_IN (Bit 26) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP13_IN_Msk (0x4000000UL) /*!< EP13_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP12_OUT_Pos (25UL)     /*!< EP12_OUT (Bit 25) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP12_OUT_Msk (0x2000000UL) /*!< EP12_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP12_IN_Pos (24UL)      /*!< EP12_IN (Bit 24) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP12_IN_Msk (0x1000000UL) /*!< EP12_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP11_OUT_Pos (23UL)     /*!< EP11_OUT (Bit 23) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP11_OUT_Msk (0x800000UL) /*!< EP11_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP11_IN_Pos (22UL)      /*!< EP11_IN (Bit 22) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP11_IN_Msk (0x400000UL) /*!< EP11_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP10_OUT_Pos (21UL)     /*!< EP10_OUT (Bit 21) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP10_OUT_Msk (0x200000UL) /*!< EP10_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP10_IN_Pos (20UL)      /*!< EP10_IN (Bit 20) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP10_IN_Msk (0x100000UL) /*!< EP10_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP9_OUT_Pos (19UL)      /*!< EP9_OUT (Bit 19) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP9_OUT_Msk (0x80000UL) /*!< EP9_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP9_IN_Pos (18UL)       /*!< EP9_IN (Bit 18) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP9_IN_Msk (0x40000UL)  /*!< EP9_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP8_OUT_Pos (17UL)      /*!< EP8_OUT (Bit 17) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP8_OUT_Msk (0x20000UL) /*!< EP8_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP8_IN_Pos (16UL)       /*!< EP8_IN (Bit 16) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP8_IN_Msk (0x10000UL)  /*!< EP8_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP7_OUT_Pos (15UL)      /*!< EP7_OUT (Bit 15) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP7_OUT_Msk (0x8000UL)  /*!< EP7_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP7_IN_Pos (14UL)       /*!< EP7_IN (Bit 14) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP7_IN_Msk (0x4000UL)   /*!< EP7_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP6_OUT_Pos (13UL)      /*!< EP6_OUT (Bit 13) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP6_OUT_Msk (0x2000UL)  /*!< EP6_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP6_IN_Pos (12UL)       /*!< EP6_IN (Bit 12) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP6_IN_Msk (0x1000UL)   /*!< EP6_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP5_OUT_Pos (11UL)      /*!< EP5_OUT (Bit 11) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP5_OUT_Msk (0x800UL)   /*!< EP5_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP5_IN_Pos (10UL)       /*!< EP5_IN (Bit 10) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP5_IN_Msk (0x400UL)    /*!< EP5_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP4_OUT_Pos (9UL)       /*!< EP4_OUT (Bit 9) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP4_OUT_Msk (0x200UL)   /*!< EP4_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP4_IN_Pos (8UL)        /*!< EP4_IN (Bit 8) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP4_IN_Msk (0x100UL)    /*!< EP4_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP3_OUT_Pos (7UL)       /*!< EP3_OUT (Bit 7) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP3_OUT_Msk (0x80UL)    /*!< EP3_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP3_IN_Pos (6UL)        /*!< EP3_IN (Bit 6) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP3_IN_Msk (0x40UL)     /*!< EP3_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP2_OUT_Pos (5UL)       /*!< EP2_OUT (Bit 5) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP2_OUT_Msk (0x20UL)    /*!< EP2_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP2_IN_Pos (4UL)        /*!< EP2_IN (Bit 4) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP2_IN_Msk (0x10UL)     /*!< EP2_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP1_OUT_Pos (3UL)       /*!< EP1_OUT (Bit 3) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP1_OUT_Msk (0x8UL)     /*!< EP1_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP1_IN_Pos (2UL)        /*!< EP1_IN (Bit 2) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP1_IN_Msk (0x4UL)      /*!< EP1_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP0_OUT_Pos (1UL)       /*!< EP0_OUT (Bit 1) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP0_OUT_Msk (0x2UL)     /*!< EP0_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP0_IN_Pos (0UL)        /*!< EP0_IN (Bit 0) */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP0_IN_Msk (0x1UL)      /*!< EP0_IN (Bitfield-Mask: 0x01) */
/* =======================================================  EP_ABORT  ======================================================== */
#define USBCTRL_REGS_EP_ABORT_EP15_OUT_Pos (31UL)                   /*!< EP15_OUT (Bit 31) */
#define USBCTRL_REGS_EP_ABORT_EP15_OUT_Msk (0x80000000UL)           /*!< EP15_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP15_IN_Pos (30UL)                    /*!< EP15_IN (Bit 30) */
#define USBCTRL_REGS_EP_ABORT_EP15_IN_Msk (0x40000000UL)            /*!< EP15_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP14_OUT_Pos (29UL)                   /*!< EP14_OUT (Bit 29) */
#define USBCTRL_REGS_EP_ABORT_EP14_OUT_Msk (0x20000000UL)           /*!< EP14_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP14_IN_Pos (28UL)                    /*!< EP14_IN (Bit 28) */
#define USBCTRL_REGS_EP_ABORT_EP14_IN_Msk (0x10000000UL)            /*!< EP14_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP13_OUT_Pos (27UL)                   /*!< EP13_OUT (Bit 27) */
#define USBCTRL_REGS_EP_ABORT_EP13_OUT_Msk (0x8000000UL)            /*!< EP13_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP13_IN_Pos (26UL)                    /*!< EP13_IN (Bit 26) */
#define USBCTRL_REGS_EP_ABORT_EP13_IN_Msk (0x4000000UL)             /*!< EP13_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP12_OUT_Pos (25UL)                   /*!< EP12_OUT (Bit 25) */
#define USBCTRL_REGS_EP_ABORT_EP12_OUT_Msk (0x2000000UL)            /*!< EP12_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP12_IN_Pos (24UL)                    /*!< EP12_IN (Bit 24) */
#define USBCTRL_REGS_EP_ABORT_EP12_IN_Msk (0x1000000UL)             /*!< EP12_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP11_OUT_Pos (23UL)                   /*!< EP11_OUT (Bit 23) */
#define USBCTRL_REGS_EP_ABORT_EP11_OUT_Msk (0x800000UL)             /*!< EP11_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP11_IN_Pos (22UL)                    /*!< EP11_IN (Bit 22) */
#define USBCTRL_REGS_EP_ABORT_EP11_IN_Msk (0x400000UL)              /*!< EP11_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP10_OUT_Pos (21UL)                   /*!< EP10_OUT (Bit 21) */
#define USBCTRL_REGS_EP_ABORT_EP10_OUT_Msk (0x200000UL)             /*!< EP10_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP10_IN_Pos (20UL)                    /*!< EP10_IN (Bit 20) */
#define USBCTRL_REGS_EP_ABORT_EP10_IN_Msk (0x100000UL)              /*!< EP10_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP9_OUT_Pos (19UL)                    /*!< EP9_OUT (Bit 19) */
#define USBCTRL_REGS_EP_ABORT_EP9_OUT_Msk (0x80000UL)               /*!< EP9_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP9_IN_Pos  (18UL)                    /*!< EP9_IN (Bit 18) */
#define USBCTRL_REGS_EP_ABORT_EP9_IN_Msk  (0x40000UL)               /*!< EP9_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP8_OUT_Pos (17UL)                    /*!< EP8_OUT (Bit 17) */
#define USBCTRL_REGS_EP_ABORT_EP8_OUT_Msk (0x20000UL)               /*!< EP8_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP8_IN_Pos  (16UL)                    /*!< EP8_IN (Bit 16) */
#define USBCTRL_REGS_EP_ABORT_EP8_IN_Msk  (0x10000UL)               /*!< EP8_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP7_OUT_Pos (15UL)                    /*!< EP7_OUT (Bit 15) */
#define USBCTRL_REGS_EP_ABORT_EP7_OUT_Msk (0x8000UL)                /*!< EP7_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP7_IN_Pos  (14UL)                    /*!< EP7_IN (Bit 14) */
#define USBCTRL_REGS_EP_ABORT_EP7_IN_Msk  (0x4000UL)                /*!< EP7_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP6_OUT_Pos (13UL)                    /*!< EP6_OUT (Bit 13) */
#define USBCTRL_REGS_EP_ABORT_EP6_OUT_Msk (0x2000UL)                /*!< EP6_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP6_IN_Pos  (12UL)                    /*!< EP6_IN (Bit 12) */
#define USBCTRL_REGS_EP_ABORT_EP6_IN_Msk  (0x1000UL)                /*!< EP6_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP5_OUT_Pos (11UL)                    /*!< EP5_OUT (Bit 11) */
#define USBCTRL_REGS_EP_ABORT_EP5_OUT_Msk (0x800UL)                 /*!< EP5_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP5_IN_Pos  (10UL)                    /*!< EP5_IN (Bit 10) */
#define USBCTRL_REGS_EP_ABORT_EP5_IN_Msk  (0x400UL)                 /*!< EP5_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP4_OUT_Pos (9UL)                     /*!< EP4_OUT (Bit 9) */
#define USBCTRL_REGS_EP_ABORT_EP4_OUT_Msk (0x200UL)                 /*!< EP4_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP4_IN_Pos  (8UL)                     /*!< EP4_IN (Bit 8) */
#define USBCTRL_REGS_EP_ABORT_EP4_IN_Msk  (0x100UL)                 /*!< EP4_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP3_OUT_Pos (7UL)                     /*!< EP3_OUT (Bit 7) */
#define USBCTRL_REGS_EP_ABORT_EP3_OUT_Msk (0x80UL)                  /*!< EP3_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP3_IN_Pos  (6UL)                     /*!< EP3_IN (Bit 6) */
#define USBCTRL_REGS_EP_ABORT_EP3_IN_Msk  (0x40UL)                  /*!< EP3_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP2_OUT_Pos (5UL)                     /*!< EP2_OUT (Bit 5) */
#define USBCTRL_REGS_EP_ABORT_EP2_OUT_Msk (0x20UL)                  /*!< EP2_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP2_IN_Pos  (4UL)                     /*!< EP2_IN (Bit 4) */
#define USBCTRL_REGS_EP_ABORT_EP2_IN_Msk  (0x10UL)                  /*!< EP2_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP1_OUT_Pos (3UL)                     /*!< EP1_OUT (Bit 3) */
#define USBCTRL_REGS_EP_ABORT_EP1_OUT_Msk (0x8UL)                   /*!< EP1_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP1_IN_Pos  (2UL)                     /*!< EP1_IN (Bit 2) */
#define USBCTRL_REGS_EP_ABORT_EP1_IN_Msk  (0x4UL)                   /*!< EP1_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP0_OUT_Pos (1UL)                     /*!< EP0_OUT (Bit 1) */
#define USBCTRL_REGS_EP_ABORT_EP0_OUT_Msk (0x2UL)                   /*!< EP0_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_EP0_IN_Pos  (0UL)                     /*!< EP0_IN (Bit 0) */
#define USBCTRL_REGS_EP_ABORT_EP0_IN_Msk  (0x1UL)                   /*!< EP0_IN (Bitfield-Mask: 0x01) */
/* =====================================================  EP_ABORT_DONE  ===================================================== */
#define USBCTRL_REGS_EP_ABORT_DONE_EP15_OUT_Pos (31UL)              /*!< EP15_OUT (Bit 31) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP15_OUT_Msk (0x80000000UL)      /*!< EP15_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP15_IN_Pos (30UL)               /*!< EP15_IN (Bit 30) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP15_IN_Msk (0x40000000UL)       /*!< EP15_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP14_OUT_Pos (29UL)              /*!< EP14_OUT (Bit 29) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP14_OUT_Msk (0x20000000UL)      /*!< EP14_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP14_IN_Pos (28UL)               /*!< EP14_IN (Bit 28) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP14_IN_Msk (0x10000000UL)       /*!< EP14_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP13_OUT_Pos (27UL)              /*!< EP13_OUT (Bit 27) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP13_OUT_Msk (0x8000000UL)       /*!< EP13_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP13_IN_Pos (26UL)               /*!< EP13_IN (Bit 26) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP13_IN_Msk (0x4000000UL)        /*!< EP13_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP12_OUT_Pos (25UL)              /*!< EP12_OUT (Bit 25) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP12_OUT_Msk (0x2000000UL)       /*!< EP12_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP12_IN_Pos (24UL)               /*!< EP12_IN (Bit 24) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP12_IN_Msk (0x1000000UL)        /*!< EP12_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP11_OUT_Pos (23UL)              /*!< EP11_OUT (Bit 23) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP11_OUT_Msk (0x800000UL)        /*!< EP11_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP11_IN_Pos (22UL)               /*!< EP11_IN (Bit 22) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP11_IN_Msk (0x400000UL)         /*!< EP11_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP10_OUT_Pos (21UL)              /*!< EP10_OUT (Bit 21) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP10_OUT_Msk (0x200000UL)        /*!< EP10_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP10_IN_Pos (20UL)               /*!< EP10_IN (Bit 20) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP10_IN_Msk (0x100000UL)         /*!< EP10_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP9_OUT_Pos (19UL)               /*!< EP9_OUT (Bit 19) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP9_OUT_Msk (0x80000UL)          /*!< EP9_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP9_IN_Pos (18UL)                /*!< EP9_IN (Bit 18) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP9_IN_Msk (0x40000UL)           /*!< EP9_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP8_OUT_Pos (17UL)               /*!< EP8_OUT (Bit 17) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP8_OUT_Msk (0x20000UL)          /*!< EP8_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP8_IN_Pos (16UL)                /*!< EP8_IN (Bit 16) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP8_IN_Msk (0x10000UL)           /*!< EP8_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP7_OUT_Pos (15UL)               /*!< EP7_OUT (Bit 15) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP7_OUT_Msk (0x8000UL)           /*!< EP7_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP7_IN_Pos (14UL)                /*!< EP7_IN (Bit 14) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP7_IN_Msk (0x4000UL)            /*!< EP7_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP6_OUT_Pos (13UL)               /*!< EP6_OUT (Bit 13) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP6_OUT_Msk (0x2000UL)           /*!< EP6_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP6_IN_Pos (12UL)                /*!< EP6_IN (Bit 12) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP6_IN_Msk (0x1000UL)            /*!< EP6_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP5_OUT_Pos (11UL)               /*!< EP5_OUT (Bit 11) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP5_OUT_Msk (0x800UL)            /*!< EP5_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP5_IN_Pos (10UL)                /*!< EP5_IN (Bit 10) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP5_IN_Msk (0x400UL)             /*!< EP5_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP4_OUT_Pos (9UL)                /*!< EP4_OUT (Bit 9) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP4_OUT_Msk (0x200UL)            /*!< EP4_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP4_IN_Pos (8UL)                 /*!< EP4_IN (Bit 8) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP4_IN_Msk (0x100UL)             /*!< EP4_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP3_OUT_Pos (7UL)                /*!< EP3_OUT (Bit 7) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP3_OUT_Msk (0x80UL)             /*!< EP3_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP3_IN_Pos (6UL)                 /*!< EP3_IN (Bit 6) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP3_IN_Msk (0x40UL)              /*!< EP3_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP2_OUT_Pos (5UL)                /*!< EP2_OUT (Bit 5) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP2_OUT_Msk (0x20UL)             /*!< EP2_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP2_IN_Pos (4UL)                 /*!< EP2_IN (Bit 4) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP2_IN_Msk (0x10UL)              /*!< EP2_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP1_OUT_Pos (3UL)                /*!< EP1_OUT (Bit 3) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP1_OUT_Msk (0x8UL)              /*!< EP1_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP1_IN_Pos (2UL)                 /*!< EP1_IN (Bit 2) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP1_IN_Msk (0x4UL)               /*!< EP1_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP0_OUT_Pos (1UL)                /*!< EP0_OUT (Bit 1) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP0_OUT_Msk (0x2UL)              /*!< EP0_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP0_IN_Pos (0UL)                 /*!< EP0_IN (Bit 0) */
#define USBCTRL_REGS_EP_ABORT_DONE_EP0_IN_Msk (0x1UL)               /*!< EP0_IN (Bitfield-Mask: 0x01) */
/* =====================================================  EP_STALL_ARM  ====================================================== */
#define USBCTRL_REGS_EP_STALL_ARM_EP0_OUT_Pos (1UL)                 /*!< EP0_OUT (Bit 1) */
#define USBCTRL_REGS_EP_STALL_ARM_EP0_OUT_Msk (0x2UL)               /*!< EP0_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STALL_ARM_EP0_IN_Pos (0UL)                  /*!< EP0_IN (Bit 0) */
#define USBCTRL_REGS_EP_STALL_ARM_EP0_IN_Msk (0x1UL)                /*!< EP0_IN (Bitfield-Mask: 0x01) */
/* =======================================================  NAK_POLL  ======================================================== */
#define USBCTRL_REGS_NAK_POLL_DELAY_FS_Pos (16UL)                   /*!< DELAY_FS (Bit 16) */
#define USBCTRL_REGS_NAK_POLL_DELAY_FS_Msk (0x3ff0000UL)            /*!< DELAY_FS (Bitfield-Mask: 0x3ff) */
#define USBCTRL_REGS_NAK_POLL_DELAY_LS_Pos (0UL)                    /*!< DELAY_LS (Bit 0) */
#define USBCTRL_REGS_NAK_POLL_DELAY_LS_Msk (0x3ffUL)                /*!< DELAY_LS (Bitfield-Mask: 0x3ff) */
/* ==================================================  EP_STATUS_STALL_NAK  ================================================== */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP15_OUT_Pos (31UL)        /*!< EP15_OUT (Bit 31) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP15_OUT_Msk (0x80000000UL) /*!< EP15_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP15_IN_Pos (30UL)         /*!< EP15_IN (Bit 30) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP15_IN_Msk (0x40000000UL) /*!< EP15_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP14_OUT_Pos (29UL)        /*!< EP14_OUT (Bit 29) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP14_OUT_Msk (0x20000000UL) /*!< EP14_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP14_IN_Pos (28UL)         /*!< EP14_IN (Bit 28) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP14_IN_Msk (0x10000000UL) /*!< EP14_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP13_OUT_Pos (27UL)        /*!< EP13_OUT (Bit 27) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP13_OUT_Msk (0x8000000UL) /*!< EP13_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP13_IN_Pos (26UL)         /*!< EP13_IN (Bit 26) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP13_IN_Msk (0x4000000UL)  /*!< EP13_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP12_OUT_Pos (25UL)        /*!< EP12_OUT (Bit 25) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP12_OUT_Msk (0x2000000UL) /*!< EP12_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP12_IN_Pos (24UL)         /*!< EP12_IN (Bit 24) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP12_IN_Msk (0x1000000UL)  /*!< EP12_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP11_OUT_Pos (23UL)        /*!< EP11_OUT (Bit 23) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP11_OUT_Msk (0x800000UL)  /*!< EP11_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP11_IN_Pos (22UL)         /*!< EP11_IN (Bit 22) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP11_IN_Msk (0x400000UL)   /*!< EP11_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP10_OUT_Pos (21UL)        /*!< EP10_OUT (Bit 21) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP10_OUT_Msk (0x200000UL)  /*!< EP10_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP10_IN_Pos (20UL)         /*!< EP10_IN (Bit 20) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP10_IN_Msk (0x100000UL)   /*!< EP10_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP9_OUT_Pos (19UL)         /*!< EP9_OUT (Bit 19) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP9_OUT_Msk (0x80000UL)    /*!< EP9_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP9_IN_Pos (18UL)          /*!< EP9_IN (Bit 18) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP9_IN_Msk (0x40000UL)     /*!< EP9_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP8_OUT_Pos (17UL)         /*!< EP8_OUT (Bit 17) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP8_OUT_Msk (0x20000UL)    /*!< EP8_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP8_IN_Pos (16UL)          /*!< EP8_IN (Bit 16) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP8_IN_Msk (0x10000UL)     /*!< EP8_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP7_OUT_Pos (15UL)         /*!< EP7_OUT (Bit 15) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP7_OUT_Msk (0x8000UL)     /*!< EP7_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP7_IN_Pos (14UL)          /*!< EP7_IN (Bit 14) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP7_IN_Msk (0x4000UL)      /*!< EP7_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP6_OUT_Pos (13UL)         /*!< EP6_OUT (Bit 13) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP6_OUT_Msk (0x2000UL)     /*!< EP6_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP6_IN_Pos (12UL)          /*!< EP6_IN (Bit 12) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP6_IN_Msk (0x1000UL)      /*!< EP6_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP5_OUT_Pos (11UL)         /*!< EP5_OUT (Bit 11) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP5_OUT_Msk (0x800UL)      /*!< EP5_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP5_IN_Pos (10UL)          /*!< EP5_IN (Bit 10) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP5_IN_Msk (0x400UL)       /*!< EP5_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP4_OUT_Pos (9UL)          /*!< EP4_OUT (Bit 9) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP4_OUT_Msk (0x200UL)      /*!< EP4_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP4_IN_Pos (8UL)           /*!< EP4_IN (Bit 8) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP4_IN_Msk (0x100UL)       /*!< EP4_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP3_OUT_Pos (7UL)          /*!< EP3_OUT (Bit 7) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP3_OUT_Msk (0x80UL)       /*!< EP3_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP3_IN_Pos (6UL)           /*!< EP3_IN (Bit 6) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP3_IN_Msk (0x40UL)        /*!< EP3_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP2_OUT_Pos (5UL)          /*!< EP2_OUT (Bit 5) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP2_OUT_Msk (0x20UL)       /*!< EP2_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP2_IN_Pos (4UL)           /*!< EP2_IN (Bit 4) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP2_IN_Msk (0x10UL)        /*!< EP2_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP1_OUT_Pos (3UL)          /*!< EP1_OUT (Bit 3) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP1_OUT_Msk (0x8UL)        /*!< EP1_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP1_IN_Pos (2UL)           /*!< EP1_IN (Bit 2) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP1_IN_Msk (0x4UL)         /*!< EP1_IN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP0_OUT_Pos (1UL)          /*!< EP0_OUT (Bit 1) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP0_OUT_Msk (0x2UL)        /*!< EP0_OUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP0_IN_Pos (0UL)           /*!< EP0_IN (Bit 0) */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP0_IN_Msk (0x1UL)         /*!< EP0_IN (Bitfield-Mask: 0x01) */
/* ======================================================  USB_MUXING  ======================================================= */
#define USBCTRL_REGS_USB_MUXING_SOFTCON_Pos (3UL)                   /*!< SOFTCON (Bit 3) */
#define USBCTRL_REGS_USB_MUXING_SOFTCON_Msk (0x8UL)                 /*!< SOFTCON (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USB_MUXING_TO_DIGITAL_PAD_Pos (2UL)            /*!< TO_DIGITAL_PAD (Bit 2) */
#define USBCTRL_REGS_USB_MUXING_TO_DIGITAL_PAD_Msk (0x4UL)          /*!< TO_DIGITAL_PAD (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USB_MUXING_TO_EXTPHY_Pos (1UL)                 /*!< TO_EXTPHY (Bit 1) */
#define USBCTRL_REGS_USB_MUXING_TO_EXTPHY_Msk (0x2UL)               /*!< TO_EXTPHY (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USB_MUXING_TO_PHY_Pos (0UL)                    /*!< TO_PHY (Bit 0) */
#define USBCTRL_REGS_USB_MUXING_TO_PHY_Msk (0x1UL)                  /*!< TO_PHY (Bitfield-Mask: 0x01) */
/* ========================================================  USB_PWR  ======================================================== */
#define USBCTRL_REGS_USB_PWR_OVERCURR_DETECT_EN_Pos (5UL)           /*!< OVERCURR_DETECT_EN (Bit 5) */
#define USBCTRL_REGS_USB_PWR_OVERCURR_DETECT_EN_Msk (0x20UL)        /*!< OVERCURR_DETECT_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USB_PWR_OVERCURR_DETECT_Pos (4UL)              /*!< OVERCURR_DETECT (Bit 4) */
#define USBCTRL_REGS_USB_PWR_OVERCURR_DETECT_Msk (0x10UL)           /*!< OVERCURR_DETECT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USB_PWR_VBUS_DETECT_OVERRIDE_EN_Pos (3UL)      /*!< VBUS_DETECT_OVERRIDE_EN (Bit 3) */
#define USBCTRL_REGS_USB_PWR_VBUS_DETECT_OVERRIDE_EN_Msk (0x8UL)    /*!< VBUS_DETECT_OVERRIDE_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USB_PWR_VBUS_DETECT_Pos (2UL)                  /*!< VBUS_DETECT (Bit 2) */
#define USBCTRL_REGS_USB_PWR_VBUS_DETECT_Msk (0x4UL)                /*!< VBUS_DETECT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USB_PWR_VBUS_EN_OVERRIDE_EN_Pos (1UL)          /*!< VBUS_EN_OVERRIDE_EN (Bit 1) */
#define USBCTRL_REGS_USB_PWR_VBUS_EN_OVERRIDE_EN_Msk (0x2UL)        /*!< VBUS_EN_OVERRIDE_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USB_PWR_VBUS_EN_Pos  (0UL)                     /*!< VBUS_EN (Bit 0) */
#define USBCTRL_REGS_USB_PWR_VBUS_EN_Msk  (0x1UL)                   /*!< VBUS_EN (Bitfield-Mask: 0x01) */
/* =====================================================  USBPHY_DIRECT  ===================================================== */
#define USBCTRL_REGS_USBPHY_DIRECT_DM_OVV_Pos (22UL)                /*!< DM_OVV (Bit 22) */
#define USBCTRL_REGS_USBPHY_DIRECT_DM_OVV_Msk (0x400000UL)          /*!< DM_OVV (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_DP_OVV_Pos (21UL)                /*!< DP_OVV (Bit 21) */
#define USBCTRL_REGS_USBPHY_DIRECT_DP_OVV_Msk (0x200000UL)          /*!< DP_OVV (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_DM_OVCN_Pos (20UL)               /*!< DM_OVCN (Bit 20) */
#define USBCTRL_REGS_USBPHY_DIRECT_DM_OVCN_Msk (0x100000UL)         /*!< DM_OVCN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_DP_OVCN_Pos (19UL)               /*!< DP_OVCN (Bit 19) */
#define USBCTRL_REGS_USBPHY_DIRECT_DP_OVCN_Msk (0x80000UL)          /*!< DP_OVCN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_RX_DM_Pos (18UL)                 /*!< RX_DM (Bit 18) */
#define USBCTRL_REGS_USBPHY_DIRECT_RX_DM_Msk (0x40000UL)            /*!< RX_DM (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_RX_DP_Pos (17UL)                 /*!< RX_DP (Bit 17) */
#define USBCTRL_REGS_USBPHY_DIRECT_RX_DP_Msk (0x20000UL)            /*!< RX_DP (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_RX_DD_Pos (16UL)                 /*!< RX_DD (Bit 16) */
#define USBCTRL_REGS_USBPHY_DIRECT_RX_DD_Msk (0x10000UL)            /*!< RX_DD (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_TX_DIFFMODE_Pos (15UL)           /*!< TX_DIFFMODE (Bit 15) */
#define USBCTRL_REGS_USBPHY_DIRECT_TX_DIFFMODE_Msk (0x8000UL)       /*!< TX_DIFFMODE (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_TX_FSSLEW_Pos (14UL)             /*!< TX_FSSLEW (Bit 14) */
#define USBCTRL_REGS_USBPHY_DIRECT_TX_FSSLEW_Msk (0x4000UL)         /*!< TX_FSSLEW (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_TX_PD_Pos (13UL)                 /*!< TX_PD (Bit 13) */
#define USBCTRL_REGS_USBPHY_DIRECT_TX_PD_Msk (0x2000UL)             /*!< TX_PD (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_RX_PD_Pos (12UL)                 /*!< RX_PD (Bit 12) */
#define USBCTRL_REGS_USBPHY_DIRECT_RX_PD_Msk (0x1000UL)             /*!< RX_PD (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_TX_DM_Pos (11UL)                 /*!< TX_DM (Bit 11) */
#define USBCTRL_REGS_USBPHY_DIRECT_TX_DM_Msk (0x800UL)              /*!< TX_DM (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_TX_DP_Pos (10UL)                 /*!< TX_DP (Bit 10) */
#define USBCTRL_REGS_USBPHY_DIRECT_TX_DP_Msk (0x400UL)              /*!< TX_DP (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_TX_DM_OE_Pos (9UL)               /*!< TX_DM_OE (Bit 9) */
#define USBCTRL_REGS_USBPHY_DIRECT_TX_DM_OE_Msk (0x200UL)           /*!< TX_DM_OE (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_TX_DP_OE_Pos (8UL)               /*!< TX_DP_OE (Bit 8) */
#define USBCTRL_REGS_USBPHY_DIRECT_TX_DP_OE_Msk (0x100UL)           /*!< TX_DP_OE (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_DM_PULLDN_EN_Pos (6UL)           /*!< DM_PULLDN_EN (Bit 6) */
#define USBCTRL_REGS_USBPHY_DIRECT_DM_PULLDN_EN_Msk (0x40UL)        /*!< DM_PULLDN_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_DM_PULLUP_EN_Pos (5UL)           /*!< DM_PULLUP_EN (Bit 5) */
#define USBCTRL_REGS_USBPHY_DIRECT_DM_PULLUP_EN_Msk (0x20UL)        /*!< DM_PULLUP_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_DM_PULLUP_HISEL_Pos (4UL)        /*!< DM_PULLUP_HISEL (Bit 4) */
#define USBCTRL_REGS_USBPHY_DIRECT_DM_PULLUP_HISEL_Msk (0x10UL)     /*!< DM_PULLUP_HISEL (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_DP_PULLDN_EN_Pos (2UL)           /*!< DP_PULLDN_EN (Bit 2) */
#define USBCTRL_REGS_USBPHY_DIRECT_DP_PULLDN_EN_Msk (0x4UL)         /*!< DP_PULLDN_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_DP_PULLUP_EN_Pos (1UL)           /*!< DP_PULLUP_EN (Bit 1) */
#define USBCTRL_REGS_USBPHY_DIRECT_DP_PULLUP_EN_Msk (0x2UL)         /*!< DP_PULLUP_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_DP_PULLUP_HISEL_Pos (0UL)        /*!< DP_PULLUP_HISEL (Bit 0) */
#define USBCTRL_REGS_USBPHY_DIRECT_DP_PULLUP_HISEL_Msk (0x1UL)      /*!< DP_PULLUP_HISEL (Bitfield-Mask: 0x01) */
/* ================================================  USBPHY_DIRECT_OVERRIDE  ================================================= */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DIFFMODE_OVERRIDE_EN_Pos (15UL) /*!< TX_DIFFMODE_OVERRIDE_EN (Bit 15) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DIFFMODE_OVERRIDE_EN_Msk (0x8000UL) /*!< TX_DIFFMODE_OVERRIDE_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DM_PULLUP_OVERRIDE_EN_Pos (12UL) /*!< DM_PULLUP_OVERRIDE_EN (Bit 12) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DM_PULLUP_OVERRIDE_EN_Msk (0x1000UL) /*!< DM_PULLUP_OVERRIDE_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_FSSLEW_OVERRIDE_EN_Pos (11UL) /*!< TX_FSSLEW_OVERRIDE_EN (Bit 11) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_FSSLEW_OVERRIDE_EN_Msk (0x800UL) /*!< TX_FSSLEW_OVERRIDE_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_PD_OVERRIDE_EN_Pos (10UL) /*!< TX_PD_OVERRIDE_EN (Bit 10) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_PD_OVERRIDE_EN_Msk (0x400UL) /*!< TX_PD_OVERRIDE_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_RX_PD_OVERRIDE_EN_Pos (9UL) /*!< RX_PD_OVERRIDE_EN (Bit 9) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_RX_PD_OVERRIDE_EN_Msk (0x200UL) /*!< RX_PD_OVERRIDE_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DM_OVERRIDE_EN_Pos (8UL) /*!< TX_DM_OVERRIDE_EN (Bit 8) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DM_OVERRIDE_EN_Msk (0x100UL) /*!< TX_DM_OVERRIDE_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DP_OVERRIDE_EN_Pos (7UL) /*!< TX_DP_OVERRIDE_EN (Bit 7) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DP_OVERRIDE_EN_Msk (0x80UL) /*!< TX_DP_OVERRIDE_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DM_OE_OVERRIDE_EN_Pos (6UL) /*!< TX_DM_OE_OVERRIDE_EN (Bit 6) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DM_OE_OVERRIDE_EN_Msk (0x40UL) /*!< TX_DM_OE_OVERRIDE_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DP_OE_OVERRIDE_EN_Pos (5UL) /*!< TX_DP_OE_OVERRIDE_EN (Bit 5) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DP_OE_OVERRIDE_EN_Msk (0x20UL) /*!< TX_DP_OE_OVERRIDE_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DM_PULLDN_EN_OVERRIDE_EN_Pos (4UL) /*!< DM_PULLDN_EN_OVERRIDE_EN (Bit 4) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DM_PULLDN_EN_OVERRIDE_EN_Msk (0x10UL) /*!< DM_PULLDN_EN_OVERRIDE_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DP_PULLDN_EN_OVERRIDE_EN_Pos (3UL) /*!< DP_PULLDN_EN_OVERRIDE_EN (Bit 3) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DP_PULLDN_EN_OVERRIDE_EN_Msk (0x8UL) /*!< DP_PULLDN_EN_OVERRIDE_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DP_PULLUP_EN_OVERRIDE_EN_Pos (2UL) /*!< DP_PULLUP_EN_OVERRIDE_EN (Bit 2) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DP_PULLUP_EN_OVERRIDE_EN_Msk (0x4UL) /*!< DP_PULLUP_EN_OVERRIDE_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DM_PULLUP_HISEL_OVERRIDE_EN_Pos (1UL) /*!< DM_PULLUP_HISEL_OVERRIDE_EN (Bit 1) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DM_PULLUP_HISEL_OVERRIDE_EN_Msk (0x2UL) /*!< DM_PULLUP_HISEL_OVERRIDE_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DP_PULLUP_HISEL_OVERRIDE_EN_Pos (0UL) /*!< DP_PULLUP_HISEL_OVERRIDE_EN (Bit 0) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DP_PULLUP_HISEL_OVERRIDE_EN_Msk (0x1UL) /*!< DP_PULLUP_HISEL_OVERRIDE_EN (Bitfield-Mask: 0x01) */
/* ======================================================  USBPHY_TRIM  ====================================================== */
#define USBCTRL_REGS_USBPHY_TRIM_DM_PULLDN_TRIM_Pos (8UL)           /*!< DM_PULLDN_TRIM (Bit 8) */
#define USBCTRL_REGS_USBPHY_TRIM_DM_PULLDN_TRIM_Msk (0x1f00UL)      /*!< DM_PULLDN_TRIM (Bitfield-Mask: 0x1f) */
#define USBCTRL_REGS_USBPHY_TRIM_DP_PULLDN_TRIM_Pos (0UL)           /*!< DP_PULLDN_TRIM (Bit 0) */
#define USBCTRL_REGS_USBPHY_TRIM_DP_PULLDN_TRIM_Msk (0x1fUL)        /*!< DP_PULLDN_TRIM (Bitfield-Mask: 0x1f) */
/* =========================================================  INTR  ========================================================== */
#define USBCTRL_REGS_INTR_EP_STALL_NAK_Pos (19UL)                   /*!< EP_STALL_NAK (Bit 19) */
#define USBCTRL_REGS_INTR_EP_STALL_NAK_Msk (0x80000UL)              /*!< EP_STALL_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTR_ABORT_DONE_Pos  (18UL)                    /*!< ABORT_DONE (Bit 18) */
#define USBCTRL_REGS_INTR_ABORT_DONE_Msk  (0x40000UL)               /*!< ABORT_DONE (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTR_DEV_SOF_Pos     (17UL)                    /*!< DEV_SOF (Bit 17) */
#define USBCTRL_REGS_INTR_DEV_SOF_Msk     (0x20000UL)               /*!< DEV_SOF (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTR_SETUP_REQ_Pos   (16UL)                    /*!< SETUP_REQ (Bit 16) */
#define USBCTRL_REGS_INTR_SETUP_REQ_Msk   (0x10000UL)               /*!< SETUP_REQ (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTR_DEV_RESUME_FROM_HOST_Pos (15UL)           /*!< DEV_RESUME_FROM_HOST (Bit 15) */
#define USBCTRL_REGS_INTR_DEV_RESUME_FROM_HOST_Msk (0x8000UL)       /*!< DEV_RESUME_FROM_HOST (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTR_DEV_SUSPEND_Pos (14UL)                    /*!< DEV_SUSPEND (Bit 14) */
#define USBCTRL_REGS_INTR_DEV_SUSPEND_Msk (0x4000UL)                /*!< DEV_SUSPEND (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTR_DEV_CONN_DIS_Pos (13UL)                   /*!< DEV_CONN_DIS (Bit 13) */
#define USBCTRL_REGS_INTR_DEV_CONN_DIS_Msk (0x2000UL)               /*!< DEV_CONN_DIS (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTR_BUS_RESET_Pos   (12UL)                    /*!< BUS_RESET (Bit 12) */
#define USBCTRL_REGS_INTR_BUS_RESET_Msk   (0x1000UL)                /*!< BUS_RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTR_VBUS_DETECT_Pos (11UL)                    /*!< VBUS_DETECT (Bit 11) */
#define USBCTRL_REGS_INTR_VBUS_DETECT_Msk (0x800UL)                 /*!< VBUS_DETECT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTR_STALL_Pos       (10UL)                    /*!< STALL (Bit 10) */
#define USBCTRL_REGS_INTR_STALL_Msk       (0x400UL)                 /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTR_ERROR_CRC_Pos   (9UL)                     /*!< ERROR_CRC (Bit 9) */
#define USBCTRL_REGS_INTR_ERROR_CRC_Msk   (0x200UL)                 /*!< ERROR_CRC (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTR_ERROR_BIT_STUFF_Pos (8UL)                 /*!< ERROR_BIT_STUFF (Bit 8) */
#define USBCTRL_REGS_INTR_ERROR_BIT_STUFF_Msk (0x100UL)             /*!< ERROR_BIT_STUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTR_ERROR_RX_OVERFLOW_Pos (7UL)               /*!< ERROR_RX_OVERFLOW (Bit 7) */
#define USBCTRL_REGS_INTR_ERROR_RX_OVERFLOW_Msk (0x80UL)            /*!< ERROR_RX_OVERFLOW (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTR_ERROR_RX_TIMEOUT_Pos (6UL)                /*!< ERROR_RX_TIMEOUT (Bit 6) */
#define USBCTRL_REGS_INTR_ERROR_RX_TIMEOUT_Msk (0x40UL)             /*!< ERROR_RX_TIMEOUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTR_ERROR_DATA_SEQ_Pos (5UL)                  /*!< ERROR_DATA_SEQ (Bit 5) */
#define USBCTRL_REGS_INTR_ERROR_DATA_SEQ_Msk (0x20UL)               /*!< ERROR_DATA_SEQ (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTR_BUFF_STATUS_Pos (4UL)                     /*!< BUFF_STATUS (Bit 4) */
#define USBCTRL_REGS_INTR_BUFF_STATUS_Msk (0x10UL)                  /*!< BUFF_STATUS (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTR_TRANS_COMPLETE_Pos (3UL)                  /*!< TRANS_COMPLETE (Bit 3) */
#define USBCTRL_REGS_INTR_TRANS_COMPLETE_Msk (0x8UL)                /*!< TRANS_COMPLETE (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTR_HOST_SOF_Pos    (2UL)                     /*!< HOST_SOF (Bit 2) */
#define USBCTRL_REGS_INTR_HOST_SOF_Msk    (0x4UL)                   /*!< HOST_SOF (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTR_HOST_RESUME_Pos (1UL)                     /*!< HOST_RESUME (Bit 1) */
#define USBCTRL_REGS_INTR_HOST_RESUME_Msk (0x2UL)                   /*!< HOST_RESUME (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTR_HOST_CONN_DIS_Pos (0UL)                   /*!< HOST_CONN_DIS (Bit 0) */
#define USBCTRL_REGS_INTR_HOST_CONN_DIS_Msk (0x1UL)                 /*!< HOST_CONN_DIS (Bitfield-Mask: 0x01) */
/* =========================================================  INTE  ========================================================== */
#define USBCTRL_REGS_INTE_EP_STALL_NAK_Pos (19UL)                   /*!< EP_STALL_NAK (Bit 19) */
#define USBCTRL_REGS_INTE_EP_STALL_NAK_Msk (0x80000UL)              /*!< EP_STALL_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTE_ABORT_DONE_Pos  (18UL)                    /*!< ABORT_DONE (Bit 18) */
#define USBCTRL_REGS_INTE_ABORT_DONE_Msk  (0x40000UL)               /*!< ABORT_DONE (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTE_DEV_SOF_Pos     (17UL)                    /*!< DEV_SOF (Bit 17) */
#define USBCTRL_REGS_INTE_DEV_SOF_Msk     (0x20000UL)               /*!< DEV_SOF (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTE_SETUP_REQ_Pos   (16UL)                    /*!< SETUP_REQ (Bit 16) */
#define USBCTRL_REGS_INTE_SETUP_REQ_Msk   (0x10000UL)               /*!< SETUP_REQ (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTE_DEV_RESUME_FROM_HOST_Pos (15UL)           /*!< DEV_RESUME_FROM_HOST (Bit 15) */
#define USBCTRL_REGS_INTE_DEV_RESUME_FROM_HOST_Msk (0x8000UL)       /*!< DEV_RESUME_FROM_HOST (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTE_DEV_SUSPEND_Pos (14UL)                    /*!< DEV_SUSPEND (Bit 14) */
#define USBCTRL_REGS_INTE_DEV_SUSPEND_Msk (0x4000UL)                /*!< DEV_SUSPEND (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTE_DEV_CONN_DIS_Pos (13UL)                   /*!< DEV_CONN_DIS (Bit 13) */
#define USBCTRL_REGS_INTE_DEV_CONN_DIS_Msk (0x2000UL)               /*!< DEV_CONN_DIS (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTE_BUS_RESET_Pos   (12UL)                    /*!< BUS_RESET (Bit 12) */
#define USBCTRL_REGS_INTE_BUS_RESET_Msk   (0x1000UL)                /*!< BUS_RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTE_VBUS_DETECT_Pos (11UL)                    /*!< VBUS_DETECT (Bit 11) */
#define USBCTRL_REGS_INTE_VBUS_DETECT_Msk (0x800UL)                 /*!< VBUS_DETECT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTE_STALL_Pos       (10UL)                    /*!< STALL (Bit 10) */
#define USBCTRL_REGS_INTE_STALL_Msk       (0x400UL)                 /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTE_ERROR_CRC_Pos   (9UL)                     /*!< ERROR_CRC (Bit 9) */
#define USBCTRL_REGS_INTE_ERROR_CRC_Msk   (0x200UL)                 /*!< ERROR_CRC (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTE_ERROR_BIT_STUFF_Pos (8UL)                 /*!< ERROR_BIT_STUFF (Bit 8) */
#define USBCTRL_REGS_INTE_ERROR_BIT_STUFF_Msk (0x100UL)             /*!< ERROR_BIT_STUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTE_ERROR_RX_OVERFLOW_Pos (7UL)               /*!< ERROR_RX_OVERFLOW (Bit 7) */
#define USBCTRL_REGS_INTE_ERROR_RX_OVERFLOW_Msk (0x80UL)            /*!< ERROR_RX_OVERFLOW (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTE_ERROR_RX_TIMEOUT_Pos (6UL)                /*!< ERROR_RX_TIMEOUT (Bit 6) */
#define USBCTRL_REGS_INTE_ERROR_RX_TIMEOUT_Msk (0x40UL)             /*!< ERROR_RX_TIMEOUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTE_ERROR_DATA_SEQ_Pos (5UL)                  /*!< ERROR_DATA_SEQ (Bit 5) */
#define USBCTRL_REGS_INTE_ERROR_DATA_SEQ_Msk (0x20UL)               /*!< ERROR_DATA_SEQ (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTE_BUFF_STATUS_Pos (4UL)                     /*!< BUFF_STATUS (Bit 4) */
#define USBCTRL_REGS_INTE_BUFF_STATUS_Msk (0x10UL)                  /*!< BUFF_STATUS (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTE_TRANS_COMPLETE_Pos (3UL)                  /*!< TRANS_COMPLETE (Bit 3) */
#define USBCTRL_REGS_INTE_TRANS_COMPLETE_Msk (0x8UL)                /*!< TRANS_COMPLETE (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTE_HOST_SOF_Pos    (2UL)                     /*!< HOST_SOF (Bit 2) */
#define USBCTRL_REGS_INTE_HOST_SOF_Msk    (0x4UL)                   /*!< HOST_SOF (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTE_HOST_RESUME_Pos (1UL)                     /*!< HOST_RESUME (Bit 1) */
#define USBCTRL_REGS_INTE_HOST_RESUME_Msk (0x2UL)                   /*!< HOST_RESUME (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTE_HOST_CONN_DIS_Pos (0UL)                   /*!< HOST_CONN_DIS (Bit 0) */
#define USBCTRL_REGS_INTE_HOST_CONN_DIS_Msk (0x1UL)                 /*!< HOST_CONN_DIS (Bitfield-Mask: 0x01) */
/* =========================================================  INTF  ========================================================== */
#define USBCTRL_REGS_INTF_EP_STALL_NAK_Pos (19UL)                   /*!< EP_STALL_NAK (Bit 19) */
#define USBCTRL_REGS_INTF_EP_STALL_NAK_Msk (0x80000UL)              /*!< EP_STALL_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTF_ABORT_DONE_Pos  (18UL)                    /*!< ABORT_DONE (Bit 18) */
#define USBCTRL_REGS_INTF_ABORT_DONE_Msk  (0x40000UL)               /*!< ABORT_DONE (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTF_DEV_SOF_Pos     (17UL)                    /*!< DEV_SOF (Bit 17) */
#define USBCTRL_REGS_INTF_DEV_SOF_Msk     (0x20000UL)               /*!< DEV_SOF (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTF_SETUP_REQ_Pos   (16UL)                    /*!< SETUP_REQ (Bit 16) */
#define USBCTRL_REGS_INTF_SETUP_REQ_Msk   (0x10000UL)               /*!< SETUP_REQ (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTF_DEV_RESUME_FROM_HOST_Pos (15UL)           /*!< DEV_RESUME_FROM_HOST (Bit 15) */
#define USBCTRL_REGS_INTF_DEV_RESUME_FROM_HOST_Msk (0x8000UL)       /*!< DEV_RESUME_FROM_HOST (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTF_DEV_SUSPEND_Pos (14UL)                    /*!< DEV_SUSPEND (Bit 14) */
#define USBCTRL_REGS_INTF_DEV_SUSPEND_Msk (0x4000UL)                /*!< DEV_SUSPEND (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTF_DEV_CONN_DIS_Pos (13UL)                   /*!< DEV_CONN_DIS (Bit 13) */
#define USBCTRL_REGS_INTF_DEV_CONN_DIS_Msk (0x2000UL)               /*!< DEV_CONN_DIS (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTF_BUS_RESET_Pos   (12UL)                    /*!< BUS_RESET (Bit 12) */
#define USBCTRL_REGS_INTF_BUS_RESET_Msk   (0x1000UL)                /*!< BUS_RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTF_VBUS_DETECT_Pos (11UL)                    /*!< VBUS_DETECT (Bit 11) */
#define USBCTRL_REGS_INTF_VBUS_DETECT_Msk (0x800UL)                 /*!< VBUS_DETECT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTF_STALL_Pos       (10UL)                    /*!< STALL (Bit 10) */
#define USBCTRL_REGS_INTF_STALL_Msk       (0x400UL)                 /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTF_ERROR_CRC_Pos   (9UL)                     /*!< ERROR_CRC (Bit 9) */
#define USBCTRL_REGS_INTF_ERROR_CRC_Msk   (0x200UL)                 /*!< ERROR_CRC (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTF_ERROR_BIT_STUFF_Pos (8UL)                 /*!< ERROR_BIT_STUFF (Bit 8) */
#define USBCTRL_REGS_INTF_ERROR_BIT_STUFF_Msk (0x100UL)             /*!< ERROR_BIT_STUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTF_ERROR_RX_OVERFLOW_Pos (7UL)               /*!< ERROR_RX_OVERFLOW (Bit 7) */
#define USBCTRL_REGS_INTF_ERROR_RX_OVERFLOW_Msk (0x80UL)            /*!< ERROR_RX_OVERFLOW (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTF_ERROR_RX_TIMEOUT_Pos (6UL)                /*!< ERROR_RX_TIMEOUT (Bit 6) */
#define USBCTRL_REGS_INTF_ERROR_RX_TIMEOUT_Msk (0x40UL)             /*!< ERROR_RX_TIMEOUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTF_ERROR_DATA_SEQ_Pos (5UL)                  /*!< ERROR_DATA_SEQ (Bit 5) */
#define USBCTRL_REGS_INTF_ERROR_DATA_SEQ_Msk (0x20UL)               /*!< ERROR_DATA_SEQ (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTF_BUFF_STATUS_Pos (4UL)                     /*!< BUFF_STATUS (Bit 4) */
#define USBCTRL_REGS_INTF_BUFF_STATUS_Msk (0x10UL)                  /*!< BUFF_STATUS (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTF_TRANS_COMPLETE_Pos (3UL)                  /*!< TRANS_COMPLETE (Bit 3) */
#define USBCTRL_REGS_INTF_TRANS_COMPLETE_Msk (0x8UL)                /*!< TRANS_COMPLETE (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTF_HOST_SOF_Pos    (2UL)                     /*!< HOST_SOF (Bit 2) */
#define USBCTRL_REGS_INTF_HOST_SOF_Msk    (0x4UL)                   /*!< HOST_SOF (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTF_HOST_RESUME_Pos (1UL)                     /*!< HOST_RESUME (Bit 1) */
#define USBCTRL_REGS_INTF_HOST_RESUME_Msk (0x2UL)                   /*!< HOST_RESUME (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTF_HOST_CONN_DIS_Pos (0UL)                   /*!< HOST_CONN_DIS (Bit 0) */
#define USBCTRL_REGS_INTF_HOST_CONN_DIS_Msk (0x1UL)                 /*!< HOST_CONN_DIS (Bitfield-Mask: 0x01) */
/* =========================================================  INTS  ========================================================== */
#define USBCTRL_REGS_INTS_EP_STALL_NAK_Pos (19UL)                   /*!< EP_STALL_NAK (Bit 19) */
#define USBCTRL_REGS_INTS_EP_STALL_NAK_Msk (0x80000UL)              /*!< EP_STALL_NAK (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTS_ABORT_DONE_Pos  (18UL)                    /*!< ABORT_DONE (Bit 18) */
#define USBCTRL_REGS_INTS_ABORT_DONE_Msk  (0x40000UL)               /*!< ABORT_DONE (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTS_DEV_SOF_Pos     (17UL)                    /*!< DEV_SOF (Bit 17) */
#define USBCTRL_REGS_INTS_DEV_SOF_Msk     (0x20000UL)               /*!< DEV_SOF (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTS_SETUP_REQ_Pos   (16UL)                    /*!< SETUP_REQ (Bit 16) */
#define USBCTRL_REGS_INTS_SETUP_REQ_Msk   (0x10000UL)               /*!< SETUP_REQ (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTS_DEV_RESUME_FROM_HOST_Pos (15UL)           /*!< DEV_RESUME_FROM_HOST (Bit 15) */
#define USBCTRL_REGS_INTS_DEV_RESUME_FROM_HOST_Msk (0x8000UL)       /*!< DEV_RESUME_FROM_HOST (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTS_DEV_SUSPEND_Pos (14UL)                    /*!< DEV_SUSPEND (Bit 14) */
#define USBCTRL_REGS_INTS_DEV_SUSPEND_Msk (0x4000UL)                /*!< DEV_SUSPEND (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTS_DEV_CONN_DIS_Pos (13UL)                   /*!< DEV_CONN_DIS (Bit 13) */
#define USBCTRL_REGS_INTS_DEV_CONN_DIS_Msk (0x2000UL)               /*!< DEV_CONN_DIS (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTS_BUS_RESET_Pos   (12UL)                    /*!< BUS_RESET (Bit 12) */
#define USBCTRL_REGS_INTS_BUS_RESET_Msk   (0x1000UL)                /*!< BUS_RESET (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTS_VBUS_DETECT_Pos (11UL)                    /*!< VBUS_DETECT (Bit 11) */
#define USBCTRL_REGS_INTS_VBUS_DETECT_Msk (0x800UL)                 /*!< VBUS_DETECT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTS_STALL_Pos       (10UL)                    /*!< STALL (Bit 10) */
#define USBCTRL_REGS_INTS_STALL_Msk       (0x400UL)                 /*!< STALL (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTS_ERROR_CRC_Pos   (9UL)                     /*!< ERROR_CRC (Bit 9) */
#define USBCTRL_REGS_INTS_ERROR_CRC_Msk   (0x200UL)                 /*!< ERROR_CRC (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTS_ERROR_BIT_STUFF_Pos (8UL)                 /*!< ERROR_BIT_STUFF (Bit 8) */
#define USBCTRL_REGS_INTS_ERROR_BIT_STUFF_Msk (0x100UL)             /*!< ERROR_BIT_STUFF (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTS_ERROR_RX_OVERFLOW_Pos (7UL)               /*!< ERROR_RX_OVERFLOW (Bit 7) */
#define USBCTRL_REGS_INTS_ERROR_RX_OVERFLOW_Msk (0x80UL)            /*!< ERROR_RX_OVERFLOW (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTS_ERROR_RX_TIMEOUT_Pos (6UL)                /*!< ERROR_RX_TIMEOUT (Bit 6) */
#define USBCTRL_REGS_INTS_ERROR_RX_TIMEOUT_Msk (0x40UL)             /*!< ERROR_RX_TIMEOUT (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTS_ERROR_DATA_SEQ_Pos (5UL)                  /*!< ERROR_DATA_SEQ (Bit 5) */
#define USBCTRL_REGS_INTS_ERROR_DATA_SEQ_Msk (0x20UL)               /*!< ERROR_DATA_SEQ (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTS_BUFF_STATUS_Pos (4UL)                     /*!< BUFF_STATUS (Bit 4) */
#define USBCTRL_REGS_INTS_BUFF_STATUS_Msk (0x10UL)                  /*!< BUFF_STATUS (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTS_TRANS_COMPLETE_Pos (3UL)                  /*!< TRANS_COMPLETE (Bit 3) */
#define USBCTRL_REGS_INTS_TRANS_COMPLETE_Msk (0x8UL)                /*!< TRANS_COMPLETE (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTS_HOST_SOF_Pos    (2UL)                     /*!< HOST_SOF (Bit 2) */
#define USBCTRL_REGS_INTS_HOST_SOF_Msk    (0x4UL)                   /*!< HOST_SOF (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTS_HOST_RESUME_Pos (1UL)                     /*!< HOST_RESUME (Bit 1) */
#define USBCTRL_REGS_INTS_HOST_RESUME_Msk (0x2UL)                   /*!< HOST_RESUME (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_INTS_HOST_CONN_DIS_Pos (0UL)                   /*!< HOST_CONN_DIS (Bit 0) */
#define USBCTRL_REGS_INTS_HOST_CONN_DIS_Msk (0x1UL)                 /*!< HOST_CONN_DIS (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                           PIO0                                            ================ */
/* =========================================================================================================================== */

/* =========================================================  CTRL  ========================================================== */
#define PIO0_CTRL_CLKDIV_RESTART_Pos      (8UL)                     /*!< CLKDIV_RESTART (Bit 8) */
#define PIO0_CTRL_CLKDIV_RESTART_Msk      (0xf00UL)                 /*!< CLKDIV_RESTART (Bitfield-Mask: 0x0f) */
#define PIO0_CTRL_SM_RESTART_Pos          (4UL)                     /*!< SM_RESTART (Bit 4) */
#define PIO0_CTRL_SM_RESTART_Msk          (0xf0UL)                  /*!< SM_RESTART (Bitfield-Mask: 0x0f) */
#define PIO0_CTRL_SM_ENABLE_Pos           (0UL)                     /*!< SM_ENABLE (Bit 0) */
#define PIO0_CTRL_SM_ENABLE_Msk           (0xfUL)                   /*!< SM_ENABLE (Bitfield-Mask: 0x0f) */
/* =========================================================  FSTAT  ========================================================= */
#define PIO0_FSTAT_TXEMPTY_Pos            (24UL)                    /*!< TXEMPTY (Bit 24) */
#define PIO0_FSTAT_TXEMPTY_Msk            (0xf000000UL)             /*!< TXEMPTY (Bitfield-Mask: 0x0f) */
#define PIO0_FSTAT_TXFULL_Pos             (16UL)                    /*!< TXFULL (Bit 16) */
#define PIO0_FSTAT_TXFULL_Msk             (0xf0000UL)               /*!< TXFULL (Bitfield-Mask: 0x0f) */
#define PIO0_FSTAT_RXEMPTY_Pos            (8UL)                     /*!< RXEMPTY (Bit 8) */
#define PIO0_FSTAT_RXEMPTY_Msk            (0xf00UL)                 /*!< RXEMPTY (Bitfield-Mask: 0x0f) */
#define PIO0_FSTAT_RXFULL_Pos             (0UL)                     /*!< RXFULL (Bit 0) */
#define PIO0_FSTAT_RXFULL_Msk             (0xfUL)                   /*!< RXFULL (Bitfield-Mask: 0x0f) */
/* ========================================================  FDEBUG  ========================================================= */
#define PIO0_FDEBUG_TXSTALL_Pos           (24UL)                    /*!< TXSTALL (Bit 24) */
#define PIO0_FDEBUG_TXSTALL_Msk           (0xf000000UL)             /*!< TXSTALL (Bitfield-Mask: 0x0f) */
#define PIO0_FDEBUG_TXOVER_Pos            (16UL)                    /*!< TXOVER (Bit 16) */
#define PIO0_FDEBUG_TXOVER_Msk            (0xf0000UL)               /*!< TXOVER (Bitfield-Mask: 0x0f) */
#define PIO0_FDEBUG_RXUNDER_Pos           (8UL)                     /*!< RXUNDER (Bit 8) */
#define PIO0_FDEBUG_RXUNDER_Msk           (0xf00UL)                 /*!< RXUNDER (Bitfield-Mask: 0x0f) */
#define PIO0_FDEBUG_RXSTALL_Pos           (0UL)                     /*!< RXSTALL (Bit 0) */
#define PIO0_FDEBUG_RXSTALL_Msk           (0xfUL)                   /*!< RXSTALL (Bitfield-Mask: 0x0f) */
/* ========================================================  FLEVEL  ========================================================= */
#define PIO0_FLEVEL_RX3_Pos               (28UL)                    /*!< RX3 (Bit 28) */
#define PIO0_FLEVEL_RX3_Msk               (0xf0000000UL)            /*!< RX3 (Bitfield-Mask: 0x0f) */
#define PIO0_FLEVEL_TX3_Pos               (24UL)                    /*!< TX3 (Bit 24) */
#define PIO0_FLEVEL_TX3_Msk               (0xf000000UL)             /*!< TX3 (Bitfield-Mask: 0x0f) */
#define PIO0_FLEVEL_RX2_Pos               (20UL)                    /*!< RX2 (Bit 20) */
#define PIO0_FLEVEL_RX2_Msk               (0xf00000UL)              /*!< RX2 (Bitfield-Mask: 0x0f) */
#define PIO0_FLEVEL_TX2_Pos               (16UL)                    /*!< TX2 (Bit 16) */
#define PIO0_FLEVEL_TX2_Msk               (0xf0000UL)               /*!< TX2 (Bitfield-Mask: 0x0f) */
#define PIO0_FLEVEL_RX1_Pos               (12UL)                    /*!< RX1 (Bit 12) */
#define PIO0_FLEVEL_RX1_Msk               (0xf000UL)                /*!< RX1 (Bitfield-Mask: 0x0f) */
#define PIO0_FLEVEL_TX1_Pos               (8UL)                     /*!< TX1 (Bit 8) */
#define PIO0_FLEVEL_TX1_Msk               (0xf00UL)                 /*!< TX1 (Bitfield-Mask: 0x0f) */
#define PIO0_FLEVEL_RX0_Pos               (4UL)                     /*!< RX0 (Bit 4) */
#define PIO0_FLEVEL_RX0_Msk               (0xf0UL)                  /*!< RX0 (Bitfield-Mask: 0x0f) */
#define PIO0_FLEVEL_TX0_Pos               (0UL)                     /*!< TX0 (Bit 0) */
#define PIO0_FLEVEL_TX0_Msk               (0xfUL)                   /*!< TX0 (Bitfield-Mask: 0x0f) */
/* =========================================================  TXF0  ========================================================== */
/* =========================================================  TXF1  ========================================================== */
/* =========================================================  TXF2  ========================================================== */
/* =========================================================  TXF3  ========================================================== */
/* =========================================================  RXF0  ========================================================== */
/* =========================================================  RXF1  ========================================================== */
/* =========================================================  RXF2  ========================================================== */
/* =========================================================  RXF3  ========================================================== */
/* ==========================================================  IRQ  ========================================================== */
#define PIO0_IRQ_IRQ_Pos                  (0UL)                     /*!< IRQ (Bit 0) */
#define PIO0_IRQ_IRQ_Msk                  (0xffUL)                  /*!< IRQ (Bitfield-Mask: 0xff) */
/* =======================================================  IRQ_FORCE  ======================================================= */
#define PIO0_IRQ_FORCE_IRQ_FORCE_Pos      (0UL)                     /*!< IRQ_FORCE (Bit 0) */
#define PIO0_IRQ_FORCE_IRQ_FORCE_Msk      (0xffUL)                  /*!< IRQ_FORCE (Bitfield-Mask: 0xff) */
/* ===================================================  INPUT_SYNC_BYPASS  =================================================== */
/* ======================================================  DBG_PADOUT  ======================================================= */
/* =======================================================  DBG_PADOE  ======================================================= */
/* ======================================================  DBG_CFGINFO  ====================================================== */
#define PIO0_DBG_CFGINFO_IMEM_SIZE_Pos    (16UL)                    /*!< IMEM_SIZE (Bit 16) */
#define PIO0_DBG_CFGINFO_IMEM_SIZE_Msk    (0x3f0000UL)              /*!< IMEM_SIZE (Bitfield-Mask: 0x3f) */
#define PIO0_DBG_CFGINFO_SM_COUNT_Pos     (8UL)                     /*!< SM_COUNT (Bit 8) */
#define PIO0_DBG_CFGINFO_SM_COUNT_Msk     (0xf00UL)                 /*!< SM_COUNT (Bitfield-Mask: 0x0f) */
#define PIO0_DBG_CFGINFO_FIFO_DEPTH_Pos   (0UL)                     /*!< FIFO_DEPTH (Bit 0) */
#define PIO0_DBG_CFGINFO_FIFO_DEPTH_Msk   (0x3fUL)                  /*!< FIFO_DEPTH (Bitfield-Mask: 0x3f) */
/* ======================================================  INSTR_MEM0  ======================================================= */
#define PIO0_INSTR_MEM0_INSTR_MEM0_Pos    (0UL)                     /*!< INSTR_MEM0 (Bit 0) */
#define PIO0_INSTR_MEM0_INSTR_MEM0_Msk    (0xffffUL)                /*!< INSTR_MEM0 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM1  ======================================================= */
#define PIO0_INSTR_MEM1_INSTR_MEM1_Pos    (0UL)                     /*!< INSTR_MEM1 (Bit 0) */
#define PIO0_INSTR_MEM1_INSTR_MEM1_Msk    (0xffffUL)                /*!< INSTR_MEM1 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM2  ======================================================= */
#define PIO0_INSTR_MEM2_INSTR_MEM2_Pos    (0UL)                     /*!< INSTR_MEM2 (Bit 0) */
#define PIO0_INSTR_MEM2_INSTR_MEM2_Msk    (0xffffUL)                /*!< INSTR_MEM2 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM3  ======================================================= */
#define PIO0_INSTR_MEM3_INSTR_MEM3_Pos    (0UL)                     /*!< INSTR_MEM3 (Bit 0) */
#define PIO0_INSTR_MEM3_INSTR_MEM3_Msk    (0xffffUL)                /*!< INSTR_MEM3 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM4  ======================================================= */
#define PIO0_INSTR_MEM4_INSTR_MEM4_Pos    (0UL)                     /*!< INSTR_MEM4 (Bit 0) */
#define PIO0_INSTR_MEM4_INSTR_MEM4_Msk    (0xffffUL)                /*!< INSTR_MEM4 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM5  ======================================================= */
#define PIO0_INSTR_MEM5_INSTR_MEM5_Pos    (0UL)                     /*!< INSTR_MEM5 (Bit 0) */
#define PIO0_INSTR_MEM5_INSTR_MEM5_Msk    (0xffffUL)                /*!< INSTR_MEM5 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM6  ======================================================= */
#define PIO0_INSTR_MEM6_INSTR_MEM6_Pos    (0UL)                     /*!< INSTR_MEM6 (Bit 0) */
#define PIO0_INSTR_MEM6_INSTR_MEM6_Msk    (0xffffUL)                /*!< INSTR_MEM6 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM7  ======================================================= */
#define PIO0_INSTR_MEM7_INSTR_MEM7_Pos    (0UL)                     /*!< INSTR_MEM7 (Bit 0) */
#define PIO0_INSTR_MEM7_INSTR_MEM7_Msk    (0xffffUL)                /*!< INSTR_MEM7 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM8  ======================================================= */
#define PIO0_INSTR_MEM8_INSTR_MEM8_Pos    (0UL)                     /*!< INSTR_MEM8 (Bit 0) */
#define PIO0_INSTR_MEM8_INSTR_MEM8_Msk    (0xffffUL)                /*!< INSTR_MEM8 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM9  ======================================================= */
#define PIO0_INSTR_MEM9_INSTR_MEM9_Pos    (0UL)                     /*!< INSTR_MEM9 (Bit 0) */
#define PIO0_INSTR_MEM9_INSTR_MEM9_Msk    (0xffffUL)                /*!< INSTR_MEM9 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM10  ====================================================== */
#define PIO0_INSTR_MEM10_INSTR_MEM10_Pos  (0UL)                     /*!< INSTR_MEM10 (Bit 0) */
#define PIO0_INSTR_MEM10_INSTR_MEM10_Msk  (0xffffUL)                /*!< INSTR_MEM10 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM11  ====================================================== */
#define PIO0_INSTR_MEM11_INSTR_MEM11_Pos  (0UL)                     /*!< INSTR_MEM11 (Bit 0) */
#define PIO0_INSTR_MEM11_INSTR_MEM11_Msk  (0xffffUL)                /*!< INSTR_MEM11 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM12  ====================================================== */
#define PIO0_INSTR_MEM12_INSTR_MEM12_Pos  (0UL)                     /*!< INSTR_MEM12 (Bit 0) */
#define PIO0_INSTR_MEM12_INSTR_MEM12_Msk  (0xffffUL)                /*!< INSTR_MEM12 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM13  ====================================================== */
#define PIO0_INSTR_MEM13_INSTR_MEM13_Pos  (0UL)                     /*!< INSTR_MEM13 (Bit 0) */
#define PIO0_INSTR_MEM13_INSTR_MEM13_Msk  (0xffffUL)                /*!< INSTR_MEM13 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM14  ====================================================== */
#define PIO0_INSTR_MEM14_INSTR_MEM14_Pos  (0UL)                     /*!< INSTR_MEM14 (Bit 0) */
#define PIO0_INSTR_MEM14_INSTR_MEM14_Msk  (0xffffUL)                /*!< INSTR_MEM14 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM15  ====================================================== */
#define PIO0_INSTR_MEM15_INSTR_MEM15_Pos  (0UL)                     /*!< INSTR_MEM15 (Bit 0) */
#define PIO0_INSTR_MEM15_INSTR_MEM15_Msk  (0xffffUL)                /*!< INSTR_MEM15 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM16  ====================================================== */
#define PIO0_INSTR_MEM16_INSTR_MEM16_Pos  (0UL)                     /*!< INSTR_MEM16 (Bit 0) */
#define PIO0_INSTR_MEM16_INSTR_MEM16_Msk  (0xffffUL)                /*!< INSTR_MEM16 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM17  ====================================================== */
#define PIO0_INSTR_MEM17_INSTR_MEM17_Pos  (0UL)                     /*!< INSTR_MEM17 (Bit 0) */
#define PIO0_INSTR_MEM17_INSTR_MEM17_Msk  (0xffffUL)                /*!< INSTR_MEM17 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM18  ====================================================== */
#define PIO0_INSTR_MEM18_INSTR_MEM18_Pos  (0UL)                     /*!< INSTR_MEM18 (Bit 0) */
#define PIO0_INSTR_MEM18_INSTR_MEM18_Msk  (0xffffUL)                /*!< INSTR_MEM18 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM19  ====================================================== */
#define PIO0_INSTR_MEM19_INSTR_MEM19_Pos  (0UL)                     /*!< INSTR_MEM19 (Bit 0) */
#define PIO0_INSTR_MEM19_INSTR_MEM19_Msk  (0xffffUL)                /*!< INSTR_MEM19 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM20  ====================================================== */
#define PIO0_INSTR_MEM20_INSTR_MEM20_Pos  (0UL)                     /*!< INSTR_MEM20 (Bit 0) */
#define PIO0_INSTR_MEM20_INSTR_MEM20_Msk  (0xffffUL)                /*!< INSTR_MEM20 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM21  ====================================================== */
#define PIO0_INSTR_MEM21_INSTR_MEM21_Pos  (0UL)                     /*!< INSTR_MEM21 (Bit 0) */
#define PIO0_INSTR_MEM21_INSTR_MEM21_Msk  (0xffffUL)                /*!< INSTR_MEM21 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM22  ====================================================== */
#define PIO0_INSTR_MEM22_INSTR_MEM22_Pos  (0UL)                     /*!< INSTR_MEM22 (Bit 0) */
#define PIO0_INSTR_MEM22_INSTR_MEM22_Msk  (0xffffUL)                /*!< INSTR_MEM22 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM23  ====================================================== */
#define PIO0_INSTR_MEM23_INSTR_MEM23_Pos  (0UL)                     /*!< INSTR_MEM23 (Bit 0) */
#define PIO0_INSTR_MEM23_INSTR_MEM23_Msk  (0xffffUL)                /*!< INSTR_MEM23 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM24  ====================================================== */
#define PIO0_INSTR_MEM24_INSTR_MEM24_Pos  (0UL)                     /*!< INSTR_MEM24 (Bit 0) */
#define PIO0_INSTR_MEM24_INSTR_MEM24_Msk  (0xffffUL)                /*!< INSTR_MEM24 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM25  ====================================================== */
#define PIO0_INSTR_MEM25_INSTR_MEM25_Pos  (0UL)                     /*!< INSTR_MEM25 (Bit 0) */
#define PIO0_INSTR_MEM25_INSTR_MEM25_Msk  (0xffffUL)                /*!< INSTR_MEM25 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM26  ====================================================== */
#define PIO0_INSTR_MEM26_INSTR_MEM26_Pos  (0UL)                     /*!< INSTR_MEM26 (Bit 0) */
#define PIO0_INSTR_MEM26_INSTR_MEM26_Msk  (0xffffUL)                /*!< INSTR_MEM26 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM27  ====================================================== */
#define PIO0_INSTR_MEM27_INSTR_MEM27_Pos  (0UL)                     /*!< INSTR_MEM27 (Bit 0) */
#define PIO0_INSTR_MEM27_INSTR_MEM27_Msk  (0xffffUL)                /*!< INSTR_MEM27 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM28  ====================================================== */
#define PIO0_INSTR_MEM28_INSTR_MEM28_Pos  (0UL)                     /*!< INSTR_MEM28 (Bit 0) */
#define PIO0_INSTR_MEM28_INSTR_MEM28_Msk  (0xffffUL)                /*!< INSTR_MEM28 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM29  ====================================================== */
#define PIO0_INSTR_MEM29_INSTR_MEM29_Pos  (0UL)                     /*!< INSTR_MEM29 (Bit 0) */
#define PIO0_INSTR_MEM29_INSTR_MEM29_Msk  (0xffffUL)                /*!< INSTR_MEM29 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM30  ====================================================== */
#define PIO0_INSTR_MEM30_INSTR_MEM30_Pos  (0UL)                     /*!< INSTR_MEM30 (Bit 0) */
#define PIO0_INSTR_MEM30_INSTR_MEM30_Msk  (0xffffUL)                /*!< INSTR_MEM30 (Bitfield-Mask: 0xffff) */
/* ======================================================  INSTR_MEM31  ====================================================== */
#define PIO0_INSTR_MEM31_INSTR_MEM31_Pos  (0UL)                     /*!< INSTR_MEM31 (Bit 0) */
#define PIO0_INSTR_MEM31_INSTR_MEM31_Msk  (0xffffUL)                /*!< INSTR_MEM31 (Bitfield-Mask: 0xffff) */
/* ======================================================  SM0_CLKDIV  ======================================================= */
#define PIO0_SM0_CLKDIV_INT_Pos           (16UL)                    /*!< INT (Bit 16) */
#define PIO0_SM0_CLKDIV_INT_Msk           (0xffff0000UL)            /*!< INT (Bitfield-Mask: 0xffff) */
#define PIO0_SM0_CLKDIV_FRAC_Pos          (8UL)                     /*!< FRAC (Bit 8) */
#define PIO0_SM0_CLKDIV_FRAC_Msk          (0xff00UL)                /*!< FRAC (Bitfield-Mask: 0xff) */
/* =====================================================  SM0_EXECCTRL  ====================================================== */
#define PIO0_SM0_EXECCTRL_EXEC_STALLED_Pos (31UL)                   /*!< EXEC_STALLED (Bit 31) */
#define PIO0_SM0_EXECCTRL_EXEC_STALLED_Msk (0x80000000UL)           /*!< EXEC_STALLED (Bitfield-Mask: 0x01) */
#define PIO0_SM0_EXECCTRL_SIDE_EN_Pos     (30UL)                    /*!< SIDE_EN (Bit 30) */
#define PIO0_SM0_EXECCTRL_SIDE_EN_Msk     (0x40000000UL)            /*!< SIDE_EN (Bitfield-Mask: 0x01) */
#define PIO0_SM0_EXECCTRL_SIDE_PINDIR_Pos (29UL)                    /*!< SIDE_PINDIR (Bit 29) */
#define PIO0_SM0_EXECCTRL_SIDE_PINDIR_Msk (0x20000000UL)            /*!< SIDE_PINDIR (Bitfield-Mask: 0x01) */
#define PIO0_SM0_EXECCTRL_JMP_PIN_Pos     (24UL)                    /*!< JMP_PIN (Bit 24) */
#define PIO0_SM0_EXECCTRL_JMP_PIN_Msk     (0x1f000000UL)            /*!< JMP_PIN (Bitfield-Mask: 0x1f) */
#define PIO0_SM0_EXECCTRL_OUT_EN_SEL_Pos  (19UL)                    /*!< OUT_EN_SEL (Bit 19) */
#define PIO0_SM0_EXECCTRL_OUT_EN_SEL_Msk  (0xf80000UL)              /*!< OUT_EN_SEL (Bitfield-Mask: 0x1f) */
#define PIO0_SM0_EXECCTRL_INLINE_OUT_EN_Pos (18UL)                  /*!< INLINE_OUT_EN (Bit 18) */
#define PIO0_SM0_EXECCTRL_INLINE_OUT_EN_Msk (0x40000UL)             /*!< INLINE_OUT_EN (Bitfield-Mask: 0x01) */
#define PIO0_SM0_EXECCTRL_OUT_STICKY_Pos  (17UL)                    /*!< OUT_STICKY (Bit 17) */
#define PIO0_SM0_EXECCTRL_OUT_STICKY_Msk  (0x20000UL)               /*!< OUT_STICKY (Bitfield-Mask: 0x01) */
#define PIO0_SM0_EXECCTRL_WRAP_TOP_Pos    (12UL)                    /*!< WRAP_TOP (Bit 12) */
#define PIO0_SM0_EXECCTRL_WRAP_TOP_Msk    (0x1f000UL)               /*!< WRAP_TOP (Bitfield-Mask: 0x1f) */
#define PIO0_SM0_EXECCTRL_WRAP_BOTTOM_Pos (7UL)                     /*!< WRAP_BOTTOM (Bit 7) */
#define PIO0_SM0_EXECCTRL_WRAP_BOTTOM_Msk (0xf80UL)                 /*!< WRAP_BOTTOM (Bitfield-Mask: 0x1f) */
#define PIO0_SM0_EXECCTRL_STATUS_SEL_Pos  (4UL)                     /*!< STATUS_SEL (Bit 4) */
#define PIO0_SM0_EXECCTRL_STATUS_SEL_Msk  (0x10UL)                  /*!< STATUS_SEL (Bitfield-Mask: 0x01) */
#define PIO0_SM0_EXECCTRL_STATUS_N_Pos    (0UL)                     /*!< STATUS_N (Bit 0) */
#define PIO0_SM0_EXECCTRL_STATUS_N_Msk    (0xfUL)                   /*!< STATUS_N (Bitfield-Mask: 0x0f) */
/* =====================================================  SM0_SHIFTCTRL  ===================================================== */
#define PIO0_SM0_SHIFTCTRL_FJOIN_RX_Pos   (31UL)                    /*!< FJOIN_RX (Bit 31) */
#define PIO0_SM0_SHIFTCTRL_FJOIN_RX_Msk   (0x80000000UL)            /*!< FJOIN_RX (Bitfield-Mask: 0x01) */
#define PIO0_SM0_SHIFTCTRL_FJOIN_TX_Pos   (30UL)                    /*!< FJOIN_TX (Bit 30) */
#define PIO0_SM0_SHIFTCTRL_FJOIN_TX_Msk   (0x40000000UL)            /*!< FJOIN_TX (Bitfield-Mask: 0x01) */
#define PIO0_SM0_SHIFTCTRL_PULL_THRESH_Pos (25UL)                   /*!< PULL_THRESH (Bit 25) */
#define PIO0_SM0_SHIFTCTRL_PULL_THRESH_Msk (0x3e000000UL)           /*!< PULL_THRESH (Bitfield-Mask: 0x1f) */
#define PIO0_SM0_SHIFTCTRL_PUSH_THRESH_Pos (20UL)                   /*!< PUSH_THRESH (Bit 20) */
#define PIO0_SM0_SHIFTCTRL_PUSH_THRESH_Msk (0x1f00000UL)            /*!< PUSH_THRESH (Bitfield-Mask: 0x1f) */
#define PIO0_SM0_SHIFTCTRL_OUT_SHIFTDIR_Pos (19UL)                  /*!< OUT_SHIFTDIR (Bit 19) */
#define PIO0_SM0_SHIFTCTRL_OUT_SHIFTDIR_Msk (0x80000UL)             /*!< OUT_SHIFTDIR (Bitfield-Mask: 0x01) */
#define PIO0_SM0_SHIFTCTRL_IN_SHIFTDIR_Pos (18UL)                   /*!< IN_SHIFTDIR (Bit 18) */
#define PIO0_SM0_SHIFTCTRL_IN_SHIFTDIR_Msk (0x40000UL)              /*!< IN_SHIFTDIR (Bitfield-Mask: 0x01) */
#define PIO0_SM0_SHIFTCTRL_AUTOPULL_Pos   (17UL)                    /*!< AUTOPULL (Bit 17) */
#define PIO0_SM0_SHIFTCTRL_AUTOPULL_Msk   (0x20000UL)               /*!< AUTOPULL (Bitfield-Mask: 0x01) */
#define PIO0_SM0_SHIFTCTRL_AUTOPUSH_Pos   (16UL)                    /*!< AUTOPUSH (Bit 16) */
#define PIO0_SM0_SHIFTCTRL_AUTOPUSH_Msk   (0x10000UL)               /*!< AUTOPUSH (Bitfield-Mask: 0x01) */
/* =======================================================  SM0_ADDR  ======================================================== */
#define PIO0_SM0_ADDR_SM0_ADDR_Pos        (0UL)                     /*!< SM0_ADDR (Bit 0) */
#define PIO0_SM0_ADDR_SM0_ADDR_Msk        (0x1fUL)                  /*!< SM0_ADDR (Bitfield-Mask: 0x1f) */
/* =======================================================  SM0_INSTR  ======================================================= */
#define PIO0_SM0_INSTR_SM0_INSTR_Pos      (0UL)                     /*!< SM0_INSTR (Bit 0) */
#define PIO0_SM0_INSTR_SM0_INSTR_Msk      (0xffffUL)                /*!< SM0_INSTR (Bitfield-Mask: 0xffff) */
/* ======================================================  SM0_PINCTRL  ====================================================== */
#define PIO0_SM0_PINCTRL_SIDESET_COUNT_Pos (29UL)                   /*!< SIDESET_COUNT (Bit 29) */
#define PIO0_SM0_PINCTRL_SIDESET_COUNT_Msk (0xe0000000UL)           /*!< SIDESET_COUNT (Bitfield-Mask: 0x07) */
#define PIO0_SM0_PINCTRL_SET_COUNT_Pos    (26UL)                    /*!< SET_COUNT (Bit 26) */
#define PIO0_SM0_PINCTRL_SET_COUNT_Msk    (0x1c000000UL)            /*!< SET_COUNT (Bitfield-Mask: 0x07) */
#define PIO0_SM0_PINCTRL_OUT_COUNT_Pos    (20UL)                    /*!< OUT_COUNT (Bit 20) */
#define PIO0_SM0_PINCTRL_OUT_COUNT_Msk    (0x3f00000UL)             /*!< OUT_COUNT (Bitfield-Mask: 0x3f) */
#define PIO0_SM0_PINCTRL_IN_BASE_Pos      (15UL)                    /*!< IN_BASE (Bit 15) */
#define PIO0_SM0_PINCTRL_IN_BASE_Msk      (0xf8000UL)               /*!< IN_BASE (Bitfield-Mask: 0x1f) */
#define PIO0_SM0_PINCTRL_SIDESET_BASE_Pos (10UL)                    /*!< SIDESET_BASE (Bit 10) */
#define PIO0_SM0_PINCTRL_SIDESET_BASE_Msk (0x7c00UL)                /*!< SIDESET_BASE (Bitfield-Mask: 0x1f) */
#define PIO0_SM0_PINCTRL_SET_BASE_Pos     (5UL)                     /*!< SET_BASE (Bit 5) */
#define PIO0_SM0_PINCTRL_SET_BASE_Msk     (0x3e0UL)                 /*!< SET_BASE (Bitfield-Mask: 0x1f) */
#define PIO0_SM0_PINCTRL_OUT_BASE_Pos     (0UL)                     /*!< OUT_BASE (Bit 0) */
#define PIO0_SM0_PINCTRL_OUT_BASE_Msk     (0x1fUL)                  /*!< OUT_BASE (Bitfield-Mask: 0x1f) */
/* ======================================================  SM1_CLKDIV  ======================================================= */
#define PIO0_SM1_CLKDIV_INT_Pos           (16UL)                    /*!< INT (Bit 16) */
#define PIO0_SM1_CLKDIV_INT_Msk           (0xffff0000UL)            /*!< INT (Bitfield-Mask: 0xffff) */
#define PIO0_SM1_CLKDIV_FRAC_Pos          (8UL)                     /*!< FRAC (Bit 8) */
#define PIO0_SM1_CLKDIV_FRAC_Msk          (0xff00UL)                /*!< FRAC (Bitfield-Mask: 0xff) */
/* =====================================================  SM1_EXECCTRL  ====================================================== */
#define PIO0_SM1_EXECCTRL_EXEC_STALLED_Pos (31UL)                   /*!< EXEC_STALLED (Bit 31) */
#define PIO0_SM1_EXECCTRL_EXEC_STALLED_Msk (0x80000000UL)           /*!< EXEC_STALLED (Bitfield-Mask: 0x01) */
#define PIO0_SM1_EXECCTRL_SIDE_EN_Pos     (30UL)                    /*!< SIDE_EN (Bit 30) */
#define PIO0_SM1_EXECCTRL_SIDE_EN_Msk     (0x40000000UL)            /*!< SIDE_EN (Bitfield-Mask: 0x01) */
#define PIO0_SM1_EXECCTRL_SIDE_PINDIR_Pos (29UL)                    /*!< SIDE_PINDIR (Bit 29) */
#define PIO0_SM1_EXECCTRL_SIDE_PINDIR_Msk (0x20000000UL)            /*!< SIDE_PINDIR (Bitfield-Mask: 0x01) */
#define PIO0_SM1_EXECCTRL_JMP_PIN_Pos     (24UL)                    /*!< JMP_PIN (Bit 24) */
#define PIO0_SM1_EXECCTRL_JMP_PIN_Msk     (0x1f000000UL)            /*!< JMP_PIN (Bitfield-Mask: 0x1f) */
#define PIO0_SM1_EXECCTRL_OUT_EN_SEL_Pos  (19UL)                    /*!< OUT_EN_SEL (Bit 19) */
#define PIO0_SM1_EXECCTRL_OUT_EN_SEL_Msk  (0xf80000UL)              /*!< OUT_EN_SEL (Bitfield-Mask: 0x1f) */
#define PIO0_SM1_EXECCTRL_INLINE_OUT_EN_Pos (18UL)                  /*!< INLINE_OUT_EN (Bit 18) */
#define PIO0_SM1_EXECCTRL_INLINE_OUT_EN_Msk (0x40000UL)             /*!< INLINE_OUT_EN (Bitfield-Mask: 0x01) */
#define PIO0_SM1_EXECCTRL_OUT_STICKY_Pos  (17UL)                    /*!< OUT_STICKY (Bit 17) */
#define PIO0_SM1_EXECCTRL_OUT_STICKY_Msk  (0x20000UL)               /*!< OUT_STICKY (Bitfield-Mask: 0x01) */
#define PIO0_SM1_EXECCTRL_WRAP_TOP_Pos    (12UL)                    /*!< WRAP_TOP (Bit 12) */
#define PIO0_SM1_EXECCTRL_WRAP_TOP_Msk    (0x1f000UL)               /*!< WRAP_TOP (Bitfield-Mask: 0x1f) */
#define PIO0_SM1_EXECCTRL_WRAP_BOTTOM_Pos (7UL)                     /*!< WRAP_BOTTOM (Bit 7) */
#define PIO0_SM1_EXECCTRL_WRAP_BOTTOM_Msk (0xf80UL)                 /*!< WRAP_BOTTOM (Bitfield-Mask: 0x1f) */
#define PIO0_SM1_EXECCTRL_STATUS_SEL_Pos  (4UL)                     /*!< STATUS_SEL (Bit 4) */
#define PIO0_SM1_EXECCTRL_STATUS_SEL_Msk  (0x10UL)                  /*!< STATUS_SEL (Bitfield-Mask: 0x01) */
#define PIO0_SM1_EXECCTRL_STATUS_N_Pos    (0UL)                     /*!< STATUS_N (Bit 0) */
#define PIO0_SM1_EXECCTRL_STATUS_N_Msk    (0xfUL)                   /*!< STATUS_N (Bitfield-Mask: 0x0f) */
/* =====================================================  SM1_SHIFTCTRL  ===================================================== */
#define PIO0_SM1_SHIFTCTRL_FJOIN_RX_Pos   (31UL)                    /*!< FJOIN_RX (Bit 31) */
#define PIO0_SM1_SHIFTCTRL_FJOIN_RX_Msk   (0x80000000UL)            /*!< FJOIN_RX (Bitfield-Mask: 0x01) */
#define PIO0_SM1_SHIFTCTRL_FJOIN_TX_Pos   (30UL)                    /*!< FJOIN_TX (Bit 30) */
#define PIO0_SM1_SHIFTCTRL_FJOIN_TX_Msk   (0x40000000UL)            /*!< FJOIN_TX (Bitfield-Mask: 0x01) */
#define PIO0_SM1_SHIFTCTRL_PULL_THRESH_Pos (25UL)                   /*!< PULL_THRESH (Bit 25) */
#define PIO0_SM1_SHIFTCTRL_PULL_THRESH_Msk (0x3e000000UL)           /*!< PULL_THRESH (Bitfield-Mask: 0x1f) */
#define PIO0_SM1_SHIFTCTRL_PUSH_THRESH_Pos (20UL)                   /*!< PUSH_THRESH (Bit 20) */
#define PIO0_SM1_SHIFTCTRL_PUSH_THRESH_Msk (0x1f00000UL)            /*!< PUSH_THRESH (Bitfield-Mask: 0x1f) */
#define PIO0_SM1_SHIFTCTRL_OUT_SHIFTDIR_Pos (19UL)                  /*!< OUT_SHIFTDIR (Bit 19) */
#define PIO0_SM1_SHIFTCTRL_OUT_SHIFTDIR_Msk (0x80000UL)             /*!< OUT_SHIFTDIR (Bitfield-Mask: 0x01) */
#define PIO0_SM1_SHIFTCTRL_IN_SHIFTDIR_Pos (18UL)                   /*!< IN_SHIFTDIR (Bit 18) */
#define PIO0_SM1_SHIFTCTRL_IN_SHIFTDIR_Msk (0x40000UL)              /*!< IN_SHIFTDIR (Bitfield-Mask: 0x01) */
#define PIO0_SM1_SHIFTCTRL_AUTOPULL_Pos   (17UL)                    /*!< AUTOPULL (Bit 17) */
#define PIO0_SM1_SHIFTCTRL_AUTOPULL_Msk   (0x20000UL)               /*!< AUTOPULL (Bitfield-Mask: 0x01) */
#define PIO0_SM1_SHIFTCTRL_AUTOPUSH_Pos   (16UL)                    /*!< AUTOPUSH (Bit 16) */
#define PIO0_SM1_SHIFTCTRL_AUTOPUSH_Msk   (0x10000UL)               /*!< AUTOPUSH (Bitfield-Mask: 0x01) */
/* =======================================================  SM1_ADDR  ======================================================== */
#define PIO0_SM1_ADDR_SM1_ADDR_Pos        (0UL)                     /*!< SM1_ADDR (Bit 0) */
#define PIO0_SM1_ADDR_SM1_ADDR_Msk        (0x1fUL)                  /*!< SM1_ADDR (Bitfield-Mask: 0x1f) */
/* =======================================================  SM1_INSTR  ======================================================= */
#define PIO0_SM1_INSTR_SM1_INSTR_Pos      (0UL)                     /*!< SM1_INSTR (Bit 0) */
#define PIO0_SM1_INSTR_SM1_INSTR_Msk      (0xffffUL)                /*!< SM1_INSTR (Bitfield-Mask: 0xffff) */
/* ======================================================  SM1_PINCTRL  ====================================================== */
#define PIO0_SM1_PINCTRL_SIDESET_COUNT_Pos (29UL)                   /*!< SIDESET_COUNT (Bit 29) */
#define PIO0_SM1_PINCTRL_SIDESET_COUNT_Msk (0xe0000000UL)           /*!< SIDESET_COUNT (Bitfield-Mask: 0x07) */
#define PIO0_SM1_PINCTRL_SET_COUNT_Pos    (26UL)                    /*!< SET_COUNT (Bit 26) */
#define PIO0_SM1_PINCTRL_SET_COUNT_Msk    (0x1c000000UL)            /*!< SET_COUNT (Bitfield-Mask: 0x07) */
#define PIO0_SM1_PINCTRL_OUT_COUNT_Pos    (20UL)                    /*!< OUT_COUNT (Bit 20) */
#define PIO0_SM1_PINCTRL_OUT_COUNT_Msk    (0x3f00000UL)             /*!< OUT_COUNT (Bitfield-Mask: 0x3f) */
#define PIO0_SM1_PINCTRL_IN_BASE_Pos      (15UL)                    /*!< IN_BASE (Bit 15) */
#define PIO0_SM1_PINCTRL_IN_BASE_Msk      (0xf8000UL)               /*!< IN_BASE (Bitfield-Mask: 0x1f) */
#define PIO0_SM1_PINCTRL_SIDESET_BASE_Pos (10UL)                    /*!< SIDESET_BASE (Bit 10) */
#define PIO0_SM1_PINCTRL_SIDESET_BASE_Msk (0x7c00UL)                /*!< SIDESET_BASE (Bitfield-Mask: 0x1f) */
#define PIO0_SM1_PINCTRL_SET_BASE_Pos     (5UL)                     /*!< SET_BASE (Bit 5) */
#define PIO0_SM1_PINCTRL_SET_BASE_Msk     (0x3e0UL)                 /*!< SET_BASE (Bitfield-Mask: 0x1f) */
#define PIO0_SM1_PINCTRL_OUT_BASE_Pos     (0UL)                     /*!< OUT_BASE (Bit 0) */
#define PIO0_SM1_PINCTRL_OUT_BASE_Msk     (0x1fUL)                  /*!< OUT_BASE (Bitfield-Mask: 0x1f) */
/* ======================================================  SM2_CLKDIV  ======================================================= */
#define PIO0_SM2_CLKDIV_INT_Pos           (16UL)                    /*!< INT (Bit 16) */
#define PIO0_SM2_CLKDIV_INT_Msk           (0xffff0000UL)            /*!< INT (Bitfield-Mask: 0xffff) */
#define PIO0_SM2_CLKDIV_FRAC_Pos          (8UL)                     /*!< FRAC (Bit 8) */
#define PIO0_SM2_CLKDIV_FRAC_Msk          (0xff00UL)                /*!< FRAC (Bitfield-Mask: 0xff) */
/* =====================================================  SM2_EXECCTRL  ====================================================== */
#define PIO0_SM2_EXECCTRL_EXEC_STALLED_Pos (31UL)                   /*!< EXEC_STALLED (Bit 31) */
#define PIO0_SM2_EXECCTRL_EXEC_STALLED_Msk (0x80000000UL)           /*!< EXEC_STALLED (Bitfield-Mask: 0x01) */
#define PIO0_SM2_EXECCTRL_SIDE_EN_Pos     (30UL)                    /*!< SIDE_EN (Bit 30) */
#define PIO0_SM2_EXECCTRL_SIDE_EN_Msk     (0x40000000UL)            /*!< SIDE_EN (Bitfield-Mask: 0x01) */
#define PIO0_SM2_EXECCTRL_SIDE_PINDIR_Pos (29UL)                    /*!< SIDE_PINDIR (Bit 29) */
#define PIO0_SM2_EXECCTRL_SIDE_PINDIR_Msk (0x20000000UL)            /*!< SIDE_PINDIR (Bitfield-Mask: 0x01) */
#define PIO0_SM2_EXECCTRL_JMP_PIN_Pos     (24UL)                    /*!< JMP_PIN (Bit 24) */
#define PIO0_SM2_EXECCTRL_JMP_PIN_Msk     (0x1f000000UL)            /*!< JMP_PIN (Bitfield-Mask: 0x1f) */
#define PIO0_SM2_EXECCTRL_OUT_EN_SEL_Pos  (19UL)                    /*!< OUT_EN_SEL (Bit 19) */
#define PIO0_SM2_EXECCTRL_OUT_EN_SEL_Msk  (0xf80000UL)              /*!< OUT_EN_SEL (Bitfield-Mask: 0x1f) */
#define PIO0_SM2_EXECCTRL_INLINE_OUT_EN_Pos (18UL)                  /*!< INLINE_OUT_EN (Bit 18) */
#define PIO0_SM2_EXECCTRL_INLINE_OUT_EN_Msk (0x40000UL)             /*!< INLINE_OUT_EN (Bitfield-Mask: 0x01) */
#define PIO0_SM2_EXECCTRL_OUT_STICKY_Pos  (17UL)                    /*!< OUT_STICKY (Bit 17) */
#define PIO0_SM2_EXECCTRL_OUT_STICKY_Msk  (0x20000UL)               /*!< OUT_STICKY (Bitfield-Mask: 0x01) */
#define PIO0_SM2_EXECCTRL_WRAP_TOP_Pos    (12UL)                    /*!< WRAP_TOP (Bit 12) */
#define PIO0_SM2_EXECCTRL_WRAP_TOP_Msk    (0x1f000UL)               /*!< WRAP_TOP (Bitfield-Mask: 0x1f) */
#define PIO0_SM2_EXECCTRL_WRAP_BOTTOM_Pos (7UL)                     /*!< WRAP_BOTTOM (Bit 7) */
#define PIO0_SM2_EXECCTRL_WRAP_BOTTOM_Msk (0xf80UL)                 /*!< WRAP_BOTTOM (Bitfield-Mask: 0x1f) */
#define PIO0_SM2_EXECCTRL_STATUS_SEL_Pos  (4UL)                     /*!< STATUS_SEL (Bit 4) */
#define PIO0_SM2_EXECCTRL_STATUS_SEL_Msk  (0x10UL)                  /*!< STATUS_SEL (Bitfield-Mask: 0x01) */
#define PIO0_SM2_EXECCTRL_STATUS_N_Pos    (0UL)                     /*!< STATUS_N (Bit 0) */
#define PIO0_SM2_EXECCTRL_STATUS_N_Msk    (0xfUL)                   /*!< STATUS_N (Bitfield-Mask: 0x0f) */
/* =====================================================  SM2_SHIFTCTRL  ===================================================== */
#define PIO0_SM2_SHIFTCTRL_FJOIN_RX_Pos   (31UL)                    /*!< FJOIN_RX (Bit 31) */
#define PIO0_SM2_SHIFTCTRL_FJOIN_RX_Msk   (0x80000000UL)            /*!< FJOIN_RX (Bitfield-Mask: 0x01) */
#define PIO0_SM2_SHIFTCTRL_FJOIN_TX_Pos   (30UL)                    /*!< FJOIN_TX (Bit 30) */
#define PIO0_SM2_SHIFTCTRL_FJOIN_TX_Msk   (0x40000000UL)            /*!< FJOIN_TX (Bitfield-Mask: 0x01) */
#define PIO0_SM2_SHIFTCTRL_PULL_THRESH_Pos (25UL)                   /*!< PULL_THRESH (Bit 25) */
#define PIO0_SM2_SHIFTCTRL_PULL_THRESH_Msk (0x3e000000UL)           /*!< PULL_THRESH (Bitfield-Mask: 0x1f) */
#define PIO0_SM2_SHIFTCTRL_PUSH_THRESH_Pos (20UL)                   /*!< PUSH_THRESH (Bit 20) */
#define PIO0_SM2_SHIFTCTRL_PUSH_THRESH_Msk (0x1f00000UL)            /*!< PUSH_THRESH (Bitfield-Mask: 0x1f) */
#define PIO0_SM2_SHIFTCTRL_OUT_SHIFTDIR_Pos (19UL)                  /*!< OUT_SHIFTDIR (Bit 19) */
#define PIO0_SM2_SHIFTCTRL_OUT_SHIFTDIR_Msk (0x80000UL)             /*!< OUT_SHIFTDIR (Bitfield-Mask: 0x01) */
#define PIO0_SM2_SHIFTCTRL_IN_SHIFTDIR_Pos (18UL)                   /*!< IN_SHIFTDIR (Bit 18) */
#define PIO0_SM2_SHIFTCTRL_IN_SHIFTDIR_Msk (0x40000UL)              /*!< IN_SHIFTDIR (Bitfield-Mask: 0x01) */
#define PIO0_SM2_SHIFTCTRL_AUTOPULL_Pos   (17UL)                    /*!< AUTOPULL (Bit 17) */
#define PIO0_SM2_SHIFTCTRL_AUTOPULL_Msk   (0x20000UL)               /*!< AUTOPULL (Bitfield-Mask: 0x01) */
#define PIO0_SM2_SHIFTCTRL_AUTOPUSH_Pos   (16UL)                    /*!< AUTOPUSH (Bit 16) */
#define PIO0_SM2_SHIFTCTRL_AUTOPUSH_Msk   (0x10000UL)               /*!< AUTOPUSH (Bitfield-Mask: 0x01) */
/* =======================================================  SM2_ADDR  ======================================================== */
#define PIO0_SM2_ADDR_SM2_ADDR_Pos        (0UL)                     /*!< SM2_ADDR (Bit 0) */
#define PIO0_SM2_ADDR_SM2_ADDR_Msk        (0x1fUL)                  /*!< SM2_ADDR (Bitfield-Mask: 0x1f) */
/* =======================================================  SM2_INSTR  ======================================================= */
#define PIO0_SM2_INSTR_SM2_INSTR_Pos      (0UL)                     /*!< SM2_INSTR (Bit 0) */
#define PIO0_SM2_INSTR_SM2_INSTR_Msk      (0xffffUL)                /*!< SM2_INSTR (Bitfield-Mask: 0xffff) */
/* ======================================================  SM2_PINCTRL  ====================================================== */
#define PIO0_SM2_PINCTRL_SIDESET_COUNT_Pos (29UL)                   /*!< SIDESET_COUNT (Bit 29) */
#define PIO0_SM2_PINCTRL_SIDESET_COUNT_Msk (0xe0000000UL)           /*!< SIDESET_COUNT (Bitfield-Mask: 0x07) */
#define PIO0_SM2_PINCTRL_SET_COUNT_Pos    (26UL)                    /*!< SET_COUNT (Bit 26) */
#define PIO0_SM2_PINCTRL_SET_COUNT_Msk    (0x1c000000UL)            /*!< SET_COUNT (Bitfield-Mask: 0x07) */
#define PIO0_SM2_PINCTRL_OUT_COUNT_Pos    (20UL)                    /*!< OUT_COUNT (Bit 20) */
#define PIO0_SM2_PINCTRL_OUT_COUNT_Msk    (0x3f00000UL)             /*!< OUT_COUNT (Bitfield-Mask: 0x3f) */
#define PIO0_SM2_PINCTRL_IN_BASE_Pos      (15UL)                    /*!< IN_BASE (Bit 15) */
#define PIO0_SM2_PINCTRL_IN_BASE_Msk      (0xf8000UL)               /*!< IN_BASE (Bitfield-Mask: 0x1f) */
#define PIO0_SM2_PINCTRL_SIDESET_BASE_Pos (10UL)                    /*!< SIDESET_BASE (Bit 10) */
#define PIO0_SM2_PINCTRL_SIDESET_BASE_Msk (0x7c00UL)                /*!< SIDESET_BASE (Bitfield-Mask: 0x1f) */
#define PIO0_SM2_PINCTRL_SET_BASE_Pos     (5UL)                     /*!< SET_BASE (Bit 5) */
#define PIO0_SM2_PINCTRL_SET_BASE_Msk     (0x3e0UL)                 /*!< SET_BASE (Bitfield-Mask: 0x1f) */
#define PIO0_SM2_PINCTRL_OUT_BASE_Pos     (0UL)                     /*!< OUT_BASE (Bit 0) */
#define PIO0_SM2_PINCTRL_OUT_BASE_Msk     (0x1fUL)                  /*!< OUT_BASE (Bitfield-Mask: 0x1f) */
/* ======================================================  SM3_CLKDIV  ======================================================= */
#define PIO0_SM3_CLKDIV_INT_Pos           (16UL)                    /*!< INT (Bit 16) */
#define PIO0_SM3_CLKDIV_INT_Msk           (0xffff0000UL)            /*!< INT (Bitfield-Mask: 0xffff) */
#define PIO0_SM3_CLKDIV_FRAC_Pos          (8UL)                     /*!< FRAC (Bit 8) */
#define PIO0_SM3_CLKDIV_FRAC_Msk          (0xff00UL)                /*!< FRAC (Bitfield-Mask: 0xff) */
/* =====================================================  SM3_EXECCTRL  ====================================================== */
#define PIO0_SM3_EXECCTRL_EXEC_STALLED_Pos (31UL)                   /*!< EXEC_STALLED (Bit 31) */
#define PIO0_SM3_EXECCTRL_EXEC_STALLED_Msk (0x80000000UL)           /*!< EXEC_STALLED (Bitfield-Mask: 0x01) */
#define PIO0_SM3_EXECCTRL_SIDE_EN_Pos     (30UL)                    /*!< SIDE_EN (Bit 30) */
#define PIO0_SM3_EXECCTRL_SIDE_EN_Msk     (0x40000000UL)            /*!< SIDE_EN (Bitfield-Mask: 0x01) */
#define PIO0_SM3_EXECCTRL_SIDE_PINDIR_Pos (29UL)                    /*!< SIDE_PINDIR (Bit 29) */
#define PIO0_SM3_EXECCTRL_SIDE_PINDIR_Msk (0x20000000UL)            /*!< SIDE_PINDIR (Bitfield-Mask: 0x01) */
#define PIO0_SM3_EXECCTRL_JMP_PIN_Pos     (24UL)                    /*!< JMP_PIN (Bit 24) */
#define PIO0_SM3_EXECCTRL_JMP_PIN_Msk     (0x1f000000UL)            /*!< JMP_PIN (Bitfield-Mask: 0x1f) */
#define PIO0_SM3_EXECCTRL_OUT_EN_SEL_Pos  (19UL)                    /*!< OUT_EN_SEL (Bit 19) */
#define PIO0_SM3_EXECCTRL_OUT_EN_SEL_Msk  (0xf80000UL)              /*!< OUT_EN_SEL (Bitfield-Mask: 0x1f) */
#define PIO0_SM3_EXECCTRL_INLINE_OUT_EN_Pos (18UL)                  /*!< INLINE_OUT_EN (Bit 18) */
#define PIO0_SM3_EXECCTRL_INLINE_OUT_EN_Msk (0x40000UL)             /*!< INLINE_OUT_EN (Bitfield-Mask: 0x01) */
#define PIO0_SM3_EXECCTRL_OUT_STICKY_Pos  (17UL)                    /*!< OUT_STICKY (Bit 17) */
#define PIO0_SM3_EXECCTRL_OUT_STICKY_Msk  (0x20000UL)               /*!< OUT_STICKY (Bitfield-Mask: 0x01) */
#define PIO0_SM3_EXECCTRL_WRAP_TOP_Pos    (12UL)                    /*!< WRAP_TOP (Bit 12) */
#define PIO0_SM3_EXECCTRL_WRAP_TOP_Msk    (0x1f000UL)               /*!< WRAP_TOP (Bitfield-Mask: 0x1f) */
#define PIO0_SM3_EXECCTRL_WRAP_BOTTOM_Pos (7UL)                     /*!< WRAP_BOTTOM (Bit 7) */
#define PIO0_SM3_EXECCTRL_WRAP_BOTTOM_Msk (0xf80UL)                 /*!< WRAP_BOTTOM (Bitfield-Mask: 0x1f) */
#define PIO0_SM3_EXECCTRL_STATUS_SEL_Pos  (4UL)                     /*!< STATUS_SEL (Bit 4) */
#define PIO0_SM3_EXECCTRL_STATUS_SEL_Msk  (0x10UL)                  /*!< STATUS_SEL (Bitfield-Mask: 0x01) */
#define PIO0_SM3_EXECCTRL_STATUS_N_Pos    (0UL)                     /*!< STATUS_N (Bit 0) */
#define PIO0_SM3_EXECCTRL_STATUS_N_Msk    (0xfUL)                   /*!< STATUS_N (Bitfield-Mask: 0x0f) */
/* =====================================================  SM3_SHIFTCTRL  ===================================================== */
#define PIO0_SM3_SHIFTCTRL_FJOIN_RX_Pos   (31UL)                    /*!< FJOIN_RX (Bit 31) */
#define PIO0_SM3_SHIFTCTRL_FJOIN_RX_Msk   (0x80000000UL)            /*!< FJOIN_RX (Bitfield-Mask: 0x01) */
#define PIO0_SM3_SHIFTCTRL_FJOIN_TX_Pos   (30UL)                    /*!< FJOIN_TX (Bit 30) */
#define PIO0_SM3_SHIFTCTRL_FJOIN_TX_Msk   (0x40000000UL)            /*!< FJOIN_TX (Bitfield-Mask: 0x01) */
#define PIO0_SM3_SHIFTCTRL_PULL_THRESH_Pos (25UL)                   /*!< PULL_THRESH (Bit 25) */
#define PIO0_SM3_SHIFTCTRL_PULL_THRESH_Msk (0x3e000000UL)           /*!< PULL_THRESH (Bitfield-Mask: 0x1f) */
#define PIO0_SM3_SHIFTCTRL_PUSH_THRESH_Pos (20UL)                   /*!< PUSH_THRESH (Bit 20) */
#define PIO0_SM3_SHIFTCTRL_PUSH_THRESH_Msk (0x1f00000UL)            /*!< PUSH_THRESH (Bitfield-Mask: 0x1f) */
#define PIO0_SM3_SHIFTCTRL_OUT_SHIFTDIR_Pos (19UL)                  /*!< OUT_SHIFTDIR (Bit 19) */
#define PIO0_SM3_SHIFTCTRL_OUT_SHIFTDIR_Msk (0x80000UL)             /*!< OUT_SHIFTDIR (Bitfield-Mask: 0x01) */
#define PIO0_SM3_SHIFTCTRL_IN_SHIFTDIR_Pos (18UL)                   /*!< IN_SHIFTDIR (Bit 18) */
#define PIO0_SM3_SHIFTCTRL_IN_SHIFTDIR_Msk (0x40000UL)              /*!< IN_SHIFTDIR (Bitfield-Mask: 0x01) */
#define PIO0_SM3_SHIFTCTRL_AUTOPULL_Pos   (17UL)                    /*!< AUTOPULL (Bit 17) */
#define PIO0_SM3_SHIFTCTRL_AUTOPULL_Msk   (0x20000UL)               /*!< AUTOPULL (Bitfield-Mask: 0x01) */
#define PIO0_SM3_SHIFTCTRL_AUTOPUSH_Pos   (16UL)                    /*!< AUTOPUSH (Bit 16) */
#define PIO0_SM3_SHIFTCTRL_AUTOPUSH_Msk   (0x10000UL)               /*!< AUTOPUSH (Bitfield-Mask: 0x01) */
/* =======================================================  SM3_ADDR  ======================================================== */
#define PIO0_SM3_ADDR_SM3_ADDR_Pos        (0UL)                     /*!< SM3_ADDR (Bit 0) */
#define PIO0_SM3_ADDR_SM3_ADDR_Msk        (0x1fUL)                  /*!< SM3_ADDR (Bitfield-Mask: 0x1f) */
/* =======================================================  SM3_INSTR  ======================================================= */
#define PIO0_SM3_INSTR_SM3_INSTR_Pos      (0UL)                     /*!< SM3_INSTR (Bit 0) */
#define PIO0_SM3_INSTR_SM3_INSTR_Msk      (0xffffUL)                /*!< SM3_INSTR (Bitfield-Mask: 0xffff) */
/* ======================================================  SM3_PINCTRL  ====================================================== */
#define PIO0_SM3_PINCTRL_SIDESET_COUNT_Pos (29UL)                   /*!< SIDESET_COUNT (Bit 29) */
#define PIO0_SM3_PINCTRL_SIDESET_COUNT_Msk (0xe0000000UL)           /*!< SIDESET_COUNT (Bitfield-Mask: 0x07) */
#define PIO0_SM3_PINCTRL_SET_COUNT_Pos    (26UL)                    /*!< SET_COUNT (Bit 26) */
#define PIO0_SM3_PINCTRL_SET_COUNT_Msk    (0x1c000000UL)            /*!< SET_COUNT (Bitfield-Mask: 0x07) */
#define PIO0_SM3_PINCTRL_OUT_COUNT_Pos    (20UL)                    /*!< OUT_COUNT (Bit 20) */
#define PIO0_SM3_PINCTRL_OUT_COUNT_Msk    (0x3f00000UL)             /*!< OUT_COUNT (Bitfield-Mask: 0x3f) */
#define PIO0_SM3_PINCTRL_IN_BASE_Pos      (15UL)                    /*!< IN_BASE (Bit 15) */
#define PIO0_SM3_PINCTRL_IN_BASE_Msk      (0xf8000UL)               /*!< IN_BASE (Bitfield-Mask: 0x1f) */
#define PIO0_SM3_PINCTRL_SIDESET_BASE_Pos (10UL)                    /*!< SIDESET_BASE (Bit 10) */
#define PIO0_SM3_PINCTRL_SIDESET_BASE_Msk (0x7c00UL)                /*!< SIDESET_BASE (Bitfield-Mask: 0x1f) */
#define PIO0_SM3_PINCTRL_SET_BASE_Pos     (5UL)                     /*!< SET_BASE (Bit 5) */
#define PIO0_SM3_PINCTRL_SET_BASE_Msk     (0x3e0UL)                 /*!< SET_BASE (Bitfield-Mask: 0x1f) */
#define PIO0_SM3_PINCTRL_OUT_BASE_Pos     (0UL)                     /*!< OUT_BASE (Bit 0) */
#define PIO0_SM3_PINCTRL_OUT_BASE_Msk     (0x1fUL)                  /*!< OUT_BASE (Bitfield-Mask: 0x1f) */
/* =========================================================  INTR  ========================================================== */
#define PIO0_INTR_SM3_Pos                 (11UL)                    /*!< SM3 (Bit 11) */
#define PIO0_INTR_SM3_Msk                 (0x800UL)                 /*!< SM3 (Bitfield-Mask: 0x01) */
#define PIO0_INTR_SM2_Pos                 (10UL)                    /*!< SM2 (Bit 10) */
#define PIO0_INTR_SM2_Msk                 (0x400UL)                 /*!< SM2 (Bitfield-Mask: 0x01) */
#define PIO0_INTR_SM1_Pos                 (9UL)                     /*!< SM1 (Bit 9) */
#define PIO0_INTR_SM1_Msk                 (0x200UL)                 /*!< SM1 (Bitfield-Mask: 0x01) */
#define PIO0_INTR_SM0_Pos                 (8UL)                     /*!< SM0 (Bit 8) */
#define PIO0_INTR_SM0_Msk                 (0x100UL)                 /*!< SM0 (Bitfield-Mask: 0x01) */
#define PIO0_INTR_SM3_TXNFULL_Pos         (7UL)                     /*!< SM3_TXNFULL (Bit 7) */
#define PIO0_INTR_SM3_TXNFULL_Msk         (0x80UL)                  /*!< SM3_TXNFULL (Bitfield-Mask: 0x01) */
#define PIO0_INTR_SM2_TXNFULL_Pos         (6UL)                     /*!< SM2_TXNFULL (Bit 6) */
#define PIO0_INTR_SM2_TXNFULL_Msk         (0x40UL)                  /*!< SM2_TXNFULL (Bitfield-Mask: 0x01) */
#define PIO0_INTR_SM1_TXNFULL_Pos         (5UL)                     /*!< SM1_TXNFULL (Bit 5) */
#define PIO0_INTR_SM1_TXNFULL_Msk         (0x20UL)                  /*!< SM1_TXNFULL (Bitfield-Mask: 0x01) */
#define PIO0_INTR_SM0_TXNFULL_Pos         (4UL)                     /*!< SM0_TXNFULL (Bit 4) */
#define PIO0_INTR_SM0_TXNFULL_Msk         (0x10UL)                  /*!< SM0_TXNFULL (Bitfield-Mask: 0x01) */
#define PIO0_INTR_SM3_RXNEMPTY_Pos        (3UL)                     /*!< SM3_RXNEMPTY (Bit 3) */
#define PIO0_INTR_SM3_RXNEMPTY_Msk        (0x8UL)                   /*!< SM3_RXNEMPTY (Bitfield-Mask: 0x01) */
#define PIO0_INTR_SM2_RXNEMPTY_Pos        (2UL)                     /*!< SM2_RXNEMPTY (Bit 2) */
#define PIO0_INTR_SM2_RXNEMPTY_Msk        (0x4UL)                   /*!< SM2_RXNEMPTY (Bitfield-Mask: 0x01) */
#define PIO0_INTR_SM1_RXNEMPTY_Pos        (1UL)                     /*!< SM1_RXNEMPTY (Bit 1) */
#define PIO0_INTR_SM1_RXNEMPTY_Msk        (0x2UL)                   /*!< SM1_RXNEMPTY (Bitfield-Mask: 0x01) */
#define PIO0_INTR_SM0_RXNEMPTY_Pos        (0UL)                     /*!< SM0_RXNEMPTY (Bit 0) */
#define PIO0_INTR_SM0_RXNEMPTY_Msk        (0x1UL)                   /*!< SM0_RXNEMPTY (Bitfield-Mask: 0x01) */
/* =======================================================  IRQ0_INTE  ======================================================= */
#define PIO0_IRQ0_INTE_SM3_Pos            (11UL)                    /*!< SM3 (Bit 11) */
#define PIO0_IRQ0_INTE_SM3_Msk            (0x800UL)                 /*!< SM3 (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTE_SM2_Pos            (10UL)                    /*!< SM2 (Bit 10) */
#define PIO0_IRQ0_INTE_SM2_Msk            (0x400UL)                 /*!< SM2 (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTE_SM1_Pos            (9UL)                     /*!< SM1 (Bit 9) */
#define PIO0_IRQ0_INTE_SM1_Msk            (0x200UL)                 /*!< SM1 (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTE_SM0_Pos            (8UL)                     /*!< SM0 (Bit 8) */
#define PIO0_IRQ0_INTE_SM0_Msk            (0x100UL)                 /*!< SM0 (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTE_SM3_TXNFULL_Pos    (7UL)                     /*!< SM3_TXNFULL (Bit 7) */
#define PIO0_IRQ0_INTE_SM3_TXNFULL_Msk    (0x80UL)                  /*!< SM3_TXNFULL (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTE_SM2_TXNFULL_Pos    (6UL)                     /*!< SM2_TXNFULL (Bit 6) */
#define PIO0_IRQ0_INTE_SM2_TXNFULL_Msk    (0x40UL)                  /*!< SM2_TXNFULL (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTE_SM1_TXNFULL_Pos    (5UL)                     /*!< SM1_TXNFULL (Bit 5) */
#define PIO0_IRQ0_INTE_SM1_TXNFULL_Msk    (0x20UL)                  /*!< SM1_TXNFULL (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTE_SM0_TXNFULL_Pos    (4UL)                     /*!< SM0_TXNFULL (Bit 4) */
#define PIO0_IRQ0_INTE_SM0_TXNFULL_Msk    (0x10UL)                  /*!< SM0_TXNFULL (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTE_SM3_RXNEMPTY_Pos   (3UL)                     /*!< SM3_RXNEMPTY (Bit 3) */
#define PIO0_IRQ0_INTE_SM3_RXNEMPTY_Msk   (0x8UL)                   /*!< SM3_RXNEMPTY (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTE_SM2_RXNEMPTY_Pos   (2UL)                     /*!< SM2_RXNEMPTY (Bit 2) */
#define PIO0_IRQ0_INTE_SM2_RXNEMPTY_Msk   (0x4UL)                   /*!< SM2_RXNEMPTY (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTE_SM1_RXNEMPTY_Pos   (1UL)                     /*!< SM1_RXNEMPTY (Bit 1) */
#define PIO0_IRQ0_INTE_SM1_RXNEMPTY_Msk   (0x2UL)                   /*!< SM1_RXNEMPTY (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTE_SM0_RXNEMPTY_Pos   (0UL)                     /*!< SM0_RXNEMPTY (Bit 0) */
#define PIO0_IRQ0_INTE_SM0_RXNEMPTY_Msk   (0x1UL)                   /*!< SM0_RXNEMPTY (Bitfield-Mask: 0x01) */
/* =======================================================  IRQ0_INTF  ======================================================= */
#define PIO0_IRQ0_INTF_SM3_Pos            (11UL)                    /*!< SM3 (Bit 11) */
#define PIO0_IRQ0_INTF_SM3_Msk            (0x800UL)                 /*!< SM3 (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTF_SM2_Pos            (10UL)                    /*!< SM2 (Bit 10) */
#define PIO0_IRQ0_INTF_SM2_Msk            (0x400UL)                 /*!< SM2 (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTF_SM1_Pos            (9UL)                     /*!< SM1 (Bit 9) */
#define PIO0_IRQ0_INTF_SM1_Msk            (0x200UL)                 /*!< SM1 (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTF_SM0_Pos            (8UL)                     /*!< SM0 (Bit 8) */
#define PIO0_IRQ0_INTF_SM0_Msk            (0x100UL)                 /*!< SM0 (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTF_SM3_TXNFULL_Pos    (7UL)                     /*!< SM3_TXNFULL (Bit 7) */
#define PIO0_IRQ0_INTF_SM3_TXNFULL_Msk    (0x80UL)                  /*!< SM3_TXNFULL (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTF_SM2_TXNFULL_Pos    (6UL)                     /*!< SM2_TXNFULL (Bit 6) */
#define PIO0_IRQ0_INTF_SM2_TXNFULL_Msk    (0x40UL)                  /*!< SM2_TXNFULL (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTF_SM1_TXNFULL_Pos    (5UL)                     /*!< SM1_TXNFULL (Bit 5) */
#define PIO0_IRQ0_INTF_SM1_TXNFULL_Msk    (0x20UL)                  /*!< SM1_TXNFULL (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTF_SM0_TXNFULL_Pos    (4UL)                     /*!< SM0_TXNFULL (Bit 4) */
#define PIO0_IRQ0_INTF_SM0_TXNFULL_Msk    (0x10UL)                  /*!< SM0_TXNFULL (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTF_SM3_RXNEMPTY_Pos   (3UL)                     /*!< SM3_RXNEMPTY (Bit 3) */
#define PIO0_IRQ0_INTF_SM3_RXNEMPTY_Msk   (0x8UL)                   /*!< SM3_RXNEMPTY (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTF_SM2_RXNEMPTY_Pos   (2UL)                     /*!< SM2_RXNEMPTY (Bit 2) */
#define PIO0_IRQ0_INTF_SM2_RXNEMPTY_Msk   (0x4UL)                   /*!< SM2_RXNEMPTY (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTF_SM1_RXNEMPTY_Pos   (1UL)                     /*!< SM1_RXNEMPTY (Bit 1) */
#define PIO0_IRQ0_INTF_SM1_RXNEMPTY_Msk   (0x2UL)                   /*!< SM1_RXNEMPTY (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTF_SM0_RXNEMPTY_Pos   (0UL)                     /*!< SM0_RXNEMPTY (Bit 0) */
#define PIO0_IRQ0_INTF_SM0_RXNEMPTY_Msk   (0x1UL)                   /*!< SM0_RXNEMPTY (Bitfield-Mask: 0x01) */
/* =======================================================  IRQ0_INTS  ======================================================= */
#define PIO0_IRQ0_INTS_SM3_Pos            (11UL)                    /*!< SM3 (Bit 11) */
#define PIO0_IRQ0_INTS_SM3_Msk            (0x800UL)                 /*!< SM3 (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTS_SM2_Pos            (10UL)                    /*!< SM2 (Bit 10) */
#define PIO0_IRQ0_INTS_SM2_Msk            (0x400UL)                 /*!< SM2 (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTS_SM1_Pos            (9UL)                     /*!< SM1 (Bit 9) */
#define PIO0_IRQ0_INTS_SM1_Msk            (0x200UL)                 /*!< SM1 (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTS_SM0_Pos            (8UL)                     /*!< SM0 (Bit 8) */
#define PIO0_IRQ0_INTS_SM0_Msk            (0x100UL)                 /*!< SM0 (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTS_SM3_TXNFULL_Pos    (7UL)                     /*!< SM3_TXNFULL (Bit 7) */
#define PIO0_IRQ0_INTS_SM3_TXNFULL_Msk    (0x80UL)                  /*!< SM3_TXNFULL (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTS_SM2_TXNFULL_Pos    (6UL)                     /*!< SM2_TXNFULL (Bit 6) */
#define PIO0_IRQ0_INTS_SM2_TXNFULL_Msk    (0x40UL)                  /*!< SM2_TXNFULL (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTS_SM1_TXNFULL_Pos    (5UL)                     /*!< SM1_TXNFULL (Bit 5) */
#define PIO0_IRQ0_INTS_SM1_TXNFULL_Msk    (0x20UL)                  /*!< SM1_TXNFULL (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTS_SM0_TXNFULL_Pos    (4UL)                     /*!< SM0_TXNFULL (Bit 4) */
#define PIO0_IRQ0_INTS_SM0_TXNFULL_Msk    (0x10UL)                  /*!< SM0_TXNFULL (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTS_SM3_RXNEMPTY_Pos   (3UL)                     /*!< SM3_RXNEMPTY (Bit 3) */
#define PIO0_IRQ0_INTS_SM3_RXNEMPTY_Msk   (0x8UL)                   /*!< SM3_RXNEMPTY (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTS_SM2_RXNEMPTY_Pos   (2UL)                     /*!< SM2_RXNEMPTY (Bit 2) */
#define PIO0_IRQ0_INTS_SM2_RXNEMPTY_Msk   (0x4UL)                   /*!< SM2_RXNEMPTY (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTS_SM1_RXNEMPTY_Pos   (1UL)                     /*!< SM1_RXNEMPTY (Bit 1) */
#define PIO0_IRQ0_INTS_SM1_RXNEMPTY_Msk   (0x2UL)                   /*!< SM1_RXNEMPTY (Bitfield-Mask: 0x01) */
#define PIO0_IRQ0_INTS_SM0_RXNEMPTY_Pos   (0UL)                     /*!< SM0_RXNEMPTY (Bit 0) */
#define PIO0_IRQ0_INTS_SM0_RXNEMPTY_Msk   (0x1UL)                   /*!< SM0_RXNEMPTY (Bitfield-Mask: 0x01) */
/* =======================================================  IRQ1_INTE  ======================================================= */
#define PIO0_IRQ1_INTE_SM3_Pos            (11UL)                    /*!< SM3 (Bit 11) */
#define PIO0_IRQ1_INTE_SM3_Msk            (0x800UL)                 /*!< SM3 (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTE_SM2_Pos            (10UL)                    /*!< SM2 (Bit 10) */
#define PIO0_IRQ1_INTE_SM2_Msk            (0x400UL)                 /*!< SM2 (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTE_SM1_Pos            (9UL)                     /*!< SM1 (Bit 9) */
#define PIO0_IRQ1_INTE_SM1_Msk            (0x200UL)                 /*!< SM1 (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTE_SM0_Pos            (8UL)                     /*!< SM0 (Bit 8) */
#define PIO0_IRQ1_INTE_SM0_Msk            (0x100UL)                 /*!< SM0 (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTE_SM3_TXNFULL_Pos    (7UL)                     /*!< SM3_TXNFULL (Bit 7) */
#define PIO0_IRQ1_INTE_SM3_TXNFULL_Msk    (0x80UL)                  /*!< SM3_TXNFULL (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTE_SM2_TXNFULL_Pos    (6UL)                     /*!< SM2_TXNFULL (Bit 6) */
#define PIO0_IRQ1_INTE_SM2_TXNFULL_Msk    (0x40UL)                  /*!< SM2_TXNFULL (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTE_SM1_TXNFULL_Pos    (5UL)                     /*!< SM1_TXNFULL (Bit 5) */
#define PIO0_IRQ1_INTE_SM1_TXNFULL_Msk    (0x20UL)                  /*!< SM1_TXNFULL (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTE_SM0_TXNFULL_Pos    (4UL)                     /*!< SM0_TXNFULL (Bit 4) */
#define PIO0_IRQ1_INTE_SM0_TXNFULL_Msk    (0x10UL)                  /*!< SM0_TXNFULL (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTE_SM3_RXNEMPTY_Pos   (3UL)                     /*!< SM3_RXNEMPTY (Bit 3) */
#define PIO0_IRQ1_INTE_SM3_RXNEMPTY_Msk   (0x8UL)                   /*!< SM3_RXNEMPTY (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTE_SM2_RXNEMPTY_Pos   (2UL)                     /*!< SM2_RXNEMPTY (Bit 2) */
#define PIO0_IRQ1_INTE_SM2_RXNEMPTY_Msk   (0x4UL)                   /*!< SM2_RXNEMPTY (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTE_SM1_RXNEMPTY_Pos   (1UL)                     /*!< SM1_RXNEMPTY (Bit 1) */
#define PIO0_IRQ1_INTE_SM1_RXNEMPTY_Msk   (0x2UL)                   /*!< SM1_RXNEMPTY (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTE_SM0_RXNEMPTY_Pos   (0UL)                     /*!< SM0_RXNEMPTY (Bit 0) */
#define PIO0_IRQ1_INTE_SM0_RXNEMPTY_Msk   (0x1UL)                   /*!< SM0_RXNEMPTY (Bitfield-Mask: 0x01) */
/* =======================================================  IRQ1_INTF  ======================================================= */
#define PIO0_IRQ1_INTF_SM3_Pos            (11UL)                    /*!< SM3 (Bit 11) */
#define PIO0_IRQ1_INTF_SM3_Msk            (0x800UL)                 /*!< SM3 (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTF_SM2_Pos            (10UL)                    /*!< SM2 (Bit 10) */
#define PIO0_IRQ1_INTF_SM2_Msk            (0x400UL)                 /*!< SM2 (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTF_SM1_Pos            (9UL)                     /*!< SM1 (Bit 9) */
#define PIO0_IRQ1_INTF_SM1_Msk            (0x200UL)                 /*!< SM1 (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTF_SM0_Pos            (8UL)                     /*!< SM0 (Bit 8) */
#define PIO0_IRQ1_INTF_SM0_Msk            (0x100UL)                 /*!< SM0 (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTF_SM3_TXNFULL_Pos    (7UL)                     /*!< SM3_TXNFULL (Bit 7) */
#define PIO0_IRQ1_INTF_SM3_TXNFULL_Msk    (0x80UL)                  /*!< SM3_TXNFULL (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTF_SM2_TXNFULL_Pos    (6UL)                     /*!< SM2_TXNFULL (Bit 6) */
#define PIO0_IRQ1_INTF_SM2_TXNFULL_Msk    (0x40UL)                  /*!< SM2_TXNFULL (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTF_SM1_TXNFULL_Pos    (5UL)                     /*!< SM1_TXNFULL (Bit 5) */
#define PIO0_IRQ1_INTF_SM1_TXNFULL_Msk    (0x20UL)                  /*!< SM1_TXNFULL (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTF_SM0_TXNFULL_Pos    (4UL)                     /*!< SM0_TXNFULL (Bit 4) */
#define PIO0_IRQ1_INTF_SM0_TXNFULL_Msk    (0x10UL)                  /*!< SM0_TXNFULL (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTF_SM3_RXNEMPTY_Pos   (3UL)                     /*!< SM3_RXNEMPTY (Bit 3) */
#define PIO0_IRQ1_INTF_SM3_RXNEMPTY_Msk   (0x8UL)                   /*!< SM3_RXNEMPTY (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTF_SM2_RXNEMPTY_Pos   (2UL)                     /*!< SM2_RXNEMPTY (Bit 2) */
#define PIO0_IRQ1_INTF_SM2_RXNEMPTY_Msk   (0x4UL)                   /*!< SM2_RXNEMPTY (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTF_SM1_RXNEMPTY_Pos   (1UL)                     /*!< SM1_RXNEMPTY (Bit 1) */
#define PIO0_IRQ1_INTF_SM1_RXNEMPTY_Msk   (0x2UL)                   /*!< SM1_RXNEMPTY (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTF_SM0_RXNEMPTY_Pos   (0UL)                     /*!< SM0_RXNEMPTY (Bit 0) */
#define PIO0_IRQ1_INTF_SM0_RXNEMPTY_Msk   (0x1UL)                   /*!< SM0_RXNEMPTY (Bitfield-Mask: 0x01) */
/* =======================================================  IRQ1_INTS  ======================================================= */
#define PIO0_IRQ1_INTS_SM3_Pos            (11UL)                    /*!< SM3 (Bit 11) */
#define PIO0_IRQ1_INTS_SM3_Msk            (0x800UL)                 /*!< SM3 (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTS_SM2_Pos            (10UL)                    /*!< SM2 (Bit 10) */
#define PIO0_IRQ1_INTS_SM2_Msk            (0x400UL)                 /*!< SM2 (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTS_SM1_Pos            (9UL)                     /*!< SM1 (Bit 9) */
#define PIO0_IRQ1_INTS_SM1_Msk            (0x200UL)                 /*!< SM1 (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTS_SM0_Pos            (8UL)                     /*!< SM0 (Bit 8) */
#define PIO0_IRQ1_INTS_SM0_Msk            (0x100UL)                 /*!< SM0 (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTS_SM3_TXNFULL_Pos    (7UL)                     /*!< SM3_TXNFULL (Bit 7) */
#define PIO0_IRQ1_INTS_SM3_TXNFULL_Msk    (0x80UL)                  /*!< SM3_TXNFULL (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTS_SM2_TXNFULL_Pos    (6UL)                     /*!< SM2_TXNFULL (Bit 6) */
#define PIO0_IRQ1_INTS_SM2_TXNFULL_Msk    (0x40UL)                  /*!< SM2_TXNFULL (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTS_SM1_TXNFULL_Pos    (5UL)                     /*!< SM1_TXNFULL (Bit 5) */
#define PIO0_IRQ1_INTS_SM1_TXNFULL_Msk    (0x20UL)                  /*!< SM1_TXNFULL (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTS_SM0_TXNFULL_Pos    (4UL)                     /*!< SM0_TXNFULL (Bit 4) */
#define PIO0_IRQ1_INTS_SM0_TXNFULL_Msk    (0x10UL)                  /*!< SM0_TXNFULL (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTS_SM3_RXNEMPTY_Pos   (3UL)                     /*!< SM3_RXNEMPTY (Bit 3) */
#define PIO0_IRQ1_INTS_SM3_RXNEMPTY_Msk   (0x8UL)                   /*!< SM3_RXNEMPTY (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTS_SM2_RXNEMPTY_Pos   (2UL)                     /*!< SM2_RXNEMPTY (Bit 2) */
#define PIO0_IRQ1_INTS_SM2_RXNEMPTY_Msk   (0x4UL)                   /*!< SM2_RXNEMPTY (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTS_SM1_RXNEMPTY_Pos   (1UL)                     /*!< SM1_RXNEMPTY (Bit 1) */
#define PIO0_IRQ1_INTS_SM1_RXNEMPTY_Msk   (0x2UL)                   /*!< SM1_RXNEMPTY (Bitfield-Mask: 0x01) */
#define PIO0_IRQ1_INTS_SM0_RXNEMPTY_Pos   (0UL)                     /*!< SM0_RXNEMPTY (Bit 0) */
#define PIO0_IRQ1_INTS_SM0_RXNEMPTY_Msk   (0x1UL)                   /*!< SM0_RXNEMPTY (Bitfield-Mask: 0x01) */


/* =========================================================================================================================== */
/* ================                                            SIO                                            ================ */
/* =========================================================================================================================== */

/* =========================================================  CPUID  ========================================================= */
/* ========================================================  GPIO_IN  ======================================================== */
#define SIO_GPIO_IN_GPIO_IN_Pos           (0UL)                     /*!< GPIO_IN (Bit 0) */
#define SIO_GPIO_IN_GPIO_IN_Msk           (0x3fffffffUL)            /*!< GPIO_IN (Bitfield-Mask: 0x3fffffff) */
/* ======================================================  GPIO_HI_IN  ======================================================= */
#define SIO_GPIO_HI_IN_GPIO_HI_IN_Pos     (0UL)                     /*!< GPIO_HI_IN (Bit 0) */
#define SIO_GPIO_HI_IN_GPIO_HI_IN_Msk     (0x3fUL)                  /*!< GPIO_HI_IN (Bitfield-Mask: 0x3f) */
/* =======================================================  GPIO_OUT  ======================================================== */
#define SIO_GPIO_OUT_GPIO_OUT_Pos         (0UL)                     /*!< GPIO_OUT (Bit 0) */
#define SIO_GPIO_OUT_GPIO_OUT_Msk         (0x3fffffffUL)            /*!< GPIO_OUT (Bitfield-Mask: 0x3fffffff) */
/* =====================================================  GPIO_OUT_SET  ====================================================== */
#define SIO_GPIO_OUT_SET_GPIO_OUT_SET_Pos (0UL)                     /*!< GPIO_OUT_SET (Bit 0) */
#define SIO_GPIO_OUT_SET_GPIO_OUT_SET_Msk (0x3fffffffUL)            /*!< GPIO_OUT_SET (Bitfield-Mask: 0x3fffffff) */
/* =====================================================  GPIO_OUT_CLR  ====================================================== */
#define SIO_GPIO_OUT_CLR_GPIO_OUT_CLR_Pos (0UL)                     /*!< GPIO_OUT_CLR (Bit 0) */
#define SIO_GPIO_OUT_CLR_GPIO_OUT_CLR_Msk (0x3fffffffUL)            /*!< GPIO_OUT_CLR (Bitfield-Mask: 0x3fffffff) */
/* =====================================================  GPIO_OUT_XOR  ====================================================== */
#define SIO_GPIO_OUT_XOR_GPIO_OUT_XOR_Pos (0UL)                     /*!< GPIO_OUT_XOR (Bit 0) */
#define SIO_GPIO_OUT_XOR_GPIO_OUT_XOR_Msk (0x3fffffffUL)            /*!< GPIO_OUT_XOR (Bitfield-Mask: 0x3fffffff) */
/* ========================================================  GPIO_OE  ======================================================== */
#define SIO_GPIO_OE_GPIO_OE_Pos           (0UL)                     /*!< GPIO_OE (Bit 0) */
#define SIO_GPIO_OE_GPIO_OE_Msk           (0x3fffffffUL)            /*!< GPIO_OE (Bitfield-Mask: 0x3fffffff) */
/* ======================================================  GPIO_OE_SET  ====================================================== */
#define SIO_GPIO_OE_SET_GPIO_OE_SET_Pos   (0UL)                     /*!< GPIO_OE_SET (Bit 0) */
#define SIO_GPIO_OE_SET_GPIO_OE_SET_Msk   (0x3fffffffUL)            /*!< GPIO_OE_SET (Bitfield-Mask: 0x3fffffff) */
/* ======================================================  GPIO_OE_CLR  ====================================================== */
#define SIO_GPIO_OE_CLR_GPIO_OE_CLR_Pos   (0UL)                     /*!< GPIO_OE_CLR (Bit 0) */
#define SIO_GPIO_OE_CLR_GPIO_OE_CLR_Msk   (0x3fffffffUL)            /*!< GPIO_OE_CLR (Bitfield-Mask: 0x3fffffff) */
/* ======================================================  GPIO_OE_XOR  ====================================================== */
#define SIO_GPIO_OE_XOR_GPIO_OE_XOR_Pos   (0UL)                     /*!< GPIO_OE_XOR (Bit 0) */
#define SIO_GPIO_OE_XOR_GPIO_OE_XOR_Msk   (0x3fffffffUL)            /*!< GPIO_OE_XOR (Bitfield-Mask: 0x3fffffff) */
/* ======================================================  GPIO_HI_OUT  ====================================================== */
#define SIO_GPIO_HI_OUT_GPIO_HI_OUT_Pos   (0UL)                     /*!< GPIO_HI_OUT (Bit 0) */
#define SIO_GPIO_HI_OUT_GPIO_HI_OUT_Msk   (0x3fUL)                  /*!< GPIO_HI_OUT (Bitfield-Mask: 0x3f) */
/* ====================================================  GPIO_HI_OUT_SET  ==================================================== */
#define SIO_GPIO_HI_OUT_SET_GPIO_HI_OUT_SET_Pos (0UL)               /*!< GPIO_HI_OUT_SET (Bit 0) */
#define SIO_GPIO_HI_OUT_SET_GPIO_HI_OUT_SET_Msk (0x3fUL)            /*!< GPIO_HI_OUT_SET (Bitfield-Mask: 0x3f) */
/* ====================================================  GPIO_HI_OUT_CLR  ==================================================== */
#define SIO_GPIO_HI_OUT_CLR_GPIO_HI_OUT_CLR_Pos (0UL)               /*!< GPIO_HI_OUT_CLR (Bit 0) */
#define SIO_GPIO_HI_OUT_CLR_GPIO_HI_OUT_CLR_Msk (0x3fUL)            /*!< GPIO_HI_OUT_CLR (Bitfield-Mask: 0x3f) */
/* ====================================================  GPIO_HI_OUT_XOR  ==================================================== */
#define SIO_GPIO_HI_OUT_XOR_GPIO_HI_OUT_XOR_Pos (0UL)               /*!< GPIO_HI_OUT_XOR (Bit 0) */
#define SIO_GPIO_HI_OUT_XOR_GPIO_HI_OUT_XOR_Msk (0x3fUL)            /*!< GPIO_HI_OUT_XOR (Bitfield-Mask: 0x3f) */
/* ======================================================  GPIO_HI_OE  ======================================================= */
#define SIO_GPIO_HI_OE_GPIO_HI_OE_Pos     (0UL)                     /*!< GPIO_HI_OE (Bit 0) */
#define SIO_GPIO_HI_OE_GPIO_HI_OE_Msk     (0x3fUL)                  /*!< GPIO_HI_OE (Bitfield-Mask: 0x3f) */
/* ====================================================  GPIO_HI_OE_SET  ===================================================== */
#define SIO_GPIO_HI_OE_SET_GPIO_HI_OE_SET_Pos (0UL)                 /*!< GPIO_HI_OE_SET (Bit 0) */
#define SIO_GPIO_HI_OE_SET_GPIO_HI_OE_SET_Msk (0x3fUL)              /*!< GPIO_HI_OE_SET (Bitfield-Mask: 0x3f) */
/* ====================================================  GPIO_HI_OE_CLR  ===================================================== */
#define SIO_GPIO_HI_OE_CLR_GPIO_HI_OE_CLR_Pos (0UL)                 /*!< GPIO_HI_OE_CLR (Bit 0) */
#define SIO_GPIO_HI_OE_CLR_GPIO_HI_OE_CLR_Msk (0x3fUL)              /*!< GPIO_HI_OE_CLR (Bitfield-Mask: 0x3f) */
/* ====================================================  GPIO_HI_OE_XOR  ===================================================== */
#define SIO_GPIO_HI_OE_XOR_GPIO_HI_OE_XOR_Pos (0UL)                 /*!< GPIO_HI_OE_XOR (Bit 0) */
#define SIO_GPIO_HI_OE_XOR_GPIO_HI_OE_XOR_Msk (0x3fUL)              /*!< GPIO_HI_OE_XOR (Bitfield-Mask: 0x3f) */
/* ========================================================  FIFO_ST  ======================================================== */
#define SIO_FIFO_ST_ROE_Pos               (3UL)                     /*!< ROE (Bit 3) */
#define SIO_FIFO_ST_ROE_Msk               (0x8UL)                   /*!< ROE (Bitfield-Mask: 0x01) */
#define SIO_FIFO_ST_WOF_Pos               (2UL)                     /*!< WOF (Bit 2) */
#define SIO_FIFO_ST_WOF_Msk               (0x4UL)                   /*!< WOF (Bitfield-Mask: 0x01) */
#define SIO_FIFO_ST_RDY_Pos               (1UL)                     /*!< RDY (Bit 1) */
#define SIO_FIFO_ST_RDY_Msk               (0x2UL)                   /*!< RDY (Bitfield-Mask: 0x01) */
#define SIO_FIFO_ST_VLD_Pos               (0UL)                     /*!< VLD (Bit 0) */
#define SIO_FIFO_ST_VLD_Msk               (0x1UL)                   /*!< VLD (Bitfield-Mask: 0x01) */
/* ========================================================  FIFO_WR  ======================================================== */
/* ========================================================  FIFO_RD  ======================================================== */
/* ======================================================  SPINLOCK_ST  ====================================================== */
/* =====================================================  DIV_UDIVIDEND  ===================================================== */
/* =====================================================  DIV_UDIVISOR  ====================================================== */
/* =====================================================  DIV_SDIVIDEND  ===================================================== */
/* =====================================================  DIV_SDIVISOR  ====================================================== */
/* =====================================================  DIV_QUOTIENT  ====================================================== */
/* =====================================================  DIV_REMAINDER  ===================================================== */
/* ========================================================  DIV_CSR  ======================================================== */
#define SIO_DIV_CSR_DIRTY_Pos             (1UL)                     /*!< DIRTY (Bit 1) */
#define SIO_DIV_CSR_DIRTY_Msk             (0x2UL)                   /*!< DIRTY (Bitfield-Mask: 0x01) */
#define SIO_DIV_CSR_READY_Pos             (0UL)                     /*!< READY (Bit 0) */
#define SIO_DIV_CSR_READY_Msk             (0x1UL)                   /*!< READY (Bitfield-Mask: 0x01) */
/* ====================================================  INTERP0_ACCUM0  ===================================================== */
/* ====================================================  INTERP0_ACCUM1  ===================================================== */
/* =====================================================  INTERP0_BASE0  ===================================================== */
/* =====================================================  INTERP0_BASE1  ===================================================== */
/* =====================================================  INTERP0_BASE2  ===================================================== */
/* ===================================================  INTERP0_POP_LANE0  =================================================== */
/* ===================================================  INTERP0_POP_LANE1  =================================================== */
/* ===================================================  INTERP0_POP_FULL  ==================================================== */
/* ==================================================  INTERP0_PEEK_LANE0  =================================================== */
/* ==================================================  INTERP0_PEEK_LANE1  =================================================== */
/* ===================================================  INTERP0_PEEK_FULL  =================================================== */
/* ==================================================  INTERP0_CTRL_LANE0  =================================================== */
#define SIO_INTERP0_CTRL_LANE0_OVERF_Pos  (25UL)                    /*!< OVERF (Bit 25) */
#define SIO_INTERP0_CTRL_LANE0_OVERF_Msk  (0x2000000UL)             /*!< OVERF (Bitfield-Mask: 0x01) */
#define SIO_INTERP0_CTRL_LANE0_OVERF1_Pos (24UL)                    /*!< OVERF1 (Bit 24) */
#define SIO_INTERP0_CTRL_LANE0_OVERF1_Msk (0x1000000UL)             /*!< OVERF1 (Bitfield-Mask: 0x01) */
#define SIO_INTERP0_CTRL_LANE0_OVERF0_Pos (23UL)                    /*!< OVERF0 (Bit 23) */
#define SIO_INTERP0_CTRL_LANE0_OVERF0_Msk (0x800000UL)              /*!< OVERF0 (Bitfield-Mask: 0x01) */
#define SIO_INTERP0_CTRL_LANE0_BLEND_Pos  (21UL)                    /*!< BLEND (Bit 21) */
#define SIO_INTERP0_CTRL_LANE0_BLEND_Msk  (0x200000UL)              /*!< BLEND (Bitfield-Mask: 0x01) */
#define SIO_INTERP0_CTRL_LANE0_FORCE_MSB_Pos (19UL)                 /*!< FORCE_MSB (Bit 19) */
#define SIO_INTERP0_CTRL_LANE0_FORCE_MSB_Msk (0x180000UL)           /*!< FORCE_MSB (Bitfield-Mask: 0x03) */
#define SIO_INTERP0_CTRL_LANE0_ADD_RAW_Pos (18UL)                   /*!< ADD_RAW (Bit 18) */
#define SIO_INTERP0_CTRL_LANE0_ADD_RAW_Msk (0x40000UL)              /*!< ADD_RAW (Bitfield-Mask: 0x01) */
#define SIO_INTERP0_CTRL_LANE0_CROSS_RESULT_Pos (17UL)              /*!< CROSS_RESULT (Bit 17) */
#define SIO_INTERP0_CTRL_LANE0_CROSS_RESULT_Msk (0x20000UL)         /*!< CROSS_RESULT (Bitfield-Mask: 0x01) */
#define SIO_INTERP0_CTRL_LANE0_CROSS_INPUT_Pos (16UL)               /*!< CROSS_INPUT (Bit 16) */
#define SIO_INTERP0_CTRL_LANE0_CROSS_INPUT_Msk (0x10000UL)          /*!< CROSS_INPUT (Bitfield-Mask: 0x01) */
#define SIO_INTERP0_CTRL_LANE0_SIGNED_Pos (15UL)                    /*!< SIGNED (Bit 15) */
#define SIO_INTERP0_CTRL_LANE0_SIGNED_Msk (0x8000UL)                /*!< SIGNED (Bitfield-Mask: 0x01) */
#define SIO_INTERP0_CTRL_LANE0_MASK_MSB_Pos (10UL)                  /*!< MASK_MSB (Bit 10) */
#define SIO_INTERP0_CTRL_LANE0_MASK_MSB_Msk (0x7c00UL)              /*!< MASK_MSB (Bitfield-Mask: 0x1f) */
#define SIO_INTERP0_CTRL_LANE0_MASK_LSB_Pos (5UL)                   /*!< MASK_LSB (Bit 5) */
#define SIO_INTERP0_CTRL_LANE0_MASK_LSB_Msk (0x3e0UL)               /*!< MASK_LSB (Bitfield-Mask: 0x1f) */
#define SIO_INTERP0_CTRL_LANE0_SHIFT_Pos  (0UL)                     /*!< SHIFT (Bit 0) */
#define SIO_INTERP0_CTRL_LANE0_SHIFT_Msk  (0x1fUL)                  /*!< SHIFT (Bitfield-Mask: 0x1f) */
/* ==================================================  INTERP0_CTRL_LANE1  =================================================== */
#define SIO_INTERP0_CTRL_LANE1_FORCE_MSB_Pos (19UL)                 /*!< FORCE_MSB (Bit 19) */
#define SIO_INTERP0_CTRL_LANE1_FORCE_MSB_Msk (0x180000UL)           /*!< FORCE_MSB (Bitfield-Mask: 0x03) */
#define SIO_INTERP0_CTRL_LANE1_ADD_RAW_Pos (18UL)                   /*!< ADD_RAW (Bit 18) */
#define SIO_INTERP0_CTRL_LANE1_ADD_RAW_Msk (0x40000UL)              /*!< ADD_RAW (Bitfield-Mask: 0x01) */
#define SIO_INTERP0_CTRL_LANE1_CROSS_RESULT_Pos (17UL)              /*!< CROSS_RESULT (Bit 17) */
#define SIO_INTERP0_CTRL_LANE1_CROSS_RESULT_Msk (0x20000UL)         /*!< CROSS_RESULT (Bitfield-Mask: 0x01) */
#define SIO_INTERP0_CTRL_LANE1_CROSS_INPUT_Pos (16UL)               /*!< CROSS_INPUT (Bit 16) */
#define SIO_INTERP0_CTRL_LANE1_CROSS_INPUT_Msk (0x10000UL)          /*!< CROSS_INPUT (Bitfield-Mask: 0x01) */
#define SIO_INTERP0_CTRL_LANE1_SIGNED_Pos (15UL)                    /*!< SIGNED (Bit 15) */
#define SIO_INTERP0_CTRL_LANE1_SIGNED_Msk (0x8000UL)                /*!< SIGNED (Bitfield-Mask: 0x01) */
#define SIO_INTERP0_CTRL_LANE1_MASK_MSB_Pos (10UL)                  /*!< MASK_MSB (Bit 10) */
#define SIO_INTERP0_CTRL_LANE1_MASK_MSB_Msk (0x7c00UL)              /*!< MASK_MSB (Bitfield-Mask: 0x1f) */
#define SIO_INTERP0_CTRL_LANE1_MASK_LSB_Pos (5UL)                   /*!< MASK_LSB (Bit 5) */
#define SIO_INTERP0_CTRL_LANE1_MASK_LSB_Msk (0x3e0UL)               /*!< MASK_LSB (Bitfield-Mask: 0x1f) */
#define SIO_INTERP0_CTRL_LANE1_SHIFT_Pos  (0UL)                     /*!< SHIFT (Bit 0) */
#define SIO_INTERP0_CTRL_LANE1_SHIFT_Msk  (0x1fUL)                  /*!< SHIFT (Bitfield-Mask: 0x1f) */
/* ==================================================  INTERP0_ACCUM0_ADD  =================================================== */
#define SIO_INTERP0_ACCUM0_ADD_INTERP0_ACCUM0_ADD_Pos (0UL)         /*!< INTERP0_ACCUM0_ADD (Bit 0) */
#define SIO_INTERP0_ACCUM0_ADD_INTERP0_ACCUM0_ADD_Msk (0xffffffUL)  /*!< INTERP0_ACCUM0_ADD (Bitfield-Mask: 0xffffff) */
/* ==================================================  INTERP0_ACCUM1_ADD  =================================================== */
#define SIO_INTERP0_ACCUM1_ADD_INTERP0_ACCUM1_ADD_Pos (0UL)         /*!< INTERP0_ACCUM1_ADD (Bit 0) */
#define SIO_INTERP0_ACCUM1_ADD_INTERP0_ACCUM1_ADD_Msk (0xffffffUL)  /*!< INTERP0_ACCUM1_ADD (Bitfield-Mask: 0xffffff) */
/* ==================================================  INTERP0_BASE_1AND0  =================================================== */
/* ====================================================  INTERP1_ACCUM0  ===================================================== */
/* ====================================================  INTERP1_ACCUM1  ===================================================== */
/* =====================================================  INTERP1_BASE0  ===================================================== */
/* =====================================================  INTERP1_BASE1  ===================================================== */
/* =====================================================  INTERP1_BASE2  ===================================================== */
/* ===================================================  INTERP1_POP_LANE0  =================================================== */
/* ===================================================  INTERP1_POP_LANE1  =================================================== */
/* ===================================================  INTERP1_POP_FULL  ==================================================== */
/* ==================================================  INTERP1_PEEK_LANE0  =================================================== */
/* ==================================================  INTERP1_PEEK_LANE1  =================================================== */
/* ===================================================  INTERP1_PEEK_FULL  =================================================== */
/* ==================================================  INTERP1_CTRL_LANE0  =================================================== */
#define SIO_INTERP1_CTRL_LANE0_OVERF_Pos  (25UL)                    /*!< OVERF (Bit 25) */
#define SIO_INTERP1_CTRL_LANE0_OVERF_Msk  (0x2000000UL)             /*!< OVERF (Bitfield-Mask: 0x01) */
#define SIO_INTERP1_CTRL_LANE0_OVERF1_Pos (24UL)                    /*!< OVERF1 (Bit 24) */
#define SIO_INTERP1_CTRL_LANE0_OVERF1_Msk (0x1000000UL)             /*!< OVERF1 (Bitfield-Mask: 0x01) */
#define SIO_INTERP1_CTRL_LANE0_OVERF0_Pos (23UL)                    /*!< OVERF0 (Bit 23) */
#define SIO_INTERP1_CTRL_LANE0_OVERF0_Msk (0x800000UL)              /*!< OVERF0 (Bitfield-Mask: 0x01) */
#define SIO_INTERP1_CTRL_LANE0_CLAMP_Pos  (22UL)                    /*!< CLAMP (Bit 22) */
#define SIO_INTERP1_CTRL_LANE0_CLAMP_Msk  (0x400000UL)              /*!< CLAMP (Bitfield-Mask: 0x01) */
#define SIO_INTERP1_CTRL_LANE0_FORCE_MSB_Pos (19UL)                 /*!< FORCE_MSB (Bit 19) */
#define SIO_INTERP1_CTRL_LANE0_FORCE_MSB_Msk (0x180000UL)           /*!< FORCE_MSB (Bitfield-Mask: 0x03) */
#define SIO_INTERP1_CTRL_LANE0_ADD_RAW_Pos (18UL)                   /*!< ADD_RAW (Bit 18) */
#define SIO_INTERP1_CTRL_LANE0_ADD_RAW_Msk (0x40000UL)              /*!< ADD_RAW (Bitfield-Mask: 0x01) */
#define SIO_INTERP1_CTRL_LANE0_CROSS_RESULT_Pos (17UL)              /*!< CROSS_RESULT (Bit 17) */
#define SIO_INTERP1_CTRL_LANE0_CROSS_RESULT_Msk (0x20000UL)         /*!< CROSS_RESULT (Bitfield-Mask: 0x01) */
#define SIO_INTERP1_CTRL_LANE0_CROSS_INPUT_Pos (16UL)               /*!< CROSS_INPUT (Bit 16) */
#define SIO_INTERP1_CTRL_LANE0_CROSS_INPUT_Msk (0x10000UL)          /*!< CROSS_INPUT (Bitfield-Mask: 0x01) */
#define SIO_INTERP1_CTRL_LANE0_SIGNED_Pos (15UL)                    /*!< SIGNED (Bit 15) */
#define SIO_INTERP1_CTRL_LANE0_SIGNED_Msk (0x8000UL)                /*!< SIGNED (Bitfield-Mask: 0x01) */
#define SIO_INTERP1_CTRL_LANE0_MASK_MSB_Pos (10UL)                  /*!< MASK_MSB (Bit 10) */
#define SIO_INTERP1_CTRL_LANE0_MASK_MSB_Msk (0x7c00UL)              /*!< MASK_MSB (Bitfield-Mask: 0x1f) */
#define SIO_INTERP1_CTRL_LANE0_MASK_LSB_Pos (5UL)                   /*!< MASK_LSB (Bit 5) */
#define SIO_INTERP1_CTRL_LANE0_MASK_LSB_Msk (0x3e0UL)               /*!< MASK_LSB (Bitfield-Mask: 0x1f) */
#define SIO_INTERP1_CTRL_LANE0_SHIFT_Pos  (0UL)                     /*!< SHIFT (Bit 0) */
#define SIO_INTERP1_CTRL_LANE0_SHIFT_Msk  (0x1fUL)                  /*!< SHIFT (Bitfield-Mask: 0x1f) */
/* ==================================================  INTERP1_CTRL_LANE1  =================================================== */
#define SIO_INTERP1_CTRL_LANE1_FORCE_MSB_Pos (19UL)                 /*!< FORCE_MSB (Bit 19) */
#define SIO_INTERP1_CTRL_LANE1_FORCE_MSB_Msk (0x180000UL)           /*!< FORCE_MSB (Bitfield-Mask: 0x03) */
#define SIO_INTERP1_CTRL_LANE1_ADD_RAW_Pos (18UL)                   /*!< ADD_RAW (Bit 18) */
#define SIO_INTERP1_CTRL_LANE1_ADD_RAW_Msk (0x40000UL)              /*!< ADD_RAW (Bitfield-Mask: 0x01) */
#define SIO_INTERP1_CTRL_LANE1_CROSS_RESULT_Pos (17UL)              /*!< CROSS_RESULT (Bit 17) */
#define SIO_INTERP1_CTRL_LANE1_CROSS_RESULT_Msk (0x20000UL)         /*!< CROSS_RESULT (Bitfield-Mask: 0x01) */
#define SIO_INTERP1_CTRL_LANE1_CROSS_INPUT_Pos (16UL)               /*!< CROSS_INPUT (Bit 16) */
#define SIO_INTERP1_CTRL_LANE1_CROSS_INPUT_Msk (0x10000UL)          /*!< CROSS_INPUT (Bitfield-Mask: 0x01) */
#define SIO_INTERP1_CTRL_LANE1_SIGNED_Pos (15UL)                    /*!< SIGNED (Bit 15) */
#define SIO_INTERP1_CTRL_LANE1_SIGNED_Msk (0x8000UL)                /*!< SIGNED (Bitfield-Mask: 0x01) */
#define SIO_INTERP1_CTRL_LANE1_MASK_MSB_Pos (10UL)                  /*!< MASK_MSB (Bit 10) */
#define SIO_INTERP1_CTRL_LANE1_MASK_MSB_Msk (0x7c00UL)              /*!< MASK_MSB (Bitfield-Mask: 0x1f) */
#define SIO_INTERP1_CTRL_LANE1_MASK_LSB_Pos (5UL)                   /*!< MASK_LSB (Bit 5) */
#define SIO_INTERP1_CTRL_LANE1_MASK_LSB_Msk (0x3e0UL)               /*!< MASK_LSB (Bitfield-Mask: 0x1f) */
#define SIO_INTERP1_CTRL_LANE1_SHIFT_Pos  (0UL)                     /*!< SHIFT (Bit 0) */
#define SIO_INTERP1_CTRL_LANE1_SHIFT_Msk  (0x1fUL)                  /*!< SHIFT (Bitfield-Mask: 0x1f) */
/* ==================================================  INTERP1_ACCUM0_ADD  =================================================== */
#define SIO_INTERP1_ACCUM0_ADD_INTERP1_ACCUM0_ADD_Pos (0UL)         /*!< INTERP1_ACCUM0_ADD (Bit 0) */
#define SIO_INTERP1_ACCUM0_ADD_INTERP1_ACCUM0_ADD_Msk (0xffffffUL)  /*!< INTERP1_ACCUM0_ADD (Bitfield-Mask: 0xffffff) */
/* ==================================================  INTERP1_ACCUM1_ADD  =================================================== */
#define SIO_INTERP1_ACCUM1_ADD_INTERP1_ACCUM1_ADD_Pos (0UL)         /*!< INTERP1_ACCUM1_ADD (Bit 0) */
#define SIO_INTERP1_ACCUM1_ADD_INTERP1_ACCUM1_ADD_Msk (0xffffffUL)  /*!< INTERP1_ACCUM1_ADD (Bitfield-Mask: 0xffffff) */
/* ==================================================  INTERP1_BASE_1AND0  =================================================== */
/* =======================================================  SPINLOCK0  ======================================================= */
/* =======================================================  SPINLOCK1  ======================================================= */
/* =======================================================  SPINLOCK2  ======================================================= */
/* =======================================================  SPINLOCK3  ======================================================= */
/* =======================================================  SPINLOCK4  ======================================================= */
/* =======================================================  SPINLOCK5  ======================================================= */
/* =======================================================  SPINLOCK6  ======================================================= */
/* =======================================================  SPINLOCK7  ======================================================= */
/* =======================================================  SPINLOCK8  ======================================================= */
/* =======================================================  SPINLOCK9  ======================================================= */
/* ======================================================  SPINLOCK10  ======================================================= */
/* ======================================================  SPINLOCK11  ======================================================= */
/* ======================================================  SPINLOCK12  ======================================================= */
/* ======================================================  SPINLOCK13  ======================================================= */
/* ======================================================  SPINLOCK14  ======================================================= */
/* ======================================================  SPINLOCK15  ======================================================= */
/* ======================================================  SPINLOCK16  ======================================================= */
/* ======================================================  SPINLOCK17  ======================================================= */
/* ======================================================  SPINLOCK18  ======================================================= */
/* ======================================================  SPINLOCK19  ======================================================= */
/* ======================================================  SPINLOCK20  ======================================================= */
/* ======================================================  SPINLOCK21  ======================================================= */
/* ======================================================  SPINLOCK22  ======================================================= */
/* ======================================================  SPINLOCK23  ======================================================= */
/* ======================================================  SPINLOCK24  ======================================================= */
/* ======================================================  SPINLOCK25  ======================================================= */
/* ======================================================  SPINLOCK26  ======================================================= */
/* ======================================================  SPINLOCK27  ======================================================= */
/* ======================================================  SPINLOCK28  ======================================================= */
/* ======================================================  SPINLOCK29  ======================================================= */
/* ======================================================  SPINLOCK30  ======================================================= */
/* ======================================================  SPINLOCK31  ======================================================= */


/* =========================================================================================================================== */
/* ================                                            PPB                                            ================ */
/* =========================================================================================================================== */

/* =======================================================  SYST_CSR  ======================================================== */
#define PPB_SYST_CSR_COUNTFLAG_Pos        (16UL)                    /*!< COUNTFLAG (Bit 16) */
#define PPB_SYST_CSR_COUNTFLAG_Msk        (0x10000UL)               /*!< COUNTFLAG (Bitfield-Mask: 0x01) */
#define PPB_SYST_CSR_CLKSOURCE_Pos        (2UL)                     /*!< CLKSOURCE (Bit 2) */
#define PPB_SYST_CSR_CLKSOURCE_Msk        (0x4UL)                   /*!< CLKSOURCE (Bitfield-Mask: 0x01) */
#define PPB_SYST_CSR_TICKINT_Pos          (1UL)                     /*!< TICKINT (Bit 1) */
#define PPB_SYST_CSR_TICKINT_Msk          (0x2UL)                   /*!< TICKINT (Bitfield-Mask: 0x01) */
#define PPB_SYST_CSR_ENABLE_Pos           (0UL)                     /*!< ENABLE (Bit 0) */
#define PPB_SYST_CSR_ENABLE_Msk           (0x1UL)                   /*!< ENABLE (Bitfield-Mask: 0x01) */
/* =======================================================  SYST_RVR  ======================================================== */
#define PPB_SYST_RVR_RELOAD_Pos           (0UL)                     /*!< RELOAD (Bit 0) */
#define PPB_SYST_RVR_RELOAD_Msk           (0xffffffUL)              /*!< RELOAD (Bitfield-Mask: 0xffffff) */
/* =======================================================  SYST_CVR  ======================================================== */
#define PPB_SYST_CVR_CURRENT_Pos          (0UL)                     /*!< CURRENT (Bit 0) */
#define PPB_SYST_CVR_CURRENT_Msk          (0xffffffUL)              /*!< CURRENT (Bitfield-Mask: 0xffffff) */
/* ======================================================  SYST_CALIB  ======================================================= */
#define PPB_SYST_CALIB_NOREF_Pos          (31UL)                    /*!< NOREF (Bit 31) */
#define PPB_SYST_CALIB_NOREF_Msk          (0x80000000UL)            /*!< NOREF (Bitfield-Mask: 0x01) */
#define PPB_SYST_CALIB_SKEW_Pos           (30UL)                    /*!< SKEW (Bit 30) */
#define PPB_SYST_CALIB_SKEW_Msk           (0x40000000UL)            /*!< SKEW (Bitfield-Mask: 0x01) */
#define PPB_SYST_CALIB_TENMS_Pos          (0UL)                     /*!< TENMS (Bit 0) */
#define PPB_SYST_CALIB_TENMS_Msk          (0xffffffUL)              /*!< TENMS (Bitfield-Mask: 0xffffff) */
/* =======================================================  NVIC_ISER  ======================================================= */
#define PPB_NVIC_ISER_SETENA_Pos          (0UL)                     /*!< SETENA (Bit 0) */
#define PPB_NVIC_ISER_SETENA_Msk          (0xffffffffUL)            /*!< SETENA (Bitfield-Mask: 0xffffffff) */
/* =======================================================  NVIC_ICER  ======================================================= */
#define PPB_NVIC_ICER_CLRENA_Pos          (0UL)                     /*!< CLRENA (Bit 0) */
#define PPB_NVIC_ICER_CLRENA_Msk          (0xffffffffUL)            /*!< CLRENA (Bitfield-Mask: 0xffffffff) */
/* =======================================================  NVIC_ISPR  ======================================================= */
#define PPB_NVIC_ISPR_SETPEND_Pos         (0UL)                     /*!< SETPEND (Bit 0) */
#define PPB_NVIC_ISPR_SETPEND_Msk         (0xffffffffUL)            /*!< SETPEND (Bitfield-Mask: 0xffffffff) */
/* =======================================================  NVIC_ICPR  ======================================================= */
#define PPB_NVIC_ICPR_CLRPEND_Pos         (0UL)                     /*!< CLRPEND (Bit 0) */
#define PPB_NVIC_ICPR_CLRPEND_Msk         (0xffffffffUL)            /*!< CLRPEND (Bitfield-Mask: 0xffffffff) */
/* =======================================================  NVIC_IPR0  ======================================================= */
#define PPB_NVIC_IPR0_IP_3_Pos            (30UL)                    /*!< IP_3 (Bit 30) */
#define PPB_NVIC_IPR0_IP_3_Msk            (0xc0000000UL)            /*!< IP_3 (Bitfield-Mask: 0x03) */
#define PPB_NVIC_IPR0_IP_2_Pos            (22UL)                    /*!< IP_2 (Bit 22) */
#define PPB_NVIC_IPR0_IP_2_Msk            (0xc00000UL)              /*!< IP_2 (Bitfield-Mask: 0x03) */
#define PPB_NVIC_IPR0_IP_1_Pos            (14UL)                    /*!< IP_1 (Bit 14) */
#define PPB_NVIC_IPR0_IP_1_Msk            (0xc000UL)                /*!< IP_1 (Bitfield-Mask: 0x03) */
#define PPB_NVIC_IPR0_IP_0_Pos            (6UL)                     /*!< IP_0 (Bit 6) */
#define PPB_NVIC_IPR0_IP_0_Msk            (0xc0UL)                  /*!< IP_0 (Bitfield-Mask: 0x03) */
/* =======================================================  NVIC_IPR1  ======================================================= */
#define PPB_NVIC_IPR1_IP_7_Pos            (30UL)                    /*!< IP_7 (Bit 30) */
#define PPB_NVIC_IPR1_IP_7_Msk            (0xc0000000UL)            /*!< IP_7 (Bitfield-Mask: 0x03) */
#define PPB_NVIC_IPR1_IP_6_Pos            (22UL)                    /*!< IP_6 (Bit 22) */
#define PPB_NVIC_IPR1_IP_6_Msk            (0xc00000UL)              /*!< IP_6 (Bitfield-Mask: 0x03) */
#define PPB_NVIC_IPR1_IP_5_Pos            (14UL)                    /*!< IP_5 (Bit 14) */
#define PPB_NVIC_IPR1_IP_5_Msk            (0xc000UL)                /*!< IP_5 (Bitfield-Mask: 0x03) */
#define PPB_NVIC_IPR1_IP_4_Pos            (6UL)                     /*!< IP_4 (Bit 6) */
#define PPB_NVIC_IPR1_IP_4_Msk            (0xc0UL)                  /*!< IP_4 (Bitfield-Mask: 0x03) */
/* =======================================================  NVIC_IPR2  ======================================================= */
#define PPB_NVIC_IPR2_IP_11_Pos           (30UL)                    /*!< IP_11 (Bit 30) */
#define PPB_NVIC_IPR2_IP_11_Msk           (0xc0000000UL)            /*!< IP_11 (Bitfield-Mask: 0x03) */
#define PPB_NVIC_IPR2_IP_10_Pos           (22UL)                    /*!< IP_10 (Bit 22) */
#define PPB_NVIC_IPR2_IP_10_Msk           (0xc00000UL)              /*!< IP_10 (Bitfield-Mask: 0x03) */
#define PPB_NVIC_IPR2_IP_9_Pos            (14UL)                    /*!< IP_9 (Bit 14) */
#define PPB_NVIC_IPR2_IP_9_Msk            (0xc000UL)                /*!< IP_9 (Bitfield-Mask: 0x03) */
#define PPB_NVIC_IPR2_IP_8_Pos            (6UL)                     /*!< IP_8 (Bit 6) */
#define PPB_NVIC_IPR2_IP_8_Msk            (0xc0UL)                  /*!< IP_8 (Bitfield-Mask: 0x03) */
/* =======================================================  NVIC_IPR3  ======================================================= */
#define PPB_NVIC_IPR3_IP_15_Pos           (30UL)                    /*!< IP_15 (Bit 30) */
#define PPB_NVIC_IPR3_IP_15_Msk           (0xc0000000UL)            /*!< IP_15 (Bitfield-Mask: 0x03) */
#define PPB_NVIC_IPR3_IP_14_Pos           (22UL)                    /*!< IP_14 (Bit 22) */
#define PPB_NVIC_IPR3_IP_14_Msk           (0xc00000UL)              /*!< IP_14 (Bitfield-Mask: 0x03) */
#define PPB_NVIC_IPR3_IP_13_Pos           (14UL)                    /*!< IP_13 (Bit 14) */
#define PPB_NVIC_IPR3_IP_13_Msk           (0xc000UL)                /*!< IP_13 (Bitfield-Mask: 0x03) */
#define PPB_NVIC_IPR3_IP_12_Pos           (6UL)                     /*!< IP_12 (Bit 6) */
#define PPB_NVIC_IPR3_IP_12_Msk           (0xc0UL)                  /*!< IP_12 (Bitfield-Mask: 0x03) */
/* =======================================================  NVIC_IPR4  ======================================================= */
#define PPB_NVIC_IPR4_IP_19_Pos           (30UL)                    /*!< IP_19 (Bit 30) */
#define PPB_NVIC_IPR4_IP_19_Msk           (0xc0000000UL)            /*!< IP_19 (Bitfield-Mask: 0x03) */
#define PPB_NVIC_IPR4_IP_18_Pos           (22UL)                    /*!< IP_18 (Bit 22) */
#define PPB_NVIC_IPR4_IP_18_Msk           (0xc00000UL)              /*!< IP_18 (Bitfield-Mask: 0x03) */
#define PPB_NVIC_IPR4_IP_17_Pos           (14UL)                    /*!< IP_17 (Bit 14) */
#define PPB_NVIC_IPR4_IP_17_Msk           (0xc000UL)                /*!< IP_17 (Bitfield-Mask: 0x03) */
#define PPB_NVIC_IPR4_IP_16_Pos           (6UL)                     /*!< IP_16 (Bit 6) */
#define PPB_NVIC_IPR4_IP_16_Msk           (0xc0UL)                  /*!< IP_16 (Bitfield-Mask: 0x03) */
/* =======================================================  NVIC_IPR5  ======================================================= */
#define PPB_NVIC_IPR5_IP_23_Pos           (30UL)                    /*!< IP_23 (Bit 30) */
#define PPB_NVIC_IPR5_IP_23_Msk           (0xc0000000UL)            /*!< IP_23 (Bitfield-Mask: 0x03) */
#define PPB_NVIC_IPR5_IP_22_Pos           (22UL)                    /*!< IP_22 (Bit 22) */
#define PPB_NVIC_IPR5_IP_22_Msk           (0xc00000UL)              /*!< IP_22 (Bitfield-Mask: 0x03) */
#define PPB_NVIC_IPR5_IP_21_Pos           (14UL)                    /*!< IP_21 (Bit 14) */
#define PPB_NVIC_IPR5_IP_21_Msk           (0xc000UL)                /*!< IP_21 (Bitfield-Mask: 0x03) */
#define PPB_NVIC_IPR5_IP_20_Pos           (6UL)                     /*!< IP_20 (Bit 6) */
#define PPB_NVIC_IPR5_IP_20_Msk           (0xc0UL)                  /*!< IP_20 (Bitfield-Mask: 0x03) */
/* =======================================================  NVIC_IPR6  ======================================================= */
#define PPB_NVIC_IPR6_IP_27_Pos           (30UL)                    /*!< IP_27 (Bit 30) */
#define PPB_NVIC_IPR6_IP_27_Msk           (0xc0000000UL)            /*!< IP_27 (Bitfield-Mask: 0x03) */
#define PPB_NVIC_IPR6_IP_26_Pos           (22UL)                    /*!< IP_26 (Bit 22) */
#define PPB_NVIC_IPR6_IP_26_Msk           (0xc00000UL)              /*!< IP_26 (Bitfield-Mask: 0x03) */
#define PPB_NVIC_IPR6_IP_25_Pos           (14UL)                    /*!< IP_25 (Bit 14) */
#define PPB_NVIC_IPR6_IP_25_Msk           (0xc000UL)                /*!< IP_25 (Bitfield-Mask: 0x03) */
#define PPB_NVIC_IPR6_IP_24_Pos           (6UL)                     /*!< IP_24 (Bit 6) */
#define PPB_NVIC_IPR6_IP_24_Msk           (0xc0UL)                  /*!< IP_24 (Bitfield-Mask: 0x03) */
/* =======================================================  NVIC_IPR7  ======================================================= */
#define PPB_NVIC_IPR7_IP_31_Pos           (30UL)                    /*!< IP_31 (Bit 30) */
#define PPB_NVIC_IPR7_IP_31_Msk           (0xc0000000UL)            /*!< IP_31 (Bitfield-Mask: 0x03) */
#define PPB_NVIC_IPR7_IP_30_Pos           (22UL)                    /*!< IP_30 (Bit 22) */
#define PPB_NVIC_IPR7_IP_30_Msk           (0xc00000UL)              /*!< IP_30 (Bitfield-Mask: 0x03) */
#define PPB_NVIC_IPR7_IP_29_Pos           (14UL)                    /*!< IP_29 (Bit 14) */
#define PPB_NVIC_IPR7_IP_29_Msk           (0xc000UL)                /*!< IP_29 (Bitfield-Mask: 0x03) */
#define PPB_NVIC_IPR7_IP_28_Pos           (6UL)                     /*!< IP_28 (Bit 6) */
#define PPB_NVIC_IPR7_IP_28_Msk           (0xc0UL)                  /*!< IP_28 (Bitfield-Mask: 0x03) */
/* =========================================================  CPUID  ========================================================= */
#define PPB_CPUID_IMPLEMENTER_Pos         (24UL)                    /*!< IMPLEMENTER (Bit 24) */
#define PPB_CPUID_IMPLEMENTER_Msk         (0xff000000UL)            /*!< IMPLEMENTER (Bitfield-Mask: 0xff) */
#define PPB_CPUID_VARIANT_Pos             (20UL)                    /*!< VARIANT (Bit 20) */
#define PPB_CPUID_VARIANT_Msk             (0xf00000UL)              /*!< VARIANT (Bitfield-Mask: 0x0f) */
#define PPB_CPUID_ARCHITECTURE_Pos        (16UL)                    /*!< ARCHITECTURE (Bit 16) */
#define PPB_CPUID_ARCHITECTURE_Msk        (0xf0000UL)               /*!< ARCHITECTURE (Bitfield-Mask: 0x0f) */
#define PPB_CPUID_PARTNO_Pos              (4UL)                     /*!< PARTNO (Bit 4) */
#define PPB_CPUID_PARTNO_Msk              (0xfff0UL)                /*!< PARTNO (Bitfield-Mask: 0xfff) */
#define PPB_CPUID_REVISION_Pos            (0UL)                     /*!< REVISION (Bit 0) */
#define PPB_CPUID_REVISION_Msk            (0xfUL)                   /*!< REVISION (Bitfield-Mask: 0x0f) */
/* =========================================================  ICSR  ========================================================== */
#define PPB_ICSR_NMIPENDSET_Pos           (31UL)                    /*!< NMIPENDSET (Bit 31) */
#define PPB_ICSR_NMIPENDSET_Msk           (0x80000000UL)            /*!< NMIPENDSET (Bitfield-Mask: 0x01) */
#define PPB_ICSR_PENDSVSET_Pos            (28UL)                    /*!< PENDSVSET (Bit 28) */
#define PPB_ICSR_PENDSVSET_Msk            (0x10000000UL)            /*!< PENDSVSET (Bitfield-Mask: 0x01) */
#define PPB_ICSR_PENDSVCLR_Pos            (27UL)                    /*!< PENDSVCLR (Bit 27) */
#define PPB_ICSR_PENDSVCLR_Msk            (0x8000000UL)             /*!< PENDSVCLR (Bitfield-Mask: 0x01) */
#define PPB_ICSR_PENDSTSET_Pos            (26UL)                    /*!< PENDSTSET (Bit 26) */
#define PPB_ICSR_PENDSTSET_Msk            (0x4000000UL)             /*!< PENDSTSET (Bitfield-Mask: 0x01) */
#define PPB_ICSR_PENDSTCLR_Pos            (25UL)                    /*!< PENDSTCLR (Bit 25) */
#define PPB_ICSR_PENDSTCLR_Msk            (0x2000000UL)             /*!< PENDSTCLR (Bitfield-Mask: 0x01) */
#define PPB_ICSR_ISRPREEMPT_Pos           (23UL)                    /*!< ISRPREEMPT (Bit 23) */
#define PPB_ICSR_ISRPREEMPT_Msk           (0x800000UL)              /*!< ISRPREEMPT (Bitfield-Mask: 0x01) */
#define PPB_ICSR_ISRPENDING_Pos           (22UL)                    /*!< ISRPENDING (Bit 22) */
#define PPB_ICSR_ISRPENDING_Msk           (0x400000UL)              /*!< ISRPENDING (Bitfield-Mask: 0x01) */
#define PPB_ICSR_VECTPENDING_Pos          (12UL)                    /*!< VECTPENDING (Bit 12) */
#define PPB_ICSR_VECTPENDING_Msk          (0x1ff000UL)              /*!< VECTPENDING (Bitfield-Mask: 0x1ff) */
#define PPB_ICSR_VECTACTIVE_Pos           (0UL)                     /*!< VECTACTIVE (Bit 0) */
#define PPB_ICSR_VECTACTIVE_Msk           (0x1ffUL)                 /*!< VECTACTIVE (Bitfield-Mask: 0x1ff) */
/* =========================================================  VTOR  ========================================================== */
#define PPB_VTOR_TBLOFF_Pos               (8UL)                     /*!< TBLOFF (Bit 8) */
#define PPB_VTOR_TBLOFF_Msk               (0xffffff00UL)            /*!< TBLOFF (Bitfield-Mask: 0xffffff) */
/* =========================================================  AIRCR  ========================================================= */
#define PPB_AIRCR_VECTKEY_Pos             (16UL)                    /*!< VECTKEY (Bit 16) */
#define PPB_AIRCR_VECTKEY_Msk             (0xffff0000UL)            /*!< VECTKEY (Bitfield-Mask: 0xffff) */
#define PPB_AIRCR_ENDIANESS_Pos           (15UL)                    /*!< ENDIANESS (Bit 15) */
#define PPB_AIRCR_ENDIANESS_Msk           (0x8000UL)                /*!< ENDIANESS (Bitfield-Mask: 0x01) */
#define PPB_AIRCR_SYSRESETREQ_Pos         (2UL)                     /*!< SYSRESETREQ (Bit 2) */
#define PPB_AIRCR_SYSRESETREQ_Msk         (0x4UL)                   /*!< SYSRESETREQ (Bitfield-Mask: 0x01) */
#define PPB_AIRCR_VECTCLRACTIVE_Pos       (1UL)                     /*!< VECTCLRACTIVE (Bit 1) */
#define PPB_AIRCR_VECTCLRACTIVE_Msk       (0x2UL)                   /*!< VECTCLRACTIVE (Bitfield-Mask: 0x01) */
/* ==========================================================  SCR  ========================================================== */
#define PPB_SCR_SEVONPEND_Pos             (4UL)                     /*!< SEVONPEND (Bit 4) */
#define PPB_SCR_SEVONPEND_Msk             (0x10UL)                  /*!< SEVONPEND (Bitfield-Mask: 0x01) */
#define PPB_SCR_SLEEPDEEP_Pos             (2UL)                     /*!< SLEEPDEEP (Bit 2) */
#define PPB_SCR_SLEEPDEEP_Msk             (0x4UL)                   /*!< SLEEPDEEP (Bitfield-Mask: 0x01) */
#define PPB_SCR_SLEEPONEXIT_Pos           (1UL)                     /*!< SLEEPONEXIT (Bit 1) */
#define PPB_SCR_SLEEPONEXIT_Msk           (0x2UL)                   /*!< SLEEPONEXIT (Bitfield-Mask: 0x01) */
/* ==========================================================  CCR  ========================================================== */
#define PPB_CCR_STKALIGN_Pos              (9UL)                     /*!< STKALIGN (Bit 9) */
#define PPB_CCR_STKALIGN_Msk              (0x200UL)                 /*!< STKALIGN (Bitfield-Mask: 0x01) */
#define PPB_CCR_UNALIGN_TRP_Pos           (3UL)                     /*!< UNALIGN_TRP (Bit 3) */
#define PPB_CCR_UNALIGN_TRP_Msk           (0x8UL)                   /*!< UNALIGN_TRP (Bitfield-Mask: 0x01) */
/* =========================================================  SHPR2  ========================================================= */
#define PPB_SHPR2_PRI_11_Pos              (30UL)                    /*!< PRI_11 (Bit 30) */
#define PPB_SHPR2_PRI_11_Msk              (0xc0000000UL)            /*!< PRI_11 (Bitfield-Mask: 0x03) */
/* =========================================================  SHPR3  ========================================================= */
#define PPB_SHPR3_PRI_15_Pos              (30UL)                    /*!< PRI_15 (Bit 30) */
#define PPB_SHPR3_PRI_15_Msk              (0xc0000000UL)            /*!< PRI_15 (Bitfield-Mask: 0x03) */
#define PPB_SHPR3_PRI_14_Pos              (22UL)                    /*!< PRI_14 (Bit 22) */
#define PPB_SHPR3_PRI_14_Msk              (0xc00000UL)              /*!< PRI_14 (Bitfield-Mask: 0x03) */
/* =========================================================  SHCSR  ========================================================= */
#define PPB_SHCSR_SVCALLPENDED_Pos        (15UL)                    /*!< SVCALLPENDED (Bit 15) */
#define PPB_SHCSR_SVCALLPENDED_Msk        (0x8000UL)                /*!< SVCALLPENDED (Bitfield-Mask: 0x01) */
/* =======================================================  MPU_TYPE  ======================================================== */
#define PPB_MPU_TYPE_IREGION_Pos          (16UL)                    /*!< IREGION (Bit 16) */
#define PPB_MPU_TYPE_IREGION_Msk          (0xff0000UL)              /*!< IREGION (Bitfield-Mask: 0xff) */
#define PPB_MPU_TYPE_DREGION_Pos          (8UL)                     /*!< DREGION (Bit 8) */
#define PPB_MPU_TYPE_DREGION_Msk          (0xff00UL)                /*!< DREGION (Bitfield-Mask: 0xff) */
#define PPB_MPU_TYPE_SEPARATE_Pos         (0UL)                     /*!< SEPARATE (Bit 0) */
#define PPB_MPU_TYPE_SEPARATE_Msk         (0x1UL)                   /*!< SEPARATE (Bitfield-Mask: 0x01) */
/* =======================================================  MPU_CTRL  ======================================================== */
#define PPB_MPU_CTRL_PRIVDEFENA_Pos       (2UL)                     /*!< PRIVDEFENA (Bit 2) */
#define PPB_MPU_CTRL_PRIVDEFENA_Msk       (0x4UL)                   /*!< PRIVDEFENA (Bitfield-Mask: 0x01) */
#define PPB_MPU_CTRL_HFNMIENA_Pos         (1UL)                     /*!< HFNMIENA (Bit 1) */
#define PPB_MPU_CTRL_HFNMIENA_Msk         (0x2UL)                   /*!< HFNMIENA (Bitfield-Mask: 0x01) */
#define PPB_MPU_CTRL_ENABLE_Pos           (0UL)                     /*!< ENABLE (Bit 0) */
#define PPB_MPU_CTRL_ENABLE_Msk           (0x1UL)                   /*!< ENABLE (Bitfield-Mask: 0x01) */
/* ========================================================  MPU_RNR  ======================================================== */
#define PPB_MPU_RNR_REGION_Pos            (0UL)                     /*!< REGION (Bit 0) */
#define PPB_MPU_RNR_REGION_Msk            (0xfUL)                   /*!< REGION (Bitfield-Mask: 0x0f) */
/* =======================================================  MPU_RBAR  ======================================================== */
#define PPB_MPU_RBAR_ADDR_Pos             (8UL)                     /*!< ADDR (Bit 8) */
#define PPB_MPU_RBAR_ADDR_Msk             (0xffffff00UL)            /*!< ADDR (Bitfield-Mask: 0xffffff) */
#define PPB_MPU_RBAR_VALID_Pos            (4UL)                     /*!< VALID (Bit 4) */
#define PPB_MPU_RBAR_VALID_Msk            (0x10UL)                  /*!< VALID (Bitfield-Mask: 0x01) */
#define PPB_MPU_RBAR_REGION_Pos           (0UL)                     /*!< REGION (Bit 0) */
#define PPB_MPU_RBAR_REGION_Msk           (0xfUL)                   /*!< REGION (Bitfield-Mask: 0x0f) */
/* =======================================================  MPU_RASR  ======================================================== */
#define PPB_MPU_RASR_ATTRS_Pos            (16UL)                    /*!< ATTRS (Bit 16) */
#define PPB_MPU_RASR_ATTRS_Msk            (0xffff0000UL)            /*!< ATTRS (Bitfield-Mask: 0xffff) */
#define PPB_MPU_RASR_SRD_Pos              (8UL)                     /*!< SRD (Bit 8) */
#define PPB_MPU_RASR_SRD_Msk              (0xff00UL)                /*!< SRD (Bitfield-Mask: 0xff) */
#define PPB_MPU_RASR_SIZE_Pos             (1UL)                     /*!< SIZE (Bit 1) */
#define PPB_MPU_RASR_SIZE_Msk             (0x3eUL)                  /*!< SIZE (Bitfield-Mask: 0x1f) */
#define PPB_MPU_RASR_ENABLE_Pos           (0UL)                     /*!< ENABLE (Bit 0) */
#define PPB_MPU_RASR_ENABLE_Msk           (0x1UL)                   /*!< ENABLE (Bitfield-Mask: 0x01) */

/** @} */ /* End of group PosMask_peripherals */


/* =========================================================================================================================== */
/* ================                           Enumerated Values Peripheral Section                            ================ */
/* =========================================================================================================================== */


/** @addtogroup EnumValue_peripherals
  * @{
  */



/* =========================================================================================================================== */
/* ================                                         XIP_CTRL                                          ================ */
/* =========================================================================================================================== */

/* =========================================================  CTRL  ========================================================== */
/* =========================================================  FLUSH  ========================================================= */
/* =========================================================  STAT  ========================================================== */
/* ========================================================  CTR_HIT  ======================================================== */
/* ========================================================  CTR_ACC  ======================================================== */
/* ======================================================  STREAM_ADDR  ====================================================== */
/* ======================================================  STREAM_CTR  ======================================================= */
/* ======================================================  STREAM_FIFO  ====================================================== */


/* =========================================================================================================================== */
/* ================                                          XIP_SSI                                          ================ */
/* =========================================================================================================================== */

/* ========================================================  CTRLR0  ========================================================= */
/* ============================================  XIP_SSI CTRLR0 SPI_FRF [21..22]  ============================================ */
typedef enum {                                  /*!< XIP_SSI_CTRLR0_SPI_FRF */
  XIP_SSI_CTRLR0_SPI_FRF_STD           = 0,     /*!< STD : Standard 1-bit SPI frame format; 1 bit per SCK, full-duplex */
  XIP_SSI_CTRLR0_SPI_FRF_DUAL          = 1,     /*!< DUAL : Dual-SPI frame format; two bits per SCK, half-duplex */
  XIP_SSI_CTRLR0_SPI_FRF_QUAD          = 2,     /*!< QUAD : Quad-SPI frame format; four bits per SCK, half-duplex */
} XIP_SSI_CTRLR0_SPI_FRF_Enum;

/* ==============================================  XIP_SSI CTRLR0 TMOD [8..9]  =============================================== */
typedef enum {                                  /*!< XIP_SSI_CTRLR0_TMOD */
  XIP_SSI_CTRLR0_TMOD_TX_AND_RX        = 0,     /*!< TX_AND_RX : Both transmit and receive */
  XIP_SSI_CTRLR0_TMOD_TX_ONLY          = 1,     /*!< TX_ONLY : Transmit only (not for FRF == 0, standard SPI mode) */
  XIP_SSI_CTRLR0_TMOD_RX_ONLY          = 2,     /*!< RX_ONLY : Receive only (not for FRF == 0, standard SPI mode) */
  XIP_SSI_CTRLR0_TMOD_EEPROM_READ      = 3,     /*!< EEPROM_READ : EEPROM read mode (TX then RX; RX starts after control data TX'd) */
} XIP_SSI_CTRLR0_TMOD_Enum;

/* ========================================================  CTRLR1  ========================================================= */
/* ========================================================  SSIENR  ========================================================= */
/* =========================================================  MWCR  ========================================================== */
/* ==========================================================  SER  ========================================================== */
/* =========================================================  BAUDR  ========================================================= */
/* ========================================================  TXFTLR  ========================================================= */
/* ========================================================  RXFTLR  ========================================================= */
/* =========================================================  TXFLR  ========================================================= */
/* =========================================================  RXFLR  ========================================================= */
/* ==========================================================  SR  =========================================================== */
/* ==========================================================  IMR  ========================================================== */
/* ==========================================================  ISR  ========================================================== */
/* =========================================================  RISR  ========================================================== */
/* ========================================================  TXOICR  ========================================================= */
/* ========================================================  RXOICR  ========================================================= */
/* ========================================================  RXUICR  ========================================================= */
/* ========================================================  MSTICR  ========================================================= */
/* ==========================================================  ICR  ========================================================== */
/* =========================================================  DMACR  ========================================================= */
/* ========================================================  DMATDLR  ======================================================== */
/* ========================================================  DMARDLR  ======================================================== */
/* ==========================================================  IDR  ========================================================== */
/* ====================================================  SSI_VERSION_ID  ===================================================== */
/* ==========================================================  DR0  ========================================================== */
/* =====================================================  RX_SAMPLE_DLY  ===================================================== */
/* ======================================================  SPI_CTRLR0  ======================================================= */
/* ===========================================  XIP_SSI SPI_CTRLR0 INST_L [8..9]  ============================================ */
typedef enum {                                  /*!< XIP_SSI_SPI_CTRLR0_INST_L */
  XIP_SSI_SPI_CTRLR0_INST_L_NONE       = 0,     /*!< NONE : No instruction */
  XIP_SSI_SPI_CTRLR0_INST_L_4B         = 1,     /*!< 4B : 4-bit instruction */
  XIP_SSI_SPI_CTRLR0_INST_L_8B         = 2,     /*!< 8B : 8-bit instruction */
  XIP_SSI_SPI_CTRLR0_INST_L_16B        = 3,     /*!< 16B : 16-bit instruction */
} XIP_SSI_SPI_CTRLR0_INST_L_Enum;

/* =========================================  XIP_SSI SPI_CTRLR0 TRANS_TYPE [0..1]  ========================================== */
typedef enum {                                  /*!< XIP_SSI_SPI_CTRLR0_TRANS_TYPE */
  XIP_SSI_SPI_CTRLR0_TRANS_TYPE_1C1A   = 0,     /*!< 1C1A : Command and address both in standard SPI frame format */
  XIP_SSI_SPI_CTRLR0_TRANS_TYPE_1C2A   = 1,     /*!< 1C2A : Command in standard SPI format, address in format specified by FRF */
  XIP_SSI_SPI_CTRLR0_TRANS_TYPE_2C2A   = 2,     /*!< 2C2A : Command and address both in format specified by FRF (e.g. Dual-SPI) */
} XIP_SSI_SPI_CTRLR0_TRANS_TYPE_Enum;

/* ====================================================  TXD_DRIVE_EDGE  ===================================================== */


/* =========================================================================================================================== */
/* ================                                          SYSINFO                                          ================ */
/* =========================================================================================================================== */

/* ========================================================  CHIP_ID  ======================================================== */
/* =======================================================  PLATFORM  ======================================================== */
/* =====================================================  GITREF_RP2040  ===================================================== */


/* =========================================================================================================================== */
/* ================                                          SYSCFG                                           ================ */
/* =========================================================================================================================== */

/* ====================================================  PROC0_NMI_MASK  ===================================================== */
/* ====================================================  PROC1_NMI_MASK  ===================================================== */
/* ======================================================  PROC_CONFIG  ====================================================== */
/* ==================================================  PROC_IN_SYNC_BYPASS  ================================================== */
/* ================================================  PROC_IN_SYNC_BYPASS_HI  ================================================= */
/* =======================================================  DBGFORCE  ======================================================== */
/* =====================================================  MEMPOWERDOWN  ====================================================== */


/* =========================================================================================================================== */
/* ================                                          CLOCKS                                           ================ */
/* =========================================================================================================================== */

/* ====================================================  CLK_GPOUT0_CTRL  ==================================================== */
/* =========================================  CLOCKS CLK_GPOUT0_CTRL AUXSRC [5..8]  ========================================== */
typedef enum {                                  /*!< CLOCKS_CLK_GPOUT0_CTRL_AUXSRC */
  CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_clksrc_pll_sys = 0,/*!< clksrc_pll_sys : clksrc_pll_sys */
  CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_clksrc_gpin0 = 1,/*!< clksrc_gpin0 : clksrc_gpin0 */
  CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_clksrc_gpin1 = 2,/*!< clksrc_gpin1 : clksrc_gpin1 */
  CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_clksrc_pll_usb = 3,/*!< clksrc_pll_usb : clksrc_pll_usb */
  CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_rosc_clksrc = 4,/*!< rosc_clksrc : rosc_clksrc */
  CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_xosc_clksrc = 5,/*!< xosc_clksrc : xosc_clksrc */
  CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_clk_sys = 6,    /*!< clk_sys : clk_sys */
  CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_clk_usb = 7,    /*!< clk_usb : clk_usb */
  CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_clk_adc = 8,    /*!< clk_adc : clk_adc */
  CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_clk_rtc = 9,    /*!< clk_rtc : clk_rtc */
  CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_clk_ref = 10,   /*!< clk_ref : clk_ref */
} CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_Enum;

/* ====================================================  CLK_GPOUT0_DIV  ===================================================== */
/* ==================================================  CLK_GPOUT0_SELECTED  ================================================== */
/* ====================================================  CLK_GPOUT1_CTRL  ==================================================== */
/* =========================================  CLOCKS CLK_GPOUT1_CTRL AUXSRC [5..8]  ========================================== */
typedef enum {                                  /*!< CLOCKS_CLK_GPOUT1_CTRL_AUXSRC */
  CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_clksrc_pll_sys = 0,/*!< clksrc_pll_sys : clksrc_pll_sys */
  CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_clksrc_gpin0 = 1,/*!< clksrc_gpin0 : clksrc_gpin0 */
  CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_clksrc_gpin1 = 2,/*!< clksrc_gpin1 : clksrc_gpin1 */
  CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_clksrc_pll_usb = 3,/*!< clksrc_pll_usb : clksrc_pll_usb */
  CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_rosc_clksrc = 4,/*!< rosc_clksrc : rosc_clksrc */
  CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_xosc_clksrc = 5,/*!< xosc_clksrc : xosc_clksrc */
  CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_clk_sys = 6,    /*!< clk_sys : clk_sys */
  CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_clk_usb = 7,    /*!< clk_usb : clk_usb */
  CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_clk_adc = 8,    /*!< clk_adc : clk_adc */
  CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_clk_rtc = 9,    /*!< clk_rtc : clk_rtc */
  CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_clk_ref = 10,   /*!< clk_ref : clk_ref */
} CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_Enum;

/* ====================================================  CLK_GPOUT1_DIV  ===================================================== */
/* ==================================================  CLK_GPOUT1_SELECTED  ================================================== */
/* ====================================================  CLK_GPOUT2_CTRL  ==================================================== */
/* =========================================  CLOCKS CLK_GPOUT2_CTRL AUXSRC [5..8]  ========================================== */
typedef enum {                                  /*!< CLOCKS_CLK_GPOUT2_CTRL_AUXSRC */
  CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_clksrc_pll_sys = 0,/*!< clksrc_pll_sys : clksrc_pll_sys */
  CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_clksrc_gpin0 = 1,/*!< clksrc_gpin0 : clksrc_gpin0 */
  CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_clksrc_gpin1 = 2,/*!< clksrc_gpin1 : clksrc_gpin1 */
  CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_clksrc_pll_usb = 3,/*!< clksrc_pll_usb : clksrc_pll_usb */
  CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_rosc_clksrc_ph = 4,/*!< rosc_clksrc_ph : rosc_clksrc_ph */
  CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_xosc_clksrc = 5,/*!< xosc_clksrc : xosc_clksrc */
  CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_clk_sys = 6,    /*!< clk_sys : clk_sys */
  CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_clk_usb = 7,    /*!< clk_usb : clk_usb */
  CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_clk_adc = 8,    /*!< clk_adc : clk_adc */
  CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_clk_rtc = 9,    /*!< clk_rtc : clk_rtc */
  CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_clk_ref = 10,   /*!< clk_ref : clk_ref */
} CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_Enum;

/* ====================================================  CLK_GPOUT2_DIV  ===================================================== */
/* ==================================================  CLK_GPOUT2_SELECTED  ================================================== */
/* ====================================================  CLK_GPOUT3_CTRL  ==================================================== */
/* =========================================  CLOCKS CLK_GPOUT3_CTRL AUXSRC [5..8]  ========================================== */
typedef enum {                                  /*!< CLOCKS_CLK_GPOUT3_CTRL_AUXSRC */
  CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_clksrc_pll_sys = 0,/*!< clksrc_pll_sys : clksrc_pll_sys */
  CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_clksrc_gpin0 = 1,/*!< clksrc_gpin0 : clksrc_gpin0 */
  CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_clksrc_gpin1 = 2,/*!< clksrc_gpin1 : clksrc_gpin1 */
  CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_clksrc_pll_usb = 3,/*!< clksrc_pll_usb : clksrc_pll_usb */
  CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_rosc_clksrc_ph = 4,/*!< rosc_clksrc_ph : rosc_clksrc_ph */
  CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_xosc_clksrc = 5,/*!< xosc_clksrc : xosc_clksrc */
  CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_clk_sys = 6,    /*!< clk_sys : clk_sys */
  CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_clk_usb = 7,    /*!< clk_usb : clk_usb */
  CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_clk_adc = 8,    /*!< clk_adc : clk_adc */
  CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_clk_rtc = 9,    /*!< clk_rtc : clk_rtc */
  CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_clk_ref = 10,   /*!< clk_ref : clk_ref */
} CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_Enum;

/* ====================================================  CLK_GPOUT3_DIV  ===================================================== */
/* ==================================================  CLK_GPOUT3_SELECTED  ================================================== */
/* =====================================================  CLK_REF_CTRL  ====================================================== */
/* ===========================================  CLOCKS CLK_REF_CTRL AUXSRC [5..6]  =========================================== */
typedef enum {                                  /*!< CLOCKS_CLK_REF_CTRL_AUXSRC */
  CLOCKS_CLK_REF_CTRL_AUXSRC_clksrc_pll_usb = 0,/*!< clksrc_pll_usb : clksrc_pll_usb */
  CLOCKS_CLK_REF_CTRL_AUXSRC_clksrc_gpin0 = 1,  /*!< clksrc_gpin0 : clksrc_gpin0 */
  CLOCKS_CLK_REF_CTRL_AUXSRC_clksrc_gpin1 = 2,  /*!< clksrc_gpin1 : clksrc_gpin1 */
} CLOCKS_CLK_REF_CTRL_AUXSRC_Enum;

/* ============================================  CLOCKS CLK_REF_CTRL SRC [0..1]  ============================================= */
typedef enum {                                  /*!< CLOCKS_CLK_REF_CTRL_SRC */
  CLOCKS_CLK_REF_CTRL_SRC_rosc_clksrc_ph = 0,   /*!< rosc_clksrc_ph : rosc_clksrc_ph */
  CLOCKS_CLK_REF_CTRL_SRC_clksrc_clk_ref_aux = 1,/*!< clksrc_clk_ref_aux : clksrc_clk_ref_aux */
  CLOCKS_CLK_REF_CTRL_SRC_xosc_clksrc  = 2,     /*!< xosc_clksrc : xosc_clksrc */
} CLOCKS_CLK_REF_CTRL_SRC_Enum;

/* ======================================================  CLK_REF_DIV  ====================================================== */
/* ===================================================  CLK_REF_SELECTED  ==================================================== */
/* =====================================================  CLK_SYS_CTRL  ====================================================== */
/* ===========================================  CLOCKS CLK_SYS_CTRL AUXSRC [5..7]  =========================================== */
typedef enum {                                  /*!< CLOCKS_CLK_SYS_CTRL_AUXSRC */
  CLOCKS_CLK_SYS_CTRL_AUXSRC_clksrc_pll_sys = 0,/*!< clksrc_pll_sys : clksrc_pll_sys */
  CLOCKS_CLK_SYS_CTRL_AUXSRC_clksrc_pll_usb = 1,/*!< clksrc_pll_usb : clksrc_pll_usb */
  CLOCKS_CLK_SYS_CTRL_AUXSRC_rosc_clksrc = 2,   /*!< rosc_clksrc : rosc_clksrc */
  CLOCKS_CLK_SYS_CTRL_AUXSRC_xosc_clksrc = 3,   /*!< xosc_clksrc : xosc_clksrc */
  CLOCKS_CLK_SYS_CTRL_AUXSRC_clksrc_gpin0 = 4,  /*!< clksrc_gpin0 : clksrc_gpin0 */
  CLOCKS_CLK_SYS_CTRL_AUXSRC_clksrc_gpin1 = 5,  /*!< clksrc_gpin1 : clksrc_gpin1 */
} CLOCKS_CLK_SYS_CTRL_AUXSRC_Enum;

/* ============================================  CLOCKS CLK_SYS_CTRL SRC [0..0]  ============================================= */
typedef enum {                                  /*!< CLOCKS_CLK_SYS_CTRL_SRC */
  CLOCKS_CLK_SYS_CTRL_SRC_clk_ref      = 0,     /*!< clk_ref : clk_ref */
  CLOCKS_CLK_SYS_CTRL_SRC_clksrc_clk_sys_aux = 1,/*!< clksrc_clk_sys_aux : clksrc_clk_sys_aux */
} CLOCKS_CLK_SYS_CTRL_SRC_Enum;

/* ======================================================  CLK_SYS_DIV  ====================================================== */
/* ===================================================  CLK_SYS_SELECTED  ==================================================== */
/* =====================================================  CLK_PERI_CTRL  ===================================================== */
/* ==========================================  CLOCKS CLK_PERI_CTRL AUXSRC [5..7]  =========================================== */
typedef enum {                                  /*!< CLOCKS_CLK_PERI_CTRL_AUXSRC */
  CLOCKS_CLK_PERI_CTRL_AUXSRC_clk_sys  = 0,     /*!< clk_sys : clk_sys */
  CLOCKS_CLK_PERI_CTRL_AUXSRC_clksrc_pll_sys = 1,/*!< clksrc_pll_sys : clksrc_pll_sys */
  CLOCKS_CLK_PERI_CTRL_AUXSRC_clksrc_pll_usb = 2,/*!< clksrc_pll_usb : clksrc_pll_usb */
  CLOCKS_CLK_PERI_CTRL_AUXSRC_rosc_clksrc_ph = 3,/*!< rosc_clksrc_ph : rosc_clksrc_ph */
  CLOCKS_CLK_PERI_CTRL_AUXSRC_xosc_clksrc = 4,  /*!< xosc_clksrc : xosc_clksrc */
  CLOCKS_CLK_PERI_CTRL_AUXSRC_clksrc_gpin0 = 5, /*!< clksrc_gpin0 : clksrc_gpin0 */
  CLOCKS_CLK_PERI_CTRL_AUXSRC_clksrc_gpin1 = 6, /*!< clksrc_gpin1 : clksrc_gpin1 */
} CLOCKS_CLK_PERI_CTRL_AUXSRC_Enum;

/* ===================================================  CLK_PERI_SELECTED  =================================================== */
/* =====================================================  CLK_USB_CTRL  ====================================================== */
/* ===========================================  CLOCKS CLK_USB_CTRL AUXSRC [5..7]  =========================================== */
typedef enum {                                  /*!< CLOCKS_CLK_USB_CTRL_AUXSRC */
  CLOCKS_CLK_USB_CTRL_AUXSRC_clksrc_pll_usb = 0,/*!< clksrc_pll_usb : clksrc_pll_usb */
  CLOCKS_CLK_USB_CTRL_AUXSRC_clksrc_pll_sys = 1,/*!< clksrc_pll_sys : clksrc_pll_sys */
  CLOCKS_CLK_USB_CTRL_AUXSRC_rosc_clksrc_ph = 2,/*!< rosc_clksrc_ph : rosc_clksrc_ph */
  CLOCKS_CLK_USB_CTRL_AUXSRC_xosc_clksrc = 3,   /*!< xosc_clksrc : xosc_clksrc */
  CLOCKS_CLK_USB_CTRL_AUXSRC_clksrc_gpin0 = 4,  /*!< clksrc_gpin0 : clksrc_gpin0 */
  CLOCKS_CLK_USB_CTRL_AUXSRC_clksrc_gpin1 = 5,  /*!< clksrc_gpin1 : clksrc_gpin1 */
} CLOCKS_CLK_USB_CTRL_AUXSRC_Enum;

/* ======================================================  CLK_USB_DIV  ====================================================== */
/* ===================================================  CLK_USB_SELECTED  ==================================================== */
/* =====================================================  CLK_ADC_CTRL  ====================================================== */
/* ===========================================  CLOCKS CLK_ADC_CTRL AUXSRC [5..7]  =========================================== */
typedef enum {                                  /*!< CLOCKS_CLK_ADC_CTRL_AUXSRC */
  CLOCKS_CLK_ADC_CTRL_AUXSRC_clksrc_pll_usb = 0,/*!< clksrc_pll_usb : clksrc_pll_usb */
  CLOCKS_CLK_ADC_CTRL_AUXSRC_clksrc_pll_sys = 1,/*!< clksrc_pll_sys : clksrc_pll_sys */
  CLOCKS_CLK_ADC_CTRL_AUXSRC_rosc_clksrc_ph = 2,/*!< rosc_clksrc_ph : rosc_clksrc_ph */
  CLOCKS_CLK_ADC_CTRL_AUXSRC_xosc_clksrc = 3,   /*!< xosc_clksrc : xosc_clksrc */
  CLOCKS_CLK_ADC_CTRL_AUXSRC_clksrc_gpin0 = 4,  /*!< clksrc_gpin0 : clksrc_gpin0 */
  CLOCKS_CLK_ADC_CTRL_AUXSRC_clksrc_gpin1 = 5,  /*!< clksrc_gpin1 : clksrc_gpin1 */
} CLOCKS_CLK_ADC_CTRL_AUXSRC_Enum;

/* ======================================================  CLK_ADC_DIV  ====================================================== */
/* ===================================================  CLK_ADC_SELECTED  ==================================================== */
/* =====================================================  CLK_RTC_CTRL  ====================================================== */
/* ===========================================  CLOCKS CLK_RTC_CTRL AUXSRC [5..7]  =========================================== */
typedef enum {                                  /*!< CLOCKS_CLK_RTC_CTRL_AUXSRC */
  CLOCKS_CLK_RTC_CTRL_AUXSRC_clksrc_pll_usb = 0,/*!< clksrc_pll_usb : clksrc_pll_usb */
  CLOCKS_CLK_RTC_CTRL_AUXSRC_clksrc_pll_sys = 1,/*!< clksrc_pll_sys : clksrc_pll_sys */
  CLOCKS_CLK_RTC_CTRL_AUXSRC_rosc_clksrc_ph = 2,/*!< rosc_clksrc_ph : rosc_clksrc_ph */
  CLOCKS_CLK_RTC_CTRL_AUXSRC_xosc_clksrc = 3,   /*!< xosc_clksrc : xosc_clksrc */
  CLOCKS_CLK_RTC_CTRL_AUXSRC_clksrc_gpin0 = 4,  /*!< clksrc_gpin0 : clksrc_gpin0 */
  CLOCKS_CLK_RTC_CTRL_AUXSRC_clksrc_gpin1 = 5,  /*!< clksrc_gpin1 : clksrc_gpin1 */
} CLOCKS_CLK_RTC_CTRL_AUXSRC_Enum;

/* ======================================================  CLK_RTC_DIV  ====================================================== */
/* ===================================================  CLK_RTC_SELECTED  ==================================================== */
/* ==================================================  CLK_SYS_RESUS_CTRL  =================================================== */
/* =================================================  CLK_SYS_RESUS_STATUS  ================================================== */
/* ======================================================  FC0_REF_KHZ  ====================================================== */
/* ======================================================  FC0_MIN_KHZ  ====================================================== */
/* ======================================================  FC0_MAX_KHZ  ====================================================== */
/* =======================================================  FC0_DELAY  ======================================================= */
/* =====================================================  FC0_INTERVAL  ====================================================== */
/* ========================================================  FC0_SRC  ======================================================== */
/* =============================================  CLOCKS FC0_SRC FC0_SRC [0..7]  ============================================= */
typedef enum {                                  /*!< CLOCKS_FC0_SRC_FC0_SRC */
  CLOCKS_FC0_SRC_FC0_SRC_NULL          = 0,     /*!< NULL : NULL */
  CLOCKS_FC0_SRC_FC0_SRC_pll_sys_clksrc_primary = 1,/*!< pll_sys_clksrc_primary : pll_sys_clksrc_primary */
  CLOCKS_FC0_SRC_FC0_SRC_pll_usb_clksrc_primary = 2,/*!< pll_usb_clksrc_primary : pll_usb_clksrc_primary */
  CLOCKS_FC0_SRC_FC0_SRC_rosc_clksrc   = 3,     /*!< rosc_clksrc : rosc_clksrc */
  CLOCKS_FC0_SRC_FC0_SRC_rosc_clksrc_ph = 4,    /*!< rosc_clksrc_ph : rosc_clksrc_ph */
  CLOCKS_FC0_SRC_FC0_SRC_xosc_clksrc   = 5,     /*!< xosc_clksrc : xosc_clksrc */
  CLOCKS_FC0_SRC_FC0_SRC_clksrc_gpin0  = 6,     /*!< clksrc_gpin0 : clksrc_gpin0 */
  CLOCKS_FC0_SRC_FC0_SRC_clksrc_gpin1  = 7,     /*!< clksrc_gpin1 : clksrc_gpin1 */
  CLOCKS_FC0_SRC_FC0_SRC_clk_ref       = 8,     /*!< clk_ref : clk_ref */
  CLOCKS_FC0_SRC_FC0_SRC_clk_sys       = 9,     /*!< clk_sys : clk_sys */
  CLOCKS_FC0_SRC_FC0_SRC_clk_peri      = 10,    /*!< clk_peri : clk_peri */
  CLOCKS_FC0_SRC_FC0_SRC_clk_usb       = 11,    /*!< clk_usb : clk_usb */
  CLOCKS_FC0_SRC_FC0_SRC_clk_adc       = 12,    /*!< clk_adc : clk_adc */
  CLOCKS_FC0_SRC_FC0_SRC_clk_rtc       = 13,    /*!< clk_rtc : clk_rtc */
} CLOCKS_FC0_SRC_FC0_SRC_Enum;

/* ======================================================  FC0_STATUS  ======================================================= */
/* ======================================================  FC0_RESULT  ======================================================= */
/* =======================================================  WAKE_EN0  ======================================================== */
/* =======================================================  WAKE_EN1  ======================================================== */
/* =======================================================  SLEEP_EN0  ======================================================= */
/* =======================================================  SLEEP_EN1  ======================================================= */
/* =======================================================  ENABLED0  ======================================================== */
/* =======================================================  ENABLED1  ======================================================== */
/* =========================================================  INTR  ========================================================== */
/* =========================================================  INTE  ========================================================== */
/* =========================================================  INTF  ========================================================== */
/* =========================================================  INTS  ========================================================== */


/* =========================================================================================================================== */
/* ================                                          RESETS                                           ================ */
/* =========================================================================================================================== */

/* =========================================================  RESET  ========================================================= */
/* =========================================================  WDSEL  ========================================================= */
/* ======================================================  RESET_DONE  ======================================================= */


/* =========================================================================================================================== */
/* ================                                            PSM                                            ================ */
/* =========================================================================================================================== */

/* ========================================================  FRCE_ON  ======================================================== */
/* =======================================================  FRCE_OFF  ======================================================== */
/* =========================================================  WDSEL  ========================================================= */
/* =========================================================  DONE  ========================================================== */


/* =========================================================================================================================== */
/* ================                                         IO_BANK0                                          ================ */
/* =========================================================================================================================== */

/* =====================================================  GPIO0_STATUS  ====================================================== */
/* ======================================================  GPIO0_CTRL  ======================================================= */
/* =========================================  IO_BANK0 GPIO0_CTRL IRQOVER [28..29]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO0_CTRL_IRQOVER */
  IO_BANK0_GPIO0_CTRL_IRQOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the interrupt */
  IO_BANK0_GPIO0_CTRL_IRQOVER_INVERT   = 1,     /*!< INVERT : invert the interrupt */
  IO_BANK0_GPIO0_CTRL_IRQOVER_LOW      = 2,     /*!< LOW : drive interrupt low */
  IO_BANK0_GPIO0_CTRL_IRQOVER_HIGH     = 3,     /*!< HIGH : drive interrupt high */
} IO_BANK0_GPIO0_CTRL_IRQOVER_Enum;

/* ==========================================  IO_BANK0 GPIO0_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO0_CTRL_INOVER */
  IO_BANK0_GPIO0_CTRL_INOVER_NORMAL    = 0,     /*!< NORMAL : don't invert the peri input */
  IO_BANK0_GPIO0_CTRL_INOVER_INVERT    = 1,     /*!< INVERT : invert the peri input */
  IO_BANK0_GPIO0_CTRL_INOVER_LOW       = 2,     /*!< LOW : drive peri input low */
  IO_BANK0_GPIO0_CTRL_INOVER_HIGH      = 3,     /*!< HIGH : drive peri input high */
} IO_BANK0_GPIO0_CTRL_INOVER_Enum;

/* ==========================================  IO_BANK0 GPIO0_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO0_CTRL_OEOVER */
  IO_BANK0_GPIO0_CTRL_OEOVER_NORMAL    = 0,     /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_BANK0_GPIO0_CTRL_OEOVER_INVERT    = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO0_CTRL_OEOVER_DISABLE   = 2,     /*!< DISABLE : disable output */
  IO_BANK0_GPIO0_CTRL_OEOVER_ENABLE    = 3,     /*!< ENABLE : enable output */
} IO_BANK0_GPIO0_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO0_CTRL OUTOVER [8..9]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO0_CTRL_OUTOVER */
  IO_BANK0_GPIO0_CTRL_OUTOVER_NORMAL   = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_BANK0_GPIO0_CTRL_OUTOVER_INVERT   = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO0_CTRL_OUTOVER_LOW      = 2,     /*!< LOW : drive output low */
  IO_BANK0_GPIO0_CTRL_OUTOVER_HIGH     = 3,     /*!< HIGH : drive output high */
} IO_BANK0_GPIO0_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO0_CTRL FUNCSEL [0..4]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO0_CTRL_FUNCSEL */
  IO_BANK0_GPIO0_CTRL_FUNCSEL_jtag_tck = 0,     /*!< jtag_tck : jtag_tck */
  IO_BANK0_GPIO0_CTRL_FUNCSEL_spi0_rx  = 1,     /*!< spi0_rx : spi0_rx */
  IO_BANK0_GPIO0_CTRL_FUNCSEL_uart0_tx = 2,     /*!< uart0_tx : uart0_tx */
  IO_BANK0_GPIO0_CTRL_FUNCSEL_i2c0_sda = 3,     /*!< i2c0_sda : i2c0_sda */
  IO_BANK0_GPIO0_CTRL_FUNCSEL_pwm_a_0  = 4,     /*!< pwm_a_0 : pwm_a_0 */
  IO_BANK0_GPIO0_CTRL_FUNCSEL_sio_0    = 5,     /*!< sio_0 : sio_0 */
  IO_BANK0_GPIO0_CTRL_FUNCSEL_pio0_0   = 6,     /*!< pio0_0 : pio0_0 */
  IO_BANK0_GPIO0_CTRL_FUNCSEL_pio1_0   = 7,     /*!< pio1_0 : pio1_0 */
  IO_BANK0_GPIO0_CTRL_FUNCSEL_usb_muxing_overcurr_detect = 9,/*!< usb_muxing_overcurr_detect : usb_muxing_overcurr_detect */
  IO_BANK0_GPIO0_CTRL_FUNCSEL_null     = 31,    /*!< null : null */
} IO_BANK0_GPIO0_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO1_STATUS  ====================================================== */
/* ======================================================  GPIO1_CTRL  ======================================================= */
/* =========================================  IO_BANK0 GPIO1_CTRL IRQOVER [28..29]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO1_CTRL_IRQOVER */
  IO_BANK0_GPIO1_CTRL_IRQOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the interrupt */
  IO_BANK0_GPIO1_CTRL_IRQOVER_INVERT   = 1,     /*!< INVERT : invert the interrupt */
  IO_BANK0_GPIO1_CTRL_IRQOVER_LOW      = 2,     /*!< LOW : drive interrupt low */
  IO_BANK0_GPIO1_CTRL_IRQOVER_HIGH     = 3,     /*!< HIGH : drive interrupt high */
} IO_BANK0_GPIO1_CTRL_IRQOVER_Enum;

/* ==========================================  IO_BANK0 GPIO1_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO1_CTRL_INOVER */
  IO_BANK0_GPIO1_CTRL_INOVER_NORMAL    = 0,     /*!< NORMAL : don't invert the peri input */
  IO_BANK0_GPIO1_CTRL_INOVER_INVERT    = 1,     /*!< INVERT : invert the peri input */
  IO_BANK0_GPIO1_CTRL_INOVER_LOW       = 2,     /*!< LOW : drive peri input low */
  IO_BANK0_GPIO1_CTRL_INOVER_HIGH      = 3,     /*!< HIGH : drive peri input high */
} IO_BANK0_GPIO1_CTRL_INOVER_Enum;

/* ==========================================  IO_BANK0 GPIO1_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO1_CTRL_OEOVER */
  IO_BANK0_GPIO1_CTRL_OEOVER_NORMAL    = 0,     /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_BANK0_GPIO1_CTRL_OEOVER_INVERT    = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO1_CTRL_OEOVER_DISABLE   = 2,     /*!< DISABLE : disable output */
  IO_BANK0_GPIO1_CTRL_OEOVER_ENABLE    = 3,     /*!< ENABLE : enable output */
} IO_BANK0_GPIO1_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO1_CTRL OUTOVER [8..9]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO1_CTRL_OUTOVER */
  IO_BANK0_GPIO1_CTRL_OUTOVER_NORMAL   = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_BANK0_GPIO1_CTRL_OUTOVER_INVERT   = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO1_CTRL_OUTOVER_LOW      = 2,     /*!< LOW : drive output low */
  IO_BANK0_GPIO1_CTRL_OUTOVER_HIGH     = 3,     /*!< HIGH : drive output high */
} IO_BANK0_GPIO1_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO1_CTRL FUNCSEL [0..4]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO1_CTRL_FUNCSEL */
  IO_BANK0_GPIO1_CTRL_FUNCSEL_jtag_tms = 0,     /*!< jtag_tms : jtag_tms */
  IO_BANK0_GPIO1_CTRL_FUNCSEL_spi0_ss_n = 1,    /*!< spi0_ss_n : spi0_ss_n */
  IO_BANK0_GPIO1_CTRL_FUNCSEL_uart0_rx = 2,     /*!< uart0_rx : uart0_rx */
  IO_BANK0_GPIO1_CTRL_FUNCSEL_i2c0_scl = 3,     /*!< i2c0_scl : i2c0_scl */
  IO_BANK0_GPIO1_CTRL_FUNCSEL_pwm_b_0  = 4,     /*!< pwm_b_0 : pwm_b_0 */
  IO_BANK0_GPIO1_CTRL_FUNCSEL_sio_1    = 5,     /*!< sio_1 : sio_1 */
  IO_BANK0_GPIO1_CTRL_FUNCSEL_pio0_1   = 6,     /*!< pio0_1 : pio0_1 */
  IO_BANK0_GPIO1_CTRL_FUNCSEL_pio1_1   = 7,     /*!< pio1_1 : pio1_1 */
  IO_BANK0_GPIO1_CTRL_FUNCSEL_usb_muxing_vbus_detect = 9,/*!< usb_muxing_vbus_detect : usb_muxing_vbus_detect */
  IO_BANK0_GPIO1_CTRL_FUNCSEL_null     = 31,    /*!< null : null */
} IO_BANK0_GPIO1_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO2_STATUS  ====================================================== */
/* ======================================================  GPIO2_CTRL  ======================================================= */
/* =========================================  IO_BANK0 GPIO2_CTRL IRQOVER [28..29]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO2_CTRL_IRQOVER */
  IO_BANK0_GPIO2_CTRL_IRQOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the interrupt */
  IO_BANK0_GPIO2_CTRL_IRQOVER_INVERT   = 1,     /*!< INVERT : invert the interrupt */
  IO_BANK0_GPIO2_CTRL_IRQOVER_LOW      = 2,     /*!< LOW : drive interrupt low */
  IO_BANK0_GPIO2_CTRL_IRQOVER_HIGH     = 3,     /*!< HIGH : drive interrupt high */
} IO_BANK0_GPIO2_CTRL_IRQOVER_Enum;

/* ==========================================  IO_BANK0 GPIO2_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO2_CTRL_INOVER */
  IO_BANK0_GPIO2_CTRL_INOVER_NORMAL    = 0,     /*!< NORMAL : don't invert the peri input */
  IO_BANK0_GPIO2_CTRL_INOVER_INVERT    = 1,     /*!< INVERT : invert the peri input */
  IO_BANK0_GPIO2_CTRL_INOVER_LOW       = 2,     /*!< LOW : drive peri input low */
  IO_BANK0_GPIO2_CTRL_INOVER_HIGH      = 3,     /*!< HIGH : drive peri input high */
} IO_BANK0_GPIO2_CTRL_INOVER_Enum;

/* ==========================================  IO_BANK0 GPIO2_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO2_CTRL_OEOVER */
  IO_BANK0_GPIO2_CTRL_OEOVER_NORMAL    = 0,     /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_BANK0_GPIO2_CTRL_OEOVER_INVERT    = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO2_CTRL_OEOVER_DISABLE   = 2,     /*!< DISABLE : disable output */
  IO_BANK0_GPIO2_CTRL_OEOVER_ENABLE    = 3,     /*!< ENABLE : enable output */
} IO_BANK0_GPIO2_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO2_CTRL OUTOVER [8..9]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO2_CTRL_OUTOVER */
  IO_BANK0_GPIO2_CTRL_OUTOVER_NORMAL   = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_BANK0_GPIO2_CTRL_OUTOVER_INVERT   = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO2_CTRL_OUTOVER_LOW      = 2,     /*!< LOW : drive output low */
  IO_BANK0_GPIO2_CTRL_OUTOVER_HIGH     = 3,     /*!< HIGH : drive output high */
} IO_BANK0_GPIO2_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO2_CTRL FUNCSEL [0..4]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO2_CTRL_FUNCSEL */
  IO_BANK0_GPIO2_CTRL_FUNCSEL_jtag_tdi = 0,     /*!< jtag_tdi : jtag_tdi */
  IO_BANK0_GPIO2_CTRL_FUNCSEL_spi0_sclk = 1,    /*!< spi0_sclk : spi0_sclk */
  IO_BANK0_GPIO2_CTRL_FUNCSEL_uart0_cts = 2,    /*!< uart0_cts : uart0_cts */
  IO_BANK0_GPIO2_CTRL_FUNCSEL_i2c1_sda = 3,     /*!< i2c1_sda : i2c1_sda */
  IO_BANK0_GPIO2_CTRL_FUNCSEL_pwm_a_1  = 4,     /*!< pwm_a_1 : pwm_a_1 */
  IO_BANK0_GPIO2_CTRL_FUNCSEL_sio_2    = 5,     /*!< sio_2 : sio_2 */
  IO_BANK0_GPIO2_CTRL_FUNCSEL_pio0_2   = 6,     /*!< pio0_2 : pio0_2 */
  IO_BANK0_GPIO2_CTRL_FUNCSEL_pio1_2   = 7,     /*!< pio1_2 : pio1_2 */
  IO_BANK0_GPIO2_CTRL_FUNCSEL_usb_muxing_vbus_en = 9,/*!< usb_muxing_vbus_en : usb_muxing_vbus_en */
  IO_BANK0_GPIO2_CTRL_FUNCSEL_null     = 31,    /*!< null : null */
} IO_BANK0_GPIO2_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO3_STATUS  ====================================================== */
/* ======================================================  GPIO3_CTRL  ======================================================= */
/* =========================================  IO_BANK0 GPIO3_CTRL IRQOVER [28..29]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO3_CTRL_IRQOVER */
  IO_BANK0_GPIO3_CTRL_IRQOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the interrupt */
  IO_BANK0_GPIO3_CTRL_IRQOVER_INVERT   = 1,     /*!< INVERT : invert the interrupt */
  IO_BANK0_GPIO3_CTRL_IRQOVER_LOW      = 2,     /*!< LOW : drive interrupt low */
  IO_BANK0_GPIO3_CTRL_IRQOVER_HIGH     = 3,     /*!< HIGH : drive interrupt high */
} IO_BANK0_GPIO3_CTRL_IRQOVER_Enum;

/* ==========================================  IO_BANK0 GPIO3_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO3_CTRL_INOVER */
  IO_BANK0_GPIO3_CTRL_INOVER_NORMAL    = 0,     /*!< NORMAL : don't invert the peri input */
  IO_BANK0_GPIO3_CTRL_INOVER_INVERT    = 1,     /*!< INVERT : invert the peri input */
  IO_BANK0_GPIO3_CTRL_INOVER_LOW       = 2,     /*!< LOW : drive peri input low */
  IO_BANK0_GPIO3_CTRL_INOVER_HIGH      = 3,     /*!< HIGH : drive peri input high */
} IO_BANK0_GPIO3_CTRL_INOVER_Enum;

/* ==========================================  IO_BANK0 GPIO3_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO3_CTRL_OEOVER */
  IO_BANK0_GPIO3_CTRL_OEOVER_NORMAL    = 0,     /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_BANK0_GPIO3_CTRL_OEOVER_INVERT    = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO3_CTRL_OEOVER_DISABLE   = 2,     /*!< DISABLE : disable output */
  IO_BANK0_GPIO3_CTRL_OEOVER_ENABLE    = 3,     /*!< ENABLE : enable output */
} IO_BANK0_GPIO3_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO3_CTRL OUTOVER [8..9]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO3_CTRL_OUTOVER */
  IO_BANK0_GPIO3_CTRL_OUTOVER_NORMAL   = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_BANK0_GPIO3_CTRL_OUTOVER_INVERT   = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO3_CTRL_OUTOVER_LOW      = 2,     /*!< LOW : drive output low */
  IO_BANK0_GPIO3_CTRL_OUTOVER_HIGH     = 3,     /*!< HIGH : drive output high */
} IO_BANK0_GPIO3_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO3_CTRL FUNCSEL [0..4]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO3_CTRL_FUNCSEL */
  IO_BANK0_GPIO3_CTRL_FUNCSEL_jtag_tdo = 0,     /*!< jtag_tdo : jtag_tdo */
  IO_BANK0_GPIO3_CTRL_FUNCSEL_spi0_tx  = 1,     /*!< spi0_tx : spi0_tx */
  IO_BANK0_GPIO3_CTRL_FUNCSEL_uart0_rts = 2,    /*!< uart0_rts : uart0_rts */
  IO_BANK0_GPIO3_CTRL_FUNCSEL_i2c1_scl = 3,     /*!< i2c1_scl : i2c1_scl */
  IO_BANK0_GPIO3_CTRL_FUNCSEL_pwm_b_1  = 4,     /*!< pwm_b_1 : pwm_b_1 */
  IO_BANK0_GPIO3_CTRL_FUNCSEL_sio_3    = 5,     /*!< sio_3 : sio_3 */
  IO_BANK0_GPIO3_CTRL_FUNCSEL_pio0_3   = 6,     /*!< pio0_3 : pio0_3 */
  IO_BANK0_GPIO3_CTRL_FUNCSEL_pio1_3   = 7,     /*!< pio1_3 : pio1_3 */
  IO_BANK0_GPIO3_CTRL_FUNCSEL_usb_muxing_overcurr_detect = 9,/*!< usb_muxing_overcurr_detect : usb_muxing_overcurr_detect */
  IO_BANK0_GPIO3_CTRL_FUNCSEL_null     = 31,    /*!< null : null */
} IO_BANK0_GPIO3_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO4_STATUS  ====================================================== */
/* ======================================================  GPIO4_CTRL  ======================================================= */
/* =========================================  IO_BANK0 GPIO4_CTRL IRQOVER [28..29]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO4_CTRL_IRQOVER */
  IO_BANK0_GPIO4_CTRL_IRQOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the interrupt */
  IO_BANK0_GPIO4_CTRL_IRQOVER_INVERT   = 1,     /*!< INVERT : invert the interrupt */
  IO_BANK0_GPIO4_CTRL_IRQOVER_LOW      = 2,     /*!< LOW : drive interrupt low */
  IO_BANK0_GPIO4_CTRL_IRQOVER_HIGH     = 3,     /*!< HIGH : drive interrupt high */
} IO_BANK0_GPIO4_CTRL_IRQOVER_Enum;

/* ==========================================  IO_BANK0 GPIO4_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO4_CTRL_INOVER */
  IO_BANK0_GPIO4_CTRL_INOVER_NORMAL    = 0,     /*!< NORMAL : don't invert the peri input */
  IO_BANK0_GPIO4_CTRL_INOVER_INVERT    = 1,     /*!< INVERT : invert the peri input */
  IO_BANK0_GPIO4_CTRL_INOVER_LOW       = 2,     /*!< LOW : drive peri input low */
  IO_BANK0_GPIO4_CTRL_INOVER_HIGH      = 3,     /*!< HIGH : drive peri input high */
} IO_BANK0_GPIO4_CTRL_INOVER_Enum;

/* ==========================================  IO_BANK0 GPIO4_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO4_CTRL_OEOVER */
  IO_BANK0_GPIO4_CTRL_OEOVER_NORMAL    = 0,     /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_BANK0_GPIO4_CTRL_OEOVER_INVERT    = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO4_CTRL_OEOVER_DISABLE   = 2,     /*!< DISABLE : disable output */
  IO_BANK0_GPIO4_CTRL_OEOVER_ENABLE    = 3,     /*!< ENABLE : enable output */
} IO_BANK0_GPIO4_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO4_CTRL OUTOVER [8..9]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO4_CTRL_OUTOVER */
  IO_BANK0_GPIO4_CTRL_OUTOVER_NORMAL   = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_BANK0_GPIO4_CTRL_OUTOVER_INVERT   = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO4_CTRL_OUTOVER_LOW      = 2,     /*!< LOW : drive output low */
  IO_BANK0_GPIO4_CTRL_OUTOVER_HIGH     = 3,     /*!< HIGH : drive output high */
} IO_BANK0_GPIO4_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO4_CTRL FUNCSEL [0..4]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO4_CTRL_FUNCSEL */
  IO_BANK0_GPIO4_CTRL_FUNCSEL_spi0_rx  = 1,     /*!< spi0_rx : spi0_rx */
  IO_BANK0_GPIO4_CTRL_FUNCSEL_uart1_tx = 2,     /*!< uart1_tx : uart1_tx */
  IO_BANK0_GPIO4_CTRL_FUNCSEL_i2c0_sda = 3,     /*!< i2c0_sda : i2c0_sda */
  IO_BANK0_GPIO4_CTRL_FUNCSEL_pwm_a_2  = 4,     /*!< pwm_a_2 : pwm_a_2 */
  IO_BANK0_GPIO4_CTRL_FUNCSEL_sio_4    = 5,     /*!< sio_4 : sio_4 */
  IO_BANK0_GPIO4_CTRL_FUNCSEL_pio0_4   = 6,     /*!< pio0_4 : pio0_4 */
  IO_BANK0_GPIO4_CTRL_FUNCSEL_pio1_4   = 7,     /*!< pio1_4 : pio1_4 */
  IO_BANK0_GPIO4_CTRL_FUNCSEL_usb_muxing_vbus_detect = 9,/*!< usb_muxing_vbus_detect : usb_muxing_vbus_detect */
  IO_BANK0_GPIO4_CTRL_FUNCSEL_null     = 31,    /*!< null : null */
} IO_BANK0_GPIO4_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO5_STATUS  ====================================================== */
/* ======================================================  GPIO5_CTRL  ======================================================= */
/* =========================================  IO_BANK0 GPIO5_CTRL IRQOVER [28..29]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO5_CTRL_IRQOVER */
  IO_BANK0_GPIO5_CTRL_IRQOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the interrupt */
  IO_BANK0_GPIO5_CTRL_IRQOVER_INVERT   = 1,     /*!< INVERT : invert the interrupt */
  IO_BANK0_GPIO5_CTRL_IRQOVER_LOW      = 2,     /*!< LOW : drive interrupt low */
  IO_BANK0_GPIO5_CTRL_IRQOVER_HIGH     = 3,     /*!< HIGH : drive interrupt high */
} IO_BANK0_GPIO5_CTRL_IRQOVER_Enum;

/* ==========================================  IO_BANK0 GPIO5_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO5_CTRL_INOVER */
  IO_BANK0_GPIO5_CTRL_INOVER_NORMAL    = 0,     /*!< NORMAL : don't invert the peri input */
  IO_BANK0_GPIO5_CTRL_INOVER_INVERT    = 1,     /*!< INVERT : invert the peri input */
  IO_BANK0_GPIO5_CTRL_INOVER_LOW       = 2,     /*!< LOW : drive peri input low */
  IO_BANK0_GPIO5_CTRL_INOVER_HIGH      = 3,     /*!< HIGH : drive peri input high */
} IO_BANK0_GPIO5_CTRL_INOVER_Enum;

/* ==========================================  IO_BANK0 GPIO5_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO5_CTRL_OEOVER */
  IO_BANK0_GPIO5_CTRL_OEOVER_NORMAL    = 0,     /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_BANK0_GPIO5_CTRL_OEOVER_INVERT    = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO5_CTRL_OEOVER_DISABLE   = 2,     /*!< DISABLE : disable output */
  IO_BANK0_GPIO5_CTRL_OEOVER_ENABLE    = 3,     /*!< ENABLE : enable output */
} IO_BANK0_GPIO5_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO5_CTRL OUTOVER [8..9]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO5_CTRL_OUTOVER */
  IO_BANK0_GPIO5_CTRL_OUTOVER_NORMAL   = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_BANK0_GPIO5_CTRL_OUTOVER_INVERT   = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO5_CTRL_OUTOVER_LOW      = 2,     /*!< LOW : drive output low */
  IO_BANK0_GPIO5_CTRL_OUTOVER_HIGH     = 3,     /*!< HIGH : drive output high */
} IO_BANK0_GPIO5_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO5_CTRL FUNCSEL [0..4]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO5_CTRL_FUNCSEL */
  IO_BANK0_GPIO5_CTRL_FUNCSEL_spi0_ss_n = 1,    /*!< spi0_ss_n : spi0_ss_n */
  IO_BANK0_GPIO5_CTRL_FUNCSEL_uart1_rx = 2,     /*!< uart1_rx : uart1_rx */
  IO_BANK0_GPIO5_CTRL_FUNCSEL_i2c0_scl = 3,     /*!< i2c0_scl : i2c0_scl */
  IO_BANK0_GPIO5_CTRL_FUNCSEL_pwm_b_2  = 4,     /*!< pwm_b_2 : pwm_b_2 */
  IO_BANK0_GPIO5_CTRL_FUNCSEL_sio_5    = 5,     /*!< sio_5 : sio_5 */
  IO_BANK0_GPIO5_CTRL_FUNCSEL_pio0_5   = 6,     /*!< pio0_5 : pio0_5 */
  IO_BANK0_GPIO5_CTRL_FUNCSEL_pio1_5   = 7,     /*!< pio1_5 : pio1_5 */
  IO_BANK0_GPIO5_CTRL_FUNCSEL_usb_muxing_vbus_en = 9,/*!< usb_muxing_vbus_en : usb_muxing_vbus_en */
  IO_BANK0_GPIO5_CTRL_FUNCSEL_null     = 31,    /*!< null : null */
} IO_BANK0_GPIO5_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO6_STATUS  ====================================================== */
/* ======================================================  GPIO6_CTRL  ======================================================= */
/* =========================================  IO_BANK0 GPIO6_CTRL IRQOVER [28..29]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO6_CTRL_IRQOVER */
  IO_BANK0_GPIO6_CTRL_IRQOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the interrupt */
  IO_BANK0_GPIO6_CTRL_IRQOVER_INVERT   = 1,     /*!< INVERT : invert the interrupt */
  IO_BANK0_GPIO6_CTRL_IRQOVER_LOW      = 2,     /*!< LOW : drive interrupt low */
  IO_BANK0_GPIO6_CTRL_IRQOVER_HIGH     = 3,     /*!< HIGH : drive interrupt high */
} IO_BANK0_GPIO6_CTRL_IRQOVER_Enum;

/* ==========================================  IO_BANK0 GPIO6_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO6_CTRL_INOVER */
  IO_BANK0_GPIO6_CTRL_INOVER_NORMAL    = 0,     /*!< NORMAL : don't invert the peri input */
  IO_BANK0_GPIO6_CTRL_INOVER_INVERT    = 1,     /*!< INVERT : invert the peri input */
  IO_BANK0_GPIO6_CTRL_INOVER_LOW       = 2,     /*!< LOW : drive peri input low */
  IO_BANK0_GPIO6_CTRL_INOVER_HIGH      = 3,     /*!< HIGH : drive peri input high */
} IO_BANK0_GPIO6_CTRL_INOVER_Enum;

/* ==========================================  IO_BANK0 GPIO6_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO6_CTRL_OEOVER */
  IO_BANK0_GPIO6_CTRL_OEOVER_NORMAL    = 0,     /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_BANK0_GPIO6_CTRL_OEOVER_INVERT    = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO6_CTRL_OEOVER_DISABLE   = 2,     /*!< DISABLE : disable output */
  IO_BANK0_GPIO6_CTRL_OEOVER_ENABLE    = 3,     /*!< ENABLE : enable output */
} IO_BANK0_GPIO6_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO6_CTRL OUTOVER [8..9]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO6_CTRL_OUTOVER */
  IO_BANK0_GPIO6_CTRL_OUTOVER_NORMAL   = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_BANK0_GPIO6_CTRL_OUTOVER_INVERT   = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO6_CTRL_OUTOVER_LOW      = 2,     /*!< LOW : drive output low */
  IO_BANK0_GPIO6_CTRL_OUTOVER_HIGH     = 3,     /*!< HIGH : drive output high */
} IO_BANK0_GPIO6_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO6_CTRL FUNCSEL [0..4]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO6_CTRL_FUNCSEL */
  IO_BANK0_GPIO6_CTRL_FUNCSEL_spi0_sclk = 1,    /*!< spi0_sclk : spi0_sclk */
  IO_BANK0_GPIO6_CTRL_FUNCSEL_uart1_cts = 2,    /*!< uart1_cts : uart1_cts */
  IO_BANK0_GPIO6_CTRL_FUNCSEL_i2c1_sda = 3,     /*!< i2c1_sda : i2c1_sda */
  IO_BANK0_GPIO6_CTRL_FUNCSEL_pwm_a_3  = 4,     /*!< pwm_a_3 : pwm_a_3 */
  IO_BANK0_GPIO6_CTRL_FUNCSEL_sio_6    = 5,     /*!< sio_6 : sio_6 */
  IO_BANK0_GPIO6_CTRL_FUNCSEL_pio0_6   = 6,     /*!< pio0_6 : pio0_6 */
  IO_BANK0_GPIO6_CTRL_FUNCSEL_pio1_6   = 7,     /*!< pio1_6 : pio1_6 */
  IO_BANK0_GPIO6_CTRL_FUNCSEL_usb_muxing_extphy_softcon = 8,/*!< usb_muxing_extphy_softcon : usb_muxing_extphy_softcon */
  IO_BANK0_GPIO6_CTRL_FUNCSEL_usb_muxing_overcurr_detect = 9,/*!< usb_muxing_overcurr_detect : usb_muxing_overcurr_detect */
  IO_BANK0_GPIO6_CTRL_FUNCSEL_null     = 31,    /*!< null : null */
} IO_BANK0_GPIO6_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO7_STATUS  ====================================================== */
/* ======================================================  GPIO7_CTRL  ======================================================= */
/* =========================================  IO_BANK0 GPIO7_CTRL IRQOVER [28..29]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO7_CTRL_IRQOVER */
  IO_BANK0_GPIO7_CTRL_IRQOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the interrupt */
  IO_BANK0_GPIO7_CTRL_IRQOVER_INVERT   = 1,     /*!< INVERT : invert the interrupt */
  IO_BANK0_GPIO7_CTRL_IRQOVER_LOW      = 2,     /*!< LOW : drive interrupt low */
  IO_BANK0_GPIO7_CTRL_IRQOVER_HIGH     = 3,     /*!< HIGH : drive interrupt high */
} IO_BANK0_GPIO7_CTRL_IRQOVER_Enum;

/* ==========================================  IO_BANK0 GPIO7_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO7_CTRL_INOVER */
  IO_BANK0_GPIO7_CTRL_INOVER_NORMAL    = 0,     /*!< NORMAL : don't invert the peri input */
  IO_BANK0_GPIO7_CTRL_INOVER_INVERT    = 1,     /*!< INVERT : invert the peri input */
  IO_BANK0_GPIO7_CTRL_INOVER_LOW       = 2,     /*!< LOW : drive peri input low */
  IO_BANK0_GPIO7_CTRL_INOVER_HIGH      = 3,     /*!< HIGH : drive peri input high */
} IO_BANK0_GPIO7_CTRL_INOVER_Enum;

/* ==========================================  IO_BANK0 GPIO7_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO7_CTRL_OEOVER */
  IO_BANK0_GPIO7_CTRL_OEOVER_NORMAL    = 0,     /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_BANK0_GPIO7_CTRL_OEOVER_INVERT    = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO7_CTRL_OEOVER_DISABLE   = 2,     /*!< DISABLE : disable output */
  IO_BANK0_GPIO7_CTRL_OEOVER_ENABLE    = 3,     /*!< ENABLE : enable output */
} IO_BANK0_GPIO7_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO7_CTRL OUTOVER [8..9]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO7_CTRL_OUTOVER */
  IO_BANK0_GPIO7_CTRL_OUTOVER_NORMAL   = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_BANK0_GPIO7_CTRL_OUTOVER_INVERT   = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO7_CTRL_OUTOVER_LOW      = 2,     /*!< LOW : drive output low */
  IO_BANK0_GPIO7_CTRL_OUTOVER_HIGH     = 3,     /*!< HIGH : drive output high */
} IO_BANK0_GPIO7_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO7_CTRL FUNCSEL [0..4]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO7_CTRL_FUNCSEL */
  IO_BANK0_GPIO7_CTRL_FUNCSEL_spi0_tx  = 1,     /*!< spi0_tx : spi0_tx */
  IO_BANK0_GPIO7_CTRL_FUNCSEL_uart1_rts = 2,    /*!< uart1_rts : uart1_rts */
  IO_BANK0_GPIO7_CTRL_FUNCSEL_i2c1_scl = 3,     /*!< i2c1_scl : i2c1_scl */
  IO_BANK0_GPIO7_CTRL_FUNCSEL_pwm_b_3  = 4,     /*!< pwm_b_3 : pwm_b_3 */
  IO_BANK0_GPIO7_CTRL_FUNCSEL_sio_7    = 5,     /*!< sio_7 : sio_7 */
  IO_BANK0_GPIO7_CTRL_FUNCSEL_pio0_7   = 6,     /*!< pio0_7 : pio0_7 */
  IO_BANK0_GPIO7_CTRL_FUNCSEL_pio1_7   = 7,     /*!< pio1_7 : pio1_7 */
  IO_BANK0_GPIO7_CTRL_FUNCSEL_usb_muxing_extphy_oe_n = 8,/*!< usb_muxing_extphy_oe_n : usb_muxing_extphy_oe_n */
  IO_BANK0_GPIO7_CTRL_FUNCSEL_usb_muxing_vbus_detect = 9,/*!< usb_muxing_vbus_detect : usb_muxing_vbus_detect */
  IO_BANK0_GPIO7_CTRL_FUNCSEL_null     = 31,    /*!< null : null */
} IO_BANK0_GPIO7_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO8_STATUS  ====================================================== */
/* ======================================================  GPIO8_CTRL  ======================================================= */
/* =========================================  IO_BANK0 GPIO8_CTRL IRQOVER [28..29]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO8_CTRL_IRQOVER */
  IO_BANK0_GPIO8_CTRL_IRQOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the interrupt */
  IO_BANK0_GPIO8_CTRL_IRQOVER_INVERT   = 1,     /*!< INVERT : invert the interrupt */
  IO_BANK0_GPIO8_CTRL_IRQOVER_LOW      = 2,     /*!< LOW : drive interrupt low */
  IO_BANK0_GPIO8_CTRL_IRQOVER_HIGH     = 3,     /*!< HIGH : drive interrupt high */
} IO_BANK0_GPIO8_CTRL_IRQOVER_Enum;

/* ==========================================  IO_BANK0 GPIO8_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO8_CTRL_INOVER */
  IO_BANK0_GPIO8_CTRL_INOVER_NORMAL    = 0,     /*!< NORMAL : don't invert the peri input */
  IO_BANK0_GPIO8_CTRL_INOVER_INVERT    = 1,     /*!< INVERT : invert the peri input */
  IO_BANK0_GPIO8_CTRL_INOVER_LOW       = 2,     /*!< LOW : drive peri input low */
  IO_BANK0_GPIO8_CTRL_INOVER_HIGH      = 3,     /*!< HIGH : drive peri input high */
} IO_BANK0_GPIO8_CTRL_INOVER_Enum;

/* ==========================================  IO_BANK0 GPIO8_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO8_CTRL_OEOVER */
  IO_BANK0_GPIO8_CTRL_OEOVER_NORMAL    = 0,     /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_BANK0_GPIO8_CTRL_OEOVER_INVERT    = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO8_CTRL_OEOVER_DISABLE   = 2,     /*!< DISABLE : disable output */
  IO_BANK0_GPIO8_CTRL_OEOVER_ENABLE    = 3,     /*!< ENABLE : enable output */
} IO_BANK0_GPIO8_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO8_CTRL OUTOVER [8..9]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO8_CTRL_OUTOVER */
  IO_BANK0_GPIO8_CTRL_OUTOVER_NORMAL   = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_BANK0_GPIO8_CTRL_OUTOVER_INVERT   = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO8_CTRL_OUTOVER_LOW      = 2,     /*!< LOW : drive output low */
  IO_BANK0_GPIO8_CTRL_OUTOVER_HIGH     = 3,     /*!< HIGH : drive output high */
} IO_BANK0_GPIO8_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO8_CTRL FUNCSEL [0..4]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO8_CTRL_FUNCSEL */
  IO_BANK0_GPIO8_CTRL_FUNCSEL_spi1_rx  = 1,     /*!< spi1_rx : spi1_rx */
  IO_BANK0_GPIO8_CTRL_FUNCSEL_uart1_tx = 2,     /*!< uart1_tx : uart1_tx */
  IO_BANK0_GPIO8_CTRL_FUNCSEL_i2c0_sda = 3,     /*!< i2c0_sda : i2c0_sda */
  IO_BANK0_GPIO8_CTRL_FUNCSEL_pwm_a_4  = 4,     /*!< pwm_a_4 : pwm_a_4 */
  IO_BANK0_GPIO8_CTRL_FUNCSEL_sio_8    = 5,     /*!< sio_8 : sio_8 */
  IO_BANK0_GPIO8_CTRL_FUNCSEL_pio0_8   = 6,     /*!< pio0_8 : pio0_8 */
  IO_BANK0_GPIO8_CTRL_FUNCSEL_pio1_8   = 7,     /*!< pio1_8 : pio1_8 */
  IO_BANK0_GPIO8_CTRL_FUNCSEL_usb_muxing_extphy_rcv = 8,/*!< usb_muxing_extphy_rcv : usb_muxing_extphy_rcv */
  IO_BANK0_GPIO8_CTRL_FUNCSEL_usb_muxing_vbus_en = 9,/*!< usb_muxing_vbus_en : usb_muxing_vbus_en */
  IO_BANK0_GPIO8_CTRL_FUNCSEL_null     = 31,    /*!< null : null */
} IO_BANK0_GPIO8_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO9_STATUS  ====================================================== */
/* ======================================================  GPIO9_CTRL  ======================================================= */
/* =========================================  IO_BANK0 GPIO9_CTRL IRQOVER [28..29]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO9_CTRL_IRQOVER */
  IO_BANK0_GPIO9_CTRL_IRQOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the interrupt */
  IO_BANK0_GPIO9_CTRL_IRQOVER_INVERT   = 1,     /*!< INVERT : invert the interrupt */
  IO_BANK0_GPIO9_CTRL_IRQOVER_LOW      = 2,     /*!< LOW : drive interrupt low */
  IO_BANK0_GPIO9_CTRL_IRQOVER_HIGH     = 3,     /*!< HIGH : drive interrupt high */
} IO_BANK0_GPIO9_CTRL_IRQOVER_Enum;

/* ==========================================  IO_BANK0 GPIO9_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO9_CTRL_INOVER */
  IO_BANK0_GPIO9_CTRL_INOVER_NORMAL    = 0,     /*!< NORMAL : don't invert the peri input */
  IO_BANK0_GPIO9_CTRL_INOVER_INVERT    = 1,     /*!< INVERT : invert the peri input */
  IO_BANK0_GPIO9_CTRL_INOVER_LOW       = 2,     /*!< LOW : drive peri input low */
  IO_BANK0_GPIO9_CTRL_INOVER_HIGH      = 3,     /*!< HIGH : drive peri input high */
} IO_BANK0_GPIO9_CTRL_INOVER_Enum;

/* ==========================================  IO_BANK0 GPIO9_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO9_CTRL_OEOVER */
  IO_BANK0_GPIO9_CTRL_OEOVER_NORMAL    = 0,     /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_BANK0_GPIO9_CTRL_OEOVER_INVERT    = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO9_CTRL_OEOVER_DISABLE   = 2,     /*!< DISABLE : disable output */
  IO_BANK0_GPIO9_CTRL_OEOVER_ENABLE    = 3,     /*!< ENABLE : enable output */
} IO_BANK0_GPIO9_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO9_CTRL OUTOVER [8..9]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO9_CTRL_OUTOVER */
  IO_BANK0_GPIO9_CTRL_OUTOVER_NORMAL   = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_BANK0_GPIO9_CTRL_OUTOVER_INVERT   = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO9_CTRL_OUTOVER_LOW      = 2,     /*!< LOW : drive output low */
  IO_BANK0_GPIO9_CTRL_OUTOVER_HIGH     = 3,     /*!< HIGH : drive output high */
} IO_BANK0_GPIO9_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO9_CTRL FUNCSEL [0..4]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO9_CTRL_FUNCSEL */
  IO_BANK0_GPIO9_CTRL_FUNCSEL_spi1_ss_n = 1,    /*!< spi1_ss_n : spi1_ss_n */
  IO_BANK0_GPIO9_CTRL_FUNCSEL_uart1_rx = 2,     /*!< uart1_rx : uart1_rx */
  IO_BANK0_GPIO9_CTRL_FUNCSEL_i2c0_scl = 3,     /*!< i2c0_scl : i2c0_scl */
  IO_BANK0_GPIO9_CTRL_FUNCSEL_pwm_b_4  = 4,     /*!< pwm_b_4 : pwm_b_4 */
  IO_BANK0_GPIO9_CTRL_FUNCSEL_sio_9    = 5,     /*!< sio_9 : sio_9 */
  IO_BANK0_GPIO9_CTRL_FUNCSEL_pio0_9   = 6,     /*!< pio0_9 : pio0_9 */
  IO_BANK0_GPIO9_CTRL_FUNCSEL_pio1_9   = 7,     /*!< pio1_9 : pio1_9 */
  IO_BANK0_GPIO9_CTRL_FUNCSEL_usb_muxing_extphy_vp = 8,/*!< usb_muxing_extphy_vp : usb_muxing_extphy_vp */
  IO_BANK0_GPIO9_CTRL_FUNCSEL_usb_muxing_overcurr_detect = 9,/*!< usb_muxing_overcurr_detect : usb_muxing_overcurr_detect */
  IO_BANK0_GPIO9_CTRL_FUNCSEL_null     = 31,    /*!< null : null */
} IO_BANK0_GPIO9_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO10_STATUS  ===================================================== */
/* ======================================================  GPIO10_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO10_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO10_CTRL_IRQOVER */
  IO_BANK0_GPIO10_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt */
  IO_BANK0_GPIO10_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt */
  IO_BANK0_GPIO10_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low */
  IO_BANK0_GPIO10_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high */
} IO_BANK0_GPIO10_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO10_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO10_CTRL_INOVER */
  IO_BANK0_GPIO10_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input */
  IO_BANK0_GPIO10_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input */
  IO_BANK0_GPIO10_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low */
  IO_BANK0_GPIO10_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high */
} IO_BANK0_GPIO10_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO10_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO10_CTRL_OEOVER */
  IO_BANK0_GPIO10_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_BANK0_GPIO10_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO10_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output */
  IO_BANK0_GPIO10_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output */
} IO_BANK0_GPIO10_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO10_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO10_CTRL_OUTOVER */
  IO_BANK0_GPIO10_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_BANK0_GPIO10_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO10_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low */
  IO_BANK0_GPIO10_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high */
} IO_BANK0_GPIO10_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO10_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO10_CTRL_FUNCSEL */
  IO_BANK0_GPIO10_CTRL_FUNCSEL_spi1_sclk = 1,   /*!< spi1_sclk : spi1_sclk */
  IO_BANK0_GPIO10_CTRL_FUNCSEL_uart1_cts = 2,   /*!< uart1_cts : uart1_cts */
  IO_BANK0_GPIO10_CTRL_FUNCSEL_i2c1_sda = 3,    /*!< i2c1_sda : i2c1_sda */
  IO_BANK0_GPIO10_CTRL_FUNCSEL_pwm_a_5 = 4,     /*!< pwm_a_5 : pwm_a_5 */
  IO_BANK0_GPIO10_CTRL_FUNCSEL_sio_10  = 5,     /*!< sio_10 : sio_10 */
  IO_BANK0_GPIO10_CTRL_FUNCSEL_pio0_10 = 6,     /*!< pio0_10 : pio0_10 */
  IO_BANK0_GPIO10_CTRL_FUNCSEL_pio1_10 = 7,     /*!< pio1_10 : pio1_10 */
  IO_BANK0_GPIO10_CTRL_FUNCSEL_usb_muxing_extphy_vm = 8,/*!< usb_muxing_extphy_vm : usb_muxing_extphy_vm */
  IO_BANK0_GPIO10_CTRL_FUNCSEL_usb_muxing_vbus_detect = 9,/*!< usb_muxing_vbus_detect : usb_muxing_vbus_detect */
  IO_BANK0_GPIO10_CTRL_FUNCSEL_null    = 31,    /*!< null : null */
} IO_BANK0_GPIO10_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO11_STATUS  ===================================================== */
/* ======================================================  GPIO11_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO11_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO11_CTRL_IRQOVER */
  IO_BANK0_GPIO11_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt */
  IO_BANK0_GPIO11_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt */
  IO_BANK0_GPIO11_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low */
  IO_BANK0_GPIO11_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high */
} IO_BANK0_GPIO11_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO11_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO11_CTRL_INOVER */
  IO_BANK0_GPIO11_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input */
  IO_BANK0_GPIO11_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input */
  IO_BANK0_GPIO11_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low */
  IO_BANK0_GPIO11_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high */
} IO_BANK0_GPIO11_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO11_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO11_CTRL_OEOVER */
  IO_BANK0_GPIO11_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_BANK0_GPIO11_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO11_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output */
  IO_BANK0_GPIO11_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output */
} IO_BANK0_GPIO11_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO11_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO11_CTRL_OUTOVER */
  IO_BANK0_GPIO11_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_BANK0_GPIO11_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO11_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low */
  IO_BANK0_GPIO11_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high */
} IO_BANK0_GPIO11_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO11_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO11_CTRL_FUNCSEL */
  IO_BANK0_GPIO11_CTRL_FUNCSEL_spi1_tx = 1,     /*!< spi1_tx : spi1_tx */
  IO_BANK0_GPIO11_CTRL_FUNCSEL_uart1_rts = 2,   /*!< uart1_rts : uart1_rts */
  IO_BANK0_GPIO11_CTRL_FUNCSEL_i2c1_scl = 3,    /*!< i2c1_scl : i2c1_scl */
  IO_BANK0_GPIO11_CTRL_FUNCSEL_pwm_b_5 = 4,     /*!< pwm_b_5 : pwm_b_5 */
  IO_BANK0_GPIO11_CTRL_FUNCSEL_sio_11  = 5,     /*!< sio_11 : sio_11 */
  IO_BANK0_GPIO11_CTRL_FUNCSEL_pio0_11 = 6,     /*!< pio0_11 : pio0_11 */
  IO_BANK0_GPIO11_CTRL_FUNCSEL_pio1_11 = 7,     /*!< pio1_11 : pio1_11 */
  IO_BANK0_GPIO11_CTRL_FUNCSEL_usb_muxing_extphy_suspnd = 8,/*!< usb_muxing_extphy_suspnd : usb_muxing_extphy_suspnd */
  IO_BANK0_GPIO11_CTRL_FUNCSEL_usb_muxing_vbus_en = 9,/*!< usb_muxing_vbus_en : usb_muxing_vbus_en */
  IO_BANK0_GPIO11_CTRL_FUNCSEL_null    = 31,    /*!< null : null */
} IO_BANK0_GPIO11_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO12_STATUS  ===================================================== */
/* ======================================================  GPIO12_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO12_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO12_CTRL_IRQOVER */
  IO_BANK0_GPIO12_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt */
  IO_BANK0_GPIO12_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt */
  IO_BANK0_GPIO12_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low */
  IO_BANK0_GPIO12_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high */
} IO_BANK0_GPIO12_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO12_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO12_CTRL_INOVER */
  IO_BANK0_GPIO12_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input */
  IO_BANK0_GPIO12_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input */
  IO_BANK0_GPIO12_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low */
  IO_BANK0_GPIO12_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high */
} IO_BANK0_GPIO12_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO12_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO12_CTRL_OEOVER */
  IO_BANK0_GPIO12_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_BANK0_GPIO12_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO12_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output */
  IO_BANK0_GPIO12_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output */
} IO_BANK0_GPIO12_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO12_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO12_CTRL_OUTOVER */
  IO_BANK0_GPIO12_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_BANK0_GPIO12_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO12_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low */
  IO_BANK0_GPIO12_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high */
} IO_BANK0_GPIO12_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO12_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO12_CTRL_FUNCSEL */
  IO_BANK0_GPIO12_CTRL_FUNCSEL_spi1_rx = 1,     /*!< spi1_rx : spi1_rx */
  IO_BANK0_GPIO12_CTRL_FUNCSEL_uart0_tx = 2,    /*!< uart0_tx : uart0_tx */
  IO_BANK0_GPIO12_CTRL_FUNCSEL_i2c0_sda = 3,    /*!< i2c0_sda : i2c0_sda */
  IO_BANK0_GPIO12_CTRL_FUNCSEL_pwm_a_6 = 4,     /*!< pwm_a_6 : pwm_a_6 */
  IO_BANK0_GPIO12_CTRL_FUNCSEL_sio_12  = 5,     /*!< sio_12 : sio_12 */
  IO_BANK0_GPIO12_CTRL_FUNCSEL_pio0_12 = 6,     /*!< pio0_12 : pio0_12 */
  IO_BANK0_GPIO12_CTRL_FUNCSEL_pio1_12 = 7,     /*!< pio1_12 : pio1_12 */
  IO_BANK0_GPIO12_CTRL_FUNCSEL_usb_muxing_extphy_speed = 8,/*!< usb_muxing_extphy_speed : usb_muxing_extphy_speed */
  IO_BANK0_GPIO12_CTRL_FUNCSEL_usb_muxing_overcurr_detect = 9,/*!< usb_muxing_overcurr_detect : usb_muxing_overcurr_detect */
  IO_BANK0_GPIO12_CTRL_FUNCSEL_null    = 31,    /*!< null : null */
} IO_BANK0_GPIO12_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO13_STATUS  ===================================================== */
/* ======================================================  GPIO13_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO13_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO13_CTRL_IRQOVER */
  IO_BANK0_GPIO13_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt */
  IO_BANK0_GPIO13_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt */
  IO_BANK0_GPIO13_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low */
  IO_BANK0_GPIO13_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high */
} IO_BANK0_GPIO13_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO13_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO13_CTRL_INOVER */
  IO_BANK0_GPIO13_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input */
  IO_BANK0_GPIO13_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input */
  IO_BANK0_GPIO13_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low */
  IO_BANK0_GPIO13_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high */
} IO_BANK0_GPIO13_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO13_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO13_CTRL_OEOVER */
  IO_BANK0_GPIO13_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_BANK0_GPIO13_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO13_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output */
  IO_BANK0_GPIO13_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output */
} IO_BANK0_GPIO13_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO13_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO13_CTRL_OUTOVER */
  IO_BANK0_GPIO13_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_BANK0_GPIO13_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO13_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low */
  IO_BANK0_GPIO13_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high */
} IO_BANK0_GPIO13_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO13_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO13_CTRL_FUNCSEL */
  IO_BANK0_GPIO13_CTRL_FUNCSEL_spi1_ss_n = 1,   /*!< spi1_ss_n : spi1_ss_n */
  IO_BANK0_GPIO13_CTRL_FUNCSEL_uart0_rx = 2,    /*!< uart0_rx : uart0_rx */
  IO_BANK0_GPIO13_CTRL_FUNCSEL_i2c0_scl = 3,    /*!< i2c0_scl : i2c0_scl */
  IO_BANK0_GPIO13_CTRL_FUNCSEL_pwm_b_6 = 4,     /*!< pwm_b_6 : pwm_b_6 */
  IO_BANK0_GPIO13_CTRL_FUNCSEL_sio_13  = 5,     /*!< sio_13 : sio_13 */
  IO_BANK0_GPIO13_CTRL_FUNCSEL_pio0_13 = 6,     /*!< pio0_13 : pio0_13 */
  IO_BANK0_GPIO13_CTRL_FUNCSEL_pio1_13 = 7,     /*!< pio1_13 : pio1_13 */
  IO_BANK0_GPIO13_CTRL_FUNCSEL_usb_muxing_extphy_vpo = 8,/*!< usb_muxing_extphy_vpo : usb_muxing_extphy_vpo */
  IO_BANK0_GPIO13_CTRL_FUNCSEL_usb_muxing_vbus_detect = 9,/*!< usb_muxing_vbus_detect : usb_muxing_vbus_detect */
  IO_BANK0_GPIO13_CTRL_FUNCSEL_null    = 31,    /*!< null : null */
} IO_BANK0_GPIO13_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO14_STATUS  ===================================================== */
/* ======================================================  GPIO14_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO14_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO14_CTRL_IRQOVER */
  IO_BANK0_GPIO14_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt */
  IO_BANK0_GPIO14_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt */
  IO_BANK0_GPIO14_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low */
  IO_BANK0_GPIO14_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high */
} IO_BANK0_GPIO14_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO14_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO14_CTRL_INOVER */
  IO_BANK0_GPIO14_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input */
  IO_BANK0_GPIO14_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input */
  IO_BANK0_GPIO14_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low */
  IO_BANK0_GPIO14_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high */
} IO_BANK0_GPIO14_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO14_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO14_CTRL_OEOVER */
  IO_BANK0_GPIO14_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_BANK0_GPIO14_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO14_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output */
  IO_BANK0_GPIO14_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output */
} IO_BANK0_GPIO14_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO14_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO14_CTRL_OUTOVER */
  IO_BANK0_GPIO14_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_BANK0_GPIO14_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO14_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low */
  IO_BANK0_GPIO14_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high */
} IO_BANK0_GPIO14_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO14_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO14_CTRL_FUNCSEL */
  IO_BANK0_GPIO14_CTRL_FUNCSEL_spi1_sclk = 1,   /*!< spi1_sclk : spi1_sclk */
  IO_BANK0_GPIO14_CTRL_FUNCSEL_uart0_cts = 2,   /*!< uart0_cts : uart0_cts */
  IO_BANK0_GPIO14_CTRL_FUNCSEL_i2c1_sda = 3,    /*!< i2c1_sda : i2c1_sda */
  IO_BANK0_GPIO14_CTRL_FUNCSEL_pwm_a_7 = 4,     /*!< pwm_a_7 : pwm_a_7 */
  IO_BANK0_GPIO14_CTRL_FUNCSEL_sio_14  = 5,     /*!< sio_14 : sio_14 */
  IO_BANK0_GPIO14_CTRL_FUNCSEL_pio0_14 = 6,     /*!< pio0_14 : pio0_14 */
  IO_BANK0_GPIO14_CTRL_FUNCSEL_pio1_14 = 7,     /*!< pio1_14 : pio1_14 */
  IO_BANK0_GPIO14_CTRL_FUNCSEL_usb_muxing_extphy_vmo = 8,/*!< usb_muxing_extphy_vmo : usb_muxing_extphy_vmo */
  IO_BANK0_GPIO14_CTRL_FUNCSEL_usb_muxing_vbus_en = 9,/*!< usb_muxing_vbus_en : usb_muxing_vbus_en */
  IO_BANK0_GPIO14_CTRL_FUNCSEL_null    = 31,    /*!< null : null */
} IO_BANK0_GPIO14_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO15_STATUS  ===================================================== */
/* ======================================================  GPIO15_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO15_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO15_CTRL_IRQOVER */
  IO_BANK0_GPIO15_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt */
  IO_BANK0_GPIO15_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt */
  IO_BANK0_GPIO15_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low */
  IO_BANK0_GPIO15_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high */
} IO_BANK0_GPIO15_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO15_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO15_CTRL_INOVER */
  IO_BANK0_GPIO15_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input */
  IO_BANK0_GPIO15_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input */
  IO_BANK0_GPIO15_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low */
  IO_BANK0_GPIO15_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high */
} IO_BANK0_GPIO15_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO15_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO15_CTRL_OEOVER */
  IO_BANK0_GPIO15_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_BANK0_GPIO15_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO15_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output */
  IO_BANK0_GPIO15_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output */
} IO_BANK0_GPIO15_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO15_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO15_CTRL_OUTOVER */
  IO_BANK0_GPIO15_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_BANK0_GPIO15_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO15_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low */
  IO_BANK0_GPIO15_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high */
} IO_BANK0_GPIO15_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO15_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO15_CTRL_FUNCSEL */
  IO_BANK0_GPIO15_CTRL_FUNCSEL_spi1_tx = 1,     /*!< spi1_tx : spi1_tx */
  IO_BANK0_GPIO15_CTRL_FUNCSEL_uart0_rts = 2,   /*!< uart0_rts : uart0_rts */
  IO_BANK0_GPIO15_CTRL_FUNCSEL_i2c1_scl = 3,    /*!< i2c1_scl : i2c1_scl */
  IO_BANK0_GPIO15_CTRL_FUNCSEL_pwm_b_7 = 4,     /*!< pwm_b_7 : pwm_b_7 */
  IO_BANK0_GPIO15_CTRL_FUNCSEL_sio_15  = 5,     /*!< sio_15 : sio_15 */
  IO_BANK0_GPIO15_CTRL_FUNCSEL_pio0_15 = 6,     /*!< pio0_15 : pio0_15 */
  IO_BANK0_GPIO15_CTRL_FUNCSEL_pio1_15 = 7,     /*!< pio1_15 : pio1_15 */
  IO_BANK0_GPIO15_CTRL_FUNCSEL_usb_muxing_digital_dp = 8,/*!< usb_muxing_digital_dp : usb_muxing_digital_dp */
  IO_BANK0_GPIO15_CTRL_FUNCSEL_usb_muxing_overcurr_detect = 9,/*!< usb_muxing_overcurr_detect : usb_muxing_overcurr_detect */
  IO_BANK0_GPIO15_CTRL_FUNCSEL_null    = 31,    /*!< null : null */
} IO_BANK0_GPIO15_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO16_STATUS  ===================================================== */
/* ======================================================  GPIO16_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO16_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO16_CTRL_IRQOVER */
  IO_BANK0_GPIO16_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt */
  IO_BANK0_GPIO16_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt */
  IO_BANK0_GPIO16_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low */
  IO_BANK0_GPIO16_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high */
} IO_BANK0_GPIO16_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO16_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO16_CTRL_INOVER */
  IO_BANK0_GPIO16_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input */
  IO_BANK0_GPIO16_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input */
  IO_BANK0_GPIO16_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low */
  IO_BANK0_GPIO16_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high */
} IO_BANK0_GPIO16_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO16_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO16_CTRL_OEOVER */
  IO_BANK0_GPIO16_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_BANK0_GPIO16_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO16_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output */
  IO_BANK0_GPIO16_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output */
} IO_BANK0_GPIO16_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO16_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO16_CTRL_OUTOVER */
  IO_BANK0_GPIO16_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_BANK0_GPIO16_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO16_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low */
  IO_BANK0_GPIO16_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high */
} IO_BANK0_GPIO16_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO16_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO16_CTRL_FUNCSEL */
  IO_BANK0_GPIO16_CTRL_FUNCSEL_spi0_rx = 1,     /*!< spi0_rx : spi0_rx */
  IO_BANK0_GPIO16_CTRL_FUNCSEL_uart0_tx = 2,    /*!< uart0_tx : uart0_tx */
  IO_BANK0_GPIO16_CTRL_FUNCSEL_i2c0_sda = 3,    /*!< i2c0_sda : i2c0_sda */
  IO_BANK0_GPIO16_CTRL_FUNCSEL_pwm_a_0 = 4,     /*!< pwm_a_0 : pwm_a_0 */
  IO_BANK0_GPIO16_CTRL_FUNCSEL_sio_16  = 5,     /*!< sio_16 : sio_16 */
  IO_BANK0_GPIO16_CTRL_FUNCSEL_pio0_16 = 6,     /*!< pio0_16 : pio0_16 */
  IO_BANK0_GPIO16_CTRL_FUNCSEL_pio1_16 = 7,     /*!< pio1_16 : pio1_16 */
  IO_BANK0_GPIO16_CTRL_FUNCSEL_usb_muxing_digital_dm = 8,/*!< usb_muxing_digital_dm : usb_muxing_digital_dm */
  IO_BANK0_GPIO16_CTRL_FUNCSEL_usb_muxing_vbus_detect = 9,/*!< usb_muxing_vbus_detect : usb_muxing_vbus_detect */
  IO_BANK0_GPIO16_CTRL_FUNCSEL_null    = 31,    /*!< null : null */
} IO_BANK0_GPIO16_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO17_STATUS  ===================================================== */
/* ======================================================  GPIO17_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO17_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO17_CTRL_IRQOVER */
  IO_BANK0_GPIO17_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt */
  IO_BANK0_GPIO17_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt */
  IO_BANK0_GPIO17_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low */
  IO_BANK0_GPIO17_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high */
} IO_BANK0_GPIO17_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO17_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO17_CTRL_INOVER */
  IO_BANK0_GPIO17_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input */
  IO_BANK0_GPIO17_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input */
  IO_BANK0_GPIO17_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low */
  IO_BANK0_GPIO17_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high */
} IO_BANK0_GPIO17_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO17_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO17_CTRL_OEOVER */
  IO_BANK0_GPIO17_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_BANK0_GPIO17_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO17_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output */
  IO_BANK0_GPIO17_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output */
} IO_BANK0_GPIO17_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO17_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO17_CTRL_OUTOVER */
  IO_BANK0_GPIO17_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_BANK0_GPIO17_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO17_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low */
  IO_BANK0_GPIO17_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high */
} IO_BANK0_GPIO17_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO17_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO17_CTRL_FUNCSEL */
  IO_BANK0_GPIO17_CTRL_FUNCSEL_spi0_ss_n = 1,   /*!< spi0_ss_n : spi0_ss_n */
  IO_BANK0_GPIO17_CTRL_FUNCSEL_uart0_rx = 2,    /*!< uart0_rx : uart0_rx */
  IO_BANK0_GPIO17_CTRL_FUNCSEL_i2c0_scl = 3,    /*!< i2c0_scl : i2c0_scl */
  IO_BANK0_GPIO17_CTRL_FUNCSEL_pwm_b_0 = 4,     /*!< pwm_b_0 : pwm_b_0 */
  IO_BANK0_GPIO17_CTRL_FUNCSEL_sio_17  = 5,     /*!< sio_17 : sio_17 */
  IO_BANK0_GPIO17_CTRL_FUNCSEL_pio0_17 = 6,     /*!< pio0_17 : pio0_17 */
  IO_BANK0_GPIO17_CTRL_FUNCSEL_pio1_17 = 7,     /*!< pio1_17 : pio1_17 */
  IO_BANK0_GPIO17_CTRL_FUNCSEL_usb_muxing_vbus_en = 9,/*!< usb_muxing_vbus_en : usb_muxing_vbus_en */
  IO_BANK0_GPIO17_CTRL_FUNCSEL_null    = 31,    /*!< null : null */
} IO_BANK0_GPIO17_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO18_STATUS  ===================================================== */
/* ======================================================  GPIO18_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO18_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO18_CTRL_IRQOVER */
  IO_BANK0_GPIO18_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt */
  IO_BANK0_GPIO18_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt */
  IO_BANK0_GPIO18_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low */
  IO_BANK0_GPIO18_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high */
} IO_BANK0_GPIO18_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO18_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO18_CTRL_INOVER */
  IO_BANK0_GPIO18_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input */
  IO_BANK0_GPIO18_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input */
  IO_BANK0_GPIO18_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low */
  IO_BANK0_GPIO18_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high */
} IO_BANK0_GPIO18_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO18_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO18_CTRL_OEOVER */
  IO_BANK0_GPIO18_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_BANK0_GPIO18_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO18_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output */
  IO_BANK0_GPIO18_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output */
} IO_BANK0_GPIO18_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO18_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO18_CTRL_OUTOVER */
  IO_BANK0_GPIO18_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_BANK0_GPIO18_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO18_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low */
  IO_BANK0_GPIO18_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high */
} IO_BANK0_GPIO18_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO18_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO18_CTRL_FUNCSEL */
  IO_BANK0_GPIO18_CTRL_FUNCSEL_spi0_sclk = 1,   /*!< spi0_sclk : spi0_sclk */
  IO_BANK0_GPIO18_CTRL_FUNCSEL_uart0_cts = 2,   /*!< uart0_cts : uart0_cts */
  IO_BANK0_GPIO18_CTRL_FUNCSEL_i2c1_sda = 3,    /*!< i2c1_sda : i2c1_sda */
  IO_BANK0_GPIO18_CTRL_FUNCSEL_pwm_a_1 = 4,     /*!< pwm_a_1 : pwm_a_1 */
  IO_BANK0_GPIO18_CTRL_FUNCSEL_sio_18  = 5,     /*!< sio_18 : sio_18 */
  IO_BANK0_GPIO18_CTRL_FUNCSEL_pio0_18 = 6,     /*!< pio0_18 : pio0_18 */
  IO_BANK0_GPIO18_CTRL_FUNCSEL_pio1_18 = 7,     /*!< pio1_18 : pio1_18 */
  IO_BANK0_GPIO18_CTRL_FUNCSEL_usb_muxing_overcurr_detect = 9,/*!< usb_muxing_overcurr_detect : usb_muxing_overcurr_detect */
  IO_BANK0_GPIO18_CTRL_FUNCSEL_null    = 31,    /*!< null : null */
} IO_BANK0_GPIO18_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO19_STATUS  ===================================================== */
/* ======================================================  GPIO19_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO19_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO19_CTRL_IRQOVER */
  IO_BANK0_GPIO19_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt */
  IO_BANK0_GPIO19_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt */
  IO_BANK0_GPIO19_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low */
  IO_BANK0_GPIO19_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high */
} IO_BANK0_GPIO19_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO19_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO19_CTRL_INOVER */
  IO_BANK0_GPIO19_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input */
  IO_BANK0_GPIO19_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input */
  IO_BANK0_GPIO19_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low */
  IO_BANK0_GPIO19_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high */
} IO_BANK0_GPIO19_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO19_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO19_CTRL_OEOVER */
  IO_BANK0_GPIO19_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_BANK0_GPIO19_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO19_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output */
  IO_BANK0_GPIO19_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output */
} IO_BANK0_GPIO19_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO19_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO19_CTRL_OUTOVER */
  IO_BANK0_GPIO19_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_BANK0_GPIO19_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO19_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low */
  IO_BANK0_GPIO19_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high */
} IO_BANK0_GPIO19_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO19_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO19_CTRL_FUNCSEL */
  IO_BANK0_GPIO19_CTRL_FUNCSEL_spi0_tx = 1,     /*!< spi0_tx : spi0_tx */
  IO_BANK0_GPIO19_CTRL_FUNCSEL_uart0_rts = 2,   /*!< uart0_rts : uart0_rts */
  IO_BANK0_GPIO19_CTRL_FUNCSEL_i2c1_scl = 3,    /*!< i2c1_scl : i2c1_scl */
  IO_BANK0_GPIO19_CTRL_FUNCSEL_pwm_b_1 = 4,     /*!< pwm_b_1 : pwm_b_1 */
  IO_BANK0_GPIO19_CTRL_FUNCSEL_sio_19  = 5,     /*!< sio_19 : sio_19 */
  IO_BANK0_GPIO19_CTRL_FUNCSEL_pio0_19 = 6,     /*!< pio0_19 : pio0_19 */
  IO_BANK0_GPIO19_CTRL_FUNCSEL_pio1_19 = 7,     /*!< pio1_19 : pio1_19 */
  IO_BANK0_GPIO19_CTRL_FUNCSEL_usb_muxing_vbus_detect = 9,/*!< usb_muxing_vbus_detect : usb_muxing_vbus_detect */
  IO_BANK0_GPIO19_CTRL_FUNCSEL_null    = 31,    /*!< null : null */
} IO_BANK0_GPIO19_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO20_STATUS  ===================================================== */
/* ======================================================  GPIO20_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO20_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO20_CTRL_IRQOVER */
  IO_BANK0_GPIO20_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt */
  IO_BANK0_GPIO20_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt */
  IO_BANK0_GPIO20_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low */
  IO_BANK0_GPIO20_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high */
} IO_BANK0_GPIO20_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO20_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO20_CTRL_INOVER */
  IO_BANK0_GPIO20_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input */
  IO_BANK0_GPIO20_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input */
  IO_BANK0_GPIO20_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low */
  IO_BANK0_GPIO20_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high */
} IO_BANK0_GPIO20_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO20_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO20_CTRL_OEOVER */
  IO_BANK0_GPIO20_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_BANK0_GPIO20_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO20_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output */
  IO_BANK0_GPIO20_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output */
} IO_BANK0_GPIO20_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO20_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO20_CTRL_OUTOVER */
  IO_BANK0_GPIO20_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_BANK0_GPIO20_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO20_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low */
  IO_BANK0_GPIO20_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high */
} IO_BANK0_GPIO20_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO20_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO20_CTRL_FUNCSEL */
  IO_BANK0_GPIO20_CTRL_FUNCSEL_spi0_rx = 1,     /*!< spi0_rx : spi0_rx */
  IO_BANK0_GPIO20_CTRL_FUNCSEL_uart1_tx = 2,    /*!< uart1_tx : uart1_tx */
  IO_BANK0_GPIO20_CTRL_FUNCSEL_i2c0_sda = 3,    /*!< i2c0_sda : i2c0_sda */
  IO_BANK0_GPIO20_CTRL_FUNCSEL_pwm_a_2 = 4,     /*!< pwm_a_2 : pwm_a_2 */
  IO_BANK0_GPIO20_CTRL_FUNCSEL_sio_20  = 5,     /*!< sio_20 : sio_20 */
  IO_BANK0_GPIO20_CTRL_FUNCSEL_pio0_20 = 6,     /*!< pio0_20 : pio0_20 */
  IO_BANK0_GPIO20_CTRL_FUNCSEL_pio1_20 = 7,     /*!< pio1_20 : pio1_20 */
  IO_BANK0_GPIO20_CTRL_FUNCSEL_clocks_gpin_0 = 8,/*!< clocks_gpin_0 : clocks_gpin_0 */
  IO_BANK0_GPIO20_CTRL_FUNCSEL_usb_muxing_vbus_en = 9,/*!< usb_muxing_vbus_en : usb_muxing_vbus_en */
  IO_BANK0_GPIO20_CTRL_FUNCSEL_null    = 31,    /*!< null : null */
} IO_BANK0_GPIO20_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO21_STATUS  ===================================================== */
/* ======================================================  GPIO21_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO21_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO21_CTRL_IRQOVER */
  IO_BANK0_GPIO21_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt */
  IO_BANK0_GPIO21_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt */
  IO_BANK0_GPIO21_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low */
  IO_BANK0_GPIO21_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high */
} IO_BANK0_GPIO21_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO21_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO21_CTRL_INOVER */
  IO_BANK0_GPIO21_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input */
  IO_BANK0_GPIO21_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input */
  IO_BANK0_GPIO21_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low */
  IO_BANK0_GPIO21_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high */
} IO_BANK0_GPIO21_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO21_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO21_CTRL_OEOVER */
  IO_BANK0_GPIO21_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_BANK0_GPIO21_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO21_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output */
  IO_BANK0_GPIO21_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output */
} IO_BANK0_GPIO21_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO21_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO21_CTRL_OUTOVER */
  IO_BANK0_GPIO21_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_BANK0_GPIO21_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO21_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low */
  IO_BANK0_GPIO21_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high */
} IO_BANK0_GPIO21_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO21_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO21_CTRL_FUNCSEL */
  IO_BANK0_GPIO21_CTRL_FUNCSEL_spi0_ss_n = 1,   /*!< spi0_ss_n : spi0_ss_n */
  IO_BANK0_GPIO21_CTRL_FUNCSEL_uart1_rx = 2,    /*!< uart1_rx : uart1_rx */
  IO_BANK0_GPIO21_CTRL_FUNCSEL_i2c0_scl = 3,    /*!< i2c0_scl : i2c0_scl */
  IO_BANK0_GPIO21_CTRL_FUNCSEL_pwm_b_2 = 4,     /*!< pwm_b_2 : pwm_b_2 */
  IO_BANK0_GPIO21_CTRL_FUNCSEL_sio_21  = 5,     /*!< sio_21 : sio_21 */
  IO_BANK0_GPIO21_CTRL_FUNCSEL_pio0_21 = 6,     /*!< pio0_21 : pio0_21 */
  IO_BANK0_GPIO21_CTRL_FUNCSEL_pio1_21 = 7,     /*!< pio1_21 : pio1_21 */
  IO_BANK0_GPIO21_CTRL_FUNCSEL_clocks_gpout_0 = 8,/*!< clocks_gpout_0 : clocks_gpout_0 */
  IO_BANK0_GPIO21_CTRL_FUNCSEL_usb_muxing_overcurr_detect = 9,/*!< usb_muxing_overcurr_detect : usb_muxing_overcurr_detect */
  IO_BANK0_GPIO21_CTRL_FUNCSEL_null    = 31,    /*!< null : null */
} IO_BANK0_GPIO21_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO22_STATUS  ===================================================== */
/* ======================================================  GPIO22_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO22_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO22_CTRL_IRQOVER */
  IO_BANK0_GPIO22_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt */
  IO_BANK0_GPIO22_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt */
  IO_BANK0_GPIO22_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low */
  IO_BANK0_GPIO22_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high */
} IO_BANK0_GPIO22_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO22_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO22_CTRL_INOVER */
  IO_BANK0_GPIO22_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input */
  IO_BANK0_GPIO22_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input */
  IO_BANK0_GPIO22_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low */
  IO_BANK0_GPIO22_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high */
} IO_BANK0_GPIO22_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO22_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO22_CTRL_OEOVER */
  IO_BANK0_GPIO22_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_BANK0_GPIO22_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO22_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output */
  IO_BANK0_GPIO22_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output */
} IO_BANK0_GPIO22_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO22_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO22_CTRL_OUTOVER */
  IO_BANK0_GPIO22_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_BANK0_GPIO22_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO22_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low */
  IO_BANK0_GPIO22_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high */
} IO_BANK0_GPIO22_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO22_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO22_CTRL_FUNCSEL */
  IO_BANK0_GPIO22_CTRL_FUNCSEL_spi0_sclk = 1,   /*!< spi0_sclk : spi0_sclk */
  IO_BANK0_GPIO22_CTRL_FUNCSEL_uart1_cts = 2,   /*!< uart1_cts : uart1_cts */
  IO_BANK0_GPIO22_CTRL_FUNCSEL_i2c1_sda = 3,    /*!< i2c1_sda : i2c1_sda */
  IO_BANK0_GPIO22_CTRL_FUNCSEL_pwm_a_3 = 4,     /*!< pwm_a_3 : pwm_a_3 */
  IO_BANK0_GPIO22_CTRL_FUNCSEL_sio_22  = 5,     /*!< sio_22 : sio_22 */
  IO_BANK0_GPIO22_CTRL_FUNCSEL_pio0_22 = 6,     /*!< pio0_22 : pio0_22 */
  IO_BANK0_GPIO22_CTRL_FUNCSEL_pio1_22 = 7,     /*!< pio1_22 : pio1_22 */
  IO_BANK0_GPIO22_CTRL_FUNCSEL_clocks_gpin_1 = 8,/*!< clocks_gpin_1 : clocks_gpin_1 */
  IO_BANK0_GPIO22_CTRL_FUNCSEL_usb_muxing_vbus_detect = 9,/*!< usb_muxing_vbus_detect : usb_muxing_vbus_detect */
  IO_BANK0_GPIO22_CTRL_FUNCSEL_null    = 31,    /*!< null : null */
} IO_BANK0_GPIO22_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO23_STATUS  ===================================================== */
/* ======================================================  GPIO23_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO23_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO23_CTRL_IRQOVER */
  IO_BANK0_GPIO23_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt */
  IO_BANK0_GPIO23_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt */
  IO_BANK0_GPIO23_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low */
  IO_BANK0_GPIO23_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high */
} IO_BANK0_GPIO23_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO23_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO23_CTRL_INOVER */
  IO_BANK0_GPIO23_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input */
  IO_BANK0_GPIO23_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input */
  IO_BANK0_GPIO23_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low */
  IO_BANK0_GPIO23_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high */
} IO_BANK0_GPIO23_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO23_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO23_CTRL_OEOVER */
  IO_BANK0_GPIO23_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_BANK0_GPIO23_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO23_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output */
  IO_BANK0_GPIO23_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output */
} IO_BANK0_GPIO23_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO23_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO23_CTRL_OUTOVER */
  IO_BANK0_GPIO23_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_BANK0_GPIO23_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO23_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low */
  IO_BANK0_GPIO23_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high */
} IO_BANK0_GPIO23_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO23_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO23_CTRL_FUNCSEL */
  IO_BANK0_GPIO23_CTRL_FUNCSEL_spi0_tx = 1,     /*!< spi0_tx : spi0_tx */
  IO_BANK0_GPIO23_CTRL_FUNCSEL_uart1_rts = 2,   /*!< uart1_rts : uart1_rts */
  IO_BANK0_GPIO23_CTRL_FUNCSEL_i2c1_scl = 3,    /*!< i2c1_scl : i2c1_scl */
  IO_BANK0_GPIO23_CTRL_FUNCSEL_pwm_b_3 = 4,     /*!< pwm_b_3 : pwm_b_3 */
  IO_BANK0_GPIO23_CTRL_FUNCSEL_sio_23  = 5,     /*!< sio_23 : sio_23 */
  IO_BANK0_GPIO23_CTRL_FUNCSEL_pio0_23 = 6,     /*!< pio0_23 : pio0_23 */
  IO_BANK0_GPIO23_CTRL_FUNCSEL_pio1_23 = 7,     /*!< pio1_23 : pio1_23 */
  IO_BANK0_GPIO23_CTRL_FUNCSEL_clocks_gpout_1 = 8,/*!< clocks_gpout_1 : clocks_gpout_1 */
  IO_BANK0_GPIO23_CTRL_FUNCSEL_usb_muxing_vbus_en = 9,/*!< usb_muxing_vbus_en : usb_muxing_vbus_en */
  IO_BANK0_GPIO23_CTRL_FUNCSEL_null    = 31,    /*!< null : null */
} IO_BANK0_GPIO23_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO24_STATUS  ===================================================== */
/* ======================================================  GPIO24_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO24_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO24_CTRL_IRQOVER */
  IO_BANK0_GPIO24_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt */
  IO_BANK0_GPIO24_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt */
  IO_BANK0_GPIO24_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low */
  IO_BANK0_GPIO24_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high */
} IO_BANK0_GPIO24_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO24_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO24_CTRL_INOVER */
  IO_BANK0_GPIO24_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input */
  IO_BANK0_GPIO24_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input */
  IO_BANK0_GPIO24_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low */
  IO_BANK0_GPIO24_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high */
} IO_BANK0_GPIO24_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO24_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO24_CTRL_OEOVER */
  IO_BANK0_GPIO24_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_BANK0_GPIO24_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO24_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output */
  IO_BANK0_GPIO24_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output */
} IO_BANK0_GPIO24_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO24_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO24_CTRL_OUTOVER */
  IO_BANK0_GPIO24_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_BANK0_GPIO24_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO24_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low */
  IO_BANK0_GPIO24_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high */
} IO_BANK0_GPIO24_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO24_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO24_CTRL_FUNCSEL */
  IO_BANK0_GPIO24_CTRL_FUNCSEL_spi1_rx = 1,     /*!< spi1_rx : spi1_rx */
  IO_BANK0_GPIO24_CTRL_FUNCSEL_uart1_tx = 2,    /*!< uart1_tx : uart1_tx */
  IO_BANK0_GPIO24_CTRL_FUNCSEL_i2c0_sda = 3,    /*!< i2c0_sda : i2c0_sda */
  IO_BANK0_GPIO24_CTRL_FUNCSEL_pwm_a_4 = 4,     /*!< pwm_a_4 : pwm_a_4 */
  IO_BANK0_GPIO24_CTRL_FUNCSEL_sio_24  = 5,     /*!< sio_24 : sio_24 */
  IO_BANK0_GPIO24_CTRL_FUNCSEL_pio0_24 = 6,     /*!< pio0_24 : pio0_24 */
  IO_BANK0_GPIO24_CTRL_FUNCSEL_pio1_24 = 7,     /*!< pio1_24 : pio1_24 */
  IO_BANK0_GPIO24_CTRL_FUNCSEL_clocks_gpout_2 = 8,/*!< clocks_gpout_2 : clocks_gpout_2 */
  IO_BANK0_GPIO24_CTRL_FUNCSEL_usb_muxing_overcurr_detect = 9,/*!< usb_muxing_overcurr_detect : usb_muxing_overcurr_detect */
  IO_BANK0_GPIO24_CTRL_FUNCSEL_null    = 31,    /*!< null : null */
} IO_BANK0_GPIO24_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO25_STATUS  ===================================================== */
/* ======================================================  GPIO25_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO25_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO25_CTRL_IRQOVER */
  IO_BANK0_GPIO25_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt */
  IO_BANK0_GPIO25_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt */
  IO_BANK0_GPIO25_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low */
  IO_BANK0_GPIO25_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high */
} IO_BANK0_GPIO25_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO25_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO25_CTRL_INOVER */
  IO_BANK0_GPIO25_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input */
  IO_BANK0_GPIO25_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input */
  IO_BANK0_GPIO25_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low */
  IO_BANK0_GPIO25_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high */
} IO_BANK0_GPIO25_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO25_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO25_CTRL_OEOVER */
  IO_BANK0_GPIO25_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_BANK0_GPIO25_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO25_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output */
  IO_BANK0_GPIO25_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output */
} IO_BANK0_GPIO25_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO25_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO25_CTRL_OUTOVER */
  IO_BANK0_GPIO25_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_BANK0_GPIO25_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO25_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low */
  IO_BANK0_GPIO25_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high */
} IO_BANK0_GPIO25_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO25_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO25_CTRL_FUNCSEL */
  IO_BANK0_GPIO25_CTRL_FUNCSEL_spi1_ss_n = 1,   /*!< spi1_ss_n : spi1_ss_n */
  IO_BANK0_GPIO25_CTRL_FUNCSEL_uart1_rx = 2,    /*!< uart1_rx : uart1_rx */
  IO_BANK0_GPIO25_CTRL_FUNCSEL_i2c0_scl = 3,    /*!< i2c0_scl : i2c0_scl */
  IO_BANK0_GPIO25_CTRL_FUNCSEL_pwm_b_4 = 4,     /*!< pwm_b_4 : pwm_b_4 */
  IO_BANK0_GPIO25_CTRL_FUNCSEL_sio_25  = 5,     /*!< sio_25 : sio_25 */
  IO_BANK0_GPIO25_CTRL_FUNCSEL_pio0_25 = 6,     /*!< pio0_25 : pio0_25 */
  IO_BANK0_GPIO25_CTRL_FUNCSEL_pio1_25 = 7,     /*!< pio1_25 : pio1_25 */
  IO_BANK0_GPIO25_CTRL_FUNCSEL_clocks_gpout_3 = 8,/*!< clocks_gpout_3 : clocks_gpout_3 */
  IO_BANK0_GPIO25_CTRL_FUNCSEL_usb_muxing_vbus_detect = 9,/*!< usb_muxing_vbus_detect : usb_muxing_vbus_detect */
  IO_BANK0_GPIO25_CTRL_FUNCSEL_null    = 31,    /*!< null : null */
} IO_BANK0_GPIO25_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO26_STATUS  ===================================================== */
/* ======================================================  GPIO26_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO26_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO26_CTRL_IRQOVER */
  IO_BANK0_GPIO26_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt */
  IO_BANK0_GPIO26_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt */
  IO_BANK0_GPIO26_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low */
  IO_BANK0_GPIO26_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high */
} IO_BANK0_GPIO26_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO26_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO26_CTRL_INOVER */
  IO_BANK0_GPIO26_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input */
  IO_BANK0_GPIO26_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input */
  IO_BANK0_GPIO26_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low */
  IO_BANK0_GPIO26_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high */
} IO_BANK0_GPIO26_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO26_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO26_CTRL_OEOVER */
  IO_BANK0_GPIO26_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_BANK0_GPIO26_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO26_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output */
  IO_BANK0_GPIO26_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output */
} IO_BANK0_GPIO26_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO26_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO26_CTRL_OUTOVER */
  IO_BANK0_GPIO26_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_BANK0_GPIO26_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO26_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low */
  IO_BANK0_GPIO26_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high */
} IO_BANK0_GPIO26_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO26_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO26_CTRL_FUNCSEL */
  IO_BANK0_GPIO26_CTRL_FUNCSEL_spi1_sclk = 1,   /*!< spi1_sclk : spi1_sclk */
  IO_BANK0_GPIO26_CTRL_FUNCSEL_uart1_cts = 2,   /*!< uart1_cts : uart1_cts */
  IO_BANK0_GPIO26_CTRL_FUNCSEL_i2c1_sda = 3,    /*!< i2c1_sda : i2c1_sda */
  IO_BANK0_GPIO26_CTRL_FUNCSEL_pwm_a_5 = 4,     /*!< pwm_a_5 : pwm_a_5 */
  IO_BANK0_GPIO26_CTRL_FUNCSEL_sio_26  = 5,     /*!< sio_26 : sio_26 */
  IO_BANK0_GPIO26_CTRL_FUNCSEL_pio0_26 = 6,     /*!< pio0_26 : pio0_26 */
  IO_BANK0_GPIO26_CTRL_FUNCSEL_pio1_26 = 7,     /*!< pio1_26 : pio1_26 */
  IO_BANK0_GPIO26_CTRL_FUNCSEL_usb_muxing_vbus_en = 9,/*!< usb_muxing_vbus_en : usb_muxing_vbus_en */
  IO_BANK0_GPIO26_CTRL_FUNCSEL_null    = 31,    /*!< null : null */
} IO_BANK0_GPIO26_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO27_STATUS  ===================================================== */
/* ======================================================  GPIO27_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO27_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO27_CTRL_IRQOVER */
  IO_BANK0_GPIO27_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt */
  IO_BANK0_GPIO27_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt */
  IO_BANK0_GPIO27_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low */
  IO_BANK0_GPIO27_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high */
} IO_BANK0_GPIO27_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO27_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO27_CTRL_INOVER */
  IO_BANK0_GPIO27_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input */
  IO_BANK0_GPIO27_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input */
  IO_BANK0_GPIO27_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low */
  IO_BANK0_GPIO27_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high */
} IO_BANK0_GPIO27_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO27_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO27_CTRL_OEOVER */
  IO_BANK0_GPIO27_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_BANK0_GPIO27_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO27_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output */
  IO_BANK0_GPIO27_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output */
} IO_BANK0_GPIO27_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO27_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO27_CTRL_OUTOVER */
  IO_BANK0_GPIO27_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_BANK0_GPIO27_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO27_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low */
  IO_BANK0_GPIO27_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high */
} IO_BANK0_GPIO27_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO27_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO27_CTRL_FUNCSEL */
  IO_BANK0_GPIO27_CTRL_FUNCSEL_spi1_tx = 1,     /*!< spi1_tx : spi1_tx */
  IO_BANK0_GPIO27_CTRL_FUNCSEL_uart1_rts = 2,   /*!< uart1_rts : uart1_rts */
  IO_BANK0_GPIO27_CTRL_FUNCSEL_i2c1_scl = 3,    /*!< i2c1_scl : i2c1_scl */
  IO_BANK0_GPIO27_CTRL_FUNCSEL_pwm_b_5 = 4,     /*!< pwm_b_5 : pwm_b_5 */
  IO_BANK0_GPIO27_CTRL_FUNCSEL_sio_27  = 5,     /*!< sio_27 : sio_27 */
  IO_BANK0_GPIO27_CTRL_FUNCSEL_pio0_27 = 6,     /*!< pio0_27 : pio0_27 */
  IO_BANK0_GPIO27_CTRL_FUNCSEL_pio1_27 = 7,     /*!< pio1_27 : pio1_27 */
  IO_BANK0_GPIO27_CTRL_FUNCSEL_usb_muxing_overcurr_detect = 9,/*!< usb_muxing_overcurr_detect : usb_muxing_overcurr_detect */
  IO_BANK0_GPIO27_CTRL_FUNCSEL_null    = 31,    /*!< null : null */
} IO_BANK0_GPIO27_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO28_STATUS  ===================================================== */
/* ======================================================  GPIO28_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO28_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO28_CTRL_IRQOVER */
  IO_BANK0_GPIO28_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt */
  IO_BANK0_GPIO28_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt */
  IO_BANK0_GPIO28_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low */
  IO_BANK0_GPIO28_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high */
} IO_BANK0_GPIO28_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO28_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO28_CTRL_INOVER */
  IO_BANK0_GPIO28_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input */
  IO_BANK0_GPIO28_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input */
  IO_BANK0_GPIO28_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low */
  IO_BANK0_GPIO28_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high */
} IO_BANK0_GPIO28_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO28_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO28_CTRL_OEOVER */
  IO_BANK0_GPIO28_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_BANK0_GPIO28_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO28_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output */
  IO_BANK0_GPIO28_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output */
} IO_BANK0_GPIO28_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO28_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO28_CTRL_OUTOVER */
  IO_BANK0_GPIO28_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_BANK0_GPIO28_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO28_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low */
  IO_BANK0_GPIO28_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high */
} IO_BANK0_GPIO28_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO28_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO28_CTRL_FUNCSEL */
  IO_BANK0_GPIO28_CTRL_FUNCSEL_spi1_rx = 1,     /*!< spi1_rx : spi1_rx */
  IO_BANK0_GPIO28_CTRL_FUNCSEL_uart0_tx = 2,    /*!< uart0_tx : uart0_tx */
  IO_BANK0_GPIO28_CTRL_FUNCSEL_i2c0_sda = 3,    /*!< i2c0_sda : i2c0_sda */
  IO_BANK0_GPIO28_CTRL_FUNCSEL_pwm_a_6 = 4,     /*!< pwm_a_6 : pwm_a_6 */
  IO_BANK0_GPIO28_CTRL_FUNCSEL_sio_28  = 5,     /*!< sio_28 : sio_28 */
  IO_BANK0_GPIO28_CTRL_FUNCSEL_pio0_28 = 6,     /*!< pio0_28 : pio0_28 */
  IO_BANK0_GPIO28_CTRL_FUNCSEL_pio1_28 = 7,     /*!< pio1_28 : pio1_28 */
  IO_BANK0_GPIO28_CTRL_FUNCSEL_usb_muxing_vbus_detect = 9,/*!< usb_muxing_vbus_detect : usb_muxing_vbus_detect */
  IO_BANK0_GPIO28_CTRL_FUNCSEL_null    = 31,    /*!< null : null */
} IO_BANK0_GPIO28_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO29_STATUS  ===================================================== */
/* ======================================================  GPIO29_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO29_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO29_CTRL_IRQOVER */
  IO_BANK0_GPIO29_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt */
  IO_BANK0_GPIO29_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt */
  IO_BANK0_GPIO29_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low */
  IO_BANK0_GPIO29_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high */
} IO_BANK0_GPIO29_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO29_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO29_CTRL_INOVER */
  IO_BANK0_GPIO29_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input */
  IO_BANK0_GPIO29_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input */
  IO_BANK0_GPIO29_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low */
  IO_BANK0_GPIO29_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high */
} IO_BANK0_GPIO29_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO29_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO29_CTRL_OEOVER */
  IO_BANK0_GPIO29_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_BANK0_GPIO29_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO29_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output */
  IO_BANK0_GPIO29_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output */
} IO_BANK0_GPIO29_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO29_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO29_CTRL_OUTOVER */
  IO_BANK0_GPIO29_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_BANK0_GPIO29_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_BANK0_GPIO29_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low */
  IO_BANK0_GPIO29_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high */
} IO_BANK0_GPIO29_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO29_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO29_CTRL_FUNCSEL */
  IO_BANK0_GPIO29_CTRL_FUNCSEL_spi1_ss_n = 1,   /*!< spi1_ss_n : spi1_ss_n */
  IO_BANK0_GPIO29_CTRL_FUNCSEL_uart0_rx = 2,    /*!< uart0_rx : uart0_rx */
  IO_BANK0_GPIO29_CTRL_FUNCSEL_i2c0_scl = 3,    /*!< i2c0_scl : i2c0_scl */
  IO_BANK0_GPIO29_CTRL_FUNCSEL_pwm_b_6 = 4,     /*!< pwm_b_6 : pwm_b_6 */
  IO_BANK0_GPIO29_CTRL_FUNCSEL_sio_29  = 5,     /*!< sio_29 : sio_29 */
  IO_BANK0_GPIO29_CTRL_FUNCSEL_pio0_29 = 6,     /*!< pio0_29 : pio0_29 */
  IO_BANK0_GPIO29_CTRL_FUNCSEL_pio1_29 = 7,     /*!< pio1_29 : pio1_29 */
  IO_BANK0_GPIO29_CTRL_FUNCSEL_usb_muxing_vbus_en = 9,/*!< usb_muxing_vbus_en : usb_muxing_vbus_en */
  IO_BANK0_GPIO29_CTRL_FUNCSEL_null    = 31,    /*!< null : null */
} IO_BANK0_GPIO29_CTRL_FUNCSEL_Enum;

/* =========================================================  INTR0  ========================================================= */
/* =========================================================  INTR1  ========================================================= */
/* =========================================================  INTR2  ========================================================= */
/* =========================================================  INTR3  ========================================================= */
/* ======================================================  PROC0_INTE0  ====================================================== */
/* ======================================================  PROC0_INTE1  ====================================================== */
/* ======================================================  PROC0_INTE2  ====================================================== */
/* ======================================================  PROC0_INTE3  ====================================================== */
/* ======================================================  PROC0_INTF0  ====================================================== */
/* ======================================================  PROC0_INTF1  ====================================================== */
/* ======================================================  PROC0_INTF2  ====================================================== */
/* ======================================================  PROC0_INTF3  ====================================================== */
/* ======================================================  PROC0_INTS0  ====================================================== */
/* ======================================================  PROC0_INTS1  ====================================================== */
/* ======================================================  PROC0_INTS2  ====================================================== */
/* ======================================================  PROC0_INTS3  ====================================================== */
/* ======================================================  PROC1_INTE0  ====================================================== */
/* ======================================================  PROC1_INTE1  ====================================================== */
/* ======================================================  PROC1_INTE2  ====================================================== */
/* ======================================================  PROC1_INTE3  ====================================================== */
/* ======================================================  PROC1_INTF0  ====================================================== */
/* ======================================================  PROC1_INTF1  ====================================================== */
/* ======================================================  PROC1_INTF2  ====================================================== */
/* ======================================================  PROC1_INTF3  ====================================================== */
/* ======================================================  PROC1_INTS0  ====================================================== */
/* ======================================================  PROC1_INTS1  ====================================================== */
/* ======================================================  PROC1_INTS2  ====================================================== */
/* ======================================================  PROC1_INTS3  ====================================================== */
/* ==================================================  DORMANT_WAKE_INTE0  =================================================== */
/* ==================================================  DORMANT_WAKE_INTE1  =================================================== */
/* ==================================================  DORMANT_WAKE_INTE2  =================================================== */
/* ==================================================  DORMANT_WAKE_INTE3  =================================================== */
/* ==================================================  DORMANT_WAKE_INTF0  =================================================== */
/* ==================================================  DORMANT_WAKE_INTF1  =================================================== */
/* ==================================================  DORMANT_WAKE_INTF2  =================================================== */
/* ==================================================  DORMANT_WAKE_INTF3  =================================================== */
/* ==================================================  DORMANT_WAKE_INTS0  =================================================== */
/* ==================================================  DORMANT_WAKE_INTS1  =================================================== */
/* ==================================================  DORMANT_WAKE_INTS2  =================================================== */
/* ==================================================  DORMANT_WAKE_INTS3  =================================================== */


/* =========================================================================================================================== */
/* ================                                          IO_QSPI                                          ================ */
/* =========================================================================================================================== */

/* =================================================  GPIO_QSPI_SCLK_STATUS  ================================================= */
/* ==================================================  GPIO_QSPI_SCLK_CTRL  ================================================== */
/* =====================================  IO_QSPI GPIO_QSPI_SCLK_CTRL IRQOVER [28..29]  ====================================== */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SCLK_CTRL_IRQOVER */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_IRQOVER_NORMAL = 0,/*!< NORMAL : don't invert the interrupt */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_IRQOVER_INVERT = 1,/*!< INVERT : invert the interrupt */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_IRQOVER_LOW = 2,  /*!< LOW : drive interrupt low */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_IRQOVER_HIGH = 3, /*!< HIGH : drive interrupt high */
} IO_QSPI_GPIO_QSPI_SCLK_CTRL_IRQOVER_Enum;

/* ======================================  IO_QSPI GPIO_QSPI_SCLK_CTRL INOVER [16..17]  ====================================== */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SCLK_CTRL_INOVER */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_INOVER_NORMAL = 0,/*!< NORMAL : don't invert the peri input */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_INOVER_INVERT = 1,/*!< INVERT : invert the peri input */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_INOVER_LOW = 2,   /*!< LOW : drive peri input low */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_INOVER_HIGH = 3,  /*!< HIGH : drive peri input high */
} IO_QSPI_GPIO_QSPI_SCLK_CTRL_INOVER_Enum;

/* ======================================  IO_QSPI GPIO_QSPI_SCLK_CTRL OEOVER [12..13]  ====================================== */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SCLK_CTRL_OEOVER */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_OEOVER_NORMAL = 0,/*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_OEOVER_INVERT = 1,/*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_OEOVER_DISABLE = 2,/*!< DISABLE : disable output */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_OEOVER_ENABLE = 3,/*!< ENABLE : enable output */
} IO_QSPI_GPIO_QSPI_SCLK_CTRL_OEOVER_Enum;

/* ======================================  IO_QSPI GPIO_QSPI_SCLK_CTRL OUTOVER [8..9]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SCLK_CTRL_OUTOVER */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_OUTOVER_NORMAL = 0,/*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_OUTOVER_INVERT = 1,/*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_OUTOVER_LOW = 2,  /*!< LOW : drive output low */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_OUTOVER_HIGH = 3, /*!< HIGH : drive output high */
} IO_QSPI_GPIO_QSPI_SCLK_CTRL_OUTOVER_Enum;

/* ======================================  IO_QSPI GPIO_QSPI_SCLK_CTRL FUNCSEL [0..4]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SCLK_CTRL_FUNCSEL */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_FUNCSEL_xip_sclk = 0,/*!< xip_sclk : xip_sclk */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_FUNCSEL_sio_30 = 5,/*!< sio_30 : sio_30 */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_FUNCSEL_null = 31,/*!< null : null */
} IO_QSPI_GPIO_QSPI_SCLK_CTRL_FUNCSEL_Enum;

/* ==================================================  GPIO_QSPI_SS_STATUS  ================================================== */
/* ===================================================  GPIO_QSPI_SS_CTRL  =================================================== */
/* ======================================  IO_QSPI GPIO_QSPI_SS_CTRL IRQOVER [28..29]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SS_CTRL_IRQOVER */
  IO_QSPI_GPIO_QSPI_SS_CTRL_IRQOVER_NORMAL = 0, /*!< NORMAL : don't invert the interrupt */
  IO_QSPI_GPIO_QSPI_SS_CTRL_IRQOVER_INVERT = 1, /*!< INVERT : invert the interrupt */
  IO_QSPI_GPIO_QSPI_SS_CTRL_IRQOVER_LOW = 2,    /*!< LOW : drive interrupt low */
  IO_QSPI_GPIO_QSPI_SS_CTRL_IRQOVER_HIGH = 3,   /*!< HIGH : drive interrupt high */
} IO_QSPI_GPIO_QSPI_SS_CTRL_IRQOVER_Enum;

/* =======================================  IO_QSPI GPIO_QSPI_SS_CTRL INOVER [16..17]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SS_CTRL_INOVER */
  IO_QSPI_GPIO_QSPI_SS_CTRL_INOVER_NORMAL = 0,  /*!< NORMAL : don't invert the peri input */
  IO_QSPI_GPIO_QSPI_SS_CTRL_INOVER_INVERT = 1,  /*!< INVERT : invert the peri input */
  IO_QSPI_GPIO_QSPI_SS_CTRL_INOVER_LOW = 2,     /*!< LOW : drive peri input low */
  IO_QSPI_GPIO_QSPI_SS_CTRL_INOVER_HIGH = 3,    /*!< HIGH : drive peri input high */
} IO_QSPI_GPIO_QSPI_SS_CTRL_INOVER_Enum;

/* =======================================  IO_QSPI GPIO_QSPI_SS_CTRL OEOVER [12..13]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SS_CTRL_OEOVER */
  IO_QSPI_GPIO_QSPI_SS_CTRL_OEOVER_NORMAL = 0,  /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_QSPI_GPIO_QSPI_SS_CTRL_OEOVER_INVERT = 1,  /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_QSPI_GPIO_QSPI_SS_CTRL_OEOVER_DISABLE = 2, /*!< DISABLE : disable output */
  IO_QSPI_GPIO_QSPI_SS_CTRL_OEOVER_ENABLE = 3,  /*!< ENABLE : enable output */
} IO_QSPI_GPIO_QSPI_SS_CTRL_OEOVER_Enum;

/* =======================================  IO_QSPI GPIO_QSPI_SS_CTRL OUTOVER [8..9]  ======================================== */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SS_CTRL_OUTOVER */
  IO_QSPI_GPIO_QSPI_SS_CTRL_OUTOVER_NORMAL = 0, /*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_QSPI_GPIO_QSPI_SS_CTRL_OUTOVER_INVERT = 1, /*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_QSPI_GPIO_QSPI_SS_CTRL_OUTOVER_LOW = 2,    /*!< LOW : drive output low */
  IO_QSPI_GPIO_QSPI_SS_CTRL_OUTOVER_HIGH = 3,   /*!< HIGH : drive output high */
} IO_QSPI_GPIO_QSPI_SS_CTRL_OUTOVER_Enum;

/* =======================================  IO_QSPI GPIO_QSPI_SS_CTRL FUNCSEL [0..4]  ======================================== */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SS_CTRL_FUNCSEL */
  IO_QSPI_GPIO_QSPI_SS_CTRL_FUNCSEL_xip_ss_n = 0,/*!< xip_ss_n : xip_ss_n */
  IO_QSPI_GPIO_QSPI_SS_CTRL_FUNCSEL_sio_31 = 5, /*!< sio_31 : sio_31 */
  IO_QSPI_GPIO_QSPI_SS_CTRL_FUNCSEL_null = 31,  /*!< null : null */
} IO_QSPI_GPIO_QSPI_SS_CTRL_FUNCSEL_Enum;

/* =================================================  GPIO_QSPI_SD0_STATUS  ================================================== */
/* ==================================================  GPIO_QSPI_SD0_CTRL  =================================================== */
/* ======================================  IO_QSPI GPIO_QSPI_SD0_CTRL IRQOVER [28..29]  ====================================== */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD0_CTRL_IRQOVER */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_IRQOVER_NORMAL = 0,/*!< NORMAL : don't invert the interrupt */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_IRQOVER_INVERT = 1,/*!< INVERT : invert the interrupt */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_IRQOVER_LOW = 2,   /*!< LOW : drive interrupt low */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_IRQOVER_HIGH = 3,  /*!< HIGH : drive interrupt high */
} IO_QSPI_GPIO_QSPI_SD0_CTRL_IRQOVER_Enum;

/* ======================================  IO_QSPI GPIO_QSPI_SD0_CTRL INOVER [16..17]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD0_CTRL_INOVER */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_INOVER_NORMAL = 0, /*!< NORMAL : don't invert the peri input */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_INOVER_INVERT = 1, /*!< INVERT : invert the peri input */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_INOVER_LOW = 2,    /*!< LOW : drive peri input low */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_INOVER_HIGH = 3,   /*!< HIGH : drive peri input high */
} IO_QSPI_GPIO_QSPI_SD0_CTRL_INOVER_Enum;

/* ======================================  IO_QSPI GPIO_QSPI_SD0_CTRL OEOVER [12..13]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD0_CTRL_OEOVER */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_OEOVER_NORMAL = 0, /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_OEOVER_INVERT = 1, /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_OEOVER_DISABLE = 2,/*!< DISABLE : disable output */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_OEOVER_ENABLE = 3, /*!< ENABLE : enable output */
} IO_QSPI_GPIO_QSPI_SD0_CTRL_OEOVER_Enum;

/* =======================================  IO_QSPI GPIO_QSPI_SD0_CTRL OUTOVER [8..9]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD0_CTRL_OUTOVER */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_OUTOVER_NORMAL = 0,/*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_OUTOVER_INVERT = 1,/*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_OUTOVER_LOW = 2,   /*!< LOW : drive output low */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_OUTOVER_HIGH = 3,  /*!< HIGH : drive output high */
} IO_QSPI_GPIO_QSPI_SD0_CTRL_OUTOVER_Enum;

/* =======================================  IO_QSPI GPIO_QSPI_SD0_CTRL FUNCSEL [0..4]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD0_CTRL_FUNCSEL */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_FUNCSEL_xip_sd0 = 0,/*!< xip_sd0 : xip_sd0 */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_FUNCSEL_sio_32 = 5,/*!< sio_32 : sio_32 */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_FUNCSEL_null = 31, /*!< null : null */
} IO_QSPI_GPIO_QSPI_SD0_CTRL_FUNCSEL_Enum;

/* =================================================  GPIO_QSPI_SD1_STATUS  ================================================== */
/* ==================================================  GPIO_QSPI_SD1_CTRL  =================================================== */
/* ======================================  IO_QSPI GPIO_QSPI_SD1_CTRL IRQOVER [28..29]  ====================================== */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD1_CTRL_IRQOVER */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_IRQOVER_NORMAL = 0,/*!< NORMAL : don't invert the interrupt */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_IRQOVER_INVERT = 1,/*!< INVERT : invert the interrupt */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_IRQOVER_LOW = 2,   /*!< LOW : drive interrupt low */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_IRQOVER_HIGH = 3,  /*!< HIGH : drive interrupt high */
} IO_QSPI_GPIO_QSPI_SD1_CTRL_IRQOVER_Enum;

/* ======================================  IO_QSPI GPIO_QSPI_SD1_CTRL INOVER [16..17]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD1_CTRL_INOVER */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_INOVER_NORMAL = 0, /*!< NORMAL : don't invert the peri input */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_INOVER_INVERT = 1, /*!< INVERT : invert the peri input */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_INOVER_LOW = 2,    /*!< LOW : drive peri input low */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_INOVER_HIGH = 3,   /*!< HIGH : drive peri input high */
} IO_QSPI_GPIO_QSPI_SD1_CTRL_INOVER_Enum;

/* ======================================  IO_QSPI GPIO_QSPI_SD1_CTRL OEOVER [12..13]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD1_CTRL_OEOVER */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_OEOVER_NORMAL = 0, /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_OEOVER_INVERT = 1, /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_OEOVER_DISABLE = 2,/*!< DISABLE : disable output */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_OEOVER_ENABLE = 3, /*!< ENABLE : enable output */
} IO_QSPI_GPIO_QSPI_SD1_CTRL_OEOVER_Enum;

/* =======================================  IO_QSPI GPIO_QSPI_SD1_CTRL OUTOVER [8..9]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD1_CTRL_OUTOVER */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_OUTOVER_NORMAL = 0,/*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_OUTOVER_INVERT = 1,/*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_OUTOVER_LOW = 2,   /*!< LOW : drive output low */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_OUTOVER_HIGH = 3,  /*!< HIGH : drive output high */
} IO_QSPI_GPIO_QSPI_SD1_CTRL_OUTOVER_Enum;

/* =======================================  IO_QSPI GPIO_QSPI_SD1_CTRL FUNCSEL [0..4]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD1_CTRL_FUNCSEL */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_FUNCSEL_xip_sd1 = 0,/*!< xip_sd1 : xip_sd1 */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_FUNCSEL_sio_33 = 5,/*!< sio_33 : sio_33 */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_FUNCSEL_null = 31, /*!< null : null */
} IO_QSPI_GPIO_QSPI_SD1_CTRL_FUNCSEL_Enum;

/* =================================================  GPIO_QSPI_SD2_STATUS  ================================================== */
/* ==================================================  GPIO_QSPI_SD2_CTRL  =================================================== */
/* ======================================  IO_QSPI GPIO_QSPI_SD2_CTRL IRQOVER [28..29]  ====================================== */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD2_CTRL_IRQOVER */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_IRQOVER_NORMAL = 0,/*!< NORMAL : don't invert the interrupt */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_IRQOVER_INVERT = 1,/*!< INVERT : invert the interrupt */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_IRQOVER_LOW = 2,   /*!< LOW : drive interrupt low */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_IRQOVER_HIGH = 3,  /*!< HIGH : drive interrupt high */
} IO_QSPI_GPIO_QSPI_SD2_CTRL_IRQOVER_Enum;

/* ======================================  IO_QSPI GPIO_QSPI_SD2_CTRL INOVER [16..17]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD2_CTRL_INOVER */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_INOVER_NORMAL = 0, /*!< NORMAL : don't invert the peri input */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_INOVER_INVERT = 1, /*!< INVERT : invert the peri input */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_INOVER_LOW = 2,    /*!< LOW : drive peri input low */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_INOVER_HIGH = 3,   /*!< HIGH : drive peri input high */
} IO_QSPI_GPIO_QSPI_SD2_CTRL_INOVER_Enum;

/* ======================================  IO_QSPI GPIO_QSPI_SD2_CTRL OEOVER [12..13]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD2_CTRL_OEOVER */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_OEOVER_NORMAL = 0, /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_OEOVER_INVERT = 1, /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_OEOVER_DISABLE = 2,/*!< DISABLE : disable output */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_OEOVER_ENABLE = 3, /*!< ENABLE : enable output */
} IO_QSPI_GPIO_QSPI_SD2_CTRL_OEOVER_Enum;

/* =======================================  IO_QSPI GPIO_QSPI_SD2_CTRL OUTOVER [8..9]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD2_CTRL_OUTOVER */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_OUTOVER_NORMAL = 0,/*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_OUTOVER_INVERT = 1,/*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_OUTOVER_LOW = 2,   /*!< LOW : drive output low */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_OUTOVER_HIGH = 3,  /*!< HIGH : drive output high */
} IO_QSPI_GPIO_QSPI_SD2_CTRL_OUTOVER_Enum;

/* =======================================  IO_QSPI GPIO_QSPI_SD2_CTRL FUNCSEL [0..4]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD2_CTRL_FUNCSEL */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_FUNCSEL_xip_sd2 = 0,/*!< xip_sd2 : xip_sd2 */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_FUNCSEL_sio_34 = 5,/*!< sio_34 : sio_34 */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_FUNCSEL_null = 31, /*!< null : null */
} IO_QSPI_GPIO_QSPI_SD2_CTRL_FUNCSEL_Enum;

/* =================================================  GPIO_QSPI_SD3_STATUS  ================================================== */
/* ==================================================  GPIO_QSPI_SD3_CTRL  =================================================== */
/* ======================================  IO_QSPI GPIO_QSPI_SD3_CTRL IRQOVER [28..29]  ====================================== */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD3_CTRL_IRQOVER */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_IRQOVER_NORMAL = 0,/*!< NORMAL : don't invert the interrupt */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_IRQOVER_INVERT = 1,/*!< INVERT : invert the interrupt */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_IRQOVER_LOW = 2,   /*!< LOW : drive interrupt low */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_IRQOVER_HIGH = 3,  /*!< HIGH : drive interrupt high */
} IO_QSPI_GPIO_QSPI_SD3_CTRL_IRQOVER_Enum;

/* ======================================  IO_QSPI GPIO_QSPI_SD3_CTRL INOVER [16..17]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD3_CTRL_INOVER */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_INOVER_NORMAL = 0, /*!< NORMAL : don't invert the peri input */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_INOVER_INVERT = 1, /*!< INVERT : invert the peri input */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_INOVER_LOW = 2,    /*!< LOW : drive peri input low */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_INOVER_HIGH = 3,   /*!< HIGH : drive peri input high */
} IO_QSPI_GPIO_QSPI_SD3_CTRL_INOVER_Enum;

/* ======================================  IO_QSPI GPIO_QSPI_SD3_CTRL OEOVER [12..13]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD3_CTRL_OEOVER */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_OEOVER_NORMAL = 0, /*!< NORMAL : drive output enable from peripheral signal selected by funcsel */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_OEOVER_INVERT = 1, /*!< INVERT : drive output enable from inverse of peripheral signal selected by funcsel */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_OEOVER_DISABLE = 2,/*!< DISABLE : disable output */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_OEOVER_ENABLE = 3, /*!< ENABLE : enable output */
} IO_QSPI_GPIO_QSPI_SD3_CTRL_OEOVER_Enum;

/* =======================================  IO_QSPI GPIO_QSPI_SD3_CTRL OUTOVER [8..9]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD3_CTRL_OUTOVER */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_OUTOVER_NORMAL = 0,/*!< NORMAL : drive output from peripheral signal selected by funcsel */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_OUTOVER_INVERT = 1,/*!< INVERT : drive output from inverse of peripheral signal selected by funcsel */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_OUTOVER_LOW = 2,   /*!< LOW : drive output low */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_OUTOVER_HIGH = 3,  /*!< HIGH : drive output high */
} IO_QSPI_GPIO_QSPI_SD3_CTRL_OUTOVER_Enum;

/* =======================================  IO_QSPI GPIO_QSPI_SD3_CTRL FUNCSEL [0..4]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD3_CTRL_FUNCSEL */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_FUNCSEL_xip_sd3 = 0,/*!< xip_sd3 : xip_sd3 */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_FUNCSEL_sio_35 = 5,/*!< sio_35 : sio_35 */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_FUNCSEL_null = 31, /*!< null : null */
} IO_QSPI_GPIO_QSPI_SD3_CTRL_FUNCSEL_Enum;

/* =========================================================  INTR  ========================================================== */
/* ======================================================  PROC0_INTE  ======================================================= */
/* ======================================================  PROC0_INTF  ======================================================= */
/* ======================================================  PROC0_INTS  ======================================================= */
/* ======================================================  PROC1_INTE  ======================================================= */
/* ======================================================  PROC1_INTF  ======================================================= */
/* ======================================================  PROC1_INTS  ======================================================= */
/* ===================================================  DORMANT_WAKE_INTE  =================================================== */
/* ===================================================  DORMANT_WAKE_INTF  =================================================== */
/* ===================================================  DORMANT_WAKE_INTS  =================================================== */


/* =========================================================================================================================== */
/* ================                                        PADS_BANK0                                         ================ */
/* =========================================================================================================================== */

/* ====================================================  VOLTAGE_SELECT  ===================================================== */
/* ====================================  PADS_BANK0 VOLTAGE_SELECT VOLTAGE_SELECT [0..0]  ==================================== */
typedef enum {                                  /*!< PADS_BANK0_VOLTAGE_SELECT_VOLTAGE_SELECT */
  PADS_BANK0_VOLTAGE_SELECT_VOLTAGE_SELECT_3v3 = 0,/*!< 3v3 : Set voltage to 3.3V (DVDD >= 2V5) */
  PADS_BANK0_VOLTAGE_SELECT_VOLTAGE_SELECT_1v8 = 1,/*!< 1v8 : Set voltage to 1.8V (DVDD <= 1V8) */
} PADS_BANK0_VOLTAGE_SELECT_VOLTAGE_SELECT_Enum;

/* =========================================================  GPIO0  ========================================================= */
/* =============================================  PADS_BANK0 GPIO0 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO0_DRIVE */
  PADS_BANK0_GPIO0_DRIVE_2mA           = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_GPIO0_DRIVE_4mA           = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_GPIO0_DRIVE_8mA           = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_GPIO0_DRIVE_12mA          = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_GPIO0_DRIVE_Enum;

/* =========================================================  GPIO1  ========================================================= */
/* =============================================  PADS_BANK0 GPIO1 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO1_DRIVE */
  PADS_BANK0_GPIO1_DRIVE_2mA           = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_GPIO1_DRIVE_4mA           = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_GPIO1_DRIVE_8mA           = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_GPIO1_DRIVE_12mA          = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_GPIO1_DRIVE_Enum;

/* =========================================================  GPIO2  ========================================================= */
/* =============================================  PADS_BANK0 GPIO2 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO2_DRIVE */
  PADS_BANK0_GPIO2_DRIVE_2mA           = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_GPIO2_DRIVE_4mA           = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_GPIO2_DRIVE_8mA           = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_GPIO2_DRIVE_12mA          = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_GPIO2_DRIVE_Enum;

/* =========================================================  GPIO3  ========================================================= */
/* =============================================  PADS_BANK0 GPIO3 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO3_DRIVE */
  PADS_BANK0_GPIO3_DRIVE_2mA           = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_GPIO3_DRIVE_4mA           = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_GPIO3_DRIVE_8mA           = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_GPIO3_DRIVE_12mA          = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_GPIO3_DRIVE_Enum;

/* =========================================================  GPIO4  ========================================================= */
/* =============================================  PADS_BANK0 GPIO4 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO4_DRIVE */
  PADS_BANK0_GPIO4_DRIVE_2mA           = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_GPIO4_DRIVE_4mA           = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_GPIO4_DRIVE_8mA           = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_GPIO4_DRIVE_12mA          = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_GPIO4_DRIVE_Enum;

/* =========================================================  GPIO5  ========================================================= */
/* =============================================  PADS_BANK0 GPIO5 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO5_DRIVE */
  PADS_BANK0_GPIO5_DRIVE_2mA           = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_GPIO5_DRIVE_4mA           = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_GPIO5_DRIVE_8mA           = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_GPIO5_DRIVE_12mA          = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_GPIO5_DRIVE_Enum;

/* =========================================================  GPIO6  ========================================================= */
/* =============================================  PADS_BANK0 GPIO6 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO6_DRIVE */
  PADS_BANK0_GPIO6_DRIVE_2mA           = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_GPIO6_DRIVE_4mA           = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_GPIO6_DRIVE_8mA           = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_GPIO6_DRIVE_12mA          = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_GPIO6_DRIVE_Enum;

/* =========================================================  GPIO7  ========================================================= */
/* =============================================  PADS_BANK0 GPIO7 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO7_DRIVE */
  PADS_BANK0_GPIO7_DRIVE_2mA           = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_GPIO7_DRIVE_4mA           = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_GPIO7_DRIVE_8mA           = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_GPIO7_DRIVE_12mA          = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_GPIO7_DRIVE_Enum;

/* =========================================================  GPIO8  ========================================================= */
/* =============================================  PADS_BANK0 GPIO8 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO8_DRIVE */
  PADS_BANK0_GPIO8_DRIVE_2mA           = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_GPIO8_DRIVE_4mA           = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_GPIO8_DRIVE_8mA           = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_GPIO8_DRIVE_12mA          = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_GPIO8_DRIVE_Enum;

/* =========================================================  GPIO9  ========================================================= */
/* =============================================  PADS_BANK0 GPIO9 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO9_DRIVE */
  PADS_BANK0_GPIO9_DRIVE_2mA           = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_GPIO9_DRIVE_4mA           = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_GPIO9_DRIVE_8mA           = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_GPIO9_DRIVE_12mA          = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_GPIO9_DRIVE_Enum;

/* ========================================================  GPIO10  ========================================================= */
/* ============================================  PADS_BANK0 GPIO10 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO10_DRIVE */
  PADS_BANK0_GPIO10_DRIVE_2mA          = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_GPIO10_DRIVE_4mA          = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_GPIO10_DRIVE_8mA          = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_GPIO10_DRIVE_12mA         = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_GPIO10_DRIVE_Enum;

/* ========================================================  GPIO11  ========================================================= */
/* ============================================  PADS_BANK0 GPIO11 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO11_DRIVE */
  PADS_BANK0_GPIO11_DRIVE_2mA          = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_GPIO11_DRIVE_4mA          = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_GPIO11_DRIVE_8mA          = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_GPIO11_DRIVE_12mA         = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_GPIO11_DRIVE_Enum;

/* ========================================================  GPIO12  ========================================================= */
/* ============================================  PADS_BANK0 GPIO12 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO12_DRIVE */
  PADS_BANK0_GPIO12_DRIVE_2mA          = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_GPIO12_DRIVE_4mA          = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_GPIO12_DRIVE_8mA          = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_GPIO12_DRIVE_12mA         = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_GPIO12_DRIVE_Enum;

/* ========================================================  GPIO13  ========================================================= */
/* ============================================  PADS_BANK0 GPIO13 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO13_DRIVE */
  PADS_BANK0_GPIO13_DRIVE_2mA          = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_GPIO13_DRIVE_4mA          = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_GPIO13_DRIVE_8mA          = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_GPIO13_DRIVE_12mA         = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_GPIO13_DRIVE_Enum;

/* ========================================================  GPIO14  ========================================================= */
/* ============================================  PADS_BANK0 GPIO14 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO14_DRIVE */
  PADS_BANK0_GPIO14_DRIVE_2mA          = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_GPIO14_DRIVE_4mA          = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_GPIO14_DRIVE_8mA          = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_GPIO14_DRIVE_12mA         = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_GPIO14_DRIVE_Enum;

/* ========================================================  GPIO15  ========================================================= */
/* ============================================  PADS_BANK0 GPIO15 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO15_DRIVE */
  PADS_BANK0_GPIO15_DRIVE_2mA          = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_GPIO15_DRIVE_4mA          = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_GPIO15_DRIVE_8mA          = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_GPIO15_DRIVE_12mA         = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_GPIO15_DRIVE_Enum;

/* ========================================================  GPIO16  ========================================================= */
/* ============================================  PADS_BANK0 GPIO16 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO16_DRIVE */
  PADS_BANK0_GPIO16_DRIVE_2mA          = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_GPIO16_DRIVE_4mA          = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_GPIO16_DRIVE_8mA          = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_GPIO16_DRIVE_12mA         = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_GPIO16_DRIVE_Enum;

/* ========================================================  GPIO17  ========================================================= */
/* ============================================  PADS_BANK0 GPIO17 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO17_DRIVE */
  PADS_BANK0_GPIO17_DRIVE_2mA          = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_GPIO17_DRIVE_4mA          = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_GPIO17_DRIVE_8mA          = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_GPIO17_DRIVE_12mA         = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_GPIO17_DRIVE_Enum;

/* ========================================================  GPIO18  ========================================================= */
/* ============================================  PADS_BANK0 GPIO18 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO18_DRIVE */
  PADS_BANK0_GPIO18_DRIVE_2mA          = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_GPIO18_DRIVE_4mA          = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_GPIO18_DRIVE_8mA          = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_GPIO18_DRIVE_12mA         = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_GPIO18_DRIVE_Enum;

/* ========================================================  GPIO19  ========================================================= */
/* ============================================  PADS_BANK0 GPIO19 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO19_DRIVE */
  PADS_BANK0_GPIO19_DRIVE_2mA          = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_GPIO19_DRIVE_4mA          = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_GPIO19_DRIVE_8mA          = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_GPIO19_DRIVE_12mA         = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_GPIO19_DRIVE_Enum;

/* ========================================================  GPIO20  ========================================================= */
/* ============================================  PADS_BANK0 GPIO20 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO20_DRIVE */
  PADS_BANK0_GPIO20_DRIVE_2mA          = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_GPIO20_DRIVE_4mA          = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_GPIO20_DRIVE_8mA          = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_GPIO20_DRIVE_12mA         = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_GPIO20_DRIVE_Enum;

/* ========================================================  GPIO21  ========================================================= */
/* ============================================  PADS_BANK0 GPIO21 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO21_DRIVE */
  PADS_BANK0_GPIO21_DRIVE_2mA          = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_GPIO21_DRIVE_4mA          = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_GPIO21_DRIVE_8mA          = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_GPIO21_DRIVE_12mA         = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_GPIO21_DRIVE_Enum;

/* ========================================================  GPIO22  ========================================================= */
/* ============================================  PADS_BANK0 GPIO22 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO22_DRIVE */
  PADS_BANK0_GPIO22_DRIVE_2mA          = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_GPIO22_DRIVE_4mA          = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_GPIO22_DRIVE_8mA          = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_GPIO22_DRIVE_12mA         = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_GPIO22_DRIVE_Enum;

/* ========================================================  GPIO23  ========================================================= */
/* ============================================  PADS_BANK0 GPIO23 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO23_DRIVE */
  PADS_BANK0_GPIO23_DRIVE_2mA          = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_GPIO23_DRIVE_4mA          = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_GPIO23_DRIVE_8mA          = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_GPIO23_DRIVE_12mA         = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_GPIO23_DRIVE_Enum;

/* ========================================================  GPIO24  ========================================================= */
/* ============================================  PADS_BANK0 GPIO24 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO24_DRIVE */
  PADS_BANK0_GPIO24_DRIVE_2mA          = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_GPIO24_DRIVE_4mA          = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_GPIO24_DRIVE_8mA          = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_GPIO24_DRIVE_12mA         = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_GPIO24_DRIVE_Enum;

/* ========================================================  GPIO25  ========================================================= */
/* ============================================  PADS_BANK0 GPIO25 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO25_DRIVE */
  PADS_BANK0_GPIO25_DRIVE_2mA          = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_GPIO25_DRIVE_4mA          = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_GPIO25_DRIVE_8mA          = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_GPIO25_DRIVE_12mA         = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_GPIO25_DRIVE_Enum;

/* ========================================================  GPIO26  ========================================================= */
/* ============================================  PADS_BANK0 GPIO26 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO26_DRIVE */
  PADS_BANK0_GPIO26_DRIVE_2mA          = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_GPIO26_DRIVE_4mA          = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_GPIO26_DRIVE_8mA          = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_GPIO26_DRIVE_12mA         = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_GPIO26_DRIVE_Enum;

/* ========================================================  GPIO27  ========================================================= */
/* ============================================  PADS_BANK0 GPIO27 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO27_DRIVE */
  PADS_BANK0_GPIO27_DRIVE_2mA          = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_GPIO27_DRIVE_4mA          = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_GPIO27_DRIVE_8mA          = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_GPIO27_DRIVE_12mA         = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_GPIO27_DRIVE_Enum;

/* ========================================================  GPIO28  ========================================================= */
/* ============================================  PADS_BANK0 GPIO28 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO28_DRIVE */
  PADS_BANK0_GPIO28_DRIVE_2mA          = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_GPIO28_DRIVE_4mA          = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_GPIO28_DRIVE_8mA          = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_GPIO28_DRIVE_12mA         = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_GPIO28_DRIVE_Enum;

/* ========================================================  GPIO29  ========================================================= */
/* ============================================  PADS_BANK0 GPIO29 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO29_DRIVE */
  PADS_BANK0_GPIO29_DRIVE_2mA          = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_GPIO29_DRIVE_4mA          = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_GPIO29_DRIVE_8mA          = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_GPIO29_DRIVE_12mA         = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_GPIO29_DRIVE_Enum;

/* =========================================================  SWCLK  ========================================================= */
/* =============================================  PADS_BANK0 SWCLK DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_SWCLK_DRIVE */
  PADS_BANK0_SWCLK_DRIVE_2mA           = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_SWCLK_DRIVE_4mA           = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_SWCLK_DRIVE_8mA           = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_SWCLK_DRIVE_12mA          = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_SWCLK_DRIVE_Enum;

/* ==========================================================  SWD  ========================================================== */
/* ==============================================  PADS_BANK0 SWD DRIVE [4..5]  ============================================== */
typedef enum {                                  /*!< PADS_BANK0_SWD_DRIVE */
  PADS_BANK0_SWD_DRIVE_2mA             = 0,     /*!< 2mA : 2mA */
  PADS_BANK0_SWD_DRIVE_4mA             = 1,     /*!< 4mA : 4mA */
  PADS_BANK0_SWD_DRIVE_8mA             = 2,     /*!< 8mA : 8mA */
  PADS_BANK0_SWD_DRIVE_12mA            = 3,     /*!< 12mA : 12mA */
} PADS_BANK0_SWD_DRIVE_Enum;



/* =========================================================================================================================== */
/* ================                                         PADS_QSPI                                         ================ */
/* =========================================================================================================================== */

/* ====================================================  VOLTAGE_SELECT  ===================================================== */
/* ====================================  PADS_QSPI VOLTAGE_SELECT VOLTAGE_SELECT [0..0]  ===================================== */
typedef enum {                                  /*!< PADS_QSPI_VOLTAGE_SELECT_VOLTAGE_SELECT */
  PADS_QSPI_VOLTAGE_SELECT_VOLTAGE_SELECT_3v3 = 0,/*!< 3v3 : Set voltage to 3.3V (DVDD >= 2V5) */
  PADS_QSPI_VOLTAGE_SELECT_VOLTAGE_SELECT_1v8 = 1,/*!< 1v8 : Set voltage to 1.8V (DVDD <= 1V8) */
} PADS_QSPI_VOLTAGE_SELECT_VOLTAGE_SELECT_Enum;

/* ====================================================  GPIO_QSPI_SCLK  ===================================================== */
/* =========================================  PADS_QSPI GPIO_QSPI_SCLK DRIVE [4..5]  ========================================= */
typedef enum {                                  /*!< PADS_QSPI_GPIO_QSPI_SCLK_DRIVE */
  PADS_QSPI_GPIO_QSPI_SCLK_DRIVE_2mA   = 0,     /*!< 2mA : 2mA */
  PADS_QSPI_GPIO_QSPI_SCLK_DRIVE_4mA   = 1,     /*!< 4mA : 4mA */
  PADS_QSPI_GPIO_QSPI_SCLK_DRIVE_8mA   = 2,     /*!< 8mA : 8mA */
  PADS_QSPI_GPIO_QSPI_SCLK_DRIVE_12mA  = 3,     /*!< 12mA : 12mA */
} PADS_QSPI_GPIO_QSPI_SCLK_DRIVE_Enum;

/* =====================================================  GPIO_QSPI_SD0  ===================================================== */
/* =========================================  PADS_QSPI GPIO_QSPI_SD0 DRIVE [4..5]  ========================================== */
typedef enum {                                  /*!< PADS_QSPI_GPIO_QSPI_SD0_DRIVE */
  PADS_QSPI_GPIO_QSPI_SD0_DRIVE_2mA    = 0,     /*!< 2mA : 2mA */
  PADS_QSPI_GPIO_QSPI_SD0_DRIVE_4mA    = 1,     /*!< 4mA : 4mA */
  PADS_QSPI_GPIO_QSPI_SD0_DRIVE_8mA    = 2,     /*!< 8mA : 8mA */
  PADS_QSPI_GPIO_QSPI_SD0_DRIVE_12mA   = 3,     /*!< 12mA : 12mA */
} PADS_QSPI_GPIO_QSPI_SD0_DRIVE_Enum;

/* =====================================================  GPIO_QSPI_SD1  ===================================================== */
/* =========================================  PADS_QSPI GPIO_QSPI_SD1 DRIVE [4..5]  ========================================== */
typedef enum {                                  /*!< PADS_QSPI_GPIO_QSPI_SD1_DRIVE */
  PADS_QSPI_GPIO_QSPI_SD1_DRIVE_2mA    = 0,     /*!< 2mA : 2mA */
  PADS_QSPI_GPIO_QSPI_SD1_DRIVE_4mA    = 1,     /*!< 4mA : 4mA */
  PADS_QSPI_GPIO_QSPI_SD1_DRIVE_8mA    = 2,     /*!< 8mA : 8mA */
  PADS_QSPI_GPIO_QSPI_SD1_DRIVE_12mA   = 3,     /*!< 12mA : 12mA */
} PADS_QSPI_GPIO_QSPI_SD1_DRIVE_Enum;

/* =====================================================  GPIO_QSPI_SD2  ===================================================== */
/* =========================================  PADS_QSPI GPIO_QSPI_SD2 DRIVE [4..5]  ========================================== */
typedef enum {                                  /*!< PADS_QSPI_GPIO_QSPI_SD2_DRIVE */
  PADS_QSPI_GPIO_QSPI_SD2_DRIVE_2mA    = 0,     /*!< 2mA : 2mA */
  PADS_QSPI_GPIO_QSPI_SD2_DRIVE_4mA    = 1,     /*!< 4mA : 4mA */
  PADS_QSPI_GPIO_QSPI_SD2_DRIVE_8mA    = 2,     /*!< 8mA : 8mA */
  PADS_QSPI_GPIO_QSPI_SD2_DRIVE_12mA   = 3,     /*!< 12mA : 12mA */
} PADS_QSPI_GPIO_QSPI_SD2_DRIVE_Enum;

/* =====================================================  GPIO_QSPI_SD3  ===================================================== */
/* =========================================  PADS_QSPI GPIO_QSPI_SD3 DRIVE [4..5]  ========================================== */
typedef enum {                                  /*!< PADS_QSPI_GPIO_QSPI_SD3_DRIVE */
  PADS_QSPI_GPIO_QSPI_SD3_DRIVE_2mA    = 0,     /*!< 2mA : 2mA */
  PADS_QSPI_GPIO_QSPI_SD3_DRIVE_4mA    = 1,     /*!< 4mA : 4mA */
  PADS_QSPI_GPIO_QSPI_SD3_DRIVE_8mA    = 2,     /*!< 8mA : 8mA */
  PADS_QSPI_GPIO_QSPI_SD3_DRIVE_12mA   = 3,     /*!< 12mA : 12mA */
} PADS_QSPI_GPIO_QSPI_SD3_DRIVE_Enum;

/* =====================================================  GPIO_QSPI_SS  ====================================================== */
/* ==========================================  PADS_QSPI GPIO_QSPI_SS DRIVE [4..5]  ========================================== */
typedef enum {                                  /*!< PADS_QSPI_GPIO_QSPI_SS_DRIVE */
  PADS_QSPI_GPIO_QSPI_SS_DRIVE_2mA     = 0,     /*!< 2mA : 2mA */
  PADS_QSPI_GPIO_QSPI_SS_DRIVE_4mA     = 1,     /*!< 4mA : 4mA */
  PADS_QSPI_GPIO_QSPI_SS_DRIVE_8mA     = 2,     /*!< 8mA : 8mA */
  PADS_QSPI_GPIO_QSPI_SS_DRIVE_12mA    = 3,     /*!< 12mA : 12mA */
} PADS_QSPI_GPIO_QSPI_SS_DRIVE_Enum;



/* =========================================================================================================================== */
/* ================                                           XOSC                                            ================ */
/* =========================================================================================================================== */

/* =========================================================  CTRL  ========================================================== */
/* ===============================================  XOSC CTRL ENABLE [12..23]  =============================================== */
typedef enum {                                  /*!< XOSC_CTRL_ENABLE */
  XOSC_CTRL_ENABLE_DISABLE             = 3358,  /*!< DISABLE : DISABLE */
  XOSC_CTRL_ENABLE_ENABLE              = 4011,  /*!< ENABLE : ENABLE */
} XOSC_CTRL_ENABLE_Enum;

/* =============================================  XOSC CTRL FREQ_RANGE [0..11]  ============================================== */
typedef enum {                                  /*!< XOSC_CTRL_FREQ_RANGE */
  XOSC_CTRL_FREQ_RANGE_1_15MHZ         = 2720,  /*!< 1_15MHZ : 1_15MHZ */
  XOSC_CTRL_FREQ_RANGE_RESERVED_1      = 2721,  /*!< RESERVED_1 : RESERVED_1 */
  XOSC_CTRL_FREQ_RANGE_RESERVED_2      = 2722,  /*!< RESERVED_2 : RESERVED_2 */
  XOSC_CTRL_FREQ_RANGE_RESERVED_3      = 2723,  /*!< RESERVED_3 : RESERVED_3 */
} XOSC_CTRL_FREQ_RANGE_Enum;

/* ========================================================  STATUS  ========================================================= */
/* =============================================  XOSC STATUS FREQ_RANGE [0..1]  ============================================= */
typedef enum {                                  /*!< XOSC_STATUS_FREQ_RANGE */
  XOSC_STATUS_FREQ_RANGE_1_15MHZ       = 0,     /*!< 1_15MHZ : 1_15MHZ */
  XOSC_STATUS_FREQ_RANGE_RESERVED_1    = 1,     /*!< RESERVED_1 : RESERVED_1 */
  XOSC_STATUS_FREQ_RANGE_RESERVED_2    = 2,     /*!< RESERVED_2 : RESERVED_2 */
  XOSC_STATUS_FREQ_RANGE_RESERVED_3    = 3,     /*!< RESERVED_3 : RESERVED_3 */
} XOSC_STATUS_FREQ_RANGE_Enum;

/* ========================================================  DORMANT  ======================================================== */
/* ========================================================  STARTUP  ======================================================== */
/* =========================================================  COUNT  ========================================================= */


/* =========================================================================================================================== */
/* ================                                          PLL_SYS                                          ================ */
/* =========================================================================================================================== */

/* ==========================================================  CS  =========================================================== */
/* ==========================================================  PWR  ========================================================== */
/* =======================================================  FBDIV_INT  ======================================================= */
/* =========================================================  PRIM  ========================================================== */


/* =========================================================================================================================== */
/* ================                                          BUSCTRL                                          ================ */
/* =========================================================================================================================== */

/* =====================================================  BUS_PRIORITY  ====================================================== */
/* ===================================================  BUS_PRIORITY_ACK  ==================================================== */
/* =======================================================  PERFCTR0  ======================================================== */
/* =======================================================  PERFSEL0  ======================================================== */
/* ===========================================  BUSCTRL PERFSEL0 PERFSEL0 [0..4]  ============================================ */
typedef enum {                                  /*!< BUSCTRL_PERFSEL0_PERFSEL0 */
  BUSCTRL_PERFSEL0_PERFSEL0_apb_contested = 0,  /*!< apb_contested : apb_contested */
  BUSCTRL_PERFSEL0_PERFSEL0_apb        = 1,     /*!< apb : apb */
  BUSCTRL_PERFSEL0_PERFSEL0_fastperi_contested = 2,/*!< fastperi_contested : fastperi_contested */
  BUSCTRL_PERFSEL0_PERFSEL0_fastperi   = 3,     /*!< fastperi : fastperi */
  BUSCTRL_PERFSEL0_PERFSEL0_sram5_contested = 4,/*!< sram5_contested : sram5_contested */
  BUSCTRL_PERFSEL0_PERFSEL0_sram5      = 5,     /*!< sram5 : sram5 */
  BUSCTRL_PERFSEL0_PERFSEL0_sram4_contested = 6,/*!< sram4_contested : sram4_contested */
  BUSCTRL_PERFSEL0_PERFSEL0_sram4      = 7,     /*!< sram4 : sram4 */
  BUSCTRL_PERFSEL0_PERFSEL0_sram3_contested = 8,/*!< sram3_contested : sram3_contested */
  BUSCTRL_PERFSEL0_PERFSEL0_sram3      = 9,     /*!< sram3 : sram3 */
  BUSCTRL_PERFSEL0_PERFSEL0_sram2_contested = 10,/*!< sram2_contested : sram2_contested */
  BUSCTRL_PERFSEL0_PERFSEL0_sram2      = 11,    /*!< sram2 : sram2 */
  BUSCTRL_PERFSEL0_PERFSEL0_sram1_contested = 12,/*!< sram1_contested : sram1_contested */
  BUSCTRL_PERFSEL0_PERFSEL0_sram1      = 13,    /*!< sram1 : sram1 */
  BUSCTRL_PERFSEL0_PERFSEL0_sram0_contested = 14,/*!< sram0_contested : sram0_contested */
  BUSCTRL_PERFSEL0_PERFSEL0_sram0      = 15,    /*!< sram0 : sram0 */
  BUSCTRL_PERFSEL0_PERFSEL0_xip_main_contested = 16,/*!< xip_main_contested : xip_main_contested */
  BUSCTRL_PERFSEL0_PERFSEL0_xip_main   = 17,    /*!< xip_main : xip_main */
  BUSCTRL_PERFSEL0_PERFSEL0_rom_contested = 18, /*!< rom_contested : rom_contested */
  BUSCTRL_PERFSEL0_PERFSEL0_rom        = 19,    /*!< rom : rom */
} BUSCTRL_PERFSEL0_PERFSEL0_Enum;

/* =======================================================  PERFCTR1  ======================================================== */
/* =======================================================  PERFSEL1  ======================================================== */
/* ===========================================  BUSCTRL PERFSEL1 PERFSEL1 [0..4]  ============================================ */
typedef enum {                                  /*!< BUSCTRL_PERFSEL1_PERFSEL1 */
  BUSCTRL_PERFSEL1_PERFSEL1_apb_contested = 0,  /*!< apb_contested : apb_contested */
  BUSCTRL_PERFSEL1_PERFSEL1_apb        = 1,     /*!< apb : apb */
  BUSCTRL_PERFSEL1_PERFSEL1_fastperi_contested = 2,/*!< fastperi_contested : fastperi_contested */
  BUSCTRL_PERFSEL1_PERFSEL1_fastperi   = 3,     /*!< fastperi : fastperi */
  BUSCTRL_PERFSEL1_PERFSEL1_sram5_contested = 4,/*!< sram5_contested : sram5_contested */
  BUSCTRL_PERFSEL1_PERFSEL1_sram5      = 5,     /*!< sram5 : sram5 */
  BUSCTRL_PERFSEL1_PERFSEL1_sram4_contested = 6,/*!< sram4_contested : sram4_contested */
  BUSCTRL_PERFSEL1_PERFSEL1_sram4      = 7,     /*!< sram4 : sram4 */
  BUSCTRL_PERFSEL1_PERFSEL1_sram3_contested = 8,/*!< sram3_contested : sram3_contested */
  BUSCTRL_PERFSEL1_PERFSEL1_sram3      = 9,     /*!< sram3 : sram3 */
  BUSCTRL_PERFSEL1_PERFSEL1_sram2_contested = 10,/*!< sram2_contested : sram2_contested */
  BUSCTRL_PERFSEL1_PERFSEL1_sram2      = 11,    /*!< sram2 : sram2 */
  BUSCTRL_PERFSEL1_PERFSEL1_sram1_contested = 12,/*!< sram1_contested : sram1_contested */
  BUSCTRL_PERFSEL1_PERFSEL1_sram1      = 13,    /*!< sram1 : sram1 */
  BUSCTRL_PERFSEL1_PERFSEL1_sram0_contested = 14,/*!< sram0_contested : sram0_contested */
  BUSCTRL_PERFSEL1_PERFSEL1_sram0      = 15,    /*!< sram0 : sram0 */
  BUSCTRL_PERFSEL1_PERFSEL1_xip_main_contested = 16,/*!< xip_main_contested : xip_main_contested */
  BUSCTRL_PERFSEL1_PERFSEL1_xip_main   = 17,    /*!< xip_main : xip_main */
  BUSCTRL_PERFSEL1_PERFSEL1_rom_contested = 18, /*!< rom_contested : rom_contested */
  BUSCTRL_PERFSEL1_PERFSEL1_rom        = 19,    /*!< rom : rom */
} BUSCTRL_PERFSEL1_PERFSEL1_Enum;

/* =======================================================  PERFCTR2  ======================================================== */
/* =======================================================  PERFSEL2  ======================================================== */
/* ===========================================  BUSCTRL PERFSEL2 PERFSEL2 [0..4]  ============================================ */
typedef enum {                                  /*!< BUSCTRL_PERFSEL2_PERFSEL2 */
  BUSCTRL_PERFSEL2_PERFSEL2_apb_contested = 0,  /*!< apb_contested : apb_contested */
  BUSCTRL_PERFSEL2_PERFSEL2_apb        = 1,     /*!< apb : apb */
  BUSCTRL_PERFSEL2_PERFSEL2_fastperi_contested = 2,/*!< fastperi_contested : fastperi_contested */
  BUSCTRL_PERFSEL2_PERFSEL2_fastperi   = 3,     /*!< fastperi : fastperi */
  BUSCTRL_PERFSEL2_PERFSEL2_sram5_contested = 4,/*!< sram5_contested : sram5_contested */
  BUSCTRL_PERFSEL2_PERFSEL2_sram5      = 5,     /*!< sram5 : sram5 */
  BUSCTRL_PERFSEL2_PERFSEL2_sram4_contested = 6,/*!< sram4_contested : sram4_contested */
  BUSCTRL_PERFSEL2_PERFSEL2_sram4      = 7,     /*!< sram4 : sram4 */
  BUSCTRL_PERFSEL2_PERFSEL2_sram3_contested = 8,/*!< sram3_contested : sram3_contested */
  BUSCTRL_PERFSEL2_PERFSEL2_sram3      = 9,     /*!< sram3 : sram3 */
  BUSCTRL_PERFSEL2_PERFSEL2_sram2_contested = 10,/*!< sram2_contested : sram2_contested */
  BUSCTRL_PERFSEL2_PERFSEL2_sram2      = 11,    /*!< sram2 : sram2 */
  BUSCTRL_PERFSEL2_PERFSEL2_sram1_contested = 12,/*!< sram1_contested : sram1_contested */
  BUSCTRL_PERFSEL2_PERFSEL2_sram1      = 13,    /*!< sram1 : sram1 */
  BUSCTRL_PERFSEL2_PERFSEL2_sram0_contested = 14,/*!< sram0_contested : sram0_contested */
  BUSCTRL_PERFSEL2_PERFSEL2_sram0      = 15,    /*!< sram0 : sram0 */
  BUSCTRL_PERFSEL2_PERFSEL2_xip_main_contested = 16,/*!< xip_main_contested : xip_main_contested */
  BUSCTRL_PERFSEL2_PERFSEL2_xip_main   = 17,    /*!< xip_main : xip_main */
  BUSCTRL_PERFSEL2_PERFSEL2_rom_contested = 18, /*!< rom_contested : rom_contested */
  BUSCTRL_PERFSEL2_PERFSEL2_rom        = 19,    /*!< rom : rom */
} BUSCTRL_PERFSEL2_PERFSEL2_Enum;

/* =======================================================  PERFCTR3  ======================================================== */
/* =======================================================  PERFSEL3  ======================================================== */
/* ===========================================  BUSCTRL PERFSEL3 PERFSEL3 [0..4]  ============================================ */
typedef enum {                                  /*!< BUSCTRL_PERFSEL3_PERFSEL3 */
  BUSCTRL_PERFSEL3_PERFSEL3_apb_contested = 0,  /*!< apb_contested : apb_contested */
  BUSCTRL_PERFSEL3_PERFSEL3_apb        = 1,     /*!< apb : apb */
  BUSCTRL_PERFSEL3_PERFSEL3_fastperi_contested = 2,/*!< fastperi_contested : fastperi_contested */
  BUSCTRL_PERFSEL3_PERFSEL3_fastperi   = 3,     /*!< fastperi : fastperi */
  BUSCTRL_PERFSEL3_PERFSEL3_sram5_contested = 4,/*!< sram5_contested : sram5_contested */
  BUSCTRL_PERFSEL3_PERFSEL3_sram5      = 5,     /*!< sram5 : sram5 */
  BUSCTRL_PERFSEL3_PERFSEL3_sram4_contested = 6,/*!< sram4_contested : sram4_contested */
  BUSCTRL_PERFSEL3_PERFSEL3_sram4      = 7,     /*!< sram4 : sram4 */
  BUSCTRL_PERFSEL3_PERFSEL3_sram3_contested = 8,/*!< sram3_contested : sram3_contested */
  BUSCTRL_PERFSEL3_PERFSEL3_sram3      = 9,     /*!< sram3 : sram3 */
  BUSCTRL_PERFSEL3_PERFSEL3_sram2_contested = 10,/*!< sram2_contested : sram2_contested */
  BUSCTRL_PERFSEL3_PERFSEL3_sram2      = 11,    /*!< sram2 : sram2 */
  BUSCTRL_PERFSEL3_PERFSEL3_sram1_contested = 12,/*!< sram1_contested : sram1_contested */
  BUSCTRL_PERFSEL3_PERFSEL3_sram1      = 13,    /*!< sram1 : sram1 */
  BUSCTRL_PERFSEL3_PERFSEL3_sram0_contested = 14,/*!< sram0_contested : sram0_contested */
  BUSCTRL_PERFSEL3_PERFSEL3_sram0      = 15,    /*!< sram0 : sram0 */
  BUSCTRL_PERFSEL3_PERFSEL3_xip_main_contested = 16,/*!< xip_main_contested : xip_main_contested */
  BUSCTRL_PERFSEL3_PERFSEL3_xip_main   = 17,    /*!< xip_main : xip_main */
  BUSCTRL_PERFSEL3_PERFSEL3_rom_contested = 18, /*!< rom_contested : rom_contested */
  BUSCTRL_PERFSEL3_PERFSEL3_rom        = 19,    /*!< rom : rom */
} BUSCTRL_PERFSEL3_PERFSEL3_Enum;



/* =========================================================================================================================== */
/* ================                                           UART0                                           ================ */
/* =========================================================================================================================== */

/* ========================================================  UARTDR  ========================================================= */
/* ========================================================  UARTRSR  ======================================================== */
/* ========================================================  UARTFR  ========================================================= */
/* =======================================================  UARTILPR  ======================================================== */
/* =======================================================  UARTIBRD  ======================================================== */
/* =======================================================  UARTFBRD  ======================================================== */
/* =======================================================  UARTLCR_H  ======================================================= */
/* ========================================================  UARTCR  ========================================================= */
/* =======================================================  UARTIFLS  ======================================================== */
/* =======================================================  UARTIMSC  ======================================================== */
/* ========================================================  UARTRIS  ======================================================== */
/* ========================================================  UARTMIS  ======================================================== */
/* ========================================================  UARTICR  ======================================================== */
/* =======================================================  UARTDMACR  ======================================================= */
/* =====================================================  UARTPERIPHID0  ===================================================== */
/* =====================================================  UARTPERIPHID1  ===================================================== */
/* =====================================================  UARTPERIPHID2  ===================================================== */
/* =====================================================  UARTPERIPHID3  ===================================================== */
/* =====================================================  UARTPCELLID0  ====================================================== */
/* =====================================================  UARTPCELLID1  ====================================================== */
/* =====================================================  UARTPCELLID2  ====================================================== */
/* =====================================================  UARTPCELLID3  ====================================================== */


/* =========================================================================================================================== */
/* ================                                           SPI0                                            ================ */
/* =========================================================================================================================== */

/* ========================================================  SSPCR0  ========================================================= */
/* ========================================================  SSPCR1  ========================================================= */
/* =========================================================  SSPDR  ========================================================= */
/* =========================================================  SSPSR  ========================================================= */
/* ========================================================  SSPCPSR  ======================================================== */
/* ========================================================  SSPIMSC  ======================================================== */
/* ========================================================  SSPRIS  ========================================================= */
/* ========================================================  SSPMIS  ========================================================= */
/* ========================================================  SSPICR  ========================================================= */
/* =======================================================  SSPDMACR  ======================================================== */
/* =====================================================  SSPPERIPHID0  ====================================================== */
/* =====================================================  SSPPERIPHID1  ====================================================== */
/* =====================================================  SSPPERIPHID2  ====================================================== */
/* =====================================================  SSPPERIPHID3  ====================================================== */
/* ======================================================  SSPPCELLID0  ====================================================== */
/* ======================================================  SSPPCELLID1  ====================================================== */
/* ======================================================  SSPPCELLID2  ====================================================== */
/* ======================================================  SSPPCELLID3  ====================================================== */


/* =========================================================================================================================== */
/* ================                                           I2C0                                            ================ */
/* =========================================================================================================================== */

/* ========================================================  IC_CON  ========================================================= */
/* =======================================  I2C0 IC_CON RX_FIFO_FULL_HLD_CTRL [9..9]  ======================================== */
typedef enum {                                  /*!< I2C0_IC_CON_RX_FIFO_FULL_HLD_CTRL */
  I2C0_IC_CON_RX_FIFO_FULL_HLD_CTRL_DISABLED = 0,/*!< DISABLED : Overflow when RX_FIFO is full */
  I2C0_IC_CON_RX_FIFO_FULL_HLD_CTRL_ENABLED = 1,/*!< ENABLED : Hold bus when RX_FIFO is full */
} I2C0_IC_CON_RX_FIFO_FULL_HLD_CTRL_Enum;

/* ===========================================  I2C0 IC_CON TX_EMPTY_CTRL [8..8]  ============================================ */
typedef enum {                                  /*!< I2C0_IC_CON_TX_EMPTY_CTRL */
  I2C0_IC_CON_TX_EMPTY_CTRL_DISABLED   = 0,     /*!< DISABLED : Default behaviour of TX_EMPTY interrupt */
  I2C0_IC_CON_TX_EMPTY_CTRL_ENABLED    = 1,     /*!< ENABLED : Controlled generation of TX_EMPTY interrupt */
} I2C0_IC_CON_TX_EMPTY_CTRL_Enum;

/* ========================================  I2C0 IC_CON STOP_DET_IFADDRESSED [7..7]  ======================================== */
typedef enum {                                  /*!< I2C0_IC_CON_STOP_DET_IFADDRESSED */
  I2C0_IC_CON_STOP_DET_IFADDRESSED_DISABLED = 0,/*!< DISABLED : slave issues STOP_DET intr always */
  I2C0_IC_CON_STOP_DET_IFADDRESSED_ENABLED = 1, /*!< ENABLED : slave issues STOP_DET intr only if addressed */
} I2C0_IC_CON_STOP_DET_IFADDRESSED_Enum;

/* ==========================================  I2C0 IC_CON IC_SLAVE_DISABLE [6..6]  ========================================== */
typedef enum {                                  /*!< I2C0_IC_CON_IC_SLAVE_DISABLE */
  I2C0_IC_CON_IC_SLAVE_DISABLE_SLAVE_ENABLED = 0,/*!< SLAVE_ENABLED : Slave mode is enabled */
  I2C0_IC_CON_IC_SLAVE_DISABLE_SLAVE_DISABLED = 1,/*!< SLAVE_DISABLED : Slave mode is disabled */
} I2C0_IC_CON_IC_SLAVE_DISABLE_Enum;

/* ===========================================  I2C0 IC_CON IC_RESTART_EN [5..5]  ============================================ */
typedef enum {                                  /*!< I2C0_IC_CON_IC_RESTART_EN */
  I2C0_IC_CON_IC_RESTART_EN_DISABLED   = 0,     /*!< DISABLED : Master restart disabled */
  I2C0_IC_CON_IC_RESTART_EN_ENABLED    = 1,     /*!< ENABLED : Master restart enabled */
} I2C0_IC_CON_IC_RESTART_EN_Enum;

/* ========================================  I2C0 IC_CON IC_10BITADDR_MASTER [4..4]  ========================================= */
typedef enum {                                  /*!< I2C0_IC_CON_IC_10BITADDR_MASTER */
  I2C0_IC_CON_IC_10BITADDR_MASTER_ADDR_7BITS = 0,/*!< ADDR_7BITS : Master 7Bit addressing mode */
  I2C0_IC_CON_IC_10BITADDR_MASTER_ADDR_10BITS = 1,/*!< ADDR_10BITS : Master 10Bit addressing mode */
} I2C0_IC_CON_IC_10BITADDR_MASTER_Enum;

/* =========================================  I2C0 IC_CON IC_10BITADDR_SLAVE [3..3]  ========================================= */
typedef enum {                                  /*!< I2C0_IC_CON_IC_10BITADDR_SLAVE */
  I2C0_IC_CON_IC_10BITADDR_SLAVE_ADDR_7BITS = 0,/*!< ADDR_7BITS : Slave 7Bit addressing */
  I2C0_IC_CON_IC_10BITADDR_SLAVE_ADDR_10BITS = 1,/*!< ADDR_10BITS : Slave 10Bit addressing */
} I2C0_IC_CON_IC_10BITADDR_SLAVE_Enum;

/* ===============================================  I2C0 IC_CON SPEED [1..2]  ================================================ */
typedef enum {                                  /*!< I2C0_IC_CON_SPEED */
  I2C0_IC_CON_SPEED_STANDARD           = 1,     /*!< STANDARD : Standard Speed mode of operation */
  I2C0_IC_CON_SPEED_FAST               = 2,     /*!< FAST : Fast or Fast Plus mode of operation */
  I2C0_IC_CON_SPEED_HIGH               = 3,     /*!< HIGH : High Speed mode of operation */
} I2C0_IC_CON_SPEED_Enum;

/* ============================================  I2C0 IC_CON MASTER_MODE [0..0]  ============================================= */
typedef enum {                                  /*!< I2C0_IC_CON_MASTER_MODE */
  I2C0_IC_CON_MASTER_MODE_DISABLED     = 0,     /*!< DISABLED : Master mode is disabled */
  I2C0_IC_CON_MASTER_MODE_ENABLED      = 1,     /*!< ENABLED : Master mode is enabled */
} I2C0_IC_CON_MASTER_MODE_Enum;

/* ========================================================  IC_TAR  ========================================================= */
/* =============================================  I2C0 IC_TAR SPECIAL [11..11]  ============================================== */
typedef enum {                                  /*!< I2C0_IC_TAR_SPECIAL */
  I2C0_IC_TAR_SPECIAL_DISABLED         = 0,     /*!< DISABLED : Disables programming of GENERAL_CALL or START_BYTE transmission */
  I2C0_IC_TAR_SPECIAL_ENABLED          = 1,     /*!< ENABLED : Enables programming of GENERAL_CALL or START_BYTE transmission */
} I2C0_IC_TAR_SPECIAL_Enum;

/* ===========================================  I2C0 IC_TAR GC_OR_START [10..10]  ============================================ */
typedef enum {                                  /*!< I2C0_IC_TAR_GC_OR_START */
  I2C0_IC_TAR_GC_OR_START_GENERAL_CALL = 0,     /*!< GENERAL_CALL : GENERAL_CALL byte transmission */
  I2C0_IC_TAR_GC_OR_START_START_BYTE   = 1,     /*!< START_BYTE : START byte transmission */
} I2C0_IC_TAR_GC_OR_START_Enum;

/* ========================================================  IC_SAR  ========================================================= */
/* ======================================================  IC_DATA_CMD  ====================================================== */
/* =======================================  I2C0 IC_DATA_CMD FIRST_DATA_BYTE [11..11]  ======================================= */
typedef enum {                                  /*!< I2C0_IC_DATA_CMD_FIRST_DATA_BYTE */
  I2C0_IC_DATA_CMD_FIRST_DATA_BYTE_INACTIVE = 0,/*!< INACTIVE : Sequential data byte received */
  I2C0_IC_DATA_CMD_FIRST_DATA_BYTE_ACTIVE = 1,  /*!< ACTIVE : Non sequential data byte received */
} I2C0_IC_DATA_CMD_FIRST_DATA_BYTE_Enum;

/* ===========================================  I2C0 IC_DATA_CMD RESTART [10..10]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_DATA_CMD_RESTART */
  I2C0_IC_DATA_CMD_RESTART_DISABLE     = 0,     /*!< DISABLE : Don't Issue RESTART before this command */
  I2C0_IC_DATA_CMD_RESTART_ENABLE      = 1,     /*!< ENABLE : Issue RESTART before this command */
} I2C0_IC_DATA_CMD_RESTART_Enum;

/* =============================================  I2C0 IC_DATA_CMD STOP [9..9]  ============================================== */
typedef enum {                                  /*!< I2C0_IC_DATA_CMD_STOP */
  I2C0_IC_DATA_CMD_STOP_DISABLE        = 0,     /*!< DISABLE : Don't Issue STOP after this command */
  I2C0_IC_DATA_CMD_STOP_ENABLE         = 1,     /*!< ENABLE : Issue STOP after this command */
} I2C0_IC_DATA_CMD_STOP_Enum;

/* ==============================================  I2C0 IC_DATA_CMD CMD [8..8]  ============================================== */
typedef enum {                                  /*!< I2C0_IC_DATA_CMD_CMD */
  I2C0_IC_DATA_CMD_CMD_WRITE           = 0,     /*!< WRITE : Master Write Command */
  I2C0_IC_DATA_CMD_CMD_READ            = 1,     /*!< READ : Master Read Command */
} I2C0_IC_DATA_CMD_CMD_Enum;

/* ====================================================  IC_SS_SCL_HCNT  ===================================================== */
/* ====================================================  IC_SS_SCL_LCNT  ===================================================== */
/* ====================================================  IC_FS_SCL_HCNT  ===================================================== */
/* ====================================================  IC_FS_SCL_LCNT  ===================================================== */
/* =====================================================  IC_INTR_STAT  ====================================================== */
/* =======================================  I2C0 IC_INTR_STAT R_RESTART_DET [12..12]  ======================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_STAT_R_RESTART_DET */
  I2C0_IC_INTR_STAT_R_RESTART_DET_INACTIVE = 0, /*!< INACTIVE : R_RESTART_DET interrupt is inactive */
  I2C0_IC_INTR_STAT_R_RESTART_DET_ACTIVE = 1,   /*!< ACTIVE : R_RESTART_DET interrupt is active */
} I2C0_IC_INTR_STAT_R_RESTART_DET_Enum;

/* =========================================  I2C0 IC_INTR_STAT R_GEN_CALL [11..11]  ========================================= */
typedef enum {                                  /*!< I2C0_IC_INTR_STAT_R_GEN_CALL */
  I2C0_IC_INTR_STAT_R_GEN_CALL_INACTIVE = 0,    /*!< INACTIVE : R_GEN_CALL interrupt is inactive */
  I2C0_IC_INTR_STAT_R_GEN_CALL_ACTIVE  = 1,     /*!< ACTIVE : R_GEN_CALL interrupt is active */
} I2C0_IC_INTR_STAT_R_GEN_CALL_Enum;

/* ========================================  I2C0 IC_INTR_STAT R_START_DET [10..10]  ========================================= */
typedef enum {                                  /*!< I2C0_IC_INTR_STAT_R_START_DET */
  I2C0_IC_INTR_STAT_R_START_DET_INACTIVE = 0,   /*!< INACTIVE : R_START_DET interrupt is inactive */
  I2C0_IC_INTR_STAT_R_START_DET_ACTIVE = 1,     /*!< ACTIVE : R_START_DET interrupt is active */
} I2C0_IC_INTR_STAT_R_START_DET_Enum;

/* ==========================================  I2C0 IC_INTR_STAT R_STOP_DET [9..9]  ========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_STAT_R_STOP_DET */
  I2C0_IC_INTR_STAT_R_STOP_DET_INACTIVE = 0,    /*!< INACTIVE : R_STOP_DET interrupt is inactive */
  I2C0_IC_INTR_STAT_R_STOP_DET_ACTIVE  = 1,     /*!< ACTIVE : R_STOP_DET interrupt is active */
} I2C0_IC_INTR_STAT_R_STOP_DET_Enum;

/* ==========================================  I2C0 IC_INTR_STAT R_ACTIVITY [8..8]  ========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_STAT_R_ACTIVITY */
  I2C0_IC_INTR_STAT_R_ACTIVITY_INACTIVE = 0,    /*!< INACTIVE : R_ACTIVITY interrupt is inactive */
  I2C0_IC_INTR_STAT_R_ACTIVITY_ACTIVE  = 1,     /*!< ACTIVE : R_ACTIVITY interrupt is active */
} I2C0_IC_INTR_STAT_R_ACTIVITY_Enum;

/* ==========================================  I2C0 IC_INTR_STAT R_RX_DONE [7..7]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_STAT_R_RX_DONE */
  I2C0_IC_INTR_STAT_R_RX_DONE_INACTIVE = 0,     /*!< INACTIVE : R_RX_DONE interrupt is inactive */
  I2C0_IC_INTR_STAT_R_RX_DONE_ACTIVE   = 1,     /*!< ACTIVE : R_RX_DONE interrupt is active */
} I2C0_IC_INTR_STAT_R_RX_DONE_Enum;

/* ==========================================  I2C0 IC_INTR_STAT R_TX_ABRT [6..6]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_STAT_R_TX_ABRT */
  I2C0_IC_INTR_STAT_R_TX_ABRT_INACTIVE = 0,     /*!< INACTIVE : R_TX_ABRT interrupt is inactive */
  I2C0_IC_INTR_STAT_R_TX_ABRT_ACTIVE   = 1,     /*!< ACTIVE : R_TX_ABRT interrupt is active */
} I2C0_IC_INTR_STAT_R_TX_ABRT_Enum;

/* ===========================================  I2C0 IC_INTR_STAT R_RD_REQ [5..5]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_STAT_R_RD_REQ */
  I2C0_IC_INTR_STAT_R_RD_REQ_INACTIVE  = 0,     /*!< INACTIVE : R_RD_REQ interrupt is inactive */
  I2C0_IC_INTR_STAT_R_RD_REQ_ACTIVE    = 1,     /*!< ACTIVE : R_RD_REQ interrupt is active */
} I2C0_IC_INTR_STAT_R_RD_REQ_Enum;

/* ==========================================  I2C0 IC_INTR_STAT R_TX_EMPTY [4..4]  ========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_STAT_R_TX_EMPTY */
  I2C0_IC_INTR_STAT_R_TX_EMPTY_INACTIVE = 0,    /*!< INACTIVE : R_TX_EMPTY interrupt is inactive */
  I2C0_IC_INTR_STAT_R_TX_EMPTY_ACTIVE  = 1,     /*!< ACTIVE : R_TX_EMPTY interrupt is active */
} I2C0_IC_INTR_STAT_R_TX_EMPTY_Enum;

/* ==========================================  I2C0 IC_INTR_STAT R_TX_OVER [3..3]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_STAT_R_TX_OVER */
  I2C0_IC_INTR_STAT_R_TX_OVER_INACTIVE = 0,     /*!< INACTIVE : R_TX_OVER interrupt is inactive */
  I2C0_IC_INTR_STAT_R_TX_OVER_ACTIVE   = 1,     /*!< ACTIVE : R_TX_OVER interrupt is active */
} I2C0_IC_INTR_STAT_R_TX_OVER_Enum;

/* ==========================================  I2C0 IC_INTR_STAT R_RX_FULL [2..2]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_STAT_R_RX_FULL */
  I2C0_IC_INTR_STAT_R_RX_FULL_INACTIVE = 0,     /*!< INACTIVE : R_RX_FULL interrupt is inactive */
  I2C0_IC_INTR_STAT_R_RX_FULL_ACTIVE   = 1,     /*!< ACTIVE : R_RX_FULL interrupt is active */
} I2C0_IC_INTR_STAT_R_RX_FULL_Enum;

/* ==========================================  I2C0 IC_INTR_STAT R_RX_OVER [1..1]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_STAT_R_RX_OVER */
  I2C0_IC_INTR_STAT_R_RX_OVER_INACTIVE = 0,     /*!< INACTIVE : R_RX_OVER interrupt is inactive */
  I2C0_IC_INTR_STAT_R_RX_OVER_ACTIVE   = 1,     /*!< ACTIVE : R_RX_OVER interrupt is active */
} I2C0_IC_INTR_STAT_R_RX_OVER_Enum;

/* ==========================================  I2C0 IC_INTR_STAT R_RX_UNDER [0..0]  ========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_STAT_R_RX_UNDER */
  I2C0_IC_INTR_STAT_R_RX_UNDER_INACTIVE = 0,    /*!< INACTIVE : RX_UNDER interrupt is inactive */
  I2C0_IC_INTR_STAT_R_RX_UNDER_ACTIVE  = 1,     /*!< ACTIVE : RX_UNDER interrupt is active */
} I2C0_IC_INTR_STAT_R_RX_UNDER_Enum;

/* =====================================================  IC_INTR_MASK  ====================================================== */
/* =======================================  I2C0 IC_INTR_MASK M_RESTART_DET [12..12]  ======================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_MASK_M_RESTART_DET */
  I2C0_IC_INTR_MASK_M_RESTART_DET_ENABLED = 0,  /*!< ENABLED : RESTART_DET interrupt is masked */
  I2C0_IC_INTR_MASK_M_RESTART_DET_DISABLED = 1, /*!< DISABLED : RESTART_DET interrupt is unmasked */
} I2C0_IC_INTR_MASK_M_RESTART_DET_Enum;

/* =========================================  I2C0 IC_INTR_MASK M_GEN_CALL [11..11]  ========================================= */
typedef enum {                                  /*!< I2C0_IC_INTR_MASK_M_GEN_CALL */
  I2C0_IC_INTR_MASK_M_GEN_CALL_ENABLED = 0,     /*!< ENABLED : GEN_CALL interrupt is masked */
  I2C0_IC_INTR_MASK_M_GEN_CALL_DISABLED = 1,    /*!< DISABLED : GEN_CALL interrupt is unmasked */
} I2C0_IC_INTR_MASK_M_GEN_CALL_Enum;

/* ========================================  I2C0 IC_INTR_MASK M_START_DET [10..10]  ========================================= */
typedef enum {                                  /*!< I2C0_IC_INTR_MASK_M_START_DET */
  I2C0_IC_INTR_MASK_M_START_DET_ENABLED = 0,    /*!< ENABLED : START_DET interrupt is masked */
  I2C0_IC_INTR_MASK_M_START_DET_DISABLED = 1,   /*!< DISABLED : START_DET interrupt is unmasked */
} I2C0_IC_INTR_MASK_M_START_DET_Enum;

/* ==========================================  I2C0 IC_INTR_MASK M_STOP_DET [9..9]  ========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_MASK_M_STOP_DET */
  I2C0_IC_INTR_MASK_M_STOP_DET_ENABLED = 0,     /*!< ENABLED : STOP_DET interrupt is masked */
  I2C0_IC_INTR_MASK_M_STOP_DET_DISABLED = 1,    /*!< DISABLED : STOP_DET interrupt is unmasked */
} I2C0_IC_INTR_MASK_M_STOP_DET_Enum;

/* ==========================================  I2C0 IC_INTR_MASK M_ACTIVITY [8..8]  ========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_MASK_M_ACTIVITY */
  I2C0_IC_INTR_MASK_M_ACTIVITY_ENABLED = 0,     /*!< ENABLED : ACTIVITY interrupt is masked */
  I2C0_IC_INTR_MASK_M_ACTIVITY_DISABLED = 1,    /*!< DISABLED : ACTIVITY interrupt is unmasked */
} I2C0_IC_INTR_MASK_M_ACTIVITY_Enum;

/* ==========================================  I2C0 IC_INTR_MASK M_RX_DONE [7..7]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_MASK_M_RX_DONE */
  I2C0_IC_INTR_MASK_M_RX_DONE_ENABLED  = 0,     /*!< ENABLED : RX_DONE interrupt is masked */
  I2C0_IC_INTR_MASK_M_RX_DONE_DISABLED = 1,     /*!< DISABLED : RX_DONE interrupt is unmasked */
} I2C0_IC_INTR_MASK_M_RX_DONE_Enum;

/* ==========================================  I2C0 IC_INTR_MASK M_TX_ABRT [6..6]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_MASK_M_TX_ABRT */
  I2C0_IC_INTR_MASK_M_TX_ABRT_ENABLED  = 0,     /*!< ENABLED : TX_ABORT interrupt is masked */
  I2C0_IC_INTR_MASK_M_TX_ABRT_DISABLED = 1,     /*!< DISABLED : TX_ABORT interrupt is unmasked */
} I2C0_IC_INTR_MASK_M_TX_ABRT_Enum;

/* ===========================================  I2C0 IC_INTR_MASK M_RD_REQ [5..5]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_MASK_M_RD_REQ */
  I2C0_IC_INTR_MASK_M_RD_REQ_ENABLED   = 0,     /*!< ENABLED : RD_REQ interrupt is masked */
  I2C0_IC_INTR_MASK_M_RD_REQ_DISABLED  = 1,     /*!< DISABLED : RD_REQ interrupt is unmasked */
} I2C0_IC_INTR_MASK_M_RD_REQ_Enum;

/* ==========================================  I2C0 IC_INTR_MASK M_TX_EMPTY [4..4]  ========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_MASK_M_TX_EMPTY */
  I2C0_IC_INTR_MASK_M_TX_EMPTY_ENABLED = 0,     /*!< ENABLED : TX_EMPTY interrupt is masked */
  I2C0_IC_INTR_MASK_M_TX_EMPTY_DISABLED = 1,    /*!< DISABLED : TX_EMPTY interrupt is unmasked */
} I2C0_IC_INTR_MASK_M_TX_EMPTY_Enum;

/* ==========================================  I2C0 IC_INTR_MASK M_TX_OVER [3..3]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_MASK_M_TX_OVER */
  I2C0_IC_INTR_MASK_M_TX_OVER_ENABLED  = 0,     /*!< ENABLED : TX_OVER interrupt is masked */
  I2C0_IC_INTR_MASK_M_TX_OVER_DISABLED = 1,     /*!< DISABLED : TX_OVER interrupt is unmasked */
} I2C0_IC_INTR_MASK_M_TX_OVER_Enum;

/* ==========================================  I2C0 IC_INTR_MASK M_RX_FULL [2..2]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_MASK_M_RX_FULL */
  I2C0_IC_INTR_MASK_M_RX_FULL_ENABLED  = 0,     /*!< ENABLED : RX_FULL interrupt is masked */
  I2C0_IC_INTR_MASK_M_RX_FULL_DISABLED = 1,     /*!< DISABLED : RX_FULL interrupt is unmasked */
} I2C0_IC_INTR_MASK_M_RX_FULL_Enum;

/* ==========================================  I2C0 IC_INTR_MASK M_RX_OVER [1..1]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_MASK_M_RX_OVER */
  I2C0_IC_INTR_MASK_M_RX_OVER_ENABLED  = 0,     /*!< ENABLED : RX_OVER interrupt is masked */
  I2C0_IC_INTR_MASK_M_RX_OVER_DISABLED = 1,     /*!< DISABLED : RX_OVER interrupt is unmasked */
} I2C0_IC_INTR_MASK_M_RX_OVER_Enum;

/* ==========================================  I2C0 IC_INTR_MASK M_RX_UNDER [0..0]  ========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_MASK_M_RX_UNDER */
  I2C0_IC_INTR_MASK_M_RX_UNDER_ENABLED = 0,     /*!< ENABLED : RX_UNDER interrupt is masked */
  I2C0_IC_INTR_MASK_M_RX_UNDER_DISABLED = 1,    /*!< DISABLED : RX_UNDER interrupt is unmasked */
} I2C0_IC_INTR_MASK_M_RX_UNDER_Enum;

/* ===================================================  IC_RAW_INTR_STAT  ==================================================== */
/* ======================================  I2C0 IC_RAW_INTR_STAT RESTART_DET [12..12]  ======================================= */
typedef enum {                                  /*!< I2C0_IC_RAW_INTR_STAT_RESTART_DET */
  I2C0_IC_RAW_INTR_STAT_RESTART_DET_INACTIVE = 0,/*!< INACTIVE : RESTART_DET interrupt is inactive */
  I2C0_IC_RAW_INTR_STAT_RESTART_DET_ACTIVE = 1, /*!< ACTIVE : RESTART_DET interrupt is active */
} I2C0_IC_RAW_INTR_STAT_RESTART_DET_Enum;

/* ========================================  I2C0 IC_RAW_INTR_STAT GEN_CALL [11..11]  ======================================== */
typedef enum {                                  /*!< I2C0_IC_RAW_INTR_STAT_GEN_CALL */
  I2C0_IC_RAW_INTR_STAT_GEN_CALL_INACTIVE = 0,  /*!< INACTIVE : GEN_CALL interrupt is inactive */
  I2C0_IC_RAW_INTR_STAT_GEN_CALL_ACTIVE = 1,    /*!< ACTIVE : GEN_CALL interrupt is active */
} I2C0_IC_RAW_INTR_STAT_GEN_CALL_Enum;

/* =======================================  I2C0 IC_RAW_INTR_STAT START_DET [10..10]  ======================================== */
typedef enum {                                  /*!< I2C0_IC_RAW_INTR_STAT_START_DET */
  I2C0_IC_RAW_INTR_STAT_START_DET_INACTIVE = 0, /*!< INACTIVE : START_DET interrupt is inactive */
  I2C0_IC_RAW_INTR_STAT_START_DET_ACTIVE = 1,   /*!< ACTIVE : START_DET interrupt is active */
} I2C0_IC_RAW_INTR_STAT_START_DET_Enum;

/* =========================================  I2C0 IC_RAW_INTR_STAT STOP_DET [9..9]  ========================================= */
typedef enum {                                  /*!< I2C0_IC_RAW_INTR_STAT_STOP_DET */
  I2C0_IC_RAW_INTR_STAT_STOP_DET_INACTIVE = 0,  /*!< INACTIVE : STOP_DET interrupt is inactive */
  I2C0_IC_RAW_INTR_STAT_STOP_DET_ACTIVE = 1,    /*!< ACTIVE : STOP_DET interrupt is active */
} I2C0_IC_RAW_INTR_STAT_STOP_DET_Enum;

/* =========================================  I2C0 IC_RAW_INTR_STAT ACTIVITY [8..8]  ========================================= */
typedef enum {                                  /*!< I2C0_IC_RAW_INTR_STAT_ACTIVITY */
  I2C0_IC_RAW_INTR_STAT_ACTIVITY_INACTIVE = 0,  /*!< INACTIVE : RAW_INTR_ACTIVITY interrupt is inactive */
  I2C0_IC_RAW_INTR_STAT_ACTIVITY_ACTIVE = 1,    /*!< ACTIVE : RAW_INTR_ACTIVITY interrupt is active */
} I2C0_IC_RAW_INTR_STAT_ACTIVITY_Enum;

/* =========================================  I2C0 IC_RAW_INTR_STAT RX_DONE [7..7]  ========================================== */
typedef enum {                                  /*!< I2C0_IC_RAW_INTR_STAT_RX_DONE */
  I2C0_IC_RAW_INTR_STAT_RX_DONE_INACTIVE = 0,   /*!< INACTIVE : RX_DONE interrupt is inactive */
  I2C0_IC_RAW_INTR_STAT_RX_DONE_ACTIVE = 1,     /*!< ACTIVE : RX_DONE interrupt is active */
} I2C0_IC_RAW_INTR_STAT_RX_DONE_Enum;

/* =========================================  I2C0 IC_RAW_INTR_STAT TX_ABRT [6..6]  ========================================== */
typedef enum {                                  /*!< I2C0_IC_RAW_INTR_STAT_TX_ABRT */
  I2C0_IC_RAW_INTR_STAT_TX_ABRT_INACTIVE = 0,   /*!< INACTIVE : TX_ABRT interrupt is inactive */
  I2C0_IC_RAW_INTR_STAT_TX_ABRT_ACTIVE = 1,     /*!< ACTIVE : TX_ABRT interrupt is active */
} I2C0_IC_RAW_INTR_STAT_TX_ABRT_Enum;

/* ==========================================  I2C0 IC_RAW_INTR_STAT RD_REQ [5..5]  ========================================== */
typedef enum {                                  /*!< I2C0_IC_RAW_INTR_STAT_RD_REQ */
  I2C0_IC_RAW_INTR_STAT_RD_REQ_INACTIVE = 0,    /*!< INACTIVE : RD_REQ interrupt is inactive */
  I2C0_IC_RAW_INTR_STAT_RD_REQ_ACTIVE  = 1,     /*!< ACTIVE : RD_REQ interrupt is active */
} I2C0_IC_RAW_INTR_STAT_RD_REQ_Enum;

/* =========================================  I2C0 IC_RAW_INTR_STAT TX_EMPTY [4..4]  ========================================= */
typedef enum {                                  /*!< I2C0_IC_RAW_INTR_STAT_TX_EMPTY */
  I2C0_IC_RAW_INTR_STAT_TX_EMPTY_INACTIVE = 0,  /*!< INACTIVE : TX_EMPTY interrupt is inactive */
  I2C0_IC_RAW_INTR_STAT_TX_EMPTY_ACTIVE = 1,    /*!< ACTIVE : TX_EMPTY interrupt is active */
} I2C0_IC_RAW_INTR_STAT_TX_EMPTY_Enum;

/* =========================================  I2C0 IC_RAW_INTR_STAT TX_OVER [3..3]  ========================================== */
typedef enum {                                  /*!< I2C0_IC_RAW_INTR_STAT_TX_OVER */
  I2C0_IC_RAW_INTR_STAT_TX_OVER_INACTIVE = 0,   /*!< INACTIVE : TX_OVER interrupt is inactive */
  I2C0_IC_RAW_INTR_STAT_TX_OVER_ACTIVE = 1,     /*!< ACTIVE : TX_OVER interrupt is active */
} I2C0_IC_RAW_INTR_STAT_TX_OVER_Enum;

/* =========================================  I2C0 IC_RAW_INTR_STAT RX_FULL [2..2]  ========================================== */
typedef enum {                                  /*!< I2C0_IC_RAW_INTR_STAT_RX_FULL */
  I2C0_IC_RAW_INTR_STAT_RX_FULL_INACTIVE = 0,   /*!< INACTIVE : RX_FULL interrupt is inactive */
  I2C0_IC_RAW_INTR_STAT_RX_FULL_ACTIVE = 1,     /*!< ACTIVE : RX_FULL interrupt is active */
} I2C0_IC_RAW_INTR_STAT_RX_FULL_Enum;

/* =========================================  I2C0 IC_RAW_INTR_STAT RX_OVER [1..1]  ========================================== */
typedef enum {                                  /*!< I2C0_IC_RAW_INTR_STAT_RX_OVER */
  I2C0_IC_RAW_INTR_STAT_RX_OVER_INACTIVE = 0,   /*!< INACTIVE : RX_OVER interrupt is inactive */
  I2C0_IC_RAW_INTR_STAT_RX_OVER_ACTIVE = 1,     /*!< ACTIVE : RX_OVER interrupt is active */
} I2C0_IC_RAW_INTR_STAT_RX_OVER_Enum;

/* =========================================  I2C0 IC_RAW_INTR_STAT RX_UNDER [0..0]  ========================================= */
typedef enum {                                  /*!< I2C0_IC_RAW_INTR_STAT_RX_UNDER */
  I2C0_IC_RAW_INTR_STAT_RX_UNDER_INACTIVE = 0,  /*!< INACTIVE : RX_UNDER interrupt is inactive */
  I2C0_IC_RAW_INTR_STAT_RX_UNDER_ACTIVE = 1,    /*!< ACTIVE : RX_UNDER interrupt is active */
} I2C0_IC_RAW_INTR_STAT_RX_UNDER_Enum;

/* =======================================================  IC_RX_TL  ======================================================== */
/* =======================================================  IC_TX_TL  ======================================================== */
/* ======================================================  IC_CLR_INTR  ====================================================== */
/* ====================================================  IC_CLR_RX_UNDER  ==================================================== */
/* ====================================================  IC_CLR_RX_OVER  ===================================================== */
/* ====================================================  IC_CLR_TX_OVER  ===================================================== */
/* =====================================================  IC_CLR_RD_REQ  ===================================================== */
/* ====================================================  IC_CLR_TX_ABRT  ===================================================== */
/* ====================================================  IC_CLR_RX_DONE  ===================================================== */
/* ====================================================  IC_CLR_ACTIVITY  ==================================================== */
/* ====================================================  IC_CLR_STOP_DET  ==================================================== */
/* ===================================================  IC_CLR_START_DET  ==================================================== */
/* ====================================================  IC_CLR_GEN_CALL  ==================================================== */
/* =======================================================  IC_ENABLE  ======================================================= */
/* ==========================================  I2C0 IC_ENABLE TX_CMD_BLOCK [2..2]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_ENABLE_TX_CMD_BLOCK */
  I2C0_IC_ENABLE_TX_CMD_BLOCK_NOT_BLOCKED = 0,  /*!< NOT_BLOCKED : Tx Command execution not blocked */
  I2C0_IC_ENABLE_TX_CMD_BLOCK_BLOCKED  = 1,     /*!< BLOCKED : Tx Command execution blocked */
} I2C0_IC_ENABLE_TX_CMD_BLOCK_Enum;

/* ==============================================  I2C0 IC_ENABLE ABORT [1..1]  ============================================== */
typedef enum {                                  /*!< I2C0_IC_ENABLE_ABORT */
  I2C0_IC_ENABLE_ABORT_DISABLE         = 0,     /*!< DISABLE : ABORT operation not in progress */
  I2C0_IC_ENABLE_ABORT_ENABLED         = 1,     /*!< ENABLED : ABORT operation in progress */
} I2C0_IC_ENABLE_ABORT_Enum;

/* =============================================  I2C0 IC_ENABLE ENABLE [0..0]  ============================================== */
typedef enum {                                  /*!< I2C0_IC_ENABLE_ENABLE */
  I2C0_IC_ENABLE_ENABLE_DISABLED       = 0,     /*!< DISABLED : I2C is disabled */
  I2C0_IC_ENABLE_ENABLE_ENABLED        = 1,     /*!< ENABLED : I2C is enabled */
} I2C0_IC_ENABLE_ENABLE_Enum;

/* =======================================================  IC_STATUS  ======================================================= */
/* ==========================================  I2C0 IC_STATUS SLV_ACTIVITY [6..6]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_STATUS_SLV_ACTIVITY */
  I2C0_IC_STATUS_SLV_ACTIVITY_IDLE     = 0,     /*!< IDLE : Slave is idle */
  I2C0_IC_STATUS_SLV_ACTIVITY_ACTIVE   = 1,     /*!< ACTIVE : Slave not idle */
} I2C0_IC_STATUS_SLV_ACTIVITY_Enum;

/* ==========================================  I2C0 IC_STATUS MST_ACTIVITY [5..5]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_STATUS_MST_ACTIVITY */
  I2C0_IC_STATUS_MST_ACTIVITY_IDLE     = 0,     /*!< IDLE : Master is idle */
  I2C0_IC_STATUS_MST_ACTIVITY_ACTIVE   = 1,     /*!< ACTIVE : Master not idle */
} I2C0_IC_STATUS_MST_ACTIVITY_Enum;

/* ===============================================  I2C0 IC_STATUS RFF [4..4]  =============================================== */
typedef enum {                                  /*!< I2C0_IC_STATUS_RFF */
  I2C0_IC_STATUS_RFF_NOT_FULL          = 0,     /*!< NOT_FULL : Rx FIFO not full */
  I2C0_IC_STATUS_RFF_FULL              = 1,     /*!< FULL : Rx FIFO is full */
} I2C0_IC_STATUS_RFF_Enum;

/* ==============================================  I2C0 IC_STATUS RFNE [3..3]  =============================================== */
typedef enum {                                  /*!< I2C0_IC_STATUS_RFNE */
  I2C0_IC_STATUS_RFNE_EMPTY            = 0,     /*!< EMPTY : Rx FIFO is empty */
  I2C0_IC_STATUS_RFNE_NOT_EMPTY        = 1,     /*!< NOT_EMPTY : Rx FIFO not empty */
} I2C0_IC_STATUS_RFNE_Enum;

/* ===============================================  I2C0 IC_STATUS TFE [2..2]  =============================================== */
typedef enum {                                  /*!< I2C0_IC_STATUS_TFE */
  I2C0_IC_STATUS_TFE_NON_EMPTY         = 0,     /*!< NON_EMPTY : Tx FIFO not empty */
  I2C0_IC_STATUS_TFE_EMPTY             = 1,     /*!< EMPTY : Tx FIFO is empty */
} I2C0_IC_STATUS_TFE_Enum;

/* ==============================================  I2C0 IC_STATUS TFNF [1..1]  =============================================== */
typedef enum {                                  /*!< I2C0_IC_STATUS_TFNF */
  I2C0_IC_STATUS_TFNF_FULL             = 0,     /*!< FULL : Tx FIFO is full */
  I2C0_IC_STATUS_TFNF_NOT_FULL         = 1,     /*!< NOT_FULL : Tx FIFO not full */
} I2C0_IC_STATUS_TFNF_Enum;

/* ============================================  I2C0 IC_STATUS ACTIVITY [0..0]  ============================================= */
typedef enum {                                  /*!< I2C0_IC_STATUS_ACTIVITY */
  I2C0_IC_STATUS_ACTIVITY_INACTIVE     = 0,     /*!< INACTIVE : I2C is idle */
  I2C0_IC_STATUS_ACTIVITY_ACTIVE       = 1,     /*!< ACTIVE : I2C is active */
} I2C0_IC_STATUS_ACTIVITY_Enum;

/* =======================================================  IC_TXFLR  ======================================================== */
/* =======================================================  IC_RXFLR  ======================================================== */
/* ======================================================  IC_SDA_HOLD  ====================================================== */
/* ===================================================  IC_TX_ABRT_SOURCE  =================================================== */
/* ====================================  I2C0 IC_TX_ABRT_SOURCE ABRT_USER_ABRT [16..16]  ===================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT_ABRT_USER_ABRT_VOID = 0,/*!< ABRT_USER_ABRT_VOID : Transfer abort detected by master- scenario not present */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT_ABRT_USER_ABRT_GENERATED = 1,/*!< ABRT_USER_ABRT_GENERATED : Transfer abort detected by master */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT_Enum;

/* ====================================  I2C0 IC_TX_ABRT_SOURCE ABRT_SLVRD_INTX [15..15]  ==================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX_ABRT_SLVRD_INTX_VOID = 0,/*!< ABRT_SLVRD_INTX_VOID : Slave trying to transmit to remote master in read mode- scenario not present */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX_ABRT_SLVRD_INTX_GENERATED = 1,/*!< ABRT_SLVRD_INTX_GENERATED : Slave trying to transmit to remote master in read mode */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX_Enum;

/* ===================================  I2C0 IC_TX_ABRT_SOURCE ABRT_SLV_ARBLOST [14..14]  ==================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST_ABRT_SLV_ARBLOST_VOID = 0,/*!< ABRT_SLV_ARBLOST_VOID : Slave lost arbitration to remote master- scenario not present */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST_ABRT_SLV_ARBLOST_GENERATED = 1,/*!< ABRT_SLV_ARBLOST_GENERATED : Slave lost arbitration to remote master */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST_Enum;

/* =================================  I2C0 IC_TX_ABRT_SOURCE ABRT_SLVFLUSH_TXFIFO [13..13]  ================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO_ABRT_SLVFLUSH_TXFIFO_VOID = 0,/*!< ABRT_SLVFLUSH_TXFIFO_VOID : Slave flushes existing data in TX-FIFO upon getting read command- scenario not present */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO_ABRT_SLVFLUSH_TXFIFO_GENERATED = 1,/*!< ABRT_SLVFLUSH_TXFIFO_GENERATED : Slave flushes existing data in TX-FIFO upon getting read command */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO_Enum;

/* =======================================  I2C0 IC_TX_ABRT_SOURCE ARB_LOST [12..12]  ======================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ARB_LOST */
  I2C0_IC_TX_ABRT_SOURCE_ARB_LOST_ABRT_LOST_VOID = 0,/*!< ABRT_LOST_VOID : Master or Slave-Transmitter lost arbitration- scenario not present */
  I2C0_IC_TX_ABRT_SOURCE_ARB_LOST_ABRT_LOST_GENERATED = 1,/*!< ABRT_LOST_GENERATED : Master or Slave-Transmitter lost arbitration */
} I2C0_IC_TX_ABRT_SOURCE_ARB_LOST_Enum;

/* ====================================  I2C0 IC_TX_ABRT_SOURCE ABRT_MASTER_DIS [11..11]  ==================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS_ABRT_MASTER_DIS_VOID = 0,/*!< ABRT_MASTER_DIS_VOID : User initiating master operation when MASTER disabled- scenario not present */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS_ABRT_MASTER_DIS_GENERATED = 1,/*!< ABRT_MASTER_DIS_GENERATED : User initiating master operation when MASTER disabled */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS_Enum;

/* ==================================  I2C0 IC_TX_ABRT_SOURCE ABRT_10B_RD_NORSTRT [10..10]  ================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT_ABRT_10B_RD_VOID = 0,/*!< ABRT_10B_RD_VOID : Master not trying to read in 10Bit addressing mode when RESTART disabled */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT_ABRT_10B_RD_GENERATED = 1,/*!< ABRT_10B_RD_GENERATED : Master trying to read in 10Bit addressing mode when RESTART disabled */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT_Enum;

/* ===================================  I2C0 IC_TX_ABRT_SOURCE ABRT_SBYTE_NORSTRT [9..9]  ==================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT_ABRT_SBYTE_NORSTRT_VOID = 0,/*!< ABRT_SBYTE_NORSTRT_VOID : User trying to send START byte when RESTART disabled- scenario not present */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT_ABRT_SBYTE_NORSTRT_GENERATED = 1,/*!< ABRT_SBYTE_NORSTRT_GENERATED : User trying to send START byte when RESTART disabled */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT_Enum;

/* =====================================  I2C0 IC_TX_ABRT_SOURCE ABRT_HS_NORSTRT [8..8]  ===================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT_ABRT_HS_NORSTRT_VOID = 0,/*!< ABRT_HS_NORSTRT_VOID : User trying to switch Master to HS mode when RESTART disabled- scenario not present */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT_ABRT_HS_NORSTRT_GENERATED = 1,/*!< ABRT_HS_NORSTRT_GENERATED : User trying to switch Master to HS mode when RESTART disabled */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT_Enum;

/* ====================================  I2C0 IC_TX_ABRT_SOURCE ABRT_SBYTE_ACKDET [7..7]  ==================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET_ABRT_SBYTE_ACKDET_VOID = 0,/*!< ABRT_SBYTE_ACKDET_VOID : ACK detected for START byte- scenario not present */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET_ABRT_SBYTE_ACKDET_GENERATED = 1,/*!< ABRT_SBYTE_ACKDET_GENERATED : ACK detected for START byte */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET_Enum;

/* =====================================  I2C0 IC_TX_ABRT_SOURCE ABRT_HS_ACKDET [6..6]  ====================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET_ABRT_HS_ACK_VOID = 0,/*!< ABRT_HS_ACK_VOID : HS Master code ACKed in HS Mode- scenario not present */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET_ABRT_HS_ACK_GENERATED = 1,/*!< ABRT_HS_ACK_GENERATED : HS Master code ACKed in HS Mode */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET_Enum;

/* =====================================  I2C0 IC_TX_ABRT_SOURCE ABRT_GCALL_READ [5..5]  ===================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ_ABRT_GCALL_READ_VOID = 0,/*!< ABRT_GCALL_READ_VOID : GCALL is followed by read from bus-scenario not present */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ_ABRT_GCALL_READ_GENERATED = 1,/*!< ABRT_GCALL_READ_GENERATED : GCALL is followed by read from bus */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ_Enum;

/* ====================================  I2C0 IC_TX_ABRT_SOURCE ABRT_GCALL_NOACK [4..4]  ===================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK_ABRT_GCALL_NOACK_VOID = 0,/*!< ABRT_GCALL_NOACK_VOID : GCALL not ACKed by any slave-scenario not present */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK_ABRT_GCALL_NOACK_GENERATED = 1,/*!< ABRT_GCALL_NOACK_GENERATED : GCALL not ACKed by any slave */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK_Enum;

/* ====================================  I2C0 IC_TX_ABRT_SOURCE ABRT_TXDATA_NOACK [3..3]  ==================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK_ABRT_TXDATA_NOACK_VOID = 0,/*!< ABRT_TXDATA_NOACK_VOID : Transmitted data non-ACKed by addressed slave-scenario not present */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK_ABRT_TXDATA_NOACK_GENERATED = 1,/*!< ABRT_TXDATA_NOACK_GENERATED : Transmitted data not ACKed by addressed slave */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK_Enum;

/* ===================================  I2C0 IC_TX_ABRT_SOURCE ABRT_10ADDR2_NOACK [2..2]  ==================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK_INACTIVE = 0,/*!< INACTIVE : This abort is not generated */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK_ACTIVE = 1,/*!< ACTIVE : Byte 2 of 10Bit Address not ACKed by any slave */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK_Enum;

/* ===================================  I2C0 IC_TX_ABRT_SOURCE ABRT_10ADDR1_NOACK [1..1]  ==================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK_INACTIVE = 0,/*!< INACTIVE : This abort is not generated */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK_ACTIVE = 1,/*!< ACTIVE : Byte 1 of 10Bit Address not ACKed by any slave */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK_Enum;

/* ===================================  I2C0 IC_TX_ABRT_SOURCE ABRT_7B_ADDR_NOACK [0..0]  ==================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK_INACTIVE = 0,/*!< INACTIVE : This abort is not generated */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK_ACTIVE = 1,/*!< ACTIVE : This abort is generated because of NOACK for 7-bit address */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK_Enum;

/* =================================================  IC_SLV_DATA_NACK_ONLY  ================================================= */
/* ========================================  I2C0 IC_SLV_DATA_NACK_ONLY NACK [0..0]  ========================================= */
typedef enum {                                  /*!< I2C0_IC_SLV_DATA_NACK_ONLY_NACK */
  I2C0_IC_SLV_DATA_NACK_ONLY_NACK_DISABLED = 0, /*!< DISABLED : Slave receiver generates NACK normally */
  I2C0_IC_SLV_DATA_NACK_ONLY_NACK_ENABLED = 1,  /*!< ENABLED : Slave receiver generates NACK upon data reception only */
} I2C0_IC_SLV_DATA_NACK_ONLY_NACK_Enum;

/* =======================================================  IC_DMA_CR  ======================================================= */
/* ==============================================  I2C0 IC_DMA_CR TDMAE [1..1]  ============================================== */
typedef enum {                                  /*!< I2C0_IC_DMA_CR_TDMAE */
  I2C0_IC_DMA_CR_TDMAE_DISABLED        = 0,     /*!< DISABLED : transmit FIFO DMA channel disabled */
  I2C0_IC_DMA_CR_TDMAE_ENABLED         = 1,     /*!< ENABLED : Transmit FIFO DMA channel enabled */
} I2C0_IC_DMA_CR_TDMAE_Enum;

/* ==============================================  I2C0 IC_DMA_CR RDMAE [0..0]  ============================================== */
typedef enum {                                  /*!< I2C0_IC_DMA_CR_RDMAE */
  I2C0_IC_DMA_CR_RDMAE_DISABLED        = 0,     /*!< DISABLED : Receive FIFO DMA channel disabled */
  I2C0_IC_DMA_CR_RDMAE_ENABLED         = 1,     /*!< ENABLED : Receive FIFO DMA channel enabled */
} I2C0_IC_DMA_CR_RDMAE_Enum;

/* ======================================================  IC_DMA_TDLR  ====================================================== */
/* ======================================================  IC_DMA_RDLR  ====================================================== */
/* =====================================================  IC_SDA_SETUP  ====================================================== */
/* ==================================================  IC_ACK_GENERAL_CALL  ================================================== */
/* =====================================  I2C0 IC_ACK_GENERAL_CALL ACK_GEN_CALL [0..0]  ====================================== */
typedef enum {                                  /*!< I2C0_IC_ACK_GENERAL_CALL_ACK_GEN_CALL */
  I2C0_IC_ACK_GENERAL_CALL_ACK_GEN_CALL_DISABLED = 0,/*!< DISABLED : Generate NACK for a General Call */
  I2C0_IC_ACK_GENERAL_CALL_ACK_GEN_CALL_ENABLED = 1,/*!< ENABLED : Generate ACK for a General Call */
} I2C0_IC_ACK_GENERAL_CALL_ACK_GEN_CALL_Enum;

/* ===================================================  IC_ENABLE_STATUS  ==================================================== */
/* =====================================  I2C0 IC_ENABLE_STATUS SLV_RX_DATA_LOST [2..2]  ===================================== */
typedef enum {                                  /*!< I2C0_IC_ENABLE_STATUS_SLV_RX_DATA_LOST */
  I2C0_IC_ENABLE_STATUS_SLV_RX_DATA_LOST_INACTIVE = 0,/*!< INACTIVE : Slave RX Data is not lost */
  I2C0_IC_ENABLE_STATUS_SLV_RX_DATA_LOST_ACTIVE = 1,/*!< ACTIVE : Slave RX Data is lost */
} I2C0_IC_ENABLE_STATUS_SLV_RX_DATA_LOST_Enum;

/* =================================  I2C0 IC_ENABLE_STATUS SLV_DISABLED_WHILE_BUSY [1..1]  ================================== */
typedef enum {                                  /*!< I2C0_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY */
  I2C0_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY_INACTIVE = 0,/*!< INACTIVE : Slave is disabled when it is idle */
  I2C0_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY_ACTIVE = 1,/*!< ACTIVE : Slave is disabled when it is active */
} I2C0_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY_Enum;

/* ==========================================  I2C0 IC_ENABLE_STATUS IC_EN [0..0]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_ENABLE_STATUS_IC_EN */
  I2C0_IC_ENABLE_STATUS_IC_EN_DISABLED = 0,     /*!< DISABLED : I2C disabled */
  I2C0_IC_ENABLE_STATUS_IC_EN_ENABLED  = 1,     /*!< ENABLED : I2C enabled */
} I2C0_IC_ENABLE_STATUS_IC_EN_Enum;

/* =====================================================  IC_FS_SPKLEN  ====================================================== */
/* ==================================================  IC_CLR_RESTART_DET  =================================================== */
/* ====================================================  IC_COMP_PARAM_1  ==================================================== */
/* ====================================================  IC_COMP_VERSION  ==================================================== */
/* =====================================================  IC_COMP_TYPE  ====================================================== */


/* =========================================================================================================================== */
/* ================                                            ADC                                            ================ */
/* =========================================================================================================================== */

/* ==========================================================  CS  =========================================================== */
/* ========================================================  RESULT  ========================================================= */
/* ==========================================================  FCS  ========================================================== */
/* =========================================================  FIFO  ========================================================== */
/* ==========================================================  DIV  ========================================================== */
/* =========================================================  INTR  ========================================================== */
/* =========================================================  INTE  ========================================================== */
/* =========================================================  INTF  ========================================================== */
/* =========================================================  INTS  ========================================================== */


/* =========================================================================================================================== */
/* ================                                            PWM                                            ================ */
/* =========================================================================================================================== */

/* ========================================================  CH0_CSR  ======================================================== */
/* ==============================================  PWM CH0_CSR DIVMODE [4..5]  =============================================== */
typedef enum {                                  /*!< PWM_CH0_CSR_DIVMODE */
  PWM_CH0_CSR_DIVMODE_div              = 0,     /*!< div : Free-running counting at rate dictated by fractional divider */
  PWM_CH0_CSR_DIVMODE_level            = 1,     /*!< level : Fractional divider operation is gated by the PWM B pin. */
  PWM_CH0_CSR_DIVMODE_rise             = 2,     /*!< rise : Counter advances with each rising edge of the PWM B pin. */
  PWM_CH0_CSR_DIVMODE_fall             = 3,     /*!< fall : Counter advances with each falling edge of the PWM B pin. */
} PWM_CH0_CSR_DIVMODE_Enum;

/* ========================================================  CH0_DIV  ======================================================== */
/* ========================================================  CH0_CTR  ======================================================== */
/* ========================================================  CH0_CC  ========================================================= */
/* ========================================================  CH0_TOP  ======================================================== */
/* ========================================================  CH1_CSR  ======================================================== */
/* ==============================================  PWM CH1_CSR DIVMODE [4..5]  =============================================== */
typedef enum {                                  /*!< PWM_CH1_CSR_DIVMODE */
  PWM_CH1_CSR_DIVMODE_div              = 0,     /*!< div : Free-running counting at rate dictated by fractional divider */
  PWM_CH1_CSR_DIVMODE_level            = 1,     /*!< level : Fractional divider operation is gated by the PWM B pin. */
  PWM_CH1_CSR_DIVMODE_rise             = 2,     /*!< rise : Counter advances with each rising edge of the PWM B pin. */
  PWM_CH1_CSR_DIVMODE_fall             = 3,     /*!< fall : Counter advances with each falling edge of the PWM B pin. */
} PWM_CH1_CSR_DIVMODE_Enum;

/* ========================================================  CH1_DIV  ======================================================== */
/* ========================================================  CH1_CTR  ======================================================== */
/* ========================================================  CH1_CC  ========================================================= */
/* ========================================================  CH1_TOP  ======================================================== */
/* ========================================================  CH2_CSR  ======================================================== */
/* ==============================================  PWM CH2_CSR DIVMODE [4..5]  =============================================== */
typedef enum {                                  /*!< PWM_CH2_CSR_DIVMODE */
  PWM_CH2_CSR_DIVMODE_div              = 0,     /*!< div : Free-running counting at rate dictated by fractional divider */
  PWM_CH2_CSR_DIVMODE_level            = 1,     /*!< level : Fractional divider operation is gated by the PWM B pin. */
  PWM_CH2_CSR_DIVMODE_rise             = 2,     /*!< rise : Counter advances with each rising edge of the PWM B pin. */
  PWM_CH2_CSR_DIVMODE_fall             = 3,     /*!< fall : Counter advances with each falling edge of the PWM B pin. */
} PWM_CH2_CSR_DIVMODE_Enum;

/* ========================================================  CH2_DIV  ======================================================== */
/* ========================================================  CH2_CTR  ======================================================== */
/* ========================================================  CH2_CC  ========================================================= */
/* ========================================================  CH2_TOP  ======================================================== */
/* ========================================================  CH3_CSR  ======================================================== */
/* ==============================================  PWM CH3_CSR DIVMODE [4..5]  =============================================== */
typedef enum {                                  /*!< PWM_CH3_CSR_DIVMODE */
  PWM_CH3_CSR_DIVMODE_div              = 0,     /*!< div : Free-running counting at rate dictated by fractional divider */
  PWM_CH3_CSR_DIVMODE_level            = 1,     /*!< level : Fractional divider operation is gated by the PWM B pin. */
  PWM_CH3_CSR_DIVMODE_rise             = 2,     /*!< rise : Counter advances with each rising edge of the PWM B pin. */
  PWM_CH3_CSR_DIVMODE_fall             = 3,     /*!< fall : Counter advances with each falling edge of the PWM B pin. */
} PWM_CH3_CSR_DIVMODE_Enum;

/* ========================================================  CH3_DIV  ======================================================== */
/* ========================================================  CH3_CTR  ======================================================== */
/* ========================================================  CH3_CC  ========================================================= */
/* ========================================================  CH3_TOP  ======================================================== */
/* ========================================================  CH4_CSR  ======================================================== */
/* ==============================================  PWM CH4_CSR DIVMODE [4..5]  =============================================== */
typedef enum {                                  /*!< PWM_CH4_CSR_DIVMODE */
  PWM_CH4_CSR_DIVMODE_div              = 0,     /*!< div : Free-running counting at rate dictated by fractional divider */
  PWM_CH4_CSR_DIVMODE_level            = 1,     /*!< level : Fractional divider operation is gated by the PWM B pin. */
  PWM_CH4_CSR_DIVMODE_rise             = 2,     /*!< rise : Counter advances with each rising edge of the PWM B pin. */
  PWM_CH4_CSR_DIVMODE_fall             = 3,     /*!< fall : Counter advances with each falling edge of the PWM B pin. */
} PWM_CH4_CSR_DIVMODE_Enum;

/* ========================================================  CH4_DIV  ======================================================== */
/* ========================================================  CH4_CTR  ======================================================== */
/* ========================================================  CH4_CC  ========================================================= */
/* ========================================================  CH4_TOP  ======================================================== */
/* ========================================================  CH5_CSR  ======================================================== */
/* ==============================================  PWM CH5_CSR DIVMODE [4..5]  =============================================== */
typedef enum {                                  /*!< PWM_CH5_CSR_DIVMODE */
  PWM_CH5_CSR_DIVMODE_div              = 0,     /*!< div : Free-running counting at rate dictated by fractional divider */
  PWM_CH5_CSR_DIVMODE_level            = 1,     /*!< level : Fractional divider operation is gated by the PWM B pin. */
  PWM_CH5_CSR_DIVMODE_rise             = 2,     /*!< rise : Counter advances with each rising edge of the PWM B pin. */
  PWM_CH5_CSR_DIVMODE_fall             = 3,     /*!< fall : Counter advances with each falling edge of the PWM B pin. */
} PWM_CH5_CSR_DIVMODE_Enum;

/* ========================================================  CH5_DIV  ======================================================== */
/* ========================================================  CH5_CTR  ======================================================== */
/* ========================================================  CH5_CC  ========================================================= */
/* ========================================================  CH5_TOP  ======================================================== */
/* ========================================================  CH6_CSR  ======================================================== */
/* ==============================================  PWM CH6_CSR DIVMODE [4..5]  =============================================== */
typedef enum {                                  /*!< PWM_CH6_CSR_DIVMODE */
  PWM_CH6_CSR_DIVMODE_div              = 0,     /*!< div : Free-running counting at rate dictated by fractional divider */
  PWM_CH6_CSR_DIVMODE_level            = 1,     /*!< level : Fractional divider operation is gated by the PWM B pin. */
  PWM_CH6_CSR_DIVMODE_rise             = 2,     /*!< rise : Counter advances with each rising edge of the PWM B pin. */
  PWM_CH6_CSR_DIVMODE_fall             = 3,     /*!< fall : Counter advances with each falling edge of the PWM B pin. */
} PWM_CH6_CSR_DIVMODE_Enum;

/* ========================================================  CH6_DIV  ======================================================== */
/* ========================================================  CH6_CTR  ======================================================== */
/* ========================================================  CH6_CC  ========================================================= */
/* ========================================================  CH6_TOP  ======================================================== */
/* ========================================================  CH7_CSR  ======================================================== */
/* ==============================================  PWM CH7_CSR DIVMODE [4..5]  =============================================== */
typedef enum {                                  /*!< PWM_CH7_CSR_DIVMODE */
  PWM_CH7_CSR_DIVMODE_div              = 0,     /*!< div : Free-running counting at rate dictated by fractional divider */
  PWM_CH7_CSR_DIVMODE_level            = 1,     /*!< level : Fractional divider operation is gated by the PWM B pin. */
  PWM_CH7_CSR_DIVMODE_rise             = 2,     /*!< rise : Counter advances with each rising edge of the PWM B pin. */
  PWM_CH7_CSR_DIVMODE_fall             = 3,     /*!< fall : Counter advances with each falling edge of the PWM B pin. */
} PWM_CH7_CSR_DIVMODE_Enum;

/* ========================================================  CH7_DIV  ======================================================== */
/* ========================================================  CH7_CTR  ======================================================== */
/* ========================================================  CH7_CC  ========================================================= */
/* ========================================================  CH7_TOP  ======================================================== */
/* ==========================================================  EN  =========================================================== */
/* =========================================================  INTR  ========================================================== */
/* =========================================================  INTE  ========================================================== */
/* =========================================================  INTF  ========================================================== */
/* =========================================================  INTS  ========================================================== */


/* =========================================================================================================================== */
/* ================                                           TIMER                                           ================ */
/* =========================================================================================================================== */

/* ========================================================  TIMEHW  ========================================================= */
/* ========================================================  TIMELW  ========================================================= */
/* ========================================================  TIMEHR  ========================================================= */
/* ========================================================  TIMELR  ========================================================= */
/* ========================================================  ALARM0  ========================================================= */
/* ========================================================  ALARM1  ========================================================= */
/* ========================================================  ALARM2  ========================================================= */
/* ========================================================  ALARM3  ========================================================= */
/* =========================================================  ARMED  ========================================================= */
/* =======================================================  TIMERAWH  ======================================================== */
/* =======================================================  TIMERAWL  ======================================================== */
/* =======================================================  DBGPAUSE  ======================================================== */
/* =========================================================  PAUSE  ========================================================= */
/* =========================================================  INTR  ========================================================== */
/* =========================================================  INTE  ========================================================== */
/* =========================================================  INTF  ========================================================== */
/* =========================================================  INTS  ========================================================== */


/* =========================================================================================================================== */
/* ================                                         WATCHDOG                                          ================ */
/* =========================================================================================================================== */

/* =========================================================  CTRL  ========================================================== */
/* =========================================================  LOAD  ========================================================== */
/* ========================================================  REASON  ========================================================= */
/* =======================================================  SCRATCH0  ======================================================== */
/* =======================================================  SCRATCH1  ======================================================== */
/* =======================================================  SCRATCH2  ======================================================== */
/* =======================================================  SCRATCH3  ======================================================== */
/* =======================================================  SCRATCH4  ======================================================== */
/* =======================================================  SCRATCH5  ======================================================== */
/* =======================================================  SCRATCH6  ======================================================== */
/* =======================================================  SCRATCH7  ======================================================== */
/* =========================================================  TICK  ========================================================== */


/* =========================================================================================================================== */
/* ================                                            RTC                                            ================ */
/* =========================================================================================================================== */

/* =======================================================  CLKDIV_M1  ======================================================= */
/* ========================================================  SETUP_0  ======================================================== */
/* ========================================================  SETUP_1  ======================================================== */
/* =========================================================  CTRL  ========================================================== */
/* ======================================================  IRQ_SETUP_0  ====================================================== */
/* ======================================================  IRQ_SETUP_1  ====================================================== */
/* =========================================================  RTC_1  ========================================================= */
/* =========================================================  RTC_0  ========================================================= */
/* =========================================================  INTR  ========================================================== */
/* =========================================================  INTE  ========================================================== */
/* =========================================================  INTF  ========================================================== */
/* =========================================================  INTS  ========================================================== */


/* =========================================================================================================================== */
/* ================                                           ROSC                                            ================ */
/* =========================================================================================================================== */

/* =========================================================  CTRL  ========================================================== */
/* ===============================================  ROSC CTRL ENABLE [12..23]  =============================================== */
typedef enum {                                  /*!< ROSC_CTRL_ENABLE */
  ROSC_CTRL_ENABLE_DISABLE             = 3358,  /*!< DISABLE : DISABLE */
  ROSC_CTRL_ENABLE_ENABLE              = 4011,  /*!< ENABLE : ENABLE */
} ROSC_CTRL_ENABLE_Enum;

/* =============================================  ROSC CTRL FREQ_RANGE [0..11]  ============================================== */
typedef enum {                                  /*!< ROSC_CTRL_FREQ_RANGE */
  ROSC_CTRL_FREQ_RANGE_LOW             = 4004,  /*!< LOW : LOW */
  ROSC_CTRL_FREQ_RANGE_MEDIUM          = 4005,  /*!< MEDIUM : MEDIUM */
  ROSC_CTRL_FREQ_RANGE_HIGH            = 4007,  /*!< HIGH : HIGH */
  ROSC_CTRL_FREQ_RANGE_TOOHIGH         = 4006,  /*!< TOOHIGH : TOOHIGH */
} ROSC_CTRL_FREQ_RANGE_Enum;

/* =========================================================  FREQA  ========================================================= */
/* ==============================================  ROSC FREQA PASSWD [16..31]  =============================================== */
typedef enum {                                  /*!< ROSC_FREQA_PASSWD */
  ROSC_FREQA_PASSWD_PASS               = 38550, /*!< PASS : PASS */
} ROSC_FREQA_PASSWD_Enum;

/* =========================================================  FREQB  ========================================================= */
/* ==============================================  ROSC FREQB PASSWD [16..31]  =============================================== */
typedef enum {                                  /*!< ROSC_FREQB_PASSWD */
  ROSC_FREQB_PASSWD_PASS               = 38550, /*!< PASS : PASS */
} ROSC_FREQB_PASSWD_Enum;

/* ========================================================  DORMANT  ======================================================== */
/* ==========================================================  DIV  ========================================================== */
/* =================================================  ROSC DIV DIV [0..11]  ================================================== */
typedef enum {                                  /*!< ROSC_DIV_DIV */
  ROSC_DIV_DIV_PASS                    = 2720,  /*!< PASS : PASS */
} ROSC_DIV_DIV_Enum;

/* =========================================================  PHASE  ========================================================= */
/* ========================================================  STATUS  ========================================================= */
/* =======================================================  RANDOMBIT  ======================================================= */
/* =========================================================  COUNT  ========================================================= */


/* =========================================================================================================================== */
/* ================                                    VREG_AND_CHIP_RESET                                    ================ */
/* =========================================================================================================================== */

/* =========================================================  VREG  ========================================================== */
/* ==========================================================  BOD  ========================================================== */
/* ======================================================  CHIP_RESET  ======================================================= */


/* =========================================================================================================================== */
/* ================                                           TBMAN                                           ================ */
/* =========================================================================================================================== */

/* =======================================================  PLATFORM  ======================================================== */


/* =========================================================================================================================== */
/* ================                                            DMA                                            ================ */
/* =========================================================================================================================== */

/* =====================================================  CH0_READ_ADDR  ===================================================== */
/* ====================================================  CH0_WRITE_ADDR  ===================================================== */
/* ====================================================  CH0_TRANS_COUNT  ==================================================== */
/* =====================================================  CH0_CTRL_TRIG  ===================================================== */
/* ==========================================  DMA CH0_CTRL_TRIG TREQ_SEL [15..20]  ========================================== */
typedef enum {                                  /*!< DMA_CH0_CTRL_TRIG_TREQ_SEL */
  DMA_CH0_CTRL_TRIG_TREQ_SEL_TIMER0    = 59,    /*!< TIMER0 : Select Timer 0 as TREQ */
  DMA_CH0_CTRL_TRIG_TREQ_SEL_TIMER1    = 60,    /*!< TIMER1 : Select Timer 1 as TREQ */
  DMA_CH0_CTRL_TRIG_TREQ_SEL_TIMER2    = 61,    /*!< TIMER2 : Select Timer 2 as TREQ (Optional) */
  DMA_CH0_CTRL_TRIG_TREQ_SEL_TIMER3    = 62,    /*!< TIMER3 : Select Timer 3 as TREQ (Optional) */
  DMA_CH0_CTRL_TRIG_TREQ_SEL_PERMANENT = 63,    /*!< PERMANENT : Permanent request, for unpaced transfers. */
} DMA_CH0_CTRL_TRIG_TREQ_SEL_Enum;

/* ==========================================  DMA CH0_CTRL_TRIG RING_SIZE [6..9]  =========================================== */
typedef enum {                                  /*!< DMA_CH0_CTRL_TRIG_RING_SIZE */
  DMA_CH0_CTRL_TRIG_RING_SIZE_RING_NONE = 0,    /*!< RING_NONE : RING_NONE */
} DMA_CH0_CTRL_TRIG_RING_SIZE_Enum;

/* ==========================================  DMA CH0_CTRL_TRIG DATA_SIZE [2..3]  =========================================== */
typedef enum {                                  /*!< DMA_CH0_CTRL_TRIG_DATA_SIZE */
  DMA_CH0_CTRL_TRIG_DATA_SIZE_SIZE_BYTE = 0,    /*!< SIZE_BYTE : SIZE_BYTE */
  DMA_CH0_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 1,/*!< SIZE_HALFWORD : SIZE_HALFWORD */
  DMA_CH0_CTRL_TRIG_DATA_SIZE_SIZE_WORD = 2,    /*!< SIZE_WORD : SIZE_WORD */
} DMA_CH0_CTRL_TRIG_DATA_SIZE_Enum;

/* =====================================================  CH0_AL1_CTRL  ====================================================== */
/* ===================================================  CH0_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH0_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH0_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH0_AL2_CTRL  ====================================================== */
/* ==================================================  CH0_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH0_AL2_READ_ADDR  =================================================== */
/* ================================================  CH0_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH0_AL3_CTRL  ====================================================== */
/* ==================================================  CH0_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH0_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH0_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH1_READ_ADDR  ===================================================== */
/* ====================================================  CH1_WRITE_ADDR  ===================================================== */
/* ====================================================  CH1_TRANS_COUNT  ==================================================== */
/* =====================================================  CH1_CTRL_TRIG  ===================================================== */
/* ==========================================  DMA CH1_CTRL_TRIG TREQ_SEL [15..20]  ========================================== */
typedef enum {                                  /*!< DMA_CH1_CTRL_TRIG_TREQ_SEL */
  DMA_CH1_CTRL_TRIG_TREQ_SEL_TIMER0    = 59,    /*!< TIMER0 : Select Timer 0 as TREQ */
  DMA_CH1_CTRL_TRIG_TREQ_SEL_TIMER1    = 60,    /*!< TIMER1 : Select Timer 1 as TREQ */
  DMA_CH1_CTRL_TRIG_TREQ_SEL_TIMER2    = 61,    /*!< TIMER2 : Select Timer 2 as TREQ (Optional) */
  DMA_CH1_CTRL_TRIG_TREQ_SEL_TIMER3    = 62,    /*!< TIMER3 : Select Timer 3 as TREQ (Optional) */
  DMA_CH1_CTRL_TRIG_TREQ_SEL_PERMANENT = 63,    /*!< PERMANENT : Permanent request, for unpaced transfers. */
} DMA_CH1_CTRL_TRIG_TREQ_SEL_Enum;

/* ==========================================  DMA CH1_CTRL_TRIG RING_SIZE [6..9]  =========================================== */
typedef enum {                                  /*!< DMA_CH1_CTRL_TRIG_RING_SIZE */
  DMA_CH1_CTRL_TRIG_RING_SIZE_RING_NONE = 0,    /*!< RING_NONE : RING_NONE */
} DMA_CH1_CTRL_TRIG_RING_SIZE_Enum;

/* ==========================================  DMA CH1_CTRL_TRIG DATA_SIZE [2..3]  =========================================== */
typedef enum {                                  /*!< DMA_CH1_CTRL_TRIG_DATA_SIZE */
  DMA_CH1_CTRL_TRIG_DATA_SIZE_SIZE_BYTE = 0,    /*!< SIZE_BYTE : SIZE_BYTE */
  DMA_CH1_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 1,/*!< SIZE_HALFWORD : SIZE_HALFWORD */
  DMA_CH1_CTRL_TRIG_DATA_SIZE_SIZE_WORD = 2,    /*!< SIZE_WORD : SIZE_WORD */
} DMA_CH1_CTRL_TRIG_DATA_SIZE_Enum;

/* =====================================================  CH1_AL1_CTRL  ====================================================== */
/* ===================================================  CH1_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH1_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH1_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH1_AL2_CTRL  ====================================================== */
/* ==================================================  CH1_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH1_AL2_READ_ADDR  =================================================== */
/* ================================================  CH1_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH1_AL3_CTRL  ====================================================== */
/* ==================================================  CH1_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH1_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH1_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH2_READ_ADDR  ===================================================== */
/* ====================================================  CH2_WRITE_ADDR  ===================================================== */
/* ====================================================  CH2_TRANS_COUNT  ==================================================== */
/* =====================================================  CH2_CTRL_TRIG  ===================================================== */
/* ==========================================  DMA CH2_CTRL_TRIG TREQ_SEL [15..20]  ========================================== */
typedef enum {                                  /*!< DMA_CH2_CTRL_TRIG_TREQ_SEL */
  DMA_CH2_CTRL_TRIG_TREQ_SEL_TIMER0    = 59,    /*!< TIMER0 : Select Timer 0 as TREQ */
  DMA_CH2_CTRL_TRIG_TREQ_SEL_TIMER1    = 60,    /*!< TIMER1 : Select Timer 1 as TREQ */
  DMA_CH2_CTRL_TRIG_TREQ_SEL_TIMER2    = 61,    /*!< TIMER2 : Select Timer 2 as TREQ (Optional) */
  DMA_CH2_CTRL_TRIG_TREQ_SEL_TIMER3    = 62,    /*!< TIMER3 : Select Timer 3 as TREQ (Optional) */
  DMA_CH2_CTRL_TRIG_TREQ_SEL_PERMANENT = 63,    /*!< PERMANENT : Permanent request, for unpaced transfers. */
} DMA_CH2_CTRL_TRIG_TREQ_SEL_Enum;

/* ==========================================  DMA CH2_CTRL_TRIG RING_SIZE [6..9]  =========================================== */
typedef enum {                                  /*!< DMA_CH2_CTRL_TRIG_RING_SIZE */
  DMA_CH2_CTRL_TRIG_RING_SIZE_RING_NONE = 0,    /*!< RING_NONE : RING_NONE */
} DMA_CH2_CTRL_TRIG_RING_SIZE_Enum;

/* ==========================================  DMA CH2_CTRL_TRIG DATA_SIZE [2..3]  =========================================== */
typedef enum {                                  /*!< DMA_CH2_CTRL_TRIG_DATA_SIZE */
  DMA_CH2_CTRL_TRIG_DATA_SIZE_SIZE_BYTE = 0,    /*!< SIZE_BYTE : SIZE_BYTE */
  DMA_CH2_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 1,/*!< SIZE_HALFWORD : SIZE_HALFWORD */
  DMA_CH2_CTRL_TRIG_DATA_SIZE_SIZE_WORD = 2,    /*!< SIZE_WORD : SIZE_WORD */
} DMA_CH2_CTRL_TRIG_DATA_SIZE_Enum;

/* =====================================================  CH2_AL1_CTRL  ====================================================== */
/* ===================================================  CH2_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH2_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH2_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH2_AL2_CTRL  ====================================================== */
/* ==================================================  CH2_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH2_AL2_READ_ADDR  =================================================== */
/* ================================================  CH2_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH2_AL3_CTRL  ====================================================== */
/* ==================================================  CH2_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH2_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH2_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH3_READ_ADDR  ===================================================== */
/* ====================================================  CH3_WRITE_ADDR  ===================================================== */
/* ====================================================  CH3_TRANS_COUNT  ==================================================== */
/* =====================================================  CH3_CTRL_TRIG  ===================================================== */
/* ==========================================  DMA CH3_CTRL_TRIG TREQ_SEL [15..20]  ========================================== */
typedef enum {                                  /*!< DMA_CH3_CTRL_TRIG_TREQ_SEL */
  DMA_CH3_CTRL_TRIG_TREQ_SEL_TIMER0    = 59,    /*!< TIMER0 : Select Timer 0 as TREQ */
  DMA_CH3_CTRL_TRIG_TREQ_SEL_TIMER1    = 60,    /*!< TIMER1 : Select Timer 1 as TREQ */
  DMA_CH3_CTRL_TRIG_TREQ_SEL_TIMER2    = 61,    /*!< TIMER2 : Select Timer 2 as TREQ (Optional) */
  DMA_CH3_CTRL_TRIG_TREQ_SEL_TIMER3    = 62,    /*!< TIMER3 : Select Timer 3 as TREQ (Optional) */
  DMA_CH3_CTRL_TRIG_TREQ_SEL_PERMANENT = 63,    /*!< PERMANENT : Permanent request, for unpaced transfers. */
} DMA_CH3_CTRL_TRIG_TREQ_SEL_Enum;

/* ==========================================  DMA CH3_CTRL_TRIG RING_SIZE [6..9]  =========================================== */
typedef enum {                                  /*!< DMA_CH3_CTRL_TRIG_RING_SIZE */
  DMA_CH3_CTRL_TRIG_RING_SIZE_RING_NONE = 0,    /*!< RING_NONE : RING_NONE */
} DMA_CH3_CTRL_TRIG_RING_SIZE_Enum;

/* ==========================================  DMA CH3_CTRL_TRIG DATA_SIZE [2..3]  =========================================== */
typedef enum {                                  /*!< DMA_CH3_CTRL_TRIG_DATA_SIZE */
  DMA_CH3_CTRL_TRIG_DATA_SIZE_SIZE_BYTE = 0,    /*!< SIZE_BYTE : SIZE_BYTE */
  DMA_CH3_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 1,/*!< SIZE_HALFWORD : SIZE_HALFWORD */
  DMA_CH3_CTRL_TRIG_DATA_SIZE_SIZE_WORD = 2,    /*!< SIZE_WORD : SIZE_WORD */
} DMA_CH3_CTRL_TRIG_DATA_SIZE_Enum;

/* =====================================================  CH3_AL1_CTRL  ====================================================== */
/* ===================================================  CH3_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH3_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH3_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH3_AL2_CTRL  ====================================================== */
/* ==================================================  CH3_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH3_AL2_READ_ADDR  =================================================== */
/* ================================================  CH3_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH3_AL3_CTRL  ====================================================== */
/* ==================================================  CH3_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH3_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH3_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH4_READ_ADDR  ===================================================== */
/* ====================================================  CH4_WRITE_ADDR  ===================================================== */
/* ====================================================  CH4_TRANS_COUNT  ==================================================== */
/* =====================================================  CH4_CTRL_TRIG  ===================================================== */
/* ==========================================  DMA CH4_CTRL_TRIG TREQ_SEL [15..20]  ========================================== */
typedef enum {                                  /*!< DMA_CH4_CTRL_TRIG_TREQ_SEL */
  DMA_CH4_CTRL_TRIG_TREQ_SEL_TIMER0    = 59,    /*!< TIMER0 : Select Timer 0 as TREQ */
  DMA_CH4_CTRL_TRIG_TREQ_SEL_TIMER1    = 60,    /*!< TIMER1 : Select Timer 1 as TREQ */
  DMA_CH4_CTRL_TRIG_TREQ_SEL_TIMER2    = 61,    /*!< TIMER2 : Select Timer 2 as TREQ (Optional) */
  DMA_CH4_CTRL_TRIG_TREQ_SEL_TIMER3    = 62,    /*!< TIMER3 : Select Timer 3 as TREQ (Optional) */
  DMA_CH4_CTRL_TRIG_TREQ_SEL_PERMANENT = 63,    /*!< PERMANENT : Permanent request, for unpaced transfers. */
} DMA_CH4_CTRL_TRIG_TREQ_SEL_Enum;

/* ==========================================  DMA CH4_CTRL_TRIG RING_SIZE [6..9]  =========================================== */
typedef enum {                                  /*!< DMA_CH4_CTRL_TRIG_RING_SIZE */
  DMA_CH4_CTRL_TRIG_RING_SIZE_RING_NONE = 0,    /*!< RING_NONE : RING_NONE */
} DMA_CH4_CTRL_TRIG_RING_SIZE_Enum;

/* ==========================================  DMA CH4_CTRL_TRIG DATA_SIZE [2..3]  =========================================== */
typedef enum {                                  /*!< DMA_CH4_CTRL_TRIG_DATA_SIZE */
  DMA_CH4_CTRL_TRIG_DATA_SIZE_SIZE_BYTE = 0,    /*!< SIZE_BYTE : SIZE_BYTE */
  DMA_CH4_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 1,/*!< SIZE_HALFWORD : SIZE_HALFWORD */
  DMA_CH4_CTRL_TRIG_DATA_SIZE_SIZE_WORD = 2,    /*!< SIZE_WORD : SIZE_WORD */
} DMA_CH4_CTRL_TRIG_DATA_SIZE_Enum;

/* =====================================================  CH4_AL1_CTRL  ====================================================== */
/* ===================================================  CH4_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH4_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH4_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH4_AL2_CTRL  ====================================================== */
/* ==================================================  CH4_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH4_AL2_READ_ADDR  =================================================== */
/* ================================================  CH4_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH4_AL3_CTRL  ====================================================== */
/* ==================================================  CH4_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH4_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH4_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH5_READ_ADDR  ===================================================== */
/* ====================================================  CH5_WRITE_ADDR  ===================================================== */
/* ====================================================  CH5_TRANS_COUNT  ==================================================== */
/* =====================================================  CH5_CTRL_TRIG  ===================================================== */
/* ==========================================  DMA CH5_CTRL_TRIG TREQ_SEL [15..20]  ========================================== */
typedef enum {                                  /*!< DMA_CH5_CTRL_TRIG_TREQ_SEL */
  DMA_CH5_CTRL_TRIG_TREQ_SEL_TIMER0    = 59,    /*!< TIMER0 : Select Timer 0 as TREQ */
  DMA_CH5_CTRL_TRIG_TREQ_SEL_TIMER1    = 60,    /*!< TIMER1 : Select Timer 1 as TREQ */
  DMA_CH5_CTRL_TRIG_TREQ_SEL_TIMER2    = 61,    /*!< TIMER2 : Select Timer 2 as TREQ (Optional) */
  DMA_CH5_CTRL_TRIG_TREQ_SEL_TIMER3    = 62,    /*!< TIMER3 : Select Timer 3 as TREQ (Optional) */
  DMA_CH5_CTRL_TRIG_TREQ_SEL_PERMANENT = 63,    /*!< PERMANENT : Permanent request, for unpaced transfers. */
} DMA_CH5_CTRL_TRIG_TREQ_SEL_Enum;

/* ==========================================  DMA CH5_CTRL_TRIG RING_SIZE [6..9]  =========================================== */
typedef enum {                                  /*!< DMA_CH5_CTRL_TRIG_RING_SIZE */
  DMA_CH5_CTRL_TRIG_RING_SIZE_RING_NONE = 0,    /*!< RING_NONE : RING_NONE */
} DMA_CH5_CTRL_TRIG_RING_SIZE_Enum;

/* ==========================================  DMA CH5_CTRL_TRIG DATA_SIZE [2..3]  =========================================== */
typedef enum {                                  /*!< DMA_CH5_CTRL_TRIG_DATA_SIZE */
  DMA_CH5_CTRL_TRIG_DATA_SIZE_SIZE_BYTE = 0,    /*!< SIZE_BYTE : SIZE_BYTE */
  DMA_CH5_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 1,/*!< SIZE_HALFWORD : SIZE_HALFWORD */
  DMA_CH5_CTRL_TRIG_DATA_SIZE_SIZE_WORD = 2,    /*!< SIZE_WORD : SIZE_WORD */
} DMA_CH5_CTRL_TRIG_DATA_SIZE_Enum;

/* =====================================================  CH5_AL1_CTRL  ====================================================== */
/* ===================================================  CH5_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH5_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH5_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH5_AL2_CTRL  ====================================================== */
/* ==================================================  CH5_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH5_AL2_READ_ADDR  =================================================== */
/* ================================================  CH5_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH5_AL3_CTRL  ====================================================== */
/* ==================================================  CH5_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH5_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH5_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH6_READ_ADDR  ===================================================== */
/* ====================================================  CH6_WRITE_ADDR  ===================================================== */
/* ====================================================  CH6_TRANS_COUNT  ==================================================== */
/* =====================================================  CH6_CTRL_TRIG  ===================================================== */
/* ==========================================  DMA CH6_CTRL_TRIG TREQ_SEL [15..20]  ========================================== */
typedef enum {                                  /*!< DMA_CH6_CTRL_TRIG_TREQ_SEL */
  DMA_CH6_CTRL_TRIG_TREQ_SEL_TIMER0    = 59,    /*!< TIMER0 : Select Timer 0 as TREQ */
  DMA_CH6_CTRL_TRIG_TREQ_SEL_TIMER1    = 60,    /*!< TIMER1 : Select Timer 1 as TREQ */
  DMA_CH6_CTRL_TRIG_TREQ_SEL_TIMER2    = 61,    /*!< TIMER2 : Select Timer 2 as TREQ (Optional) */
  DMA_CH6_CTRL_TRIG_TREQ_SEL_TIMER3    = 62,    /*!< TIMER3 : Select Timer 3 as TREQ (Optional) */
  DMA_CH6_CTRL_TRIG_TREQ_SEL_PERMANENT = 63,    /*!< PERMANENT : Permanent request, for unpaced transfers. */
} DMA_CH6_CTRL_TRIG_TREQ_SEL_Enum;

/* ==========================================  DMA CH6_CTRL_TRIG RING_SIZE [6..9]  =========================================== */
typedef enum {                                  /*!< DMA_CH6_CTRL_TRIG_RING_SIZE */
  DMA_CH6_CTRL_TRIG_RING_SIZE_RING_NONE = 0,    /*!< RING_NONE : RING_NONE */
} DMA_CH6_CTRL_TRIG_RING_SIZE_Enum;

/* ==========================================  DMA CH6_CTRL_TRIG DATA_SIZE [2..3]  =========================================== */
typedef enum {                                  /*!< DMA_CH6_CTRL_TRIG_DATA_SIZE */
  DMA_CH6_CTRL_TRIG_DATA_SIZE_SIZE_BYTE = 0,    /*!< SIZE_BYTE : SIZE_BYTE */
  DMA_CH6_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 1,/*!< SIZE_HALFWORD : SIZE_HALFWORD */
  DMA_CH6_CTRL_TRIG_DATA_SIZE_SIZE_WORD = 2,    /*!< SIZE_WORD : SIZE_WORD */
} DMA_CH6_CTRL_TRIG_DATA_SIZE_Enum;

/* =====================================================  CH6_AL1_CTRL  ====================================================== */
/* ===================================================  CH6_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH6_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH6_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH6_AL2_CTRL  ====================================================== */
/* ==================================================  CH6_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH6_AL2_READ_ADDR  =================================================== */
/* ================================================  CH6_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH6_AL3_CTRL  ====================================================== */
/* ==================================================  CH6_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH6_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH6_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH7_READ_ADDR  ===================================================== */
/* ====================================================  CH7_WRITE_ADDR  ===================================================== */
/* ====================================================  CH7_TRANS_COUNT  ==================================================== */
/* =====================================================  CH7_CTRL_TRIG  ===================================================== */
/* ==========================================  DMA CH7_CTRL_TRIG TREQ_SEL [15..20]  ========================================== */
typedef enum {                                  /*!< DMA_CH7_CTRL_TRIG_TREQ_SEL */
  DMA_CH7_CTRL_TRIG_TREQ_SEL_TIMER0    = 59,    /*!< TIMER0 : Select Timer 0 as TREQ */
  DMA_CH7_CTRL_TRIG_TREQ_SEL_TIMER1    = 60,    /*!< TIMER1 : Select Timer 1 as TREQ */
  DMA_CH7_CTRL_TRIG_TREQ_SEL_TIMER2    = 61,    /*!< TIMER2 : Select Timer 2 as TREQ (Optional) */
  DMA_CH7_CTRL_TRIG_TREQ_SEL_TIMER3    = 62,    /*!< TIMER3 : Select Timer 3 as TREQ (Optional) */
  DMA_CH7_CTRL_TRIG_TREQ_SEL_PERMANENT = 63,    /*!< PERMANENT : Permanent request, for unpaced transfers. */
} DMA_CH7_CTRL_TRIG_TREQ_SEL_Enum;

/* ==========================================  DMA CH7_CTRL_TRIG RING_SIZE [6..9]  =========================================== */
typedef enum {                                  /*!< DMA_CH7_CTRL_TRIG_RING_SIZE */
  DMA_CH7_CTRL_TRIG_RING_SIZE_RING_NONE = 0,    /*!< RING_NONE : RING_NONE */
} DMA_CH7_CTRL_TRIG_RING_SIZE_Enum;

/* ==========================================  DMA CH7_CTRL_TRIG DATA_SIZE [2..3]  =========================================== */
typedef enum {                                  /*!< DMA_CH7_CTRL_TRIG_DATA_SIZE */
  DMA_CH7_CTRL_TRIG_DATA_SIZE_SIZE_BYTE = 0,    /*!< SIZE_BYTE : SIZE_BYTE */
  DMA_CH7_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 1,/*!< SIZE_HALFWORD : SIZE_HALFWORD */
  DMA_CH7_CTRL_TRIG_DATA_SIZE_SIZE_WORD = 2,    /*!< SIZE_WORD : SIZE_WORD */
} DMA_CH7_CTRL_TRIG_DATA_SIZE_Enum;

/* =====================================================  CH7_AL1_CTRL  ====================================================== */
/* ===================================================  CH7_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH7_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH7_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH7_AL2_CTRL  ====================================================== */
/* ==================================================  CH7_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH7_AL2_READ_ADDR  =================================================== */
/* ================================================  CH7_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH7_AL3_CTRL  ====================================================== */
/* ==================================================  CH7_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH7_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH7_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH8_READ_ADDR  ===================================================== */
/* ====================================================  CH8_WRITE_ADDR  ===================================================== */
/* ====================================================  CH8_TRANS_COUNT  ==================================================== */
/* =====================================================  CH8_CTRL_TRIG  ===================================================== */
/* ==========================================  DMA CH8_CTRL_TRIG TREQ_SEL [15..20]  ========================================== */
typedef enum {                                  /*!< DMA_CH8_CTRL_TRIG_TREQ_SEL */
  DMA_CH8_CTRL_TRIG_TREQ_SEL_TIMER0    = 59,    /*!< TIMER0 : Select Timer 0 as TREQ */
  DMA_CH8_CTRL_TRIG_TREQ_SEL_TIMER1    = 60,    /*!< TIMER1 : Select Timer 1 as TREQ */
  DMA_CH8_CTRL_TRIG_TREQ_SEL_TIMER2    = 61,    /*!< TIMER2 : Select Timer 2 as TREQ (Optional) */
  DMA_CH8_CTRL_TRIG_TREQ_SEL_TIMER3    = 62,    /*!< TIMER3 : Select Timer 3 as TREQ (Optional) */
  DMA_CH8_CTRL_TRIG_TREQ_SEL_PERMANENT = 63,    /*!< PERMANENT : Permanent request, for unpaced transfers. */
} DMA_CH8_CTRL_TRIG_TREQ_SEL_Enum;

/* ==========================================  DMA CH8_CTRL_TRIG RING_SIZE [6..9]  =========================================== */
typedef enum {                                  /*!< DMA_CH8_CTRL_TRIG_RING_SIZE */
  DMA_CH8_CTRL_TRIG_RING_SIZE_RING_NONE = 0,    /*!< RING_NONE : RING_NONE */
} DMA_CH8_CTRL_TRIG_RING_SIZE_Enum;

/* ==========================================  DMA CH8_CTRL_TRIG DATA_SIZE [2..3]  =========================================== */
typedef enum {                                  /*!< DMA_CH8_CTRL_TRIG_DATA_SIZE */
  DMA_CH8_CTRL_TRIG_DATA_SIZE_SIZE_BYTE = 0,    /*!< SIZE_BYTE : SIZE_BYTE */
  DMA_CH8_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 1,/*!< SIZE_HALFWORD : SIZE_HALFWORD */
  DMA_CH8_CTRL_TRIG_DATA_SIZE_SIZE_WORD = 2,    /*!< SIZE_WORD : SIZE_WORD */
} DMA_CH8_CTRL_TRIG_DATA_SIZE_Enum;

/* =====================================================  CH8_AL1_CTRL  ====================================================== */
/* ===================================================  CH8_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH8_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH8_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH8_AL2_CTRL  ====================================================== */
/* ==================================================  CH8_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH8_AL2_READ_ADDR  =================================================== */
/* ================================================  CH8_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH8_AL3_CTRL  ====================================================== */
/* ==================================================  CH8_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH8_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH8_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH9_READ_ADDR  ===================================================== */
/* ====================================================  CH9_WRITE_ADDR  ===================================================== */
/* ====================================================  CH9_TRANS_COUNT  ==================================================== */
/* =====================================================  CH9_CTRL_TRIG  ===================================================== */
/* ==========================================  DMA CH9_CTRL_TRIG TREQ_SEL [15..20]  ========================================== */
typedef enum {                                  /*!< DMA_CH9_CTRL_TRIG_TREQ_SEL */
  DMA_CH9_CTRL_TRIG_TREQ_SEL_TIMER0    = 59,    /*!< TIMER0 : Select Timer 0 as TREQ */
  DMA_CH9_CTRL_TRIG_TREQ_SEL_TIMER1    = 60,    /*!< TIMER1 : Select Timer 1 as TREQ */
  DMA_CH9_CTRL_TRIG_TREQ_SEL_TIMER2    = 61,    /*!< TIMER2 : Select Timer 2 as TREQ (Optional) */
  DMA_CH9_CTRL_TRIG_TREQ_SEL_TIMER3    = 62,    /*!< TIMER3 : Select Timer 3 as TREQ (Optional) */
  DMA_CH9_CTRL_TRIG_TREQ_SEL_PERMANENT = 63,    /*!< PERMANENT : Permanent request, for unpaced transfers. */
} DMA_CH9_CTRL_TRIG_TREQ_SEL_Enum;

/* ==========================================  DMA CH9_CTRL_TRIG RING_SIZE [6..9]  =========================================== */
typedef enum {                                  /*!< DMA_CH9_CTRL_TRIG_RING_SIZE */
  DMA_CH9_CTRL_TRIG_RING_SIZE_RING_NONE = 0,    /*!< RING_NONE : RING_NONE */
} DMA_CH9_CTRL_TRIG_RING_SIZE_Enum;

/* ==========================================  DMA CH9_CTRL_TRIG DATA_SIZE [2..3]  =========================================== */
typedef enum {                                  /*!< DMA_CH9_CTRL_TRIG_DATA_SIZE */
  DMA_CH9_CTRL_TRIG_DATA_SIZE_SIZE_BYTE = 0,    /*!< SIZE_BYTE : SIZE_BYTE */
  DMA_CH9_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 1,/*!< SIZE_HALFWORD : SIZE_HALFWORD */
  DMA_CH9_CTRL_TRIG_DATA_SIZE_SIZE_WORD = 2,    /*!< SIZE_WORD : SIZE_WORD */
} DMA_CH9_CTRL_TRIG_DATA_SIZE_Enum;

/* =====================================================  CH9_AL1_CTRL  ====================================================== */
/* ===================================================  CH9_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH9_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH9_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH9_AL2_CTRL  ====================================================== */
/* ==================================================  CH9_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH9_AL2_READ_ADDR  =================================================== */
/* ================================================  CH9_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH9_AL3_CTRL  ====================================================== */
/* ==================================================  CH9_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH9_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH9_AL3_READ_ADDR_TRIG  ================================================= */
/* ====================================================  CH10_READ_ADDR  ===================================================== */
/* ====================================================  CH10_WRITE_ADDR  ==================================================== */
/* ===================================================  CH10_TRANS_COUNT  ==================================================== */
/* ====================================================  CH10_CTRL_TRIG  ===================================================== */
/* =========================================  DMA CH10_CTRL_TRIG TREQ_SEL [15..20]  ========================================== */
typedef enum {                                  /*!< DMA_CH10_CTRL_TRIG_TREQ_SEL */
  DMA_CH10_CTRL_TRIG_TREQ_SEL_TIMER0   = 59,    /*!< TIMER0 : Select Timer 0 as TREQ */
  DMA_CH10_CTRL_TRIG_TREQ_SEL_TIMER1   = 60,    /*!< TIMER1 : Select Timer 1 as TREQ */
  DMA_CH10_CTRL_TRIG_TREQ_SEL_TIMER2   = 61,    /*!< TIMER2 : Select Timer 2 as TREQ (Optional) */
  DMA_CH10_CTRL_TRIG_TREQ_SEL_TIMER3   = 62,    /*!< TIMER3 : Select Timer 3 as TREQ (Optional) */
  DMA_CH10_CTRL_TRIG_TREQ_SEL_PERMANENT = 63,   /*!< PERMANENT : Permanent request, for unpaced transfers. */
} DMA_CH10_CTRL_TRIG_TREQ_SEL_Enum;

/* ==========================================  DMA CH10_CTRL_TRIG RING_SIZE [6..9]  ========================================== */
typedef enum {                                  /*!< DMA_CH10_CTRL_TRIG_RING_SIZE */
  DMA_CH10_CTRL_TRIG_RING_SIZE_RING_NONE = 0,   /*!< RING_NONE : RING_NONE */
} DMA_CH10_CTRL_TRIG_RING_SIZE_Enum;

/* ==========================================  DMA CH10_CTRL_TRIG DATA_SIZE [2..3]  ========================================== */
typedef enum {                                  /*!< DMA_CH10_CTRL_TRIG_DATA_SIZE */
  DMA_CH10_CTRL_TRIG_DATA_SIZE_SIZE_BYTE = 0,   /*!< SIZE_BYTE : SIZE_BYTE */
  DMA_CH10_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 1,/*!< SIZE_HALFWORD : SIZE_HALFWORD */
  DMA_CH10_CTRL_TRIG_DATA_SIZE_SIZE_WORD = 2,   /*!< SIZE_WORD : SIZE_WORD */
} DMA_CH10_CTRL_TRIG_DATA_SIZE_Enum;

/* =====================================================  CH10_AL1_CTRL  ===================================================== */
/* ==================================================  CH10_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH10_AL1_WRITE_ADDR  ================================================== */
/* ===============================================  CH10_AL1_TRANS_COUNT_TRIG  =============================================== */
/* =====================================================  CH10_AL2_CTRL  ===================================================== */
/* =================================================  CH10_AL2_TRANS_COUNT  ================================================== */
/* ==================================================  CH10_AL2_READ_ADDR  =================================================== */
/* ===============================================  CH10_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH10_AL3_CTRL  ===================================================== */
/* ==================================================  CH10_AL3_WRITE_ADDR  ================================================== */
/* =================================================  CH10_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH10_AL3_READ_ADDR_TRIG  ================================================ */
/* ====================================================  CH11_READ_ADDR  ===================================================== */
/* ====================================================  CH11_WRITE_ADDR  ==================================================== */
/* ===================================================  CH11_TRANS_COUNT  ==================================================== */
/* ====================================================  CH11_CTRL_TRIG  ===================================================== */
/* =========================================  DMA CH11_CTRL_TRIG TREQ_SEL [15..20]  ========================================== */
typedef enum {                                  /*!< DMA_CH11_CTRL_TRIG_TREQ_SEL */
  DMA_CH11_CTRL_TRIG_TREQ_SEL_TIMER0   = 59,    /*!< TIMER0 : Select Timer 0 as TREQ */
  DMA_CH11_CTRL_TRIG_TREQ_SEL_TIMER1   = 60,    /*!< TIMER1 : Select Timer 1 as TREQ */
  DMA_CH11_CTRL_TRIG_TREQ_SEL_TIMER2   = 61,    /*!< TIMER2 : Select Timer 2 as TREQ (Optional) */
  DMA_CH11_CTRL_TRIG_TREQ_SEL_TIMER3   = 62,    /*!< TIMER3 : Select Timer 3 as TREQ (Optional) */
  DMA_CH11_CTRL_TRIG_TREQ_SEL_PERMANENT = 63,   /*!< PERMANENT : Permanent request, for unpaced transfers. */
} DMA_CH11_CTRL_TRIG_TREQ_SEL_Enum;

/* ==========================================  DMA CH11_CTRL_TRIG RING_SIZE [6..9]  ========================================== */
typedef enum {                                  /*!< DMA_CH11_CTRL_TRIG_RING_SIZE */
  DMA_CH11_CTRL_TRIG_RING_SIZE_RING_NONE = 0,   /*!< RING_NONE : RING_NONE */
} DMA_CH11_CTRL_TRIG_RING_SIZE_Enum;

/* ==========================================  DMA CH11_CTRL_TRIG DATA_SIZE [2..3]  ========================================== */
typedef enum {                                  /*!< DMA_CH11_CTRL_TRIG_DATA_SIZE */
  DMA_CH11_CTRL_TRIG_DATA_SIZE_SIZE_BYTE = 0,   /*!< SIZE_BYTE : SIZE_BYTE */
  DMA_CH11_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 1,/*!< SIZE_HALFWORD : SIZE_HALFWORD */
  DMA_CH11_CTRL_TRIG_DATA_SIZE_SIZE_WORD = 2,   /*!< SIZE_WORD : SIZE_WORD */
} DMA_CH11_CTRL_TRIG_DATA_SIZE_Enum;

/* =====================================================  CH11_AL1_CTRL  ===================================================== */
/* ==================================================  CH11_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH11_AL1_WRITE_ADDR  ================================================== */
/* ===============================================  CH11_AL1_TRANS_COUNT_TRIG  =============================================== */
/* =====================================================  CH11_AL2_CTRL  ===================================================== */
/* =================================================  CH11_AL2_TRANS_COUNT  ================================================== */
/* ==================================================  CH11_AL2_READ_ADDR  =================================================== */
/* ===============================================  CH11_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH11_AL3_CTRL  ===================================================== */
/* ==================================================  CH11_AL3_WRITE_ADDR  ================================================== */
/* =================================================  CH11_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH11_AL3_READ_ADDR_TRIG  ================================================ */
/* =========================================================  INTR  ========================================================== */
/* =========================================================  INTE0  ========================================================= */
/* =========================================================  INTF0  ========================================================= */
/* =========================================================  INTS0  ========================================================= */
/* =========================================================  INTE1  ========================================================= */
/* =========================================================  INTF1  ========================================================= */
/* =========================================================  INTS1  ========================================================= */
/* ========================================================  TIMER0  ========================================================= */
/* ========================================================  TIMER1  ========================================================= */
/* ========================================================  TIMER2  ========================================================= */
/* ========================================================  TIMER3  ========================================================= */
/* ==================================================  MULTI_CHAN_TRIGGER  =================================================== */
/* ======================================================  SNIFF_CTRL  ======================================================= */
/* ==============================================  DMA SNIFF_CTRL CALC [5..8]  =============================================== */
typedef enum {                                  /*!< DMA_SNIFF_CTRL_CALC */
  DMA_SNIFF_CTRL_CALC_CRC32            = 0,     /*!< CRC32 : Calculate a CRC-32 (IEEE802.3 polynomial) */
  DMA_SNIFF_CTRL_CALC_CRC32R           = 1,     /*!< CRC32R : Calculate a CRC-32 (IEEE802.3 polynomial) with bit reversed data */
  DMA_SNIFF_CTRL_CALC_CRC16            = 2,     /*!< CRC16 : Calculate a CRC-16-CCITT */
  DMA_SNIFF_CTRL_CALC_CRC16R           = 3,     /*!< CRC16R : Calculate a CRC-16-CCITT with bit reversed data */
  DMA_SNIFF_CTRL_CALC_EVEN             = 14,    /*!< EVEN : XOR reduction over all data. == 1 if the total 1 population count is odd. */
  DMA_SNIFF_CTRL_CALC_SUM              = 15,    /*!< SUM : Calculate a simple 32-bit checksum (addition with a 32 bit accumulator) */
} DMA_SNIFF_CTRL_CALC_Enum;

/* ======================================================  SNIFF_DATA  ======================================================= */
/* ======================================================  FIFO_LEVELS  ====================================================== */
/* ======================================================  CHAN_ABORT  ======================================================= */
/* ======================================================  N_CHANNELS  ======================================================= */
/* ====================================================  CH0_DBG_CTDREQ  ===================================================== */
/* ======================================================  CH0_DBG_TCR  ====================================================== */
/* ====================================================  CH1_DBG_CTDREQ  ===================================================== */
/* ======================================================  CH1_DBG_TCR  ====================================================== */
/* ====================================================  CH2_DBG_CTDREQ  ===================================================== */
/* ======================================================  CH2_DBG_TCR  ====================================================== */
/* ====================================================  CH3_DBG_CTDREQ  ===================================================== */
/* ======================================================  CH3_DBG_TCR  ====================================================== */
/* ====================================================  CH4_DBG_CTDREQ  ===================================================== */
/* ======================================================  CH4_DBG_TCR  ====================================================== */
/* ====================================================  CH5_DBG_CTDREQ  ===================================================== */
/* ======================================================  CH5_DBG_TCR  ====================================================== */
/* ====================================================  CH6_DBG_CTDREQ  ===================================================== */
/* ======================================================  CH6_DBG_TCR  ====================================================== */
/* ====================================================  CH7_DBG_CTDREQ  ===================================================== */
/* ======================================================  CH7_DBG_TCR  ====================================================== */
/* ====================================================  CH8_DBG_CTDREQ  ===================================================== */
/* ======================================================  CH8_DBG_TCR  ====================================================== */
/* ====================================================  CH9_DBG_CTDREQ  ===================================================== */
/* ======================================================  CH9_DBG_TCR  ====================================================== */
/* ====================================================  CH10_DBG_CTDREQ  ==================================================== */
/* =====================================================  CH10_DBG_TCR  ====================================================== */
/* ====================================================  CH11_DBG_CTDREQ  ==================================================== */
/* =====================================================  CH11_DBG_TCR  ====================================================== */


/* =========================================================================================================================== */
/* ================                                       USBCTRL_DPRAM                                       ================ */
/* =========================================================================================================================== */

/* ===================================================  SETUP_PACKET_LOW  ==================================================== */
/* ===================================================  SETUP_PACKET_HIGH  =================================================== */
/* ====================================================  EP1_IN_CONTROL  ===================================================== */
/* ==================================  USBCTRL_DPRAM EP1_IN_CONTROL ENDPOINT_TYPE [26..27]  ================================== */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP1_IN_CONTROL_ENDPOINT_TYPE */
  USBCTRL_DPRAM_EP1_IN_CONTROL_ENDPOINT_TYPE_Control = 0,/*!< Control : Control */
  USBCTRL_DPRAM_EP1_IN_CONTROL_ENDPOINT_TYPE_Isochronous = 1,/*!< Isochronous : Isochronous */
  USBCTRL_DPRAM_EP1_IN_CONTROL_ENDPOINT_TYPE_Bulk = 2,/*!< Bulk : Bulk */
  USBCTRL_DPRAM_EP1_IN_CONTROL_ENDPOINT_TYPE_Interrupt = 3,/*!< Interrupt : Interrupt */
} USBCTRL_DPRAM_EP1_IN_CONTROL_ENDPOINT_TYPE_Enum;

/* ====================================================  EP1_OUT_CONTROL  ==================================================== */
/* =================================  USBCTRL_DPRAM EP1_OUT_CONTROL ENDPOINT_TYPE [26..27]  ================================== */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP1_OUT_CONTROL_ENDPOINT_TYPE */
  USBCTRL_DPRAM_EP1_OUT_CONTROL_ENDPOINT_TYPE_Control = 0,/*!< Control : Control */
  USBCTRL_DPRAM_EP1_OUT_CONTROL_ENDPOINT_TYPE_Isochronous = 1,/*!< Isochronous : Isochronous */
  USBCTRL_DPRAM_EP1_OUT_CONTROL_ENDPOINT_TYPE_Bulk = 2,/*!< Bulk : Bulk */
  USBCTRL_DPRAM_EP1_OUT_CONTROL_ENDPOINT_TYPE_Interrupt = 3,/*!< Interrupt : Interrupt */
} USBCTRL_DPRAM_EP1_OUT_CONTROL_ENDPOINT_TYPE_Enum;

/* ====================================================  EP2_IN_CONTROL  ===================================================== */
/* ==================================  USBCTRL_DPRAM EP2_IN_CONTROL ENDPOINT_TYPE [26..27]  ================================== */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP2_IN_CONTROL_ENDPOINT_TYPE */
  USBCTRL_DPRAM_EP2_IN_CONTROL_ENDPOINT_TYPE_Control = 0,/*!< Control : Control */
  USBCTRL_DPRAM_EP2_IN_CONTROL_ENDPOINT_TYPE_Isochronous = 1,/*!< Isochronous : Isochronous */
  USBCTRL_DPRAM_EP2_IN_CONTROL_ENDPOINT_TYPE_Bulk = 2,/*!< Bulk : Bulk */
  USBCTRL_DPRAM_EP2_IN_CONTROL_ENDPOINT_TYPE_Interrupt = 3,/*!< Interrupt : Interrupt */
} USBCTRL_DPRAM_EP2_IN_CONTROL_ENDPOINT_TYPE_Enum;

/* ====================================================  EP2_OUT_CONTROL  ==================================================== */
/* =================================  USBCTRL_DPRAM EP2_OUT_CONTROL ENDPOINT_TYPE [26..27]  ================================== */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP2_OUT_CONTROL_ENDPOINT_TYPE */
  USBCTRL_DPRAM_EP2_OUT_CONTROL_ENDPOINT_TYPE_Control = 0,/*!< Control : Control */
  USBCTRL_DPRAM_EP2_OUT_CONTROL_ENDPOINT_TYPE_Isochronous = 1,/*!< Isochronous : Isochronous */
  USBCTRL_DPRAM_EP2_OUT_CONTROL_ENDPOINT_TYPE_Bulk = 2,/*!< Bulk : Bulk */
  USBCTRL_DPRAM_EP2_OUT_CONTROL_ENDPOINT_TYPE_Interrupt = 3,/*!< Interrupt : Interrupt */
} USBCTRL_DPRAM_EP2_OUT_CONTROL_ENDPOINT_TYPE_Enum;

/* ====================================================  EP3_IN_CONTROL  ===================================================== */
/* ==================================  USBCTRL_DPRAM EP3_IN_CONTROL ENDPOINT_TYPE [26..27]  ================================== */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP3_IN_CONTROL_ENDPOINT_TYPE */
  USBCTRL_DPRAM_EP3_IN_CONTROL_ENDPOINT_TYPE_Control = 0,/*!< Control : Control */
  USBCTRL_DPRAM_EP3_IN_CONTROL_ENDPOINT_TYPE_Isochronous = 1,/*!< Isochronous : Isochronous */
  USBCTRL_DPRAM_EP3_IN_CONTROL_ENDPOINT_TYPE_Bulk = 2,/*!< Bulk : Bulk */
  USBCTRL_DPRAM_EP3_IN_CONTROL_ENDPOINT_TYPE_Interrupt = 3,/*!< Interrupt : Interrupt */
} USBCTRL_DPRAM_EP3_IN_CONTROL_ENDPOINT_TYPE_Enum;

/* ====================================================  EP3_OUT_CONTROL  ==================================================== */
/* =================================  USBCTRL_DPRAM EP3_OUT_CONTROL ENDPOINT_TYPE [26..27]  ================================== */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP3_OUT_CONTROL_ENDPOINT_TYPE */
  USBCTRL_DPRAM_EP3_OUT_CONTROL_ENDPOINT_TYPE_Control = 0,/*!< Control : Control */
  USBCTRL_DPRAM_EP3_OUT_CONTROL_ENDPOINT_TYPE_Isochronous = 1,/*!< Isochronous : Isochronous */
  USBCTRL_DPRAM_EP3_OUT_CONTROL_ENDPOINT_TYPE_Bulk = 2,/*!< Bulk : Bulk */
  USBCTRL_DPRAM_EP3_OUT_CONTROL_ENDPOINT_TYPE_Interrupt = 3,/*!< Interrupt : Interrupt */
} USBCTRL_DPRAM_EP3_OUT_CONTROL_ENDPOINT_TYPE_Enum;

/* ====================================================  EP4_IN_CONTROL  ===================================================== */
/* ==================================  USBCTRL_DPRAM EP4_IN_CONTROL ENDPOINT_TYPE [26..27]  ================================== */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP4_IN_CONTROL_ENDPOINT_TYPE */
  USBCTRL_DPRAM_EP4_IN_CONTROL_ENDPOINT_TYPE_Control = 0,/*!< Control : Control */
  USBCTRL_DPRAM_EP4_IN_CONTROL_ENDPOINT_TYPE_Isochronous = 1,/*!< Isochronous : Isochronous */
  USBCTRL_DPRAM_EP4_IN_CONTROL_ENDPOINT_TYPE_Bulk = 2,/*!< Bulk : Bulk */
  USBCTRL_DPRAM_EP4_IN_CONTROL_ENDPOINT_TYPE_Interrupt = 3,/*!< Interrupt : Interrupt */
} USBCTRL_DPRAM_EP4_IN_CONTROL_ENDPOINT_TYPE_Enum;

/* ====================================================  EP4_OUT_CONTROL  ==================================================== */
/* =================================  USBCTRL_DPRAM EP4_OUT_CONTROL ENDPOINT_TYPE [26..27]  ================================== */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP4_OUT_CONTROL_ENDPOINT_TYPE */
  USBCTRL_DPRAM_EP4_OUT_CONTROL_ENDPOINT_TYPE_Control = 0,/*!< Control : Control */
  USBCTRL_DPRAM_EP4_OUT_CONTROL_ENDPOINT_TYPE_Isochronous = 1,/*!< Isochronous : Isochronous */
  USBCTRL_DPRAM_EP4_OUT_CONTROL_ENDPOINT_TYPE_Bulk = 2,/*!< Bulk : Bulk */
  USBCTRL_DPRAM_EP4_OUT_CONTROL_ENDPOINT_TYPE_Interrupt = 3,/*!< Interrupt : Interrupt */
} USBCTRL_DPRAM_EP4_OUT_CONTROL_ENDPOINT_TYPE_Enum;

/* ====================================================  EP5_IN_CONTROL  ===================================================== */
/* ==================================  USBCTRL_DPRAM EP5_IN_CONTROL ENDPOINT_TYPE [26..27]  ================================== */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP5_IN_CONTROL_ENDPOINT_TYPE */
  USBCTRL_DPRAM_EP5_IN_CONTROL_ENDPOINT_TYPE_Control = 0,/*!< Control : Control */
  USBCTRL_DPRAM_EP5_IN_CONTROL_ENDPOINT_TYPE_Isochronous = 1,/*!< Isochronous : Isochronous */
  USBCTRL_DPRAM_EP5_IN_CONTROL_ENDPOINT_TYPE_Bulk = 2,/*!< Bulk : Bulk */
  USBCTRL_DPRAM_EP5_IN_CONTROL_ENDPOINT_TYPE_Interrupt = 3,/*!< Interrupt : Interrupt */
} USBCTRL_DPRAM_EP5_IN_CONTROL_ENDPOINT_TYPE_Enum;

/* ====================================================  EP5_OUT_CONTROL  ==================================================== */
/* =================================  USBCTRL_DPRAM EP5_OUT_CONTROL ENDPOINT_TYPE [26..27]  ================================== */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP5_OUT_CONTROL_ENDPOINT_TYPE */
  USBCTRL_DPRAM_EP5_OUT_CONTROL_ENDPOINT_TYPE_Control = 0,/*!< Control : Control */
  USBCTRL_DPRAM_EP5_OUT_CONTROL_ENDPOINT_TYPE_Isochronous = 1,/*!< Isochronous : Isochronous */
  USBCTRL_DPRAM_EP5_OUT_CONTROL_ENDPOINT_TYPE_Bulk = 2,/*!< Bulk : Bulk */
  USBCTRL_DPRAM_EP5_OUT_CONTROL_ENDPOINT_TYPE_Interrupt = 3,/*!< Interrupt : Interrupt */
} USBCTRL_DPRAM_EP5_OUT_CONTROL_ENDPOINT_TYPE_Enum;

/* ====================================================  EP6_IN_CONTROL  ===================================================== */
/* ==================================  USBCTRL_DPRAM EP6_IN_CONTROL ENDPOINT_TYPE [26..27]  ================================== */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP6_IN_CONTROL_ENDPOINT_TYPE */
  USBCTRL_DPRAM_EP6_IN_CONTROL_ENDPOINT_TYPE_Control = 0,/*!< Control : Control */
  USBCTRL_DPRAM_EP6_IN_CONTROL_ENDPOINT_TYPE_Isochronous = 1,/*!< Isochronous : Isochronous */
  USBCTRL_DPRAM_EP6_IN_CONTROL_ENDPOINT_TYPE_Bulk = 2,/*!< Bulk : Bulk */
  USBCTRL_DPRAM_EP6_IN_CONTROL_ENDPOINT_TYPE_Interrupt = 3,/*!< Interrupt : Interrupt */
} USBCTRL_DPRAM_EP6_IN_CONTROL_ENDPOINT_TYPE_Enum;

/* ====================================================  EP6_OUT_CONTROL  ==================================================== */
/* =================================  USBCTRL_DPRAM EP6_OUT_CONTROL ENDPOINT_TYPE [26..27]  ================================== */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP6_OUT_CONTROL_ENDPOINT_TYPE */
  USBCTRL_DPRAM_EP6_OUT_CONTROL_ENDPOINT_TYPE_Control = 0,/*!< Control : Control */
  USBCTRL_DPRAM_EP6_OUT_CONTROL_ENDPOINT_TYPE_Isochronous = 1,/*!< Isochronous : Isochronous */
  USBCTRL_DPRAM_EP6_OUT_CONTROL_ENDPOINT_TYPE_Bulk = 2,/*!< Bulk : Bulk */
  USBCTRL_DPRAM_EP6_OUT_CONTROL_ENDPOINT_TYPE_Interrupt = 3,/*!< Interrupt : Interrupt */
} USBCTRL_DPRAM_EP6_OUT_CONTROL_ENDPOINT_TYPE_Enum;

/* ====================================================  EP7_IN_CONTROL  ===================================================== */
/* ==================================  USBCTRL_DPRAM EP7_IN_CONTROL ENDPOINT_TYPE [26..27]  ================================== */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP7_IN_CONTROL_ENDPOINT_TYPE */
  USBCTRL_DPRAM_EP7_IN_CONTROL_ENDPOINT_TYPE_Control = 0,/*!< Control : Control */
  USBCTRL_DPRAM_EP7_IN_CONTROL_ENDPOINT_TYPE_Isochronous = 1,/*!< Isochronous : Isochronous */
  USBCTRL_DPRAM_EP7_IN_CONTROL_ENDPOINT_TYPE_Bulk = 2,/*!< Bulk : Bulk */
  USBCTRL_DPRAM_EP7_IN_CONTROL_ENDPOINT_TYPE_Interrupt = 3,/*!< Interrupt : Interrupt */
} USBCTRL_DPRAM_EP7_IN_CONTROL_ENDPOINT_TYPE_Enum;

/* ====================================================  EP7_OUT_CONTROL  ==================================================== */
/* =================================  USBCTRL_DPRAM EP7_OUT_CONTROL ENDPOINT_TYPE [26..27]  ================================== */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP7_OUT_CONTROL_ENDPOINT_TYPE */
  USBCTRL_DPRAM_EP7_OUT_CONTROL_ENDPOINT_TYPE_Control = 0,/*!< Control : Control */
  USBCTRL_DPRAM_EP7_OUT_CONTROL_ENDPOINT_TYPE_Isochronous = 1,/*!< Isochronous : Isochronous */
  USBCTRL_DPRAM_EP7_OUT_CONTROL_ENDPOINT_TYPE_Bulk = 2,/*!< Bulk : Bulk */
  USBCTRL_DPRAM_EP7_OUT_CONTROL_ENDPOINT_TYPE_Interrupt = 3,/*!< Interrupt : Interrupt */
} USBCTRL_DPRAM_EP7_OUT_CONTROL_ENDPOINT_TYPE_Enum;

/* ====================================================  EP8_IN_CONTROL  ===================================================== */
/* ==================================  USBCTRL_DPRAM EP8_IN_CONTROL ENDPOINT_TYPE [26..27]  ================================== */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP8_IN_CONTROL_ENDPOINT_TYPE */
  USBCTRL_DPRAM_EP8_IN_CONTROL_ENDPOINT_TYPE_Control = 0,/*!< Control : Control */
  USBCTRL_DPRAM_EP8_IN_CONTROL_ENDPOINT_TYPE_Isochronous = 1,/*!< Isochronous : Isochronous */
  USBCTRL_DPRAM_EP8_IN_CONTROL_ENDPOINT_TYPE_Bulk = 2,/*!< Bulk : Bulk */
  USBCTRL_DPRAM_EP8_IN_CONTROL_ENDPOINT_TYPE_Interrupt = 3,/*!< Interrupt : Interrupt */
} USBCTRL_DPRAM_EP8_IN_CONTROL_ENDPOINT_TYPE_Enum;

/* ====================================================  EP8_OUT_CONTROL  ==================================================== */
/* =================================  USBCTRL_DPRAM EP8_OUT_CONTROL ENDPOINT_TYPE [26..27]  ================================== */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP8_OUT_CONTROL_ENDPOINT_TYPE */
  USBCTRL_DPRAM_EP8_OUT_CONTROL_ENDPOINT_TYPE_Control = 0,/*!< Control : Control */
  USBCTRL_DPRAM_EP8_OUT_CONTROL_ENDPOINT_TYPE_Isochronous = 1,/*!< Isochronous : Isochronous */
  USBCTRL_DPRAM_EP8_OUT_CONTROL_ENDPOINT_TYPE_Bulk = 2,/*!< Bulk : Bulk */
  USBCTRL_DPRAM_EP8_OUT_CONTROL_ENDPOINT_TYPE_Interrupt = 3,/*!< Interrupt : Interrupt */
} USBCTRL_DPRAM_EP8_OUT_CONTROL_ENDPOINT_TYPE_Enum;

/* ====================================================  EP9_IN_CONTROL  ===================================================== */
/* ==================================  USBCTRL_DPRAM EP9_IN_CONTROL ENDPOINT_TYPE [26..27]  ================================== */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP9_IN_CONTROL_ENDPOINT_TYPE */
  USBCTRL_DPRAM_EP9_IN_CONTROL_ENDPOINT_TYPE_Control = 0,/*!< Control : Control */
  USBCTRL_DPRAM_EP9_IN_CONTROL_ENDPOINT_TYPE_Isochronous = 1,/*!< Isochronous : Isochronous */
  USBCTRL_DPRAM_EP9_IN_CONTROL_ENDPOINT_TYPE_Bulk = 2,/*!< Bulk : Bulk */
  USBCTRL_DPRAM_EP9_IN_CONTROL_ENDPOINT_TYPE_Interrupt = 3,/*!< Interrupt : Interrupt */
} USBCTRL_DPRAM_EP9_IN_CONTROL_ENDPOINT_TYPE_Enum;

/* ====================================================  EP9_OUT_CONTROL  ==================================================== */
/* =================================  USBCTRL_DPRAM EP9_OUT_CONTROL ENDPOINT_TYPE [26..27]  ================================== */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP9_OUT_CONTROL_ENDPOINT_TYPE */
  USBCTRL_DPRAM_EP9_OUT_CONTROL_ENDPOINT_TYPE_Control = 0,/*!< Control : Control */
  USBCTRL_DPRAM_EP9_OUT_CONTROL_ENDPOINT_TYPE_Isochronous = 1,/*!< Isochronous : Isochronous */
  USBCTRL_DPRAM_EP9_OUT_CONTROL_ENDPOINT_TYPE_Bulk = 2,/*!< Bulk : Bulk */
  USBCTRL_DPRAM_EP9_OUT_CONTROL_ENDPOINT_TYPE_Interrupt = 3,/*!< Interrupt : Interrupt */
} USBCTRL_DPRAM_EP9_OUT_CONTROL_ENDPOINT_TYPE_Enum;

/* ====================================================  EP10_IN_CONTROL  ==================================================== */
/* =================================  USBCTRL_DPRAM EP10_IN_CONTROL ENDPOINT_TYPE [26..27]  ================================== */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP10_IN_CONTROL_ENDPOINT_TYPE */
  USBCTRL_DPRAM_EP10_IN_CONTROL_ENDPOINT_TYPE_Control = 0,/*!< Control : Control */
  USBCTRL_DPRAM_EP10_IN_CONTROL_ENDPOINT_TYPE_Isochronous = 1,/*!< Isochronous : Isochronous */
  USBCTRL_DPRAM_EP10_IN_CONTROL_ENDPOINT_TYPE_Bulk = 2,/*!< Bulk : Bulk */
  USBCTRL_DPRAM_EP10_IN_CONTROL_ENDPOINT_TYPE_Interrupt = 3,/*!< Interrupt : Interrupt */
} USBCTRL_DPRAM_EP10_IN_CONTROL_ENDPOINT_TYPE_Enum;

/* ===================================================  EP10_OUT_CONTROL  ==================================================== */
/* =================================  USBCTRL_DPRAM EP10_OUT_CONTROL ENDPOINT_TYPE [26..27]  ================================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP10_OUT_CONTROL_ENDPOINT_TYPE */
  USBCTRL_DPRAM_EP10_OUT_CONTROL_ENDPOINT_TYPE_Control = 0,/*!< Control : Control */
  USBCTRL_DPRAM_EP10_OUT_CONTROL_ENDPOINT_TYPE_Isochronous = 1,/*!< Isochronous : Isochronous */
  USBCTRL_DPRAM_EP10_OUT_CONTROL_ENDPOINT_TYPE_Bulk = 2,/*!< Bulk : Bulk */
  USBCTRL_DPRAM_EP10_OUT_CONTROL_ENDPOINT_TYPE_Interrupt = 3,/*!< Interrupt : Interrupt */
} USBCTRL_DPRAM_EP10_OUT_CONTROL_ENDPOINT_TYPE_Enum;

/* ====================================================  EP11_IN_CONTROL  ==================================================== */
/* =================================  USBCTRL_DPRAM EP11_IN_CONTROL ENDPOINT_TYPE [26..27]  ================================== */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP11_IN_CONTROL_ENDPOINT_TYPE */
  USBCTRL_DPRAM_EP11_IN_CONTROL_ENDPOINT_TYPE_Control = 0,/*!< Control : Control */
  USBCTRL_DPRAM_EP11_IN_CONTROL_ENDPOINT_TYPE_Isochronous = 1,/*!< Isochronous : Isochronous */
  USBCTRL_DPRAM_EP11_IN_CONTROL_ENDPOINT_TYPE_Bulk = 2,/*!< Bulk : Bulk */
  USBCTRL_DPRAM_EP11_IN_CONTROL_ENDPOINT_TYPE_Interrupt = 3,/*!< Interrupt : Interrupt */
} USBCTRL_DPRAM_EP11_IN_CONTROL_ENDPOINT_TYPE_Enum;

/* ===================================================  EP11_OUT_CONTROL  ==================================================== */
/* =================================  USBCTRL_DPRAM EP11_OUT_CONTROL ENDPOINT_TYPE [26..27]  ================================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP11_OUT_CONTROL_ENDPOINT_TYPE */
  USBCTRL_DPRAM_EP11_OUT_CONTROL_ENDPOINT_TYPE_Control = 0,/*!< Control : Control */
  USBCTRL_DPRAM_EP11_OUT_CONTROL_ENDPOINT_TYPE_Isochronous = 1,/*!< Isochronous : Isochronous */
  USBCTRL_DPRAM_EP11_OUT_CONTROL_ENDPOINT_TYPE_Bulk = 2,/*!< Bulk : Bulk */
  USBCTRL_DPRAM_EP11_OUT_CONTROL_ENDPOINT_TYPE_Interrupt = 3,/*!< Interrupt : Interrupt */
} USBCTRL_DPRAM_EP11_OUT_CONTROL_ENDPOINT_TYPE_Enum;

/* ====================================================  EP12_IN_CONTROL  ==================================================== */
/* =================================  USBCTRL_DPRAM EP12_IN_CONTROL ENDPOINT_TYPE [26..27]  ================================== */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP12_IN_CONTROL_ENDPOINT_TYPE */
  USBCTRL_DPRAM_EP12_IN_CONTROL_ENDPOINT_TYPE_Control = 0,/*!< Control : Control */
  USBCTRL_DPRAM_EP12_IN_CONTROL_ENDPOINT_TYPE_Isochronous = 1,/*!< Isochronous : Isochronous */
  USBCTRL_DPRAM_EP12_IN_CONTROL_ENDPOINT_TYPE_Bulk = 2,/*!< Bulk : Bulk */
  USBCTRL_DPRAM_EP12_IN_CONTROL_ENDPOINT_TYPE_Interrupt = 3,/*!< Interrupt : Interrupt */
} USBCTRL_DPRAM_EP12_IN_CONTROL_ENDPOINT_TYPE_Enum;

/* ===================================================  EP12_OUT_CONTROL  ==================================================== */
/* =================================  USBCTRL_DPRAM EP12_OUT_CONTROL ENDPOINT_TYPE [26..27]  ================================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP12_OUT_CONTROL_ENDPOINT_TYPE */
  USBCTRL_DPRAM_EP12_OUT_CONTROL_ENDPOINT_TYPE_Control = 0,/*!< Control : Control */
  USBCTRL_DPRAM_EP12_OUT_CONTROL_ENDPOINT_TYPE_Isochronous = 1,/*!< Isochronous : Isochronous */
  USBCTRL_DPRAM_EP12_OUT_CONTROL_ENDPOINT_TYPE_Bulk = 2,/*!< Bulk : Bulk */
  USBCTRL_DPRAM_EP12_OUT_CONTROL_ENDPOINT_TYPE_Interrupt = 3,/*!< Interrupt : Interrupt */
} USBCTRL_DPRAM_EP12_OUT_CONTROL_ENDPOINT_TYPE_Enum;

/* ====================================================  EP13_IN_CONTROL  ==================================================== */
/* =================================  USBCTRL_DPRAM EP13_IN_CONTROL ENDPOINT_TYPE [26..27]  ================================== */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP13_IN_CONTROL_ENDPOINT_TYPE */
  USBCTRL_DPRAM_EP13_IN_CONTROL_ENDPOINT_TYPE_Control = 0,/*!< Control : Control */
  USBCTRL_DPRAM_EP13_IN_CONTROL_ENDPOINT_TYPE_Isochronous = 1,/*!< Isochronous : Isochronous */
  USBCTRL_DPRAM_EP13_IN_CONTROL_ENDPOINT_TYPE_Bulk = 2,/*!< Bulk : Bulk */
  USBCTRL_DPRAM_EP13_IN_CONTROL_ENDPOINT_TYPE_Interrupt = 3,/*!< Interrupt : Interrupt */
} USBCTRL_DPRAM_EP13_IN_CONTROL_ENDPOINT_TYPE_Enum;

/* ===================================================  EP13_OUT_CONTROL  ==================================================== */
/* =================================  USBCTRL_DPRAM EP13_OUT_CONTROL ENDPOINT_TYPE [26..27]  ================================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP13_OUT_CONTROL_ENDPOINT_TYPE */
  USBCTRL_DPRAM_EP13_OUT_CONTROL_ENDPOINT_TYPE_Control = 0,/*!< Control : Control */
  USBCTRL_DPRAM_EP13_OUT_CONTROL_ENDPOINT_TYPE_Isochronous = 1,/*!< Isochronous : Isochronous */
  USBCTRL_DPRAM_EP13_OUT_CONTROL_ENDPOINT_TYPE_Bulk = 2,/*!< Bulk : Bulk */
  USBCTRL_DPRAM_EP13_OUT_CONTROL_ENDPOINT_TYPE_Interrupt = 3,/*!< Interrupt : Interrupt */
} USBCTRL_DPRAM_EP13_OUT_CONTROL_ENDPOINT_TYPE_Enum;

/* ====================================================  EP14_IN_CONTROL  ==================================================== */
/* =================================  USBCTRL_DPRAM EP14_IN_CONTROL ENDPOINT_TYPE [26..27]  ================================== */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP14_IN_CONTROL_ENDPOINT_TYPE */
  USBCTRL_DPRAM_EP14_IN_CONTROL_ENDPOINT_TYPE_Control = 0,/*!< Control : Control */
  USBCTRL_DPRAM_EP14_IN_CONTROL_ENDPOINT_TYPE_Isochronous = 1,/*!< Isochronous : Isochronous */
  USBCTRL_DPRAM_EP14_IN_CONTROL_ENDPOINT_TYPE_Bulk = 2,/*!< Bulk : Bulk */
  USBCTRL_DPRAM_EP14_IN_CONTROL_ENDPOINT_TYPE_Interrupt = 3,/*!< Interrupt : Interrupt */
} USBCTRL_DPRAM_EP14_IN_CONTROL_ENDPOINT_TYPE_Enum;

/* ===================================================  EP14_OUT_CONTROL  ==================================================== */
/* =================================  USBCTRL_DPRAM EP14_OUT_CONTROL ENDPOINT_TYPE [26..27]  ================================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP14_OUT_CONTROL_ENDPOINT_TYPE */
  USBCTRL_DPRAM_EP14_OUT_CONTROL_ENDPOINT_TYPE_Control = 0,/*!< Control : Control */
  USBCTRL_DPRAM_EP14_OUT_CONTROL_ENDPOINT_TYPE_Isochronous = 1,/*!< Isochronous : Isochronous */
  USBCTRL_DPRAM_EP14_OUT_CONTROL_ENDPOINT_TYPE_Bulk = 2,/*!< Bulk : Bulk */
  USBCTRL_DPRAM_EP14_OUT_CONTROL_ENDPOINT_TYPE_Interrupt = 3,/*!< Interrupt : Interrupt */
} USBCTRL_DPRAM_EP14_OUT_CONTROL_ENDPOINT_TYPE_Enum;

/* ====================================================  EP15_IN_CONTROL  ==================================================== */
/* =================================  USBCTRL_DPRAM EP15_IN_CONTROL ENDPOINT_TYPE [26..27]  ================================== */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP15_IN_CONTROL_ENDPOINT_TYPE */
  USBCTRL_DPRAM_EP15_IN_CONTROL_ENDPOINT_TYPE_Control = 0,/*!< Control : Control */
  USBCTRL_DPRAM_EP15_IN_CONTROL_ENDPOINT_TYPE_Isochronous = 1,/*!< Isochronous : Isochronous */
  USBCTRL_DPRAM_EP15_IN_CONTROL_ENDPOINT_TYPE_Bulk = 2,/*!< Bulk : Bulk */
  USBCTRL_DPRAM_EP15_IN_CONTROL_ENDPOINT_TYPE_Interrupt = 3,/*!< Interrupt : Interrupt */
} USBCTRL_DPRAM_EP15_IN_CONTROL_ENDPOINT_TYPE_Enum;

/* ===================================================  EP15_OUT_CONTROL  ==================================================== */
/* =================================  USBCTRL_DPRAM EP15_OUT_CONTROL ENDPOINT_TYPE [26..27]  ================================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP15_OUT_CONTROL_ENDPOINT_TYPE */
  USBCTRL_DPRAM_EP15_OUT_CONTROL_ENDPOINT_TYPE_Control = 0,/*!< Control : Control */
  USBCTRL_DPRAM_EP15_OUT_CONTROL_ENDPOINT_TYPE_Isochronous = 1,/*!< Isochronous : Isochronous */
  USBCTRL_DPRAM_EP15_OUT_CONTROL_ENDPOINT_TYPE_Bulk = 2,/*!< Bulk : Bulk */
  USBCTRL_DPRAM_EP15_OUT_CONTROL_ENDPOINT_TYPE_Interrupt = 3,/*!< Interrupt : Interrupt */
} USBCTRL_DPRAM_EP15_OUT_CONTROL_ENDPOINT_TYPE_Enum;

/* =================================================  EP0_IN_BUFFER_CONTROL  ================================================= */
/* =========================  USBCTRL_DPRAM EP0_IN_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ========================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* ================================================  EP0_OUT_BUFFER_CONTROL  ================================================= */
/* ========================  USBCTRL_DPRAM EP0_OUT_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ========================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* =================================================  EP1_IN_BUFFER_CONTROL  ================================================= */
/* =========================  USBCTRL_DPRAM EP1_IN_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ========================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* ================================================  EP1_OUT_BUFFER_CONTROL  ================================================= */
/* ========================  USBCTRL_DPRAM EP1_OUT_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ========================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* =================================================  EP2_IN_BUFFER_CONTROL  ================================================= */
/* =========================  USBCTRL_DPRAM EP2_IN_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ========================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* ================================================  EP2_OUT_BUFFER_CONTROL  ================================================= */
/* ========================  USBCTRL_DPRAM EP2_OUT_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ========================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* =================================================  EP3_IN_BUFFER_CONTROL  ================================================= */
/* =========================  USBCTRL_DPRAM EP3_IN_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ========================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* ================================================  EP3_OUT_BUFFER_CONTROL  ================================================= */
/* ========================  USBCTRL_DPRAM EP3_OUT_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ========================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* =================================================  EP4_IN_BUFFER_CONTROL  ================================================= */
/* =========================  USBCTRL_DPRAM EP4_IN_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ========================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* ================================================  EP4_OUT_BUFFER_CONTROL  ================================================= */
/* ========================  USBCTRL_DPRAM EP4_OUT_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ========================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* =================================================  EP5_IN_BUFFER_CONTROL  ================================================= */
/* =========================  USBCTRL_DPRAM EP5_IN_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ========================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* ================================================  EP5_OUT_BUFFER_CONTROL  ================================================= */
/* ========================  USBCTRL_DPRAM EP5_OUT_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ========================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* =================================================  EP6_IN_BUFFER_CONTROL  ================================================= */
/* =========================  USBCTRL_DPRAM EP6_IN_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ========================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* ================================================  EP6_OUT_BUFFER_CONTROL  ================================================= */
/* ========================  USBCTRL_DPRAM EP6_OUT_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ========================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* =================================================  EP7_IN_BUFFER_CONTROL  ================================================= */
/* =========================  USBCTRL_DPRAM EP7_IN_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ========================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* ================================================  EP7_OUT_BUFFER_CONTROL  ================================================= */
/* ========================  USBCTRL_DPRAM EP7_OUT_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ========================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* =================================================  EP8_IN_BUFFER_CONTROL  ================================================= */
/* =========================  USBCTRL_DPRAM EP8_IN_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ========================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* ================================================  EP8_OUT_BUFFER_CONTROL  ================================================= */
/* ========================  USBCTRL_DPRAM EP8_OUT_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ========================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* =================================================  EP9_IN_BUFFER_CONTROL  ================================================= */
/* =========================  USBCTRL_DPRAM EP9_IN_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ========================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* ================================================  EP9_OUT_BUFFER_CONTROL  ================================================= */
/* ========================  USBCTRL_DPRAM EP9_OUT_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ========================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* ================================================  EP10_IN_BUFFER_CONTROL  ================================================= */
/* ========================  USBCTRL_DPRAM EP10_IN_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ========================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* ================================================  EP10_OUT_BUFFER_CONTROL  ================================================ */
/* ========================  USBCTRL_DPRAM EP10_OUT_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ======================== */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* ================================================  EP11_IN_BUFFER_CONTROL  ================================================= */
/* ========================  USBCTRL_DPRAM EP11_IN_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ========================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* ================================================  EP11_OUT_BUFFER_CONTROL  ================================================ */
/* ========================  USBCTRL_DPRAM EP11_OUT_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ======================== */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* ================================================  EP12_IN_BUFFER_CONTROL  ================================================= */
/* ========================  USBCTRL_DPRAM EP12_IN_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ========================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* ================================================  EP12_OUT_BUFFER_CONTROL  ================================================ */
/* ========================  USBCTRL_DPRAM EP12_OUT_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ======================== */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* ================================================  EP13_IN_BUFFER_CONTROL  ================================================= */
/* ========================  USBCTRL_DPRAM EP13_IN_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ========================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* ================================================  EP13_OUT_BUFFER_CONTROL  ================================================ */
/* ========================  USBCTRL_DPRAM EP13_OUT_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ======================== */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* ================================================  EP14_IN_BUFFER_CONTROL  ================================================= */
/* ========================  USBCTRL_DPRAM EP14_IN_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ========================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* ================================================  EP14_OUT_BUFFER_CONTROL  ================================================ */
/* ========================  USBCTRL_DPRAM EP14_OUT_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ======================== */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* ================================================  EP15_IN_BUFFER_CONTROL  ================================================= */
/* ========================  USBCTRL_DPRAM EP15_IN_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ========================= */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;

/* ================================================  EP15_OUT_BUFFER_CONTROL  ================================================ */
/* ========================  USBCTRL_DPRAM EP15_OUT_BUFFER_CONTROL DOUBLE_BUFFER_ISO_OFFSET [27..28]  ======================== */
typedef enum {                                  /*!< USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET */
  USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_128 = 0,/*!< 128 : 128 */
  USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_256 = 1,/*!< 256 : 256 */
  USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_512 = 2,/*!< 512 : 512 */
  USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_1024 = 3,/*!< 1024 : 1024 */
} USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET_Enum;



/* =========================================================================================================================== */
/* ================                                       USBCTRL_REGS                                        ================ */
/* =========================================================================================================================== */

/* =======================================================  ADDR_ENDP  ======================================================= */
/* ======================================================  ADDR_ENDP1  ======================================================= */
/* ======================================================  ADDR_ENDP2  ======================================================= */
/* ======================================================  ADDR_ENDP3  ======================================================= */
/* ======================================================  ADDR_ENDP4  ======================================================= */
/* ======================================================  ADDR_ENDP5  ======================================================= */
/* ======================================================  ADDR_ENDP6  ======================================================= */
/* ======================================================  ADDR_ENDP7  ======================================================= */
/* ======================================================  ADDR_ENDP8  ======================================================= */
/* ======================================================  ADDR_ENDP9  ======================================================= */
/* ======================================================  ADDR_ENDP10  ====================================================== */
/* ======================================================  ADDR_ENDP11  ====================================================== */
/* ======================================================  ADDR_ENDP12  ====================================================== */
/* ======================================================  ADDR_ENDP13  ====================================================== */
/* ======================================================  ADDR_ENDP14  ====================================================== */
/* ======================================================  ADDR_ENDP15  ====================================================== */
/* =======================================================  MAIN_CTRL  ======================================================= */
/* ========================================================  SOF_WR  ========================================================= */
/* ========================================================  SOF_RD  ========================================================= */
/* =======================================================  SIE_CTRL  ======================================================== */
/* ======================================================  SIE_STATUS  ======================================================= */
/* ======================================================  INT_EP_CTRL  ====================================================== */
/* ======================================================  BUFF_STATUS  ====================================================== */
/* ================================================  BUFF_CPU_SHOULD_HANDLE  ================================================= */
/* =======================================================  EP_ABORT  ======================================================== */
/* =====================================================  EP_ABORT_DONE  ===================================================== */
/* =====================================================  EP_STALL_ARM  ====================================================== */
/* =======================================================  NAK_POLL  ======================================================== */
/* ==================================================  EP_STATUS_STALL_NAK  ================================================== */
/* ======================================================  USB_MUXING  ======================================================= */
/* ========================================================  USB_PWR  ======================================================== */
/* =====================================================  USBPHY_DIRECT  ===================================================== */
/* ================================================  USBPHY_DIRECT_OVERRIDE  ================================================= */
/* ======================================================  USBPHY_TRIM  ====================================================== */
/* =========================================================  INTR  ========================================================== */
/* =========================================================  INTE  ========================================================== */
/* =========================================================  INTF  ========================================================== */
/* =========================================================  INTS  ========================================================== */


/* =========================================================================================================================== */
/* ================                                           PIO0                                            ================ */
/* =========================================================================================================================== */

/* =========================================================  CTRL  ========================================================== */
/* =========================================================  FSTAT  ========================================================= */
/* ========================================================  FDEBUG  ========================================================= */
/* ========================================================  FLEVEL  ========================================================= */
/* =========================================================  TXF0  ========================================================== */
/* =========================================================  TXF1  ========================================================== */
/* =========================================================  TXF2  ========================================================== */
/* =========================================================  TXF3  ========================================================== */
/* =========================================================  RXF0  ========================================================== */
/* =========================================================  RXF1  ========================================================== */
/* =========================================================  RXF2  ========================================================== */
/* =========================================================  RXF3  ========================================================== */
/* ==========================================================  IRQ  ========================================================== */
/* =======================================================  IRQ_FORCE  ======================================================= */
/* ===================================================  INPUT_SYNC_BYPASS  =================================================== */
/* ======================================================  DBG_PADOUT  ======================================================= */
/* =======================================================  DBG_PADOE  ======================================================= */
/* ======================================================  DBG_CFGINFO  ====================================================== */
/* ======================================================  INSTR_MEM0  ======================================================= */
/* ======================================================  INSTR_MEM1  ======================================================= */
/* ======================================================  INSTR_MEM2  ======================================================= */
/* ======================================================  INSTR_MEM3  ======================================================= */
/* ======================================================  INSTR_MEM4  ======================================================= */
/* ======================================================  INSTR_MEM5  ======================================================= */
/* ======================================================  INSTR_MEM6  ======================================================= */
/* ======================================================  INSTR_MEM7  ======================================================= */
/* ======================================================  INSTR_MEM8  ======================================================= */
/* ======================================================  INSTR_MEM9  ======================================================= */
/* ======================================================  INSTR_MEM10  ====================================================== */
/* ======================================================  INSTR_MEM11  ====================================================== */
/* ======================================================  INSTR_MEM12  ====================================================== */
/* ======================================================  INSTR_MEM13  ====================================================== */
/* ======================================================  INSTR_MEM14  ====================================================== */
/* ======================================================  INSTR_MEM15  ====================================================== */
/* ======================================================  INSTR_MEM16  ====================================================== */
/* ======================================================  INSTR_MEM17  ====================================================== */
/* ======================================================  INSTR_MEM18  ====================================================== */
/* ======================================================  INSTR_MEM19  ====================================================== */
/* ======================================================  INSTR_MEM20  ====================================================== */
/* ======================================================  INSTR_MEM21  ====================================================== */
/* ======================================================  INSTR_MEM22  ====================================================== */
/* ======================================================  INSTR_MEM23  ====================================================== */
/* ======================================================  INSTR_MEM24  ====================================================== */
/* ======================================================  INSTR_MEM25  ====================================================== */
/* ======================================================  INSTR_MEM26  ====================================================== */
/* ======================================================  INSTR_MEM27  ====================================================== */
/* ======================================================  INSTR_MEM28  ====================================================== */
/* ======================================================  INSTR_MEM29  ====================================================== */
/* ======================================================  INSTR_MEM30  ====================================================== */
/* ======================================================  INSTR_MEM31  ====================================================== */
/* ======================================================  SM0_CLKDIV  ======================================================= */
/* =====================================================  SM0_EXECCTRL  ====================================================== */
/* ==========================================  PIO0 SM0_EXECCTRL STATUS_SEL [4..4]  ========================================== */
typedef enum {                                  /*!< PIO0_SM0_EXECCTRL_STATUS_SEL */
  PIO0_SM0_EXECCTRL_STATUS_SEL_TXLEVEL = 0,     /*!< TXLEVEL : All-ones if TX FIFO level < N, otherwise all-zeroes */
  PIO0_SM0_EXECCTRL_STATUS_SEL_RXLEVEL = 1,     /*!< RXLEVEL : All-ones if RX FIFO level < N, otherwise all-zeroes */
} PIO0_SM0_EXECCTRL_STATUS_SEL_Enum;

/* =====================================================  SM0_SHIFTCTRL  ===================================================== */
/* =======================================================  SM0_ADDR  ======================================================== */
/* =======================================================  SM0_INSTR  ======================================================= */
/* ======================================================  SM0_PINCTRL  ====================================================== */
/* ======================================================  SM1_CLKDIV  ======================================================= */
/* =====================================================  SM1_EXECCTRL  ====================================================== */
/* ==========================================  PIO0 SM1_EXECCTRL STATUS_SEL [4..4]  ========================================== */
typedef enum {                                  /*!< PIO0_SM1_EXECCTRL_STATUS_SEL */
  PIO0_SM1_EXECCTRL_STATUS_SEL_TXLEVEL = 0,     /*!< TXLEVEL : All-ones if TX FIFO level < N, otherwise all-zeroes */
  PIO0_SM1_EXECCTRL_STATUS_SEL_RXLEVEL = 1,     /*!< RXLEVEL : All-ones if RX FIFO level < N, otherwise all-zeroes */
} PIO0_SM1_EXECCTRL_STATUS_SEL_Enum;

/* =====================================================  SM1_SHIFTCTRL  ===================================================== */
/* =======================================================  SM1_ADDR  ======================================================== */
/* =======================================================  SM1_INSTR  ======================================================= */
/* ======================================================  SM1_PINCTRL  ====================================================== */
/* ======================================================  SM2_CLKDIV  ======================================================= */
/* =====================================================  SM2_EXECCTRL  ====================================================== */
/* ==========================================  PIO0 SM2_EXECCTRL STATUS_SEL [4..4]  ========================================== */
typedef enum {                                  /*!< PIO0_SM2_EXECCTRL_STATUS_SEL */
  PIO0_SM2_EXECCTRL_STATUS_SEL_TXLEVEL = 0,     /*!< TXLEVEL : All-ones if TX FIFO level < N, otherwise all-zeroes */
  PIO0_SM2_EXECCTRL_STATUS_SEL_RXLEVEL = 1,     /*!< RXLEVEL : All-ones if RX FIFO level < N, otherwise all-zeroes */
} PIO0_SM2_EXECCTRL_STATUS_SEL_Enum;

/* =====================================================  SM2_SHIFTCTRL  ===================================================== */
/* =======================================================  SM2_ADDR  ======================================================== */
/* =======================================================  SM2_INSTR  ======================================================= */
/* ======================================================  SM2_PINCTRL  ====================================================== */
/* ======================================================  SM3_CLKDIV  ======================================================= */
/* =====================================================  SM3_EXECCTRL  ====================================================== */
/* ==========================================  PIO0 SM3_EXECCTRL STATUS_SEL [4..4]  ========================================== */
typedef enum {                                  /*!< PIO0_SM3_EXECCTRL_STATUS_SEL */
  PIO0_SM3_EXECCTRL_STATUS_SEL_TXLEVEL = 0,     /*!< TXLEVEL : All-ones if TX FIFO level < N, otherwise all-zeroes */
  PIO0_SM3_EXECCTRL_STATUS_SEL_RXLEVEL = 1,     /*!< RXLEVEL : All-ones if RX FIFO level < N, otherwise all-zeroes */
} PIO0_SM3_EXECCTRL_STATUS_SEL_Enum;

/* =====================================================  SM3_SHIFTCTRL  ===================================================== */
/* =======================================================  SM3_ADDR  ======================================================== */
/* =======================================================  SM3_INSTR  ======================================================= */
/* ======================================================  SM3_PINCTRL  ====================================================== */
/* =========================================================  INTR  ========================================================== */
/* =======================================================  IRQ0_INTE  ======================================================= */
/* =======================================================  IRQ0_INTF  ======================================================= */
/* =======================================================  IRQ0_INTS  ======================================================= */
/* =======================================================  IRQ1_INTE  ======================================================= */
/* =======================================================  IRQ1_INTF  ======================================================= */
/* =======================================================  IRQ1_INTS  ======================================================= */


/* =========================================================================================================================== */
/* ================                                            SIO                                            ================ */
/* =========================================================================================================================== */

/* =========================================================  CPUID  ========================================================= */
/* ========================================================  GPIO_IN  ======================================================== */
/* ======================================================  GPIO_HI_IN  ======================================================= */
/* =======================================================  GPIO_OUT  ======================================================== */
/* =====================================================  GPIO_OUT_SET  ====================================================== */
/* =====================================================  GPIO_OUT_CLR  ====================================================== */
/* =====================================================  GPIO_OUT_XOR  ====================================================== */
/* ========================================================  GPIO_OE  ======================================================== */
/* ======================================================  GPIO_OE_SET  ====================================================== */
/* ======================================================  GPIO_OE_CLR  ====================================================== */
/* ======================================================  GPIO_OE_XOR  ====================================================== */
/* ======================================================  GPIO_HI_OUT  ====================================================== */
/* ====================================================  GPIO_HI_OUT_SET  ==================================================== */
/* ====================================================  GPIO_HI_OUT_CLR  ==================================================== */
/* ====================================================  GPIO_HI_OUT_XOR  ==================================================== */
/* ======================================================  GPIO_HI_OE  ======================================================= */
/* ====================================================  GPIO_HI_OE_SET  ===================================================== */
/* ====================================================  GPIO_HI_OE_CLR  ===================================================== */
/* ====================================================  GPIO_HI_OE_XOR  ===================================================== */
/* ========================================================  FIFO_ST  ======================================================== */
/* ========================================================  FIFO_WR  ======================================================== */
/* ========================================================  FIFO_RD  ======================================================== */
/* ======================================================  SPINLOCK_ST  ====================================================== */
/* =====================================================  DIV_UDIVIDEND  ===================================================== */
/* =====================================================  DIV_UDIVISOR  ====================================================== */
/* =====================================================  DIV_SDIVIDEND  ===================================================== */
/* =====================================================  DIV_SDIVISOR  ====================================================== */
/* =====================================================  DIV_QUOTIENT  ====================================================== */
/* =====================================================  DIV_REMAINDER  ===================================================== */
/* ========================================================  DIV_CSR  ======================================================== */
/* ====================================================  INTERP0_ACCUM0  ===================================================== */
/* ====================================================  INTERP0_ACCUM1  ===================================================== */
/* =====================================================  INTERP0_BASE0  ===================================================== */
/* =====================================================  INTERP0_BASE1  ===================================================== */
/* =====================================================  INTERP0_BASE2  ===================================================== */
/* ===================================================  INTERP0_POP_LANE0  =================================================== */
/* ===================================================  INTERP0_POP_LANE1  =================================================== */
/* ===================================================  INTERP0_POP_FULL  ==================================================== */
/* ==================================================  INTERP0_PEEK_LANE0  =================================================== */
/* ==================================================  INTERP0_PEEK_LANE1  =================================================== */
/* ===================================================  INTERP0_PEEK_FULL  =================================================== */
/* ==================================================  INTERP0_CTRL_LANE0  =================================================== */
/* ==================================================  INTERP0_CTRL_LANE1  =================================================== */
/* ==================================================  INTERP0_ACCUM0_ADD  =================================================== */
/* ==================================================  INTERP0_ACCUM1_ADD  =================================================== */
/* ==================================================  INTERP0_BASE_1AND0  =================================================== */
/* ====================================================  INTERP1_ACCUM0  ===================================================== */
/* ====================================================  INTERP1_ACCUM1  ===================================================== */
/* =====================================================  INTERP1_BASE0  ===================================================== */
/* =====================================================  INTERP1_BASE1  ===================================================== */
/* =====================================================  INTERP1_BASE2  ===================================================== */
/* ===================================================  INTERP1_POP_LANE0  =================================================== */
/* ===================================================  INTERP1_POP_LANE1  =================================================== */
/* ===================================================  INTERP1_POP_FULL  ==================================================== */
/* ==================================================  INTERP1_PEEK_LANE0  =================================================== */
/* ==================================================  INTERP1_PEEK_LANE1  =================================================== */
/* ===================================================  INTERP1_PEEK_FULL  =================================================== */
/* ==================================================  INTERP1_CTRL_LANE0  =================================================== */
/* ==================================================  INTERP1_CTRL_LANE1  =================================================== */
/* ==================================================  INTERP1_ACCUM0_ADD  =================================================== */
/* ==================================================  INTERP1_ACCUM1_ADD  =================================================== */
/* ==================================================  INTERP1_BASE_1AND0  =================================================== */
/* =======================================================  SPINLOCK0  ======================================================= */
/* =======================================================  SPINLOCK1  ======================================================= */
/* =======================================================  SPINLOCK2  ======================================================= */
/* =======================================================  SPINLOCK3  ======================================================= */
/* =======================================================  SPINLOCK4  ======================================================= */
/* =======================================================  SPINLOCK5  ======================================================= */
/* =======================================================  SPINLOCK6  ======================================================= */
/* =======================================================  SPINLOCK7  ======================================================= */
/* =======================================================  SPINLOCK8  ======================================================= */
/* =======================================================  SPINLOCK9  ======================================================= */
/* ======================================================  SPINLOCK10  ======================================================= */
/* ======================================================  SPINLOCK11  ======================================================= */
/* ======================================================  SPINLOCK12  ======================================================= */
/* ======================================================  SPINLOCK13  ======================================================= */
/* ======================================================  SPINLOCK14  ======================================================= */
/* ======================================================  SPINLOCK15  ======================================================= */
/* ======================================================  SPINLOCK16  ======================================================= */
/* ======================================================  SPINLOCK17  ======================================================= */
/* ======================================================  SPINLOCK18  ======================================================= */
/* ======================================================  SPINLOCK19  ======================================================= */
/* ======================================================  SPINLOCK20  ======================================================= */
/* ======================================================  SPINLOCK21  ======================================================= */
/* ======================================================  SPINLOCK22  ======================================================= */
/* ======================================================  SPINLOCK23  ======================================================= */
/* ======================================================  SPINLOCK24  ======================================================= */
/* ======================================================  SPINLOCK25  ======================================================= */
/* ======================================================  SPINLOCK26  ======================================================= */
/* ======================================================  SPINLOCK27  ======================================================= */
/* ======================================================  SPINLOCK28  ======================================================= */
/* ======================================================  SPINLOCK29  ======================================================= */
/* ======================================================  SPINLOCK30  ======================================================= */
/* ======================================================  SPINLOCK31  ======================================================= */


/* =========================================================================================================================== */
/* ================                                            PPB                                            ================ */
/* =========================================================================================================================== */

/* =======================================================  SYST_CSR  ======================================================== */
/* =======================================================  SYST_RVR  ======================================================== */
/* =======================================================  SYST_CVR  ======================================================== */
/* ======================================================  SYST_CALIB  ======================================================= */
/* =======================================================  NVIC_ISER  ======================================================= */
/* =======================================================  NVIC_ICER  ======================================================= */
/* =======================================================  NVIC_ISPR  ======================================================= */
/* =======================================================  NVIC_ICPR  ======================================================= */
/* =======================================================  NVIC_IPR0  ======================================================= */
/* =======================================================  NVIC_IPR1  ======================================================= */
/* =======================================================  NVIC_IPR2  ======================================================= */
/* =======================================================  NVIC_IPR3  ======================================================= */
/* =======================================================  NVIC_IPR4  ======================================================= */
/* =======================================================  NVIC_IPR5  ======================================================= */
/* =======================================================  NVIC_IPR6  ======================================================= */
/* =======================================================  NVIC_IPR7  ======================================================= */
/* =========================================================  CPUID  ========================================================= */
/* =========================================================  ICSR  ========================================================== */
/* =========================================================  VTOR  ========================================================== */
/* =========================================================  AIRCR  ========================================================= */
/* ==========================================================  SCR  ========================================================== */
/* ==========================================================  CCR  ========================================================== */
/* =========================================================  SHPR2  ========================================================= */
/* =========================================================  SHPR3  ========================================================= */
/* =========================================================  SHCSR  ========================================================= */
/* =======================================================  MPU_TYPE  ======================================================== */
/* =======================================================  MPU_CTRL  ======================================================== */
/* ========================================================  MPU_RNR  ======================================================== */
/* =======================================================  MPU_RBAR  ======================================================== */
/* =======================================================  MPU_RASR  ======================================================== */

/** @} */ /* End of group EnumValue_peripherals */


#ifdef __cplusplus
}
#endif

#endif /* RP2040_H */


/** @} */ /* End of group rp2040 */

/** @} */ /* End of group Raspberry Pi */
