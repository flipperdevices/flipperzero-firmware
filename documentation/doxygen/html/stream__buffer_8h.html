<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flipper Zero Firmware: /Users/astrr/wtf/flipperzero-firmware/furi/core/stream_buffer.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Flipper Zero Firmware
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_1b10a0714798903fe36325b43d76a276.html">furi</a></li><li class="navelem"><a class="el" href="dir_129cdca8bb1a0bec5ad41e77336da62e.html">core</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">stream_buffer.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Furi stream buffer primitive.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
</div>
<p><a href="stream__buffer_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a119538b475d1d23084d0094a16cdc464"><td class="memItemLeft" align="right" valign="top"><a id="a119538b475d1d23084d0094a16cdc464" name="a119538b475d1d23084d0094a16cdc464"></a>
typedef void&#160;</td><td class="memItemRight" valign="bottom"><b>FuriStreamBuffer</b></td></tr>
<tr class="separator:a119538b475d1d23084d0094a16cdc464"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a496892963c8fd564034443c233b24fcb"><td class="memItemLeft" align="right" valign="top">FuriStreamBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream__buffer_8h.html#a496892963c8fd564034443c233b24fcb">furi_stream_buffer_alloc</a> (size_t size, size_t trigger_level)</td></tr>
<tr class="memdesc:a496892963c8fd564034443c233b24fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate stream buffer instance.  <a href="stream__buffer_8h.html#a496892963c8fd564034443c233b24fcb">More...</a><br /></td></tr>
<tr class="separator:a496892963c8fd564034443c233b24fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06715fb70e1d202e31c3921ec695979"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream__buffer_8h.html#af06715fb70e1d202e31c3921ec695979">furi_stream_buffer_free</a> (FuriStreamBuffer *stream_buffer)</td></tr>
<tr class="memdesc:af06715fb70e1d202e31c3921ec695979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free stream buffer instance.  <a href="stream__buffer_8h.html#af06715fb70e1d202e31c3921ec695979">More...</a><br /></td></tr>
<tr class="separator:af06715fb70e1d202e31c3921ec695979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1562edbf93e5cfe7753fbde14dea48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream__buffer_8h.html#a9d1562edbf93e5cfe7753fbde14dea48">furi_stream_set_trigger_level</a> (FuriStreamBuffer *stream_buffer, size_t trigger_level)</td></tr>
<tr class="memdesc:a9d1562edbf93e5cfe7753fbde14dea48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set trigger level for stream buffer.  <a href="stream__buffer_8h.html#a9d1562edbf93e5cfe7753fbde14dea48">More...</a><br /></td></tr>
<tr class="separator:a9d1562edbf93e5cfe7753fbde14dea48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae986dea8af844e659d9530bd6ce2bb12"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream__buffer_8h.html#ae986dea8af844e659d9530bd6ce2bb12">furi_stream_buffer_send</a> (FuriStreamBuffer *stream_buffer, const void *data, size_t length, uint32_t timeout)</td></tr>
<tr class="memdesc:ae986dea8af844e659d9530bd6ce2bb12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends bytes to a stream buffer.  <a href="stream__buffer_8h.html#ae986dea8af844e659d9530bd6ce2bb12">More...</a><br /></td></tr>
<tr class="separator:ae986dea8af844e659d9530bd6ce2bb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24a22070ec3c6ef0ee2c4fc84ff713e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream__buffer_8h.html#ad24a22070ec3c6ef0ee2c4fc84ff713e">furi_stream_buffer_receive</a> (FuriStreamBuffer *stream_buffer, void *data, size_t length, uint32_t timeout)</td></tr>
<tr class="memdesc:ad24a22070ec3c6ef0ee2c4fc84ff713e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives bytes from a stream buffer.  <a href="stream__buffer_8h.html#ad24a22070ec3c6ef0ee2c4fc84ff713e">More...</a><br /></td></tr>
<tr class="separator:ad24a22070ec3c6ef0ee2c4fc84ff713e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217a0b6abb62f5d7c6a3a41c14745aae"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream__buffer_8h.html#a217a0b6abb62f5d7c6a3a41c14745aae">furi_stream_buffer_bytes_available</a> (FuriStreamBuffer *stream_buffer)</td></tr>
<tr class="memdesc:a217a0b6abb62f5d7c6a3a41c14745aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries a stream buffer to see how much data it contains, which is equal to the number of bytes that can be read from the stream buffer before the stream buffer would be empty.  <a href="stream__buffer_8h.html#a217a0b6abb62f5d7c6a3a41c14745aae">More...</a><br /></td></tr>
<tr class="separator:a217a0b6abb62f5d7c6a3a41c14745aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a753b1857e7396880397748db677e13"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream__buffer_8h.html#a8a753b1857e7396880397748db677e13">furi_stream_buffer_spaces_available</a> (FuriStreamBuffer *stream_buffer)</td></tr>
<tr class="memdesc:a8a753b1857e7396880397748db677e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries a stream buffer to see how much free space it contains, which is equal to the amount of data that can be sent to the stream buffer before it is full.  <a href="stream__buffer_8h.html#a8a753b1857e7396880397748db677e13">More...</a><br /></td></tr>
<tr class="separator:a8a753b1857e7396880397748db677e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf14c7cf7fa875df46a640883c9d78c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream__buffer_8h.html#adf14c7cf7fa875df46a640883c9d78c6">furi_stream_buffer_is_full</a> (FuriStreamBuffer *stream_buffer)</td></tr>
<tr class="memdesc:adf14c7cf7fa875df46a640883c9d78c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries a stream buffer to see if it is full.  <a href="stream__buffer_8h.html#adf14c7cf7fa875df46a640883c9d78c6">More...</a><br /></td></tr>
<tr class="separator:adf14c7cf7fa875df46a640883c9d78c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5d31d822164900e0776b6d68a5749b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream__buffer_8h.html#a8e5d31d822164900e0776b6d68a5749b">furi_stream_buffer_is_empty</a> (FuriStreamBuffer *stream_buffer)</td></tr>
<tr class="memdesc:a8e5d31d822164900e0776b6d68a5749b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries a stream buffer to see if it is empty.  <a href="stream__buffer_8h.html#a8e5d31d822164900e0776b6d68a5749b">More...</a><br /></td></tr>
<tr class="separator:a8e5d31d822164900e0776b6d68a5749b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1816391dd20128cb1aff22f73a2f8427"><td class="memItemLeft" align="right" valign="top">FuriStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stream__buffer_8h.html#a1816391dd20128cb1aff22f73a2f8427">furi_stream_buffer_reset</a> (FuriStreamBuffer *stream_buffer)</td></tr>
<tr class="memdesc:a1816391dd20128cb1aff22f73a2f8427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a stream buffer to its initial, empty, state.  <a href="stream__buffer_8h.html#a1816391dd20128cb1aff22f73a2f8427">More...</a><br /></td></tr>
<tr class="separator:a1816391dd20128cb1aff22f73a2f8427"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Furi stream buffer primitive. </p>
<p ><a class="el" href="struct_stream.html">Stream</a> buffers are used to send a continuous stream of data from one task or interrupt to another. Their implementation is light weight, making them particularly suited for interrupt to task and core to core communication scenarios.</p>
<p >***NOTE***: <a class="el" href="struct_stream.html">Stream</a> buffer implementation assumes there is only one task or interrupt that will write to the buffer (the writer), and only one task or interrupt that will read from the buffer (the reader). </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a496892963c8fd564034443c233b24fcb" name="a496892963c8fd564034443c233b24fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a496892963c8fd564034443c233b24fcb">&#9670;&nbsp;</a></span>furi_stream_buffer_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FuriStreamBuffer * furi_stream_buffer_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>trigger_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate stream buffer instance. </p>
<p ><a class="el" href="struct_stream.html">Stream</a> buffer implementation assumes there is only one task or interrupt that will write to the buffer (the writer), and only one task or interrupt that will read from the buffer (the reader).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The total number of bytes the stream buffer will be able to hold at any one time. </td></tr>
    <tr><td class="paramname">trigger_level</td><td>The number of bytes that must be in the stream buffer before a task that is blocked on the stream buffer to wait for data is moved out of the blocked state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stream buffer instance. </dd></dl>

</div>
</div>
<a id="a217a0b6abb62f5d7c6a3a41c14745aae" name="a217a0b6abb62f5d7c6a3a41c14745aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a217a0b6abb62f5d7c6a3a41c14745aae">&#9670;&nbsp;</a></span>furi_stream_buffer_bytes_available()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t furi_stream_buffer_bytes_available </td>
          <td>(</td>
          <td class="paramtype">FuriStreamBuffer *&#160;</td>
          <td class="paramname"><em>stream_buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries a stream buffer to see how much data it contains, which is equal to the number of bytes that can be read from the stream buffer before the stream buffer would be empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream_buffer</td><td>The stream buffer instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes that can be read from the stream buffer before the stream buffer would be empty. </dd></dl>

</div>
</div>
<a id="af06715fb70e1d202e31c3921ec695979" name="af06715fb70e1d202e31c3921ec695979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af06715fb70e1d202e31c3921ec695979">&#9670;&nbsp;</a></span>furi_stream_buffer_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void furi_stream_buffer_free </td>
          <td>(</td>
          <td class="paramtype">FuriStreamBuffer *&#160;</td>
          <td class="paramname"><em>stream_buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free stream buffer instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream_buffer</td><td>The stream buffer instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e5d31d822164900e0776b6d68a5749b" name="a8e5d31d822164900e0776b6d68a5749b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5d31d822164900e0776b6d68a5749b">&#9670;&nbsp;</a></span>furi_stream_buffer_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool furi_stream_buffer_is_empty </td>
          <td>(</td>
          <td class="paramtype">FuriStreamBuffer *&#160;</td>
          <td class="paramname"><em>stream_buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries a stream buffer to see if it is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream_buffer</td><td>The stream buffer instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the stream buffer is empty. </dd>
<dd>
false if the stream buffer is not empty. </dd></dl>

</div>
</div>
<a id="adf14c7cf7fa875df46a640883c9d78c6" name="adf14c7cf7fa875df46a640883c9d78c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf14c7cf7fa875df46a640883c9d78c6">&#9670;&nbsp;</a></span>furi_stream_buffer_is_full()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool furi_stream_buffer_is_full </td>
          <td>(</td>
          <td class="paramtype">FuriStreamBuffer *&#160;</td>
          <td class="paramname"><em>stream_buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries a stream buffer to see if it is full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream_buffer</td><td>stream buffer instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the stream buffer is full. </dd>
<dd>
false if the stream buffer is not full. </dd></dl>

</div>
</div>
<a id="ad24a22070ec3c6ef0ee2c4fc84ff713e" name="ad24a22070ec3c6ef0ee2c4fc84ff713e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24a22070ec3c6ef0ee2c4fc84ff713e">&#9670;&nbsp;</a></span>furi_stream_buffer_receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t furi_stream_buffer_receive </td>
          <td>(</td>
          <td class="paramtype">FuriStreamBuffer *&#160;</td>
          <td class="paramname"><em>stream_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives bytes from a stream buffer. </p>
<p >Wakes up task waiting for space to become available if called from ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream_buffer</td><td>The stream buffer instance. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the buffer into which the received bytes will be copied. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the buffer pointed to by the data parameter. </td></tr>
    <tr><td class="paramname">timeout</td><td>The maximum amount of time the task should remain in the Blocked state to wait for data to become available if the stream buffer is empty. Will return immediately if timeout is zero. Setting timeout to FuriWaitForever will cause the task to wait indefinitely. Ignored if called from ISR. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read from the stream buffer, if any. </dd></dl>

</div>
</div>
<a id="a1816391dd20128cb1aff22f73a2f8427" name="a1816391dd20128cb1aff22f73a2f8427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1816391dd20128cb1aff22f73a2f8427">&#9670;&nbsp;</a></span>furi_stream_buffer_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FuriStatus furi_stream_buffer_reset </td>
          <td>(</td>
          <td class="paramtype">FuriStreamBuffer *&#160;</td>
          <td class="paramname"><em>stream_buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets a stream buffer to its initial, empty, state. </p>
<p >Any data that was in the stream buffer is discarded. A stream buffer can only be reset if there are no tasks blocked waiting to either send to or receive from the stream buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream_buffer</td><td>The stream buffer instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FuriStatusOk if the stream buffer is reset. </dd>
<dd>
FuriStatusError if there was a task blocked waiting to send to or read from the stream buffer then the stream buffer is not reset. </dd></dl>

</div>
</div>
<a id="ae986dea8af844e659d9530bd6ce2bb12" name="ae986dea8af844e659d9530bd6ce2bb12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae986dea8af844e659d9530bd6ce2bb12">&#9670;&nbsp;</a></span>furi_stream_buffer_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t furi_stream_buffer_send </td>
          <td>(</td>
          <td class="paramtype">FuriStreamBuffer *&#160;</td>
          <td class="paramname"><em>stream_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends bytes to a stream buffer. </p>
<p >The bytes are copied into the stream buffer. Wakes up task waiting for data to become available if called from ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream_buffer</td><td>The stream buffer instance. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the data that is to be copied into the stream buffer. </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of bytes to copy from data into the stream buffer. </td></tr>
    <tr><td class="paramname">timeout</td><td>The maximum amount of time the task should remain in the Blocked state to wait for space to become available if the stream buffer is full. Will return immediately if timeout is zero. Setting timeout to FuriWaitForever will cause the task to wait indefinitely. Ignored if called from ISR. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually written to the stream buffer. </dd></dl>

</div>
</div>
<a id="a8a753b1857e7396880397748db677e13" name="a8a753b1857e7396880397748db677e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a753b1857e7396880397748db677e13">&#9670;&nbsp;</a></span>furi_stream_buffer_spaces_available()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t furi_stream_buffer_spaces_available </td>
          <td>(</td>
          <td class="paramtype">FuriStreamBuffer *&#160;</td>
          <td class="paramname"><em>stream_buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries a stream buffer to see how much free space it contains, which is equal to the amount of data that can be sent to the stream buffer before it is full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream_buffer</td><td>The stream buffer instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes that can be written to the stream buffer before the stream buffer would be full. </dd></dl>

</div>
</div>
<a id="a9d1562edbf93e5cfe7753fbde14dea48" name="a9d1562edbf93e5cfe7753fbde14dea48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d1562edbf93e5cfe7753fbde14dea48">&#9670;&nbsp;</a></span>furi_stream_set_trigger_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool furi_stream_set_trigger_level </td>
          <td>(</td>
          <td class="paramtype">FuriStreamBuffer *&#160;</td>
          <td class="paramname"><em>stream_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>trigger_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set trigger level for stream buffer. </p>
<p >A stream buffer's trigger level is the number of bytes that must be in the stream buffer before a task that is blocked on the stream buffer to wait for data is moved out of the blocked state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream_buffer</td><td>The stream buffer instance </td></tr>
    <tr><td class="paramname">trigger_level</td><td>The new trigger level for the stream buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if trigger level can be be updated (new trigger level was less than or equal to the stream buffer's length). </dd>
<dd>
false if trigger level can't be be updated (new trigger level was greater than the stream buffer's length). </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
